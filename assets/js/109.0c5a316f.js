(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{611:function(t,a,r){"use strict";r.r(a);var s=r(21),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"分时和调度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分时和调度"}},[t._v("#")]),t._v(" 分时和调度")]),t._v(" "),r("p",[t._v("因为通常机器中 CPU 核心数量少（从几个到几十个）、进程&线程数量很多（从几十到几百甚至更多），你可以类比为发动机少，而机器多，因此进程们在操作系统中只能排着队一个个执行。每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。再强调一下，现代操作系统都是直接调度线程，不会调度进程。")]),t._v(" "),r("h4",{attrs:{id:"分配时间片段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分配时间片段"}},[t._v("#")]),t._v(" 分配时间片段")]),t._v(" "),r("p",[t._v("如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始。这个就是分时技术。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AdmireAn/blobImage@main/img/CgqCHl-iUNWARGseAACvXwFzOgM513.png",alt:"Lark20201104-145535.png"}})]),t._v(" "),r("p",[t._v("下面这张图更加直观一些，进程 P1 先执行一个时间片段，然后进程 P2 开始执行一个时间片段， 然后进程 P3，然后进程 P4……")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AdmireAn/blobImage@main/img/Ciqc1F-iUOOAH_pCAAAxJPD4vZk085.png",alt:"Lark20201104-145538.png"}})]),t._v(" "),r("p",[t._v("注意，上面的两张图是以进程为单位演示，如果换成线程，操作系统依旧是这么处理。")])])}),[],!1,null,null,null);a.default=e.exports}}]);