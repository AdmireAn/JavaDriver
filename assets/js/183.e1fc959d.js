(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{685:function(r,o,e){"use strict";e.r(o);var n=e(21),t=Object(n.a)({},(function(){var r=this,o=r.$createElement,e=r._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"集群成员关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集群成员关系"}},[r._v("#")]),r._v(" 集群成员关系")]),r._v(" "),e("p",[r._v("Kafka使用 Zookeeper来维护集群成员的信息.\n每个broker都有唯一的标识符，可以配置指定，也可以自动生成。\n在broker启动时，他通过创建临时节点把自己注册到zk。\nbroker订阅zk的/brokers/ids路径，当有broker加入或者退出集群时，这些组件可以获得通知。")]),r._v(" "),e("p",[r._v("在关闭 broker时，它对应的节点也会消失，不过它的 ID会继续存在于其他数据结构中。例如，主题的副本列表(下面会介绍)里就可能包含这些ID。\n在完全关闭一个 broker之 后，如果使用相同的 ID 启动另一个全新的 broker，它会立即加入集群，井拥有与旧 broker 相同的分区和主题。")]),r._v(" "),e("h1",{attrs:{id:"控制器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#控制器"}},[r._v("#")]),r._v(" 控制器")]),r._v(" "),e("p",[r._v("控制器其实就是 一 个 broker，只不过它除了具有一般 broker 的功能之外，还负责分区 首领的选举。\n"),e("strong",[r._v("哪个broker可以成为控制器？")]),r._v("\n在集群启动时，所有broker都会尝试在zk创建节点/controller，但是只有一个broker可以创建成功，它就是控制器。\n非控制器的broker节点会在控制器节点创建zk watch对象，用于接收这个节点的变更通知。\n通过watch对象得知控制器节点消失，那么其他broker节点会进入下一轮的首领选举，选举成功会有一个新的递增的ID产生。\n"),e("strong",[r._v("新broker加入集群会发生什么？")]),r._v("\n控制器会检查新broker是否包含现有分区的副本，如果有，则通知其他broker，允许新的broker同步分区副本。\n"),e("strong",[r._v("broker退出集群会发生什么？")]),r._v("\n控制器监听到broker离开集群的消息，check哪些分区首领在该broker上。然后再其他broker上选举新的分区首领，并通知所有broker新的分区首领。")]),r._v(" "),e("h1",{attrs:{id:"复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复制"}},[r._v("#")]),r._v(" 复制")]),r._v(" "),e("p",[r._v("kafka是一个分布式的、可分区的、可复制的提交日志服务。\n"),e("strong",[r._v("复制什么？")]),r._v("\n每个topic由对个partition、每个partition有多个副本，其中一个是首领副本，其他是跟随者副本。\n该partition的生产者和消费者请求都会经过首领副本。\n复制就发生在首领副本和跟随者副本之间。\n当首领副本崩溃时，其中一个跟随者副本可以提升为首领副本。\n"),e("strong",[r._v("当首领副本崩溃时，哪个跟随者副本可以提升为首领副本")]),r._v("\n不同步的跟随者是不能成为首领的\n什么标准判断一个跟随者是不同步的？\n跟随者请求同步时总是按照offset递增的顺序请求同步的消息，而且总是在收到上一个请求的影响之后才会发出下一个请求。所以当首领收不到follower的请求最新的offset时或者一定时间内收不到follower的同步请求时，认为这个follower是不同步的。这个一定时间可以通过replica.lg.time.max.ms配置。\n首选首领是可以优先称为下一届首领的。\n首选首领是在创建分区时，为了在broker之间均衡首领选举的分区首领。")]),r._v(" "),e("h1",{attrs:{id:"处理请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#处理请求"}},[r._v("#")]),r._v(" 处理请求")]),r._v(" "),e("p",[r._v("broker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求。\nproducer的生产请求和consumer的获取请求都必须发送给分区的首领副本。\n"),e("strong",[r._v("那么客户端怎么知道谁是首领副本呢?")]),r._v("\n客户端使用了另一 种请求类型，也就是元数据请求。请求到元数据后缓存在本地。\n通过配置matedata.max.age.ms设置定时刷新元数据。")]),r._v(" "),e("p",[e("strong",[r._v("生产者请求")]),r._v("\n包含首领副本的 broker在收到生产请求时，会对请求做一些验证")]),r._v(" "),e("ul",[e("li",[r._v("发送数据的用户是否有主题的写权限")]),r._v(" "),e("li",[r._v("请求里的acks值是否是有效值（只允许0、1、all）")]),r._v(" "),e("li",[r._v("如果acks=all，是否有足够的读本保证消息已经被安全写入？\n以上都做完给客户端相应。")])]),r._v(" "),e("p",[e("strong",[r._v("消费者请求")]),r._v("\n客户端可以指定broker最多从一个分区里返回多少数据，这是有必要的，因为broker返回大量的数据有可能撑爆客户端的buffer\nbroke会check请求是否有效，比如请求的偏移量是否存在，如果存在，则用"),e("strong",[r._v("零拷贝")]),r._v("的方式返回数据。\n客户端也可以指定broker积攒一定的数据再返回，避免频繁的网络IO。\n并不是首领副本上的消息都可以返回给客户端，只有被所有follower同步了的消息才可以返回给客户端。")]),r._v(" "),e("h1",{attrs:{id:"物理存储"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#物理存储"}},[r._v("#")]),r._v(" 物理存储")]),r._v(" "),e("p",[r._v("kafka的基本存储单元是分区。\nlog.dirs配置用于指定存储分区的目录。\n"),e("strong",[r._v("如何做分区和broker之间的分配")]),r._v("\n加入要在6个broker的kafka集群上创建分区数为10复制系数为3的主题，那么这30个分区副本如何分配给6个broker?\n做分区和broker之间的分配要遵循以下原则：")]),r._v(" "),e("ul",[e("li",[r._v("在broker间平均的分布分区副本")]),r._v(" "),e("li",[r._v("每个分区的副本尽可能的分布在不同的broker上")]),r._v(" "),e("li",[r._v("如果制定了broker的机架信息，尽可能的把每个分区的副本分配到不同的机架上")])]),r._v(" "),e("p",[r._v("依照这个规则，分配方式可以如下：")]),r._v(" "),e("ol",[e("li",[r._v("先均匀分配首领分区。随机选一个broker，轮训的方式给每个broker分配分区来确定首领分区的位置。")]),r._v(" "),e("li",[r._v("再均匀分配分区副本。以首领分区为起点，了轮训分配分区副本。")]),r._v(" "),e("li",[r._v("指定机架信息的时候，均匀分配分区的方式。假设 broker0、 broker1和 broker2放置在同一个机架上， broker3、 broker4 和 broker5分别放置在其他不同的机架上，那么在轮训分配的时候，我们不是按照从 0到 5的顺序来选择 broker，而 是按照 0, 3, 1, 4, 2, 5 的顺序来选择。")])]),r._v(" "),e("p",[e("strong",[r._v("如何做文件管理")]),r._v("\n因为在一个大文件中查找和删除是非常耗时的，所以我们把分区分成若干个"),e("strong",[r._v("片段")]),r._v("。默认每个片段包含1G或者1周的数据。\n当前正在写入数据的片段叫做活跃片段。活跃片段永远不会被删除。\nbroker会为分区的每个片段打开一个文件句柄，这会导致打开过多的文件句柄，所以操作系统必须根据实际情况做一些调优。\n"),e("strong",[r._v("broker如何在一个分区的众多文件中定位指定的offset位置？")]),r._v("\nkakfa为每个分区文件建立索引，根据索引可以快速定位offset在文件中的位置。")]),r._v(" "),e("p",[r._v("如果有必要，管理员可以删除索引，kafka会重新生成这些索引。")])])}),[],!1,null,null,null);o.default=t.exports}}]);