(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{514:function(e,s,a){"use strict";a.r(s);var t=a(21),h=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"为什么重写-equals-必须重写-hashcode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么重写-equals-必须重写-hashcode"}},[e._v("#")]),e._v(" 为什么重写 equals 必须重写 hashcode ？")]),e._v(" "),a("p",[e._v("如果 我们重写了 equals 没有重写 hashcode 会导致HashSet 里面可以存储重复的元素。"),a("br")]),e._v(" "),a("p",[e._v("以 HashSet 为例来说"),a("br"),e._v("\nHashSet 底层是数组结构 存储的元素不重复（ O1和O2重复的意思是O1.equals(O2)==true ）"),a("br"),e._v("\nadd 一个元素进来放在哪里呢？"),a("br"),e._v("\n是根据元素的hash值（即 hashcode ）来确定数组下标 将元素放在里面。"),a("br"),e._v("\n如果 我们重写了 equals 没有重写 hashcode"),a("br"),e._v("\n那么 可能会产生这样的数据： O1.equals(O2)==true 但是O1.hashcode()!=O2.hashcode()"),a("br"),e._v("\n导致 HashSet 里面可以存储重复的元素。")])])}),[],!1,null,null,null);s.default=h.exports}}]);