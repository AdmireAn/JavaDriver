(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{616:function(t,s,a){"use strict";a.r(s);var e=a(21),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("一个输入操作通常包括两个阶段：")]),t._v(" "),a("ul",[a("li",[t._v("等待数据准备好")]),t._v(" "),a("li",[t._v("从内核向进程复制数据")])]),t._v(" "),a("p",[t._v("对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。")]),t._v(" "),a("p",[t._v("Unix 有五种 I/O 模型：")]),t._v(" "),a("ul",[a("li",[t._v("阻塞式 I/O")]),t._v(" "),a("li",[t._v("非阻塞式 I/O")]),t._v(" "),a("li",[t._v("I/O 复用（select 和 poll）")]),t._v(" "),a("li",[t._v("信号驱动式 I/O（SIGIO）")]),t._v(" "),a("li",[t._v("异步 I/O（AIO）")])]),t._v(" "),a("h3",{attrs:{id:"阻塞式-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞式-i-o"}},[t._v("#")]),t._v(" ## 阻塞式 I/O")]),t._v(" "),a("p",[t._v("应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。")]),t._v(" "),a("p",[t._v("应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。")]),t._v(" "),a("p",[t._v("下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。")]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ssize_t")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("recvfrom")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sockfd"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("buf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" len"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" flags"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("sockaddr")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("src_addr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("socklen_t")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("addrlen"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AdmireAn/blobImage@main/img/1492928416812_4.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"非阻塞式-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞式-i-o"}},[t._v("#")]),t._v(" ## 非阻塞式 I/O")]),t._v(" "),a("p",[t._v("应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。")]),t._v(" "),a("p",[t._v("由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AdmireAn/blobImage@main/img/1492929000361_5.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"i-o-复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i-o-复用"}},[t._v("#")]),t._v(" ## I/O 复用")]),t._v(" "),a("p",[t._v("使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。")]),t._v(" "),a("p",[t._v("它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。")]),t._v(" "),a("p",[t._v("如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AdmireAn/blobImage@main/img/1492929444818_6.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"信号驱动-i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信号驱动-i-o"}},[t._v("#")]),t._v(" ## 信号驱动 I/O")]),t._v(" "),a("p",[t._v("应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。")]),t._v(" "),a("p",[t._v("相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AdmireAn/blobImage@main/img/1492929553651_7.png",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"异步i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步i-o"}},[t._v("#")]),t._v(" 异步I/O")]),t._v(" "),a("p",[t._v("应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。")]),t._v(" "),a("p",[t._v("异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AdmireAn/blobImage@main/img/1492930243286_8.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"五大-i-o-模型比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五大-i-o-模型比较"}},[t._v("#")]),t._v(" ## 五大 I/O 模型比较")]),t._v(" "),a("ul",[a("li",[t._v("同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。")]),t._v(" "),a("li",[t._v("异步 I/O：第二阶段应用进程不会阻塞。")])]),t._v(" "),a("p",[t._v("同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。")]),t._v(" "),a("p",[t._v("非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AdmireAn/blobImage@main/img/1492928105791_3.png",alt:"img"}})])])}),[],!1,null,null,null);s.default=r.exports}}]);