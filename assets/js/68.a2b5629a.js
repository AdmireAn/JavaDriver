(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{570:function(v,_,t){"use strict";t.r(_);var a=t(21),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"tcp粘包与拆包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp粘包与拆包"}},[v._v("#")]),v._v(" TCP粘包与拆包")]),v._v(" "),t("p",[v._v("TCP是个“流”协议，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24ely1h6il1rx9b8j21b80lcgn0.jpg",alt:""}})]),v._v(" "),t("p",[v._v("假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。")]),v._v(" "),t("p",[v._v("（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；")]),v._v(" "),t("p",[v._v("（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；")]),v._v(" "),t("p",[v._v("（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；")]),v._v(" "),t("p",[v._v("（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。")]),v._v(" "),t("p",[v._v("如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。")]),v._v(" "),t("h2",{attrs:{id:"粘包和拆包原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#粘包和拆包原因"}},[v._v("#")]),v._v(" 粘包和拆包原因")]),v._v(" "),t("p",[v._v("（1）要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；")]),v._v(" "),t("p",[v._v("（2）接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；")]),v._v(" "),t("p",[v._v("（3）要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；")]),v._v(" "),t("p",[v._v("（4）待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。")]),v._v(" "),t("h2",{attrs:{id:"粘包和拆包解决策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#粘包和拆包解决策略"}},[v._v("#")]),v._v(" 粘包和拆包解决策略")]),v._v(" "),t("p",[v._v("由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：")]),v._v(" "),t("p",[v._v("消息定长。发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。")]),v._v(" "),t("p",[v._v("设置消息边界。服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如FTP协议。")]),v._v(" "),t("p",[v._v("将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。\n更复杂的应用层协议。")]),v._v(" "),t("h2",{attrs:{id:"粘包的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#粘包的概念"}},[v._v("#")]),v._v(" 粘包的概念")]),v._v(" "),t("p",[v._v("粘包：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。")]),v._v(" "),t("p",[v._v("比如说：发送方发送了两个数据，接收方一次收了一个半数据（接收方可能不清楚一个包有多大）")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24ely1h6il36bwhrj21c00e4myr.jpg",alt:""}})]),v._v(" "),t("h2",{attrs:{id:"出现粘包的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#出现粘包的原因"}},[v._v("#")]),v._v(" 出现粘包的原因")]),v._v(" "),t("p",[v._v("出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。")]),v._v(" "),t("p",[v._v("发送方引起的粘包是由TCP协议本身造成的：")]),v._v(" "),t("p",[v._v("TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24ely1h6il3mbawaj21ec09o75g.jpg",alt:""}})]),v._v(" "),t("p",[v._v("TCP协议规定有MSS，如果数据包过长就会被分开传输。这样接收方就收到了拆包数据。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24ely1h6il4nlrlmj21f80f0gna.jpg",alt:""}})]),v._v(" "),t("p",[v._v("接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。")]),v._v(" "),t("p",[v._v("在代码中常见体现：")]),v._v(" "),t("p",[v._v("要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。")]),v._v(" "),t("p",[v._v("要发送的数据大于MSS，TCP在传输前将进行拆包。")]),v._v(" "),t("p",[v._v("要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。")]),v._v(" "),t("p",[v._v("接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。\n等等。")]),v._v(" "),t("h2",{attrs:{id:"粘包的处理方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#粘包的处理方式"}},[v._v("#")]),v._v(" 粘包的处理方式")]),v._v(" "),t("p",[v._v("当短连接的情况下，不用考虑粘包的情况")]),v._v(" "),t("p",[v._v("如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包")]),v._v(" "),t("p",[v._v("如果双方建立长连接，需要在连接后一段时间内发送不同结构数据")]),v._v(" "),t("p",[v._v("发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。")]),v._v(" "),t("p",[v._v("发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。")]),v._v(" "),t("p",[v._v("可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。")])])}),[],!1,null,null,null);_.default=s.exports}}]);