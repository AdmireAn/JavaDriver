(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,l=e[0],s=e[1],c=e[2],u=0,p=[];u<l.length;u++)o=l[u],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&p.push(a[o][0]),a[o]=0;for(r in s)Object.prototype.hasOwnProperty.call(s,r)&&(n[r]=s[r]);for(d&&d(e);p.length;)p.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],r=!0,l=1;l<t.length;l++){var s=t[l];0!==a[s]&&(r=!1)}r&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},a={1:0},i=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var i,l=document.createElement("script");l.charset="utf-8",l.timeout=120,o.nc&&l.setAttribute("nonce",o.nc),l.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"8d23e9e5",3:"ac8e7f2b",4:"1be738b1",5:"a1f24142",6:"9b4da7fa",7:"d087188e",8:"c9b8a060",9:"0d1b917b",10:"1edb6dac",11:"06baedfc",12:"f630918a",13:"a35107d5",14:"4ee86474",15:"92d29b5e",16:"98bffc3b",17:"a8538471",18:"080f06c4",19:"3d0b2033",20:"561a0ed2",21:"420dd843",22:"98b908ab",23:"84d6cab1",24:"dbf6b50f",25:"4d483080",26:"c686e987",27:"9de53bd3",28:"9ba021c1",29:"f569f48b",30:"572c0ea8",31:"56979919",32:"abc7cf1b",33:"c8320ed6",34:"52928a22",35:"e6a425be",36:"7e6e2485",37:"edf87a13",38:"c47c2369",39:"9aaceb5c",40:"276a8da4",41:"a14cbeea",42:"865930a2",43:"285c2f43",44:"cc6f4789",45:"6e0506e9",46:"da5a18f8",47:"72808083",48:"3344f1f8",49:"23c17619",50:"4230b8a8",51:"a6eb687f",52:"c4502dea",53:"eba15757",54:"4b3ecb2b",55:"2dfeef15",56:"6cf927ae",57:"00621ad1",58:"4eb2acfb",59:"d84c66ff",60:"7de90538",61:"8ae7f9c6",62:"b9ecfb10",63:"46f48322",64:"b26606de",65:"4d7824c8",66:"986ba9c4",67:"958eb003",68:"a2b5629a",69:"1aec44ee",70:"7cd7b4e4",71:"c7b8deb0",72:"c9db6cf2",73:"5746737d",74:"bf9a945b",75:"04eaebc8",76:"8ac15c25",77:"a4e297af",78:"2d565948",79:"cc4189f4",80:"b711ac4f",81:"102f6e53",82:"87bcba98",83:"e64e025e",84:"a2a3695e",85:"a152164e",86:"dd920be9",87:"7b9fd336",88:"b1f3de32",89:"584649c5",90:"cecafbf6",91:"7b4c1cdc",92:"9b07fe88",93:"221fff07",94:"b7ad5ce6",95:"9608f6c5",96:"659db525",97:"2b2d3726",98:"5085b009",99:"9b605260",100:"b33f86ba",101:"0a94513e",102:"33e6a080",103:"232a13ca",104:"7ee6ced0",105:"7da3ff13",106:"4f67fbe0",107:"83ad896a",108:"acd73b33",109:"0c5a316f",110:"468674e0",111:"0884b25d",112:"14a4db1b",113:"3665d791",114:"a76daf3e",115:"fc50325c",116:"d878d354",117:"41111223",118:"2e33528d",119:"1c5c3ccd",120:"cf624d25",121:"dc9a84ed",122:"8cefab56",123:"93d23262",124:"1df41ca4",125:"a7953d41",126:"60e10f35",127:"dd1cb7a8",128:"243a5468",129:"5218fc77",130:"337ce8b9",131:"3ede4d10",132:"a0f7bf5f",133:"2b7b4e83",134:"22676154",135:"bd2ef845",136:"9ee85e23",137:"f4f86f41",138:"6ebed0f8",139:"d65c870e",140:"6c013524",141:"6bb0f0b2",142:"0dd7ee63",143:"1744f01b",144:"3e7af70b",145:"26c5f49a",146:"a843c882",147:"b9986ee3",148:"e233f6ad",149:"786ca846",150:"6b361d6c",151:"0c087956",152:"12e13429",153:"b75da292",154:"b47ad622",155:"8515b2fc",156:"7e86e112",157:"eb25995c",158:"460bdca5",159:"c844a271",160:"d3ef9371",161:"652a1055",162:"418b94d8",163:"bb566a17",164:"6b2ebfa9",165:"95392c30",166:"144c9c87",167:"058b2c31",168:"beb41dd9",169:"52df9915",170:"c34bbc93",171:"b2363da5",172:"2b2f8c5a",173:"da36aaa4",174:"71264f30",175:"611e943b",176:"7cfb044f",177:"15beef70",178:"79ff820c",179:"c08c74c3",180:"681ee059",181:"7102e101",182:"72203307",183:"e1fc959d",184:"65792811",185:"892e87d5",186:"b6b36b6b",187:"912699b1",188:"42fde07d",189:"6c294030",190:"b7427722",191:"0905ec2f",192:"d25b1912",193:"308f070f",194:"0aec45c8",195:"7b67c639",196:"38b72bcd",197:"42b37542",198:"5a0a06dd",199:"8d196f68",200:"019c8e76",201:"fd9e7b3e",202:"93342e23",203:"6a28f1ac",204:"6eaf6ea1",205:"abb6e9b0",206:"cd876280",207:"1c3edc66",208:"9d9a37b6",209:"45060ee6",210:"8ba5ce75",211:"aec9815a",212:"375fc6cb",213:"991a0661"}[n]+".js"}(n);var s=new Error;i=function(e){l.onerror=l.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+r+": "+i+")",s.name="ChunkLoadError",s.type=r,s.request=i,t[1](s)}a[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:l})}),12e4);l.onerror=l.onload=i,document.head.appendChild(l)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/JavaDriver/",o.oe=function(n){throw console.error(n),n};var l=window.webpackJsonp=window.webpackJsonp||[],s=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var d=s;i.push([246,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(0),a=t(37).f,i=t(28),o=t(14),l=t(117),s=t(123),c=t(110);n.exports=function(n,e){var t,d,u,p,h,f=n.target,m=n.global,g=n.stat;if(t=m?r:g?r[f]||l(f,{}):(r[f]||{}).prototype)for(d in e){if(p=e[d],u=n.noTargetGet?(h=a(t,d))&&h.value:t[d],!c(m?d:f+(g?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;s(p,u)}(n.sham||u&&u.sham)&&i(p,"sham",!0),o(t,d,p,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(66),a=Function.prototype,i=a.bind,o=a.call,l=r&&i.bind(o,o);n.exports=r?function(n){return n&&l(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(127),a=t(14),i=t(266);r||a(Object.prototype,"toString",i,{unsafe:!0})},function(n,e,t){var r=t(0),a=t(51),i=t(9),o=t(86),l=t(52),s=t(160),c=a("wks"),d=r.Symbol,u=d&&d.for,p=s?d:d&&d.withoutSetter||o;n.exports=function(n){if(!i(c,n)||!l&&"string"!=typeof c[n]){var e="Symbol."+n;l&&i(d,n)?c[n]=d[n]:c[n]=s&&u?u(e):p(e)}return c[n]}},function(n,e,t){var r=t(2);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(66),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){var r=t(3),a=t(17),i=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(a(n),e)}},function(n,e,t){var r=t(0),a=t(11),i=r.String,o=r.TypeError;n.exports=function(n){if(a(n))return n;throw o(i(n)+" is not an object")}},function(n,e,t){var r=t(4);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(0),a=t(83),i=r.String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var r=t(0),a=t(7),i=t(162),o=t(161),l=t(10),s=t(88),c=r.TypeError,d=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=a?o?function(n,e,t){if(l(n),e=s(e),l(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return d(n,e,t)}:d:function(n,e,t){if(l(n),e=s(e),l(t),i)try{return d(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(0),a=t(4),i=t(28),o=t(167),l=t(117);n.exports=function(n,e,t,s){var c=!!s&&!!s.unsafe,d=!!s&&!!s.enumerable,u=!!s&&!!s.noTargetGet,p=s&&void 0!==s.name?s.name:e;return a(t)&&o(t,p,s),n===r?(d?n[e]=t:l(e,t),n):(c?!u&&n[e]&&(d=!0):delete n[e],d?n[e]=t:i(n,e,t),n)}},function(n,e,t){var r=t(0),a=t(4),i=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(r[n]):r[n]&&r[n][e]}},function(n,e){n.exports=!1},function(n,e,t){var r=t(0),a=t(19),i=r.Object;n.exports=function(n){return i(a(n))}},function(n,e,t){"use strict";var r=t(1),a=t(98);r({target:"RegExp",proto:!0,forced:/./.exec!==a},{exec:a})},function(n,e,t){var r=t(0).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,e,t){var r=t(65),a=t(19);n.exports=function(n){return r(a(n))}},function(n,e,t){"use strict";function r(n,e,t,r,a,i,o,l){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=s):a&&(s=l?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(n,e){return s.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(179).charAt,a=t(12),i=t(38),o=t(166),l=i.set,s=i.getterFor("String Iterator");o(String,"String",(function(n){l(this,{type:"String Iterator",string:a(n),index:0})}),(function(){var n,e=s(this),t=e.string,a=e.index;return a>=t.length?{value:void 0,done:!0}:(n=r(t,a),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(0),a=t(4),i=t(68),o=r.TypeError;n.exports=function(n){if(a(n))return n;throw o(i(n)+" is not a function")}},function(n,e,t){var r=t(54);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(1),a=t(60).filter;r({target:"Array",proto:!0,forced:!t(96)("filter")},{filter:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),a=t(180),i=t(181),o=t(149),l=t(28),s=t(6),c=s("iterator"),d=s("toStringTag"),u=o.values,p=function(n,e){if(n){if(n[c]!==u)try{l(n,c,u)}catch(e){n[c]=u}if(n[d]||l(n,d,e),a[e])for(var t in o)if(n[t]!==o[t])try{l(n,t,o[t])}catch(e){n[t]=o[t]}}};for(var h in a)p(r[h]&&r[h].prototype,h);p(i,"DOMTokenList")},function(n,e,t){var r=t(3),a=r({}.toString),i=r("".slice);n.exports=function(n){return i(a(n),8,-1)}},function(n,e,t){var r=t(7),a=t(13),i=t(48);n.exports=r?function(n,e,t){return a.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var r=t(1),a=t(187);r({target:"Array",proto:!0,forced:[].forEach!=a},{forEach:a})},function(n,e,t){var r=t(0),a=t(180),i=t(181),o=t(187),l=t(28),s=function(n){if(n&&n.forEach!==o)try{l(n,"forEach",o)}catch(e){n.forEach=o}};for(var c in a)a[c]&&s(r[c]&&r[c].prototype);s(i)},function(n,e,t){var r=t(14),a=t(286),i=Error.prototype;i.toString!==a&&r(i,"toString",a)},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(15);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(198),a="object"==typeof self&&self&&self.Object===Object&&self,i=r||a||Function("return this")();n.exports=i},function(n,e,t){var r,a=t(10),i=t(118),o=t(121),l=t(69),s=t(165),c=t(87),d=t(90),u=d("IE_PROTO"),p=function(){},h=function(n){return"<script>"+n+"<\/script>"},f=function(n){n.write(h("")),n.close();var e=n.parentWindow.Object;return n=null,e},m=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;m="undefined"!=typeof document?document.domain&&r?f(r):((e=c("iframe")).style.display="none",s.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(h("document.F=Object")),n.close(),n.F):f(r);for(var t=o.length;t--;)delete m.prototype[o[t]];return m()};l[u]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=a(n),t=new p,p.prototype=null,t[u]=n):t=m(),void 0===e?t:i.f(t,e)}},function(n,e,t){var r=t(3);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(7),a=t(8),i=t(122),o=t(48),l=t(20),s=t(88),c=t(9),d=t(162),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=l(n),e=s(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return o(!a(i.f,n,e),n[e])}},function(n,e,t){var r,a,i,o=t(248),l=t(0),s=t(3),c=t(11),d=t(28),u=t(9),p=t(116),h=t(90),f=t(69),m=l.TypeError,g=l.WeakMap;if(o||p.state){var v=p.state||(p.state=new g),b=s(v.get),y=s(v.has),E=s(v.set);r=function(n,e){if(y(v,n))throw new m("Object already initialized");return e.facade=n,E(v,n,e),e},a=function(n){return b(v,n)||{}},i=function(n){return y(v,n)}}else{var x=h("state");f[x]=!0,r=function(n,e){if(u(n,x))throw new m("Object already initialized");return e.facade=n,d(n,x,e),e},a=function(n){return u(n,x)?n[x]:{}},i=function(n){return u(n,x)}}n.exports={set:r,get:a,has:i,enforce:function(n){return i(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=a(e)).type!==n)throw m("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(66),a=Function.prototype,i=a.apply,o=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){var r=t(1),a=t(0),i=t(39),o=t(282),l=a.WebAssembly,s=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,s),r({global:!0,constructor:!0,arity:1,forced:s},t)},d=function(n,e){if(l&&l[n]){var t={};t[n]=o("WebAssembly."+n,e,s),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:s},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var r=t(306),a=t(309);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";var r=t(1),a=t(0),i=t(63),o=t(94),l=t(11),s=t(120),c=t(24),d=t(20),u=t(76),p=t(6),h=t(96),f=t(73),m=h("slice"),g=p("species"),v=a.Array,b=Math.max;r({target:"Array",proto:!0,forced:!m},{slice:function(n,e){var t,r,a,p=d(this),h=c(p),m=s(n,h),y=s(void 0===e?h:e,h);if(i(p)&&(t=p.constructor,(o(t)&&(t===v||i(t.prototype))||l(t)&&null===(t=t[g]))&&(t=void 0),t===v||void 0===t))return f(p,m,y);for(r=new(void 0===t?v:t)(b(y-m,0)),a=0;m<y;m++,a++)m in p&&u(r,a,p[m]);return r.length=a,r}})},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return s})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return h})),t.d(e,"m",(function(){return f})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return E}));t(18),t(45),t(145),t(81),t(109),t(115),t(44),t(29),t(5),t(30),t(25),t(84),t(108),t(159),t(56),t(219),t(31),t(148);var r=/#.*$/,a=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function l(n){return decodeURI(n).replace(r,"").replace(a,"")}function s(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(s(n))return n;if(!n)return"404";var e=n.match(r),t=e?e[0]:"",a=l(n);return i.test(a)?n:a+".html"+t}function p(n,e){var t=n.hash,a=function(n){var e=n&&n.match(r);if(e)return e[0]}(e);return(!a||t===a)&&l(n.path)===l(e)}function h(n,e,t){if(s(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var l=i[o];".."===l?a.pop():"."!==l&&a.push(l)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));for(var r=l(e),a=0;a<n.length;a++)if(l(n[a].regularPath)===r)return Object.assign({},n[a],{type:"page",path:u(n[a].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function f(n,e,t,r){var a=t.pages,i=t.themeConfig,o=r&&i.locales&&i.locales[r]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return m(n);var l=o.sidebar||i.sidebar;if(l){var s=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,l),c=s.base,d=s.config;return"auto"===d?m(n):d?d.map((function(n){return function n(e,t,r){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return h(t,e,r);if(Array.isArray(e))return Object.assign(h(t,e[0],r),{title:e[1]});a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var i=e.children||[];return 0===i.length&&e.path?Object.assign(h(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map((function(e){return n(e,t,r,a+1)})),collapsable:!1!==e.collapsable}}(n,a,c)})):[]}return[]}function m(n){var e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function g(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function E(n,e){return y(e)-y(n)}},function(n,e,t){"use strict";var r=t(1),a=t(60).map;r({target:"Array",proto:!0,forced:!t(96)("map")},{map:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(39),a=t(8),i=t(3),o=t(113),l=t(2),s=t(10),c=t(4),d=t(58),u=t(54),p=t(12),h=t(19),f=t(132),m=t(47),g=t(287),v=t(114),b=t(6)("replace"),y=Math.max,E=Math.min,x=i([].concat),k=i([].push),w=i("".indexOf),T=i("".slice),A="$0"==="a".replace(/./,"$0"),S=!!/./[b]&&""===/./[b]("a","$0");o("replace",(function(n,e,t){var i=S?"$":"$0";return[function(n,t){var r=h(this),i=null==n?void 0:m(n,b);return i?a(i,n,r,t):a(e,p(r),n,t)},function(n,a){var o=s(this),l=p(n);if("string"==typeof a&&-1===w(a,i)&&-1===w(a,"$<")){var h=t(e,o,l,a);if(h.done)return h.value}var m=c(a);m||(a=p(a));var b=o.global;if(b){var A=o.unicode;o.lastIndex=0}for(var S=[];;){var B=v(o,l);if(null===B)break;if(k(S,B),!b)break;""===p(B[0])&&(o.lastIndex=f(l,u(o.lastIndex),A))}for(var I,C="",_=0,P=0;P<S.length;P++){for(var z=p((B=S[P])[0]),j=y(E(d(B.index),l.length),0),L=[],O=1;O<B.length;O++)k(L,void 0===(I=B[O])?I:String(I));var D=B.groups;if(m){var M=x([z],L,j,l);void 0!==D&&k(M,D);var R=p(r(a,void 0,M))}else R=g(z,l,j,L,D,a);j>=_&&(C+=T(l,_,j)+R,_=j+z.length)}return C+T(l,_)}]}),!!l((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!A||S)},function(n,e,t){"use strict";var r=t(2);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(23);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(82),t(77),t(25),t(5),t(400),t(29),t(30),t(182),t(401),t(104);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}},function(n,e,t){var r=t(16),a=t(116);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.5",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.5/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var r=t(53),a=t(2);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,i=t(0),o=t(33),l=i.process,s=i.Deno,c=l&&l.versions||s&&s.version,d=c&&c.v8;d&&(a=(r=d.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(58),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e,t){var r=t(0);n.exports=r.Promise},function(n,e,t){"use strict";var r=t(1),a=t(0),i=t(2),o=t(63),l=t(11),s=t(17),c=t(24),d=t(76),u=t(152),p=t(96),h=t(6),f=t(53),m=h("isConcatSpreadable"),g=a.TypeError,v=f>=51||!i((function(){var n=[];return n[m]=!1,n.concat()[0]!==n})),b=p("concat"),y=function(n){if(!l(n))return!1;var e=n[m];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,arity:1,forced:!v||!b},{concat:function(n){var e,t,r,a,i,o=s(this),l=u(o,0),p=0;for(e=-1,r=arguments.length;e<r;e++)if(y(i=-1===e?o:arguments[e])){if(p+(a=c(i))>9007199254740991)throw g("Maximum allowed index exceeded");for(t=0;t<a;t++,p++)t in i&&d(l,p,i[t])}else{if(p>=9007199254740991)throw g("Maximum allowed index exceeded");d(l,p++,i)}return l.length=p,l}})},function(n,e,t){t(382),t(383)},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?r:t)(e)}},function(n,e,t){var r=t(3),a=t(23),i=t(66),o=r(r.bind);n.exports=function(n,e){return a(n),void 0===e?n:i?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(59),a=t(3),i=t(65),o=t(17),l=t(24),s=t(152),c=a([].push),d=function(n){var e=1==n,t=2==n,a=3==n,d=4==n,u=6==n,p=7==n,h=5==n||u;return function(f,m,g,v){for(var b,y,E=o(f),x=i(E),k=r(m,g),w=l(x),T=0,A=v||s,S=e?A(f,w):t||p?A(f,0):void 0;w>T;T++)if((h||T in x)&&(y=k(b=x[T],T,E),n))if(e)S[T]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return T;case 2:c(S,b)}else switch(n){case 4:return!1;case 7:c(S,b)}return u?-1:a||d?d:S}};n.exports={forEach:d(0),map:d(1),filter:d(2),some:d(3),every:d(4),find:d(5),findIndex:d(6),filterReject:d(7)}},function(n,e,t){var r=t(164),a=t(121).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(13).f,a=t(9),i=t(6)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!a(n,i)&&r(n,i,{configurable:!0,value:e})}},function(n,e,t){var r=t(27);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(78),a=t(291),i=t(292),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?a(n):i(n)}},function(n,e,t){var r=t(0),a=t(3),i=t(2),o=t(27),l=r.Object,s=a("".split);n.exports=i((function(){return!l("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):l(n)}:l},function(n,e,t){var r=t(2);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(0),a=t(15),i=t(4),o=t(36),l=t(160),s=r.Object;n.exports=l?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return i(e)&&o(e.prototype,s(n))}},function(n,e,t){var r=t(0).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(7),a=t(9),i=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,l=a(i,"name"),s=l&&"something"===function(){}.name,c=l&&(!r||r&&o(i,"name").configurable);n.exports={EXISTS:l,PROPER:s,CONFIGURABLE:c}},function(n,e,t){var r=t(3),a=t(10),i=t(249);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),i(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e,t){var r=t(3);n.exports=r([].slice)},function(n,e,t){var r=t(0),a=t(55),i=t(4),o=t(110),l=t(91),s=t(6),c=t(257),d=t(16),u=t(53),p=a&&a.prototype,h=s("species"),f=!1,m=i(r.PromiseRejectionEvent),g=o("Promise",(function(){var n=l(a),e=n!==String(a);if(!e&&66===u)return!0;if(d&&(!p.catch||!p.finally))return!0;if(u>=51&&/native code/.test(n))return!1;var t=new a((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[h]=r,!(f=t.then((function(){}))instanceof r)||!e&&c&&!m}));n.exports={CONSTRUCTOR:g,REJECTION_EVENT:m,SUBCLASSING:f}},function(n,e,t){"use strict";var r=t(23),a=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new a(n)}},function(n,e,t){"use strict";var r=t(88),a=t(13),i=t(48);n.exports=function(n,e,t){var o=r(e);o in n?a.f(n,o,i(0,t)):n[o]=t}},function(n,e,t){t(274),t(277),t(278),t(130),t(279)},function(n,e,t){var r=t(34).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(84);var r=t(80);t(77),t(97),t(5),t(131),t(22),t(26),t(193);var a=t(105);t(40),t(31);function i(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(a.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";t(18);var r,a,i=t(1),o=t(0),l=t(8),s=t(3),c=t(4),d=t(11),u=(r=!1,(a=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===a.test("abc")&&r),p=o.Error,h=s(/./.test);i({target:"RegExp",proto:!0,forced:!u},{test:function(n){var e=this.exec;if(!c(e))return h(this,n);var t=l(e,this,n);if(null!==t&&!d(t))throw new p("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var r=t(1),a=t(17),i=t(89);r({target:"Object",stat:!0,forced:t(2)((function(){i(1)}))},{keys:function(n){return i(a(n))}})},function(n,e,t){var r=t(0),a=t(127),i=t(4),o=t(27),l=t(6)("toStringTag"),s=r.Object,c="Arguments"==o(function(){return arguments}());n.exports=a?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),l))?t:c?o(e):"Object"==(r=o(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){t(1)({target:"Array",stat:!0},{isArray:t(63)})},function(n,e,t){var r=t(7),a=t(71).EXISTS,i=t(3),o=t(13).f,l=Function.prototype,s=i(l.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,d=i(c.exec);r&&!a&&o(l,"name",{configurable:!0,get:function(){try{return d(c,s(this))[1]}catch(n){return""}}})},function(n,e,t){var r=t(3),a=0,i=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++a+i,36)}},function(n,e,t){var r=t(0),a=t(11),i=r.document,o=a(i)&&a(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var r=t(163),a=t(67);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e,t){var r=t(164),a=t(121);n.exports=Object.keys||function(n){return r(n,a)}},function(n,e,t){var r=t(51),a=t(86),i=r("keys");n.exports=function(n){return i[n]||(i[n]=a(n))}},function(n,e,t){var r=t(3),a=t(4),i=t(116),o=r(Function.toString);a(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(27),a=t(0);n.exports="process"==r(a.process)},function(n,e,t){var r=t(3),a=t(2),i=t(4),o=t(83),l=t(15),s=t(91),c=function(){},d=[],u=l("Reflect","construct"),p=/^\s*(?:class|function)\b/,h=r(p.exec),f=!p.exec(c),m=function(n){if(!i(n))return!1;try{return u(c,d,n),!0}catch(n){return!1}},g=function(n){if(!i(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return f||!!h(p,s(n))}catch(n){return!0}};g.sham=!0,n.exports=!u||a((function(){var n;return m(m.call)||!m(Object)||!m((function(){n=!0}))||n}))?g:m},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(5);function r(n,e,t,r,a,i,o){try{var l=n[i](o),s=l.value}catch(n){return void t(n)}l.done?e(s):Promise.resolve(s).then(r,a)}function a(n){return function(){var e=this,t=arguments;return new Promise((function(a,i){var o=n.apply(e,t);function l(n){r(o,a,i,l,s,"next",n)}function s(n){r(o,a,i,l,s,"throw",n)}l(void 0)}))}}},function(n,e,t){var r=t(2),a=t(6),i=t(53),o=a("species");n.exports=function(n){return i>=51||!r((function(){var e=[];return(e.constructor={})[o]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var r=t(1),a=t(7),i=t(0),o=t(3),l=t(9),s=t(4),c=t(36),d=t(12),u=t(13).f,p=t(123),h=i.Symbol,f=h&&h.prototype;if(a&&s(h)&&(!("description"in f)||void 0!==h().description)){var m={},g=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:d(arguments[0]),e=c(f,this)?new h(n):void 0===n?h():h(n);return""===n&&(m[e]=!0),e};p(g,h),g.prototype=f,f.constructor=g;var v="Symbol(test)"==String(h("test")),b=o(f.toString),y=o(f.valueOf),E=/^Symbol\((.*)\)[^)]+$/,x=o("".replace),k=o("".slice);u(f,"description",{configurable:!0,get:function(){var n=y(this),e=b(n);if(l(m,n))return"";var t=v?k(e,7,-1):x(e,E,"$1");return""===t?void 0:t}}),r({global:!0,constructor:!0,forced:!0},{Symbol:g})}},function(n,e,t){"use strict";var r,a,i=t(8),o=t(3),l=t(12),s=t(194),c=t(112),d=t(51),u=t(35),p=t(38).get,h=t(232),f=t(236),m=d("native-string-replace",String.prototype.replace),g=RegExp.prototype.exec,v=g,b=o("".charAt),y=o("".indexOf),E=o("".replace),x=o("".slice),k=(a=/b*/g,i(g,r=/a/,"a"),i(g,a,"a"),0!==r.lastIndex||0!==a.lastIndex),w=c.BROKEN_CARET,T=void 0!==/()??/.exec("")[1];(k||T||w||h||f)&&(v=function(n){var e,t,r,a,o,c,d,h=this,f=p(h),A=l(n),S=f.raw;if(S)return S.lastIndex=h.lastIndex,e=i(v,S,A),h.lastIndex=S.lastIndex,e;var B=f.groups,I=w&&h.sticky,C=i(s,h),_=h.source,P=0,z=A;if(I&&(C=E(C,"y",""),-1===y(C,"g")&&(C+="g"),z=x(A,h.lastIndex),h.lastIndex>0&&(!h.multiline||h.multiline&&"\n"!==b(A,h.lastIndex-1))&&(_="(?: "+_+")",z=" "+z,P++),t=new RegExp("^(?:"+_+")",C)),T&&(t=new RegExp("^"+_+"$(?!\\s)",C)),k&&(r=h.lastIndex),a=i(g,I?t:h,z),I?a?(a.input=x(a.input,P),a[0]=x(a[0],P),a.index=h.lastIndex,h.lastIndex+=a[0].length):h.lastIndex=0:k&&a&&(h.lastIndex=h.global?a.index+a[0].length:r),T&&a&&a.length>1&&i(m,a[0],t,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(a[o]=void 0)})),a&&B)for(a.groups=c=u(null),o=0;o<B.length;o++)c[(d=B[o])[0]]=a[d[1]];return a}),n.exports=v},function(n,e,t){var r=t(296),a=t(297),i=t(298),o=t(299),l=t(300);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=a,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var r=t(200);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(41)(Object,"create");n.exports=r},function(n,e,t){var r=t(318);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(140);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r=t(1),a=t(7),i=t(13).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==i,sham:!a},{defineProperty:i})},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(42),t(5),t(85),t(193),t(22),t(18),t(81);var r=t(80);function a(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(r.barSelector),d=r.speed,u=r.easing;return s.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),l(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,a}(n,d,u)),1===n?(l(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){l(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,o=e.querySelector(r.barSelector),s=n?"-100":i(t.status||0),d=document.querySelector(r.parent);return l(o,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&p(a),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),l=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+i)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,i=arguments;if(2==i.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,i[1],i[2])}}();function s(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;s(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=u(n);s(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){"use strict";var r=t(1),a=t(3),i=t(119).indexOf,o=t(46),l=a([].indexOf),s=!!l&&1/l([1],1,-0)<0,c=o("indexOf");r({target:"Array",proto:!0,forced:s||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return s?l(this,n,e)||0:i(this,n,e)}})},function(n,e,t){"use strict";var r=t(39),a=t(8),i=t(3),o=t(113),l=t(153),s=t(10),c=t(19),d=t(126),u=t(132),p=t(54),h=t(12),f=t(47),m=t(129),g=t(114),v=t(98),b=t(112),y=t(2),E=b.UNSUPPORTED_Y,x=Math.min,k=[].push,w=i(/./.exec),T=i(k),A=i("".slice);o("split",(function(n,e,t){var i;return i="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var i=h(c(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[i];if(!l(n))return a(e,i,n,o);for(var s,d,u,p=[],f=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),g=0,b=new RegExp(n.source,f+"g");(s=a(v,b,i))&&!((d=b.lastIndex)>g&&(T(p,A(i,g,s.index)),s.length>1&&s.index<i.length&&r(k,p,m(s,1)),u=s[0].length,g=d,p.length>=o));)b.lastIndex===s.index&&b.lastIndex++;return g===i.length?!u&&w(b,"")||T(p,""):T(p,A(i,g)),p.length>o?m(p,0,o):p}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:a(e,this,n,t)}:e,[function(e,t){var r=c(this),o=null==e?void 0:f(e,n);return o?a(o,e,r,t):a(i,h(r),e,t)},function(n,r){var a=s(this),o=h(n),l=t(i,a,o,r,i!==e);if(l.done)return l.value;var c=d(a,RegExp),f=a.unicode,m=(a.ignoreCase?"i":"")+(a.multiline?"m":"")+(a.unicode?"u":"")+(E?"g":"y"),v=new c(E?"^(?:"+a.source+")":a,m),b=void 0===r?4294967295:r>>>0;if(0===b)return[];if(0===o.length)return null===g(v,o)?[o]:[];for(var y=0,k=0,w=[];k<o.length;){v.lastIndex=E?0:k;var S,B=g(v,E?A(o,k):o);if(null===B||(S=x(p(v.lastIndex+(E?k:0)),o.length))===y)k=u(o,k,f);else{if(T(w,A(o,y,k)),w.length===b)return w;for(var I=1;I<=B.length-1;I++)if(T(w,B[I]),w.length===b)return w;k=y=S}}return T(w,A(o,y)),w}]}),!!y((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),E)},function(n,e,t){var r=t(2),a=t(4),i=/#|\.prototype\./,o=function(n,e){var t=s[l(n)];return t==d||t!=c&&(a(e)?r(e):!!e)},l=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},s=o.data={},c=o.NATIVE="N",d=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(83),a=t(47),i=t(70),o=t(6)("iterator");n.exports=function(n){if(null!=n)return a(n,o)||a(n,"@@iterator")||i[r(n)]}},function(n,e,t){var r=t(2),a=t(0).RegExp,i=r((function(){var n=a("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=i||r((function(){return!a("a","y").sticky})),l=i||r((function(){var n=a("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:l,MISSED_STICKY:o,UNSUPPORTED_Y:i}},function(n,e,t){"use strict";t(18);var r=t(3),a=t(14),i=t(98),o=t(2),l=t(6),s=t(28),c=l("species"),d=RegExp.prototype;n.exports=function(n,e,t,u){var p=l(n),h=!o((function(){var e={};return e[p]=function(){return 7},7!=""[n](e)})),f=h&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[p]=/./[p]),t.exec=function(){return e=!0,null},t[p](""),!e}));if(!h||!f||t){var m=r(/./[p]),g=e(p,""[n],(function(n,e,t,a,o){var l=r(n),s=e.exec;return s===i||s===d.exec?h&&!o?{done:!0,value:m(e,t,a)}:{done:!0,value:l(t,e,a)}:{done:!1}}));a(String.prototype,n,g[0]),a(d,p,g[1])}u&&s(d[p],"sham",!0)}},function(n,e,t){var r=t(0),a=t(8),i=t(10),o=t(4),l=t(27),s=t(98),c=r.TypeError;n.exports=function(n,e){var t=n.exec;if(o(t)){var r=a(t,n,e);return null!==r&&i(r),r}if("RegExp"===l(n))return a(s,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var r=t(1),a=t(3),i=t(65),o=t(20),l=t(46),s=a([].join),c=i!=Object,d=l("join",",");r({target:"Array",proto:!0,forced:c||!d},{join:function(n){return s(o(this),void 0===n?",":n)}})},function(n,e,t){var r=t(0),a=t(117),i=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=i},function(n,e,t){var r=t(0),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(7),a=t(161),i=t(13),o=t(10),l=t(20),s=t(89);e.f=r&&!a?Object.defineProperties:function(n,e){o(n);for(var t,r=l(e),a=s(e),c=a.length,d=0;c>d;)i.f(n,t=a[d++],r[t]);return n}},function(n,e,t){var r=t(20),a=t(120),i=t(24),o=function(n){return function(e,t,o){var l,s=r(e),c=i(s),d=a(o,c);if(n&&t!=t){for(;c>d;)if((l=s[d++])!=l)return!0}else for(;c>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(58),a=Math.max,i=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):i(t,e)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,i=a&&!r.call({1:2},1);e.f=i?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(9),a=t(124),i=t(37),o=t(13);n.exports=function(n,e,t){for(var l=a(e),s=o.f,c=i.f,d=0;d<l.length;d++){var u=l[d];r(n,u)||t&&r(t,u)||s(n,u,c(e,u))}}},function(n,e,t){var r=t(15),a=t(3),i=t(61),o=t(92),l=t(10),s=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=i.f(l(n)),t=o.f;return t?s(e,t(n)):e}},function(n,e,t){var r=t(0),a=t(9),i=t(4),o=t(17),l=t(90),s=t(169),c=l("IE_PROTO"),d=r.Object,u=d.prototype;n.exports=s?d.getPrototypeOf:function(n){var e=o(n);if(a(e,c))return e[c];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof d?u:null}},function(n,e,t){var r=t(10),a=t(170),i=t(6)("species");n.exports=function(n,e){var t,o=r(n).constructor;return void 0===o||null==(t=r(o)[i])?e:a(t)}},function(n,e,t){var r={};r[t(6)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var r=t(0),a=t(120),i=t(24),o=t(76),l=r.Array,s=Math.max;n.exports=function(n,e,t){for(var r=i(n),c=a(e,r),d=a(void 0===t?r:t,r),u=l(s(d-c,0)),p=0;c<d;c++,p++)o(u,p,n[c]);return u.length=p,u}},function(n,e,t){var r=t(1),a=t(15),i=t(39),o=t(8),l=t(3),s=t(2),c=t(63),d=t(4),u=t(11),p=t(67),h=t(73),f=t(52),m=a("JSON","stringify"),g=l(/./.exec),v=l("".charAt),b=l("".charCodeAt),y=l("".replace),E=l(1..toString),x=/[\uD800-\uDFFF]/g,k=/^[\uD800-\uDBFF]$/,w=/^[\uDC00-\uDFFF]$/,T=!f||s((function(){var n=a("Symbol")();return"[null]"!=m([n])||"{}"!=m({a:n})||"{}"!=m(Object(n))})),A=s((function(){return'"\\udf06\\ud834"'!==m("\udf06\ud834")||'"\\udead"'!==m("\udead")})),S=function(n,e){var t=h(arguments),r=e;if((u(e)||void 0!==n)&&!p(n))return c(e)||(e=function(n,e){if(d(r)&&(e=o(r,this,n,e)),!p(e))return e}),t[1]=e,i(m,null,t)},B=function(n,e,t){var r=v(t,e-1),a=v(t,e+1);return g(k,n)&&!g(w,a)||g(w,n)&&!g(k,r)?"\\u"+E(b(n,0),16):n};m&&r({target:"JSON",stat:!0,arity:3,forced:T||A},{stringify:function(n,e,t){var r=h(arguments),a=i(T?S:m,null,r);return A&&"string"==typeof a?y(a,x,B):a}})},function(n,e,t){t(191)("iterator")},function(n,e,t){"use strict";var r=t(179).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(290),a=t(49),i=Object.prototype,o=i.hasOwnProperty,l=i.propertyIsEnumerable,s=r(function(){return arguments}())?r:function(n){return a(n)&&o.call(n,"callee")&&!l.call(n,"callee")};n.exports=s},function(n,e,t){var r=t(41)(t(34),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(310),a=t(317),i=t(319),o=t(320),l=t(321);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=a,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(32),a=t(140),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(64),a=t(49);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),a=t(0),i=t(62);r({global:!0},{Reflect:{}}),i(a.Reflect,"Reflect",!0)},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(84);t(77),t(97),t(5),t(131),t(22),t(26);var r=t(105);t(40),t(31);function a(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,a,i=[],o=!0,l=!1;try{for(t=t.call(n);!(o=(r=t.next()).done)&&(i.push(r.value),!e||i.length!==e);o=!0);}catch(n){l=!0,a=n}finally{try{o||null==t.return||t.return()}finally{if(l)throw a}}return i}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(1),a=t(60).some;r({target:"Array",proto:!0,forced:!t(46)("some")},{some:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(8),a=t(113),i=t(10),o=t(54),l=t(12),s=t(19),c=t(47),d=t(132),u=t(114);a("match",(function(n,e,t){return[function(e){var t=s(this),a=null==e?void 0:c(e,n);return a?r(a,e,t):new RegExp(e)[n](l(t))},function(n){var r=i(this),a=l(n),s=t(e,r,a);if(s.done)return s.value;if(!r.global)return u(r,a);var c=r.unicode;r.lastIndex=0;for(var p,h=[],f=0;null!==(p=u(r,a));){var m=l(p[0]);h[f]=m,""===m&&(r.lastIndex=d(a,o(r.lastIndex),c)),f++}return 0===f?null:h}]}))},function(n,e,t){var r=t(6),a=t(35),i=t(13),o=r("unscopables"),l=Array.prototype;null==l[o]&&i.f(l,o,{configurable:!0,value:a(null)}),n.exports=function(n){l[o][n]=!0}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},a=r.iterator||"@@iterator",i=r.asyncIterator||"@@asyncIterator",o=r.toStringTag||"@@toStringTag";function l(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{l({},"")}catch(n){l=function(n,e,t){return n[e]=t}}function s(n,e,t,r){var a=e&&e.prototype instanceof u?e:u,i=Object.create(a.prototype),o=new w(r||[]);return i._invoke=function(n,e,t){var r="suspendedStart";return function(a,i){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw i;return A()}for(t.method=a,t.arg=i;;){var o=t.delegate;if(o){var l=E(o,t);if(l){if(l===d)continue;return l}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var s=c(n,e,t);if("normal"===s.type){if(r=t.done?"completed":"suspendedYield",s.arg===d)continue;return{value:s.arg,done:t.done}}"throw"===s.type&&(r="completed",t.method="throw",t.arg=s.arg)}}}(n,t,o),i}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=s;var d={};function u(){}function p(){}function h(){}var f={};l(f,a,(function(){return this}));var m=Object.getPrototypeOf,g=m&&m(m(T([])));g&&g!==e&&t.call(g,a)&&(f=g);var v=h.prototype=u.prototype=Object.create(f);function b(n){["next","throw","return"].forEach((function(e){l(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var r;this._invoke=function(a,i){function o(){return new e((function(r,o){!function r(a,i,o,l){var s=c(n[a],n,i);if("throw"!==s.type){var d=s.arg,u=d.value;return u&&"object"==typeof u&&t.call(u,"__await")?e.resolve(u.__await).then((function(n){r("next",n,o,l)}),(function(n){r("throw",n,o,l)})):e.resolve(u).then((function(n){d.value=n,o(d)}),(function(n){return r("throw",n,o,l)}))}l(s.arg)}(a,i,r,o)}))}return r=r?r.then(o,o):o()}}function E(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,E(n,e),"throw"===e.method))return d;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,d;var a=r.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,d):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,d)}function x(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function w(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(x,this),this.reset(!0)}function T(n){if(n){var e=n[a];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,i=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return i.next=i}}return{next:A}}function A(){return{value:void 0,done:!0}}return p.prototype=h,l(v,"constructor",h),l(h,"constructor",p),p.displayName=l(h,o,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,h):(n.__proto__=h,l(n,o,"GeneratorFunction")),n.prototype=Object.create(v),n},n.awrap=function(n){return{__await:n}},b(y.prototype),l(y.prototype,i,(function(){return this})),n.AsyncIterator=y,n.async=function(e,t,r,a,i){void 0===i&&(i=Promise);var o=new y(s(e,t,r,a),i);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},b(v),l(v,o,"Generator"),l(v,a,(function(){return this})),l(v,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=T,w.prototype={constructor:w,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return o.type="throw",o.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a],o=i.completion;if("root"===i.tryLoc)return r("end");if(i.tryLoc<=this.prev){var l=t.call(i,"catchLoc"),s=t.call(i,"finallyLoc");if(l&&s){if(this.prev<i.catchLoc)return r(i.catchLoc,!0);if(this.prev<i.finallyLoc)return r(i.finallyLoc)}else if(l){if(this.prev<i.catchLoc)return r(i.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return r(i.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&t.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var i=a;break}}i&&("break"===n||"continue"===n)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=n,o.arg=e,i?(this.method="next",this.next=i.finallyLoc,d):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),d},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),d}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var a=r.arg;k(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:T(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),d}},n}(n.exports);try{regeneratorRuntime=r}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){"use strict";var r=t(71).PROPER,a=t(14),i=t(10),o=t(12),l=t(2),s=t(242),c=RegExp.prototype.toString,d=l((function(){return"/a/b"!=c.call({source:"a",flags:"b"})})),u=r&&"toString"!=c.name;(d||u)&&a(RegExp.prototype,"toString",(function(){var n=i(this);return"/"+o(n.source)+"/"+o(s(n))}),{unsafe:!0})},function(n,e,t){"use strict";var r=t(20),a=t(146),i=t(70),o=t(38),l=t(13).f,s=t(166),c=t(16),d=t(7),u=o.set,p=o.getterFor("Array Iterator");n.exports=s(Array,"Array",(function(n,e){u(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=p(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values");var h=i.Arguments=i.Array;if(a("keys"),a("values"),a("entries"),!c&&d&&"values"!==h.name)try{l(h,"name",{value:"values"})}catch(n){}},function(n,e,t){var r=t(0).TypeError;n.exports=function(n,e){if(n<e)throw r("Not enough arguments");return n}},function(n,e,t){var r=t(0),a=t(8),i=t(23),o=t(10),l=t(68),s=t(111),c=r.TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(i(t))return o(a(t,n));throw c(l(n)+" is not iterable")}},function(n,e,t){var r=t(267);n.exports=function(n,e){return new(r(n))(0===e?0:e)}},function(n,e,t){var r=t(11),a=t(27),i=t(6)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[i])?!!e:"RegExp"==a(n))}},function(n,e,t){var r=t(4),a=t(11),i=t(72);n.exports=function(n,e,t){var o,l;return i&&r(o=e.constructor)&&o!==t&&a(l=o.prototype)&&l!==t.prototype&&i(n,l),n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,l="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=l||s||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,h=function(){return c.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var l=a.test(n);return l||i.test(n)?o(n.slice(2),l?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,i,o,l,s,c=0,d=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,i=a;return r=a=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,l=setTimeout(x,e),d?b(n):o}function E(n){var t=n-s;return void 0===s||t>=e||t<0||g&&n-c>=i}function x(){var n=h();if(E(n))return k(n);l=setTimeout(x,function(n){var t=e-(n-s);return g?p(t,i-(n-c)):t}(n))}function k(n){return l=void 0,v&&r?b(n):(r=a=void 0,o)}function w(){var n=h(),t=E(n);if(r=arguments,a=this,s=n,t){if(void 0===l)return y(s);if(g)return l=setTimeout(x,e),b(s)}return void 0===l&&(l=setTimeout(x,e)),o}return e=m(e)||0,f(t)&&(d=!!t.leading,i=(g="maxWait"in t)?u(m(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),w.cancel=function(){void 0!==l&&clearTimeout(l),c=0,r=s=a=l=void 0},w.flush=function(){return void 0===l?o:k(h())},w}},function(n,e,t){var r=t(3),a=t(19),i=t(12),o=t(158),l=r("".replace),s="["+o+"]",c=RegExp("^"+s+s+"*"),d=RegExp(s+s+"*$"),u=function(n){return function(e){var t=i(a(e));return 1&n&&(t=l(t,c,"")),2&n&&(t=l(t,d,"")),t}};n.exports={start:u(1),end:u(2),trim:u(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var r=t(3),a=t(14),i=Date.prototype,o=r(i.toString),l=r(i.getTime);"Invalid Date"!=String(new Date(NaN))&&a(i,"toString",(function(){var n=l(this);return n==n?o(this):"Invalid Date"}))},function(n,e,t){var r=t(52);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(7),a=t(2);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(7),a=t(2),i=t(87);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(0),a=t(8),i=t(11),o=t(67),l=t(47),s=t(247),c=t(6),d=r.TypeError,u=c("toPrimitive");n.exports=function(n,e){if(!i(n)||o(n))return n;var t,r=l(n,u);if(r){if(void 0===e&&(e="default"),t=a(r,n,e),!i(t)||o(t))return t;throw d("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(3),a=t(9),i=t(20),o=t(119).indexOf,l=t(69),s=r([].push);n.exports=function(n,e){var t,r=i(n),c=0,d=[];for(t in r)!a(l,t)&&a(r,t)&&s(d,t);for(;e.length>c;)a(r,t=e[c++])&&(~o(d,t)||s(d,t));return d}},function(n,e,t){var r=t(15);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(1),a=t(8),i=t(16),o=t(71),l=t(4),s=t(233),c=t(125),d=t(72),u=t(62),p=t(28),h=t(14),f=t(6),m=t(70),g=t(168),v=o.PROPER,b=o.CONFIGURABLE,y=g.IteratorPrototype,E=g.BUGGY_SAFARI_ITERATORS,x=f("iterator"),k=function(){return this};n.exports=function(n,e,t,o,f,g,w){s(t,e,o);var T,A,S,B=function(n){if(n===f&&z)return z;if(!E&&n in _)return _[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},I=e+" Iterator",C=!1,_=n.prototype,P=_[x]||_["@@iterator"]||f&&_[f],z=!E&&P||B(f),j="Array"==e&&_.entries||P;if(j&&(T=c(j.call(new n)))!==Object.prototype&&T.next&&(i||c(T)===y||(d?d(T,y):l(T[x])||h(T,x,k)),u(T,I,!0,!0),i&&(m[I]=k)),v&&"values"==f&&P&&"values"!==P.name&&(!i&&b?p(_,"name","values"):(C=!0,z=function(){return a(P,this)})),f)if(A={values:B("values"),keys:g?z:B("keys"),entries:B("entries")},w)for(S in A)(E||C||!(S in _))&&h(_,S,A[S]);else r({target:e,proto:!0,forced:E||C},A);return i&&!w||_[x]===z||h(_,x,z,{name:f}),m[e]=z,A}},function(n,e,t){var r=t(2),a=t(4),i=t(9),o=t(7),l=t(71).CONFIGURABLE,s=t(91),c=t(38),d=c.enforce,u=c.get,p=Object.defineProperty,h=o&&!r((function(){return 8!==p((function(){}),"length",{value:8}).length})),f=String(String).split("String"),m=n.exports=function(n,e,t){if("Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||l&&n.name!==e)&&p(n,"name",{value:e,configurable:!0}),h&&t&&i(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity}),t&&i(t,"constructor")&&t.constructor){if(o)try{p(n,"prototype",{writable:!1})}catch(n){}}else n.prototype=void 0;var r=d(n);return i(r,"source")||(r.source=f.join("string"==typeof e?e:"")),n};Function.prototype.toString=m((function(){return a(this)&&u(this).source||s(this)}),"toString")},function(n,e,t){"use strict";var r,a,i,o=t(2),l=t(4),s=t(35),c=t(125),d=t(14),u=t(6),p=t(16),h=u("iterator"),f=!1;[].keys&&("next"in(i=[].keys())?(a=c(c(i)))!==Object.prototype&&(r=a):f=!0),null==r||o((function(){var n={};return r[h].call(n)!==n}))?r={}:p&&(r=s(r)),l(r[h])||d(r,h,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:f}},function(n,e,t){var r=t(2);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(0),a=t(94),i=t(68),o=r.TypeError;n.exports=function(n){if(a(n))return n;throw o(i(n)+" is not a constructor")}},function(n,e,t){var r,a,i,o,l=t(0),s=t(39),c=t(59),d=t(4),u=t(9),p=t(2),h=t(165),f=t(73),m=t(87),g=t(150),v=t(172),b=t(93),y=l.setImmediate,E=l.clearImmediate,x=l.process,k=l.Dispatch,w=l.Function,T=l.MessageChannel,A=l.String,S=0,B={};try{r=l.location}catch(n){}var I=function(n){if(u(B,n)){var e=B[n];delete B[n],e()}},C=function(n){return function(){I(n)}},_=function(n){I(n.data)},P=function(n){l.postMessage(A(n),r.protocol+"//"+r.host)};y&&E||(y=function(n){g(arguments.length,1);var e=d(n)?n:w(n),t=f(arguments,1);return B[++S]=function(){s(e,void 0,t)},a(S),S},E=function(n){delete B[n]},b?a=function(n){x.nextTick(C(n))}:k&&k.now?a=function(n){k.now(C(n))}:T&&!v?(o=(i=new T).port2,i.port1.onmessage=_,a=c(o.postMessage,o)):l.addEventListener&&d(l.postMessage)&&!l.importScripts&&r&&"file:"!==r.protocol&&!p(P)?(a=P,l.addEventListener("message",_,!1)):a="onreadystatechange"in m("script")?function(n){h.appendChild(m("script")).onreadystatechange=function(){h.removeChild(this),I(n)}}:function(n){setTimeout(C(n),0)}),n.exports={set:y,clear:E}},function(n,e,t){var r=t(33);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,e,t){var r=t(0),a=t(59),i=t(8),o=t(10),l=t(68),s=t(174),c=t(24),d=t(36),u=t(151),p=t(111),h=t(175),f=r.TypeError,m=function(n,e){this.stopped=n,this.result=e},g=m.prototype;n.exports=function(n,e,t){var r,v,b,y,E,x,k,w=t&&t.that,T=!(!t||!t.AS_ENTRIES),A=!(!t||!t.IS_ITERATOR),S=!(!t||!t.INTERRUPTED),B=a(e,w),I=function(n){return r&&h(r,"normal",n),new m(!0,n)},C=function(n){return T?(o(n),S?B(n[0],n[1],I):B(n[0],n[1])):S?B(n,I):B(n)};if(A)r=n;else{if(!(v=p(n)))throw f(l(n)+" is not iterable");if(s(v)){for(b=0,y=c(n);y>b;b++)if((E=C(n[b]))&&d(g,E))return E;return new m(!1)}r=u(n,v)}for(x=r.next;!(k=i(x,r)).done;){try{E=C(k.value)}catch(n){h(r,"throw",n)}if("object"==typeof E&&E&&d(g,E))return E}return new m(!1)}},function(n,e,t){var r=t(6),a=t(70),i=r("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(a.Array===n||o[i]===n)}},function(n,e,t){var r=t(8),a=t(10),i=t(47);n.exports=function(n,e,t){var o,l;a(n);try{if(!(o=i(n,"return"))){if("throw"===e)throw t;return t}o=r(o,n)}catch(n){l=!0,o=n}if("throw"===e)throw t;if(l)throw o;return a(o),t}},function(n,e,t){var r=t(55),a=t(177),i=t(74).CONSTRUCTOR;n.exports=i||!a((function(n){r.all(n).then(void 0,(function(){}))}))},function(n,e,t){var r=t(6)("iterator"),a=!1;try{var i=0,o={next:function(){return{done:!!i++}},return:function(){a=!0}};o[r]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var i={};i[r]=function(){return{next:function(){return{done:t=!0}}}},n(i)}catch(n){}return t}},function(n,e,t){var r=t(10),a=t(11),i=t(75);n.exports=function(n,e){if(r(n),a(e)&&e.constructor===n)return e;var t=i.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){var r=t(3),a=t(58),i=t(12),o=t(19),l=r("".charAt),s=r("".charCodeAt),c=r("".slice),d=function(n){return function(e,t){var r,d,u=i(o(e)),p=a(t),h=u.length;return p<0||p>=h?n?"":void 0:(r=s(u,p))<55296||r>56319||p+1===h||(d=s(u,p+1))<56320||d>57343?n?l(u,p):r:n?c(u,p,p+2):d-56320+(r-55296<<10)+65536}};n.exports={codeAt:d(!1),charAt:d(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(87)("span").classList,a=r&&r.constructor&&r.constructor.prototype;n.exports=a===Object.prototype?void 0:a},function(n,e,t){var r=t(1),a=t(7),i=t(124),o=t(20),l=t(37),s=t(76);r({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(n){for(var e,t,r=o(n),a=l.f,c=i(r),d={},u=0;c.length>u;)void 0!==(t=a(r,e=c[u++]))&&s(d,e,t);return d}})},function(n,e,t){var r=t(1),a=t(2),i=t(17),o=t(125),l=t(169);r({target:"Object",stat:!0,forced:a((function(){o(1)})),sham:!l},{getPrototypeOf:function(n){return o(i(n))}})},function(n,e,t){"use strict";var r,a=t(1),i=t(3),o=t(37).f,l=t(54),s=t(12),c=t(185),d=t(19),u=t(186),p=t(16),h=i("".startsWith),f=i("".slice),m=Math.min,g=u("startsWith");a({target:"String",proto:!0,forced:!!(p||g||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!g},{startsWith:function(n){var e=s(d(this));c(n);var t=l(m(arguments.length>1?arguments[1]:void 0,e.length)),r=s(n);return h?h(e,r,t):f(e,t,t+r.length)===r}})},function(n,e,t){var r=t(0),a=t(153),i=r.TypeError;n.exports=function(n){if(a(n))throw i("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(6)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(60).forEach,a=t(46)("forEach");n.exports=a?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(2);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(27),a=t(20),i=t(61).f,o=t(129),l="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return l&&"Window"==r(n)?function(n){try{return i(n)}catch(n){return o(l)}}(n):i(a(n))}},function(n,e,t){var r=t(6);e.f=r},function(n,e,t){var r=t(275),a=t(9),i=t(190),o=t(13).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});a(e,n)||o(e,n,{value:i.f(n)})}},function(n,e,t){var r=t(52);n.exports=r&&!!Symbol.for&&!!Symbol.keyFor},function(n,e,t){var r=t(1),a=t(280);r({target:"Array",stat:!0,forced:!t(177)((function(n){Array.from(n)}))},{from:a})},function(n,e,t){"use strict";var r=t(10);n.exports=function(){var n=r(this),e="";return n.hasIndices&&(e+="d"),n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){t(1)({target:"Object",stat:!0,sham:!t(7)},{create:t(35)})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(99),a=t(301),i=t(302),o=t(303),l=t(304),s=t(305);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=l,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(64),a=t(135);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(322),a=t(49);n.exports=function n(e,t,i,o,l){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,i,o,n,l))}},function(n,e,t){var r=t(205),a=t(325),i=t(206);n.exports=function(n,e,t,o,l,s){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=s.get(n),h=s.get(e);if(p&&h)return p==e&&h==n;var f=-1,m=!0,g=2&t?new r:void 0;for(s.set(n,e),s.set(e,n);++f<d;){var v=n[f],b=e[f];if(o)var y=c?o(b,v,f,e,n,s):o(v,b,f,n,e,s);if(void 0!==y){if(y)continue;m=!1;break}if(g){if(!a(e,(function(n,e){if(!i(g,e)&&(v===n||l(v,n,t,o,s)))return g.push(e)}))){m=!1;break}}else if(v!==b&&!l(v,b,t,o,s)){m=!1;break}}return s.delete(n),s.delete(e),m}},function(n,e,t){var r=t(136),a=t(323),i=t(324);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=a,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(335),a=t(341),i=t(211);n.exports=function(n){return i(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(34),a=t(337),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,l=o&&o.exports===i?r.Buffer:void 0,s=(l?l.isBuffer:void 0)||a;n.exports=s}).call(this,t(155)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(338),a=t(339),i=t(340),o=i&&i.isTypedArray,l=o?a(o):r;n.exports=l},function(n,e,t){var r=t(201),a=t(138);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(41)(t(34),"Set");n.exports=r},function(n,e,t){var r=t(135);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(216),a=t(103);n.exports=function(n,e){for(var t=0,i=(e=r(e,n)).length;null!=n&&t<i;)n=n[a(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var r=t(32),a=t(139),i=t(352),o=t(355);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:i(o(n))}},function(n,e,t){var r=t(0),a=t(39),i=t(4),o=t(33),l=t(73),s=t(150),c=/MSIE .\./.test(o),d=r.Function,u=function(n){return c?function(e,t){var r=s(arguments.length,1)>2,o=i(e)?e:d(e),c=r?l(arguments,2):void 0;return n(r?function(){a(o,this,c)}:o,t)}:n};n.exports={setTimeout:u(r.setTimeout),setInterval:u(r.setInterval)}},function(n,e,t){"use strict";var r=t(0),a=t(3),i=t(23),o=t(11),l=t(9),s=t(73),c=t(66),d=r.Function,u=a([].concat),p=a([].join),h={},f=function(n,e,t){if(!l(h,e)){for(var r=[],a=0;a<e;a++)r[a]="a["+a+"]";h[e]=d("C,a","return new C("+p(r,",")+")")}return h[e](n,t)};n.exports=c?d.bind:function(n){var e=i(this),t=e.prototype,r=s(arguments,1),a=function(){var t=u(r,s(arguments));return this instanceof a?f(e,t.length,t):e.apply(n,t)};return o(t)&&(a.prototype=t),a}},function(n,e,t){"use strict";var r=t(1),a=t(389).start;r({target:"String",proto:!0,forced:t(391)},{padStart:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(1)({target:"Object",stat:!0},{setPrototypeOf:t(72)})},function(n,e,t){var r=t(1),a=t(15),i=t(39),o=t(218),l=t(170),s=t(10),c=t(11),d=t(35),u=t(2),p=a("Reflect","construct"),h=Object.prototype,f=[].push,m=u((function(){function n(){}return!(p((function(){}),[],n)instanceof n)})),g=!u((function(){p((function(){}))})),v=m||g;r({target:"Reflect",stat:!0,forced:v,sham:v},{construct:function(n,e){l(n),s(e);var t=arguments.length<3?n:l(arguments[2]);if(g&&!m)return p(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return i(f,r,e),new(i(o,n,r))}var a=t.prototype,u=d(c(a)?a:h),v=i(n,u,e);return c(v)?v:u}})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(288),a=t(293),i=t(364),o=t(372),l=t(381),s=t(240),c=i((function(n){var e=s(n);return l(e)&&(e=void 0),o(r(n,1,l,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var i="",o=0,l=0;for(o=a.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}l!==o&&(i+=t.substring(l,o)),l=o+1,i+=e}return l!==o?i+t.substring(l,o):i}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(403),a=t(404),i=t(405),o=!1,l=t(406).version,s=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=s.concat("cache"),d=/^\uFEFF/;function u(n,t){var a,i,o=t.views,l=/^[A-Za-z]+:\\|^\//.exec(n);if(l&&l.length)a=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(i=e.resolveInclude(n,t.filename),r.existsSync(i)&&(a=i)),a||Array.isArray(o)&&o.some((function(t){return i=e.resolveInclude(n,t,!0),r.existsSync(i)}))&&(a=i),!a)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return a}function p(n,t){var r,a=n.filename,i=arguments.length>1;if(n.cache){if(!a)throw new Error("cache option requires a filename");if(r=e.cache.get(a))return r;i||(t=f(a).toString().replace(d,""))}else if(!i){if(!a)throw new Error("Internal EJS error: no file name or template provided");t=f(a).toString().replace(d,"")}return r=e.compile(t,n),n.cache&&e.cache.set(a,r),r}function h(n,t,r){var a;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(a=p(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{a=p(n)(t)}catch(n){return r(n)}r(null,a)}function f(n){return e.fileLoader(n)}function m(n,e,t,r,a){var i=e.split("\n"),o=Math.max(r-3,0),l=Math.min(i.length,r+3),s=a(t),c=i.slice(o,l).map((function(n,e){var t=e+o+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=s,n.message=(s||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||i.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=i.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=a.dirname,i=a.extname,o=(0,a.resolve)(t?e:r(e),n);return i(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var r=e||{},a=t||{};return 2==arguments.length&&i.shallowCopyFromList(a,r,s),p(a,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),a=r.shift(),o={filename:a};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?i.shallowCopy(o,r.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&i.shallowCopy(o,t)),i.shallowCopyFromList(o,e,c)),o.filename=a):e={},h(o,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=i.escapeRegExpChars(this.opts.delimiter),t=i.escapeRegExpChars(this.opts.openDelimiter),r=i.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,o="",l="",s=r.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(o+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",d=0;d<r.destructuredLocals.length;d++){var h=r.destructuredLocals[d];d>0&&(c+=",\n  "),c+=h+" = __locals."+h}o+=c+";\n"}!1!==r._with&&(o+="  with ("+r.localsName+" || {}) {\n",l+="  }\n"),l+="  return __output;\n",this.source=o+this.source+l}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+s.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+m.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var f=r.client?e:function(n){return e.apply(r.context,[n||{},s,function(e,t){var a=i.shallowCopy({},n);return t&&(a=i.shallowCopy(a,t)),function(n,e){var t=i.shallowCopy({},e);return t.filename=u(n,t),p(t)}(e,r)(a)},m])};if(f.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var g=r.filename,v=a.basename(g,a.extname(g));try{Object.defineProperty(f,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return f},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),a=this.opts.delimiter,o=this.opts.openDelimiter,l=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(s,c){var p,h,m,g,b,y;if(0===s.indexOf(o+a)&&0!==s.indexOf(o+a+a)&&(h=r[c+2])!=a+l&&h!="-"+a+l&&h!="_"+a+l)throw new Error('Could not find matching close tag for "'+s+'".');if(n.legacyInclude&&(m=s.match(/^\s*include\s+(\S+)/))&&(p=r[c-1])&&(p==o+a||p==o+a+"-"||p==o+a+"_"))return g=i.shallowCopy({},t.opts),b=function(n,e){var t,r,a=i.shallowCopy({},e);r=f(t=u(n,a)).toString().replace(d,""),a.filename=t;var o=new v(r,a);return o.generateSource(),{source:o.source,filename:t,template:r}}(m[1],g),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(m[1],g.filename));t.scanLine(s)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),a=[];r;)0!==(n=r.index)&&(a.push(e.substring(0,n)),e=e.slice(n)),a.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&a.push(e),a},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,a=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=v.modes.EVAL;break;case r+t+"=":this.mode=v.modes.ESCAPED;break;case r+t+"-":this.mode=v.modes.RAW;break;case r+t+"#":this.mode=v.modes.COMMENT;break;case r+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+a:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+a,t+a)+'")\n';break;case t+a:case"-"+t+a:case"_"+t+a:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=i.escapeXML,e.__express=e.renderFile,e.VERSION=l,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(392),t(21)),i=Object(a.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);t(29),t(5),t(30),t(44),t(25);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},a=(t(393),t(21)),i=Object(a.a)(r,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,r){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e,t){"use strict";var r=t(7),a=t(0),i=t(3),o=t(110),l=t(14),s=t(9),c=t(154),d=t(36),u=t(67),p=t(163),h=t(2),f=t(61).f,m=t(37).f,g=t(13).f,v=t(388),b=t(157).trim,y=a.Number,E=y.prototype,x=a.TypeError,k=i("".slice),w=i("".charCodeAt),T=function(n){var e=p(n,"number");return"bigint"==typeof e?e:A(e)},A=function(n){var e,t,r,a,i,o,l,s,c=p(n,"number");if(u(c))throw x("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=b(c),43===(e=w(c,0))||45===e){if(88===(t=w(c,2))||120===t)return NaN}else if(48===e){switch(w(c,1)){case 66:case 98:r=2,a=49;break;case 79:case 111:r=8,a=55;break;default:return+c}for(o=(i=k(c,2)).length,l=0;l<o;l++)if((s=w(i,l))<48||s>a)return NaN;return parseInt(i,r)}return+c};if(o("Number",!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var S,B=function(n){var e=arguments.length<1?0:y(T(n)),t=this;return d(E,t)&&h((function(){v(t)}))?c(Object(e),t,B):e},I=r?f(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),C=0;I.length>C;C++)s(y,S=I[C])&&!s(B,S)&&g(B,S,m(y,S));B.prototype=E,E.constructor=B,l(a,"Number",B,{constructor:!0})}},function(n,e,t){var r=t(2),a=t(0).RegExp;n.exports=r((function(){var n=a(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var r=t(168).IteratorPrototype,a=t(35),i=t(48),o=t(62),l=t(70),s=function(){return this};n.exports=function(n,e,t,c){var d=e+" Iterator";return n.prototype=a(r,{next:i(+!c,t)}),o(n,d,!1,!0),l[d]=s,n}},function(n,e,t){"use strict";var r=t(15),a=t(13),i=t(6),o=t(7),l=i("species");n.exports=function(n){var e=r(n),t=a.f;o&&e&&!e[l]&&t(e,l,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(0),a=t(36),i=r.TypeError;n.exports=function(n,e){if(a(e,n))return n;throw i("Incorrect invocation")}},function(n,e,t){var r=t(2),a=t(0).RegExp;n.exports=r((function(){var n=a("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){var r=t(13).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),a=t(119).includes,i=t(2),o=t(146);r({target:"Array",proto:!0,forced:i((function(){return!Array(1).includes()}))},{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(1),a=t(3),i=t(185),o=t(19),l=t(12),s=t(186),c=a("".indexOf);r({target:"String",proto:!0,forced:!s("includes")},{includes:function(n){return!!~c(l(o(this)),l(i(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(1),a=t(157).trim;r({target:"String",proto:!0,forced:t(386)("trim")},{trim:function(){return a(this)}})},function(n,e,t){var r=t(8),a=t(9),i=t(36),o=t(194),l=RegExp.prototype;n.exports=function(n){var e=n.flags;return void 0!==e||"flags"in l||a(n,"flags")||!i(l,n)?e:r(o,n)}},function(n,e,t){var r=t(129),a=Math.floor,i=function(n,e){var t=n.length,s=a(t/2);return t<8?o(n,e):l(n,i(r(n,0,s),e),i(r(n,s),e),e)},o=function(n,e){for(var t,r,a=n.length,i=1;i<a;){for(r=i,t=n[i];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==i++&&(n[r]=t)}return n},l=function(n,e,t,r){for(var a=e.length,i=t.length,o=0,l=0;o<a||l<i;)n[o+l]=o<a&&l<i?r(e[o],t[l])<=0?e[o++]:t[l++]:o<a?e[o++]:t[l++];return n};n.exports=i},function(n,e,t){var r=t(0),a=t(7),i=t(112).MISSED_STICKY,o=t(27),l=t(245),s=t(38).get,c=RegExp.prototype,d=r.TypeError;a&&i&&l(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===o(this))return!!s(this).sticky;throw d("Incompatible receiver, RegExp required")}}})},function(n,e,t){var r=t(167),a=t(13);n.exports=function(n,e,t){return t.get&&r(t.get,e,{getter:!0}),t.set&&r(t.set,e,{setter:!0}),a.f(n,e,t)}},function(n,e,t){n.exports=t(409)},function(n,e,t){var r=t(0),a=t(8),i=t(4),o=t(11),l=r.TypeError;n.exports=function(n,e){var t,r;if("string"===e&&i(t=n.toString)&&!o(r=a(t,n)))return r;if(i(t=n.valueOf)&&!o(r=a(t,n)))return r;if("string"!==e&&i(t=n.toString)&&!o(r=a(t,n)))return r;throw l("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),a=t(4),i=t(91),o=r.WeakMap;n.exports=a(o)&&/native code/.test(i(o))},function(n,e,t){var r=t(0),a=t(4),i=r.String,o=r.TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw o("Can't set "+i(n)+" as a prototype")}},function(n,e,t){t(251),t(258),t(259),t(260),t(261),t(262)},function(n,e,t){"use strict";var r,a,i,o=t(1),l=t(16),s=t(93),c=t(0),d=t(8),u=t(14),p=t(72),h=t(62),f=t(234),m=t(23),g=t(4),v=t(11),b=t(235),y=t(126),E=t(171).set,x=t(252),k=t(255),w=t(128),T=t(256),A=t(38),S=t(55),B=t(74),I=t(75),C=B.CONSTRUCTOR,_=B.REJECTION_EVENT,P=B.SUBCLASSING,z=A.getterFor("Promise"),j=A.set,L=S&&S.prototype,O=S,D=L,M=c.TypeError,R=c.document,F=c.process,N=I.f,q=N,U=!!(R&&R.createEvent&&c.dispatchEvent),J=function(n){var e;return!(!v(n)||!g(e=n.then))&&e},H=function(n,e){var t,r,a,i=e.value,o=1==e.state,l=o?n.ok:n.fail,s=n.resolve,c=n.reject,u=n.domain;try{l?(o||(2===e.rejection&&W(e),e.rejection=1),!0===l?t=i:(u&&u.enter(),t=l(i),u&&(u.exit(),a=!0)),t===n.promise?c(M("Promise-chain cycle")):(r=J(t))?d(r,t,s,c):s(t)):c(i)}catch(n){u&&!a&&u.exit(),c(n)}},K=function(n,e){n.notified||(n.notified=!0,x((function(){for(var t,r=n.reactions;t=r.get();)H(t,n);n.notified=!1,e&&!n.rejection&&G(n)})))},V=function(n,e,t){var r,a;U?((r=R.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!_&&(a=c["on"+n])?a(r):"unhandledrejection"===n&&k("Unhandled promise rejection",t)},G=function(n){d(E,c,(function(){var e,t=n.facade,r=n.value;if($(n)&&(e=w((function(){s?F.emit("unhandledRejection",r,t):V("unhandledrejection",t,r)})),n.rejection=s||$(n)?2:1,e.error))throw e.value}))},$=function(n){return 1!==n.rejection&&!n.parent},W=function(n){d(E,c,(function(){var e=n.facade;s?F.emit("rejectionHandled",e):V("rejectionhandled",e,n.value)}))},Q=function(n,e,t){return function(r){n(e,r,t)}},Y=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,K(n,!0))},Z=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw M("Promise can't be resolved itself");var r=J(e);r?x((function(){var t={done:!1};try{d(r,e,Q(Z,t,n),Q(Y,t,n))}catch(e){Y(t,e,n)}})):(n.value=e,n.state=1,K(n,!1))}catch(e){Y({done:!1},e,n)}}};if(C&&(D=(O=function(n){b(this,D),m(n),d(r,this);var e=z(this);try{n(Q(Z,e),Q(Y,e))}catch(n){Y(e,n)}}).prototype,(r=function(n){j(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new T,rejection:!1,state:0,value:void 0})}).prototype=u(D,"then",(function(n,e){var t=z(this),r=N(y(this,O));return t.parent=!0,r.ok=!g(n)||n,r.fail=g(e)&&e,r.domain=s?F.domain:void 0,0==t.state?t.reactions.add(r):x((function(){H(r,t)})),r.promise})),a=function(){var n=new r,e=z(n);this.promise=n,this.resolve=Q(Z,e),this.reject=Q(Y,e)},I.f=N=function(n){return n===O||void 0===n?new a(n):q(n)},!l&&g(S)&&L!==Object.prototype)){i=L.then,P||u(L,"then",(function(n,e){var t=this;return new O((function(n,e){d(i,t,n,e)})).then(n,e)}),{unsafe:!0});try{delete L.constructor}catch(n){}p&&p(L,D)}o({global:!0,constructor:!0,wrap:!0,forced:C},{Promise:O}),h(O,"Promise",!1,!0),f("Promise")},function(n,e,t){var r,a,i,o,l,s,c,d,u=t(0),p=t(59),h=t(37).f,f=t(171).set,m=t(172),g=t(253),v=t(254),b=t(93),y=u.MutationObserver||u.WebKitMutationObserver,E=u.document,x=u.process,k=u.Promise,w=h(u,"queueMicrotask"),T=w&&w.value;T||(r=function(){var n,e;for(b&&(n=x.domain)&&n.exit();a;){e=a.fn,a=a.next;try{e()}catch(n){throw a?o():i=void 0,n}}i=void 0,n&&n.enter()},m||b||v||!y||!E?!g&&k&&k.resolve?((c=k.resolve(void 0)).constructor=k,d=p(c.then,c),o=function(){d(r)}):b?o=function(){x.nextTick(r)}:(f=p(f,u),o=function(){f(r)}):(l=!0,s=E.createTextNode(""),new y(r).observe(s,{characterData:!0}),o=function(){s.data=l=!l})),n.exports=T||function(n){var e={fn:n,next:void 0};i&&(i.next=e),a||(a=e,o()),i=e}},function(n,e,t){var r=t(33),a=t(0);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==a.Pebble},function(n,e,t){var r=t(33);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(0);n.exports=function(n,e){var t=r.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,e,t){"use strict";var r=t(1),a=t(8),i=t(23),o=t(75),l=t(128),s=t(173);r({target:"Promise",stat:!0,forced:t(176)},{all:function(n){var e=this,t=o.f(e),r=t.resolve,c=t.reject,d=l((function(){var t=i(e.resolve),o=[],l=0,d=1;s(n,(function(n){var i=l++,s=!1;d++,a(t,e,n).then((function(n){s||(s=!0,o[i]=n,--d||r(o))}),c)})),--d||r(o)}));return d.error&&c(d.value),t.promise}})},function(n,e,t){"use strict";var r=t(1),a=t(16),i=t(74).CONSTRUCTOR,o=t(55),l=t(15),s=t(4),c=t(14),d=o&&o.prototype;if(r({target:"Promise",proto:!0,forced:i,real:!0},{catch:function(n){return this.then(void 0,n)}}),!a&&s(o)){var u=l("Promise").prototype.catch;d.catch!==u&&c(d,"catch",u,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(1),a=t(8),i=t(23),o=t(75),l=t(128),s=t(173);r({target:"Promise",stat:!0,forced:t(176)},{race:function(n){var e=this,t=o.f(e),r=t.reject,c=l((function(){var o=i(e.resolve);s(n,(function(n){a(o,e,n).then(t.resolve,r)}))}));return c.error&&r(c.value),t.promise}})},function(n,e,t){"use strict";var r=t(1),a=t(8),i=t(75);r({target:"Promise",stat:!0,forced:t(74).CONSTRUCTOR},{reject:function(n){var e=i.f(this);return a(e.reject,void 0,n),e.promise}})},function(n,e,t){"use strict";var r=t(1),a=t(15),i=t(16),o=t(55),l=t(74).CONSTRUCTOR,s=t(178),c=a("Promise"),d=i&&!l;r({target:"Promise",stat:!0,forced:i||l},{resolve:function(n){return s(d&&this===c?o:this,n)}})},function(n,e,t){var r=t(1),a=t(264);r({target:"Object",stat:!0,arity:2,forced:Object.assign!==a},{assign:a})},function(n,e,t){"use strict";var r=t(7),a=t(3),i=t(8),o=t(2),l=t(89),s=t(92),c=t(122),d=t(17),u=t(65),p=Object.assign,h=Object.defineProperty,f=a([].concat);n.exports=!p||o((function(){if(r&&1!==p({b:1},p(h({},"a",{enumerable:!0,get:function(){h(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=p({},n)[t]||"abcdefghijklmnopqrst"!=l(p({},e)).join("")}))?function(n,e){for(var t=d(n),a=arguments.length,o=1,p=s.f,h=c.f;a>o;)for(var m,g=u(arguments[o++]),v=p?f(l(g),p(g)):l(g),b=v.length,y=0;b>y;)m=v[y++],r&&!i(h,g,m)||(t[m]=g[m]);return t}:p},function(n,e,t){"use strict";var r=t(1),a=t(16),i=t(55),o=t(2),l=t(15),s=t(4),c=t(126),d=t(178),u=t(14),p=i&&i.prototype;if(r({target:"Promise",proto:!0,real:!0,forced:!!i&&o((function(){p.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,l("Promise")),t=s(n);return this.then(t?function(t){return d(e,n()).then((function(){return t}))}:n,t?function(t){return d(e,n()).then((function(){throw t}))}:n)}}),!a&&s(i)){var h=l("Promise").prototype.finally;p.finally!==h&&u(p,"finally",h,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(127),a=t(83);n.exports=r?{}.toString:function(){return"[object "+a(this)+"]"}},function(n,e,t){var r=t(0),a=t(63),i=t(94),o=t(11),l=t(6)("species"),s=r.Array;n.exports=function(n){var e;return a(n)&&(e=n.constructor,(i(e)&&(e===s||a(e.prototype))||o(e)&&null===(e=e[l]))&&(e=void 0)),void 0===e?s:e}},function(n,e,t){"use strict";var r=t(1),a=t(269).left,i=t(46),o=t(53),l=t(93);r({target:"Array",proto:!0,forced:!i("reduce")||!l&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),a=t(23),i=t(17),o=t(65),l=t(24),s=r.TypeError,c=function(n){return function(e,t,r,c){a(t);var d=i(e),u=o(d),p=l(d),h=n?p-1:0,f=n?-1:1;if(r<2)for(;;){if(h in u){c=u[h],h+=f;break}if(h+=f,n?h<0:p<=h)throw s("Reduce of empty array with no initial value")}for(;n?h>=0:p>h;h+=f)h in u&&(c=t(c,u[h],h,d));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){var r=t(1),a=t(188),i=t(2),o=t(11),l=t(271).onFreeze,s=Object.freeze;r({target:"Object",stat:!0,forced:i((function(){s(1)})),sham:!a},{freeze:function(n){return s&&o(n)?s(l(n)):n}})},function(n,e,t){var r=t(1),a=t(3),i=t(69),o=t(11),l=t(9),s=t(13).f,c=t(61),d=t(189),u=t(272),p=t(86),h=t(188),f=!1,m=p("meta"),g=0,v=function(n){s(n,m,{value:{objectID:"O"+g++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},f=!0;var n=c.f,e=a([].splice),t={};t[m]=1,n(t).length&&(c.f=function(t){for(var r=n(t),a=0,i=r.length;a<i;a++)if(r[a]===m){e(r,a,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:d.f}))},fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!l(n,m)){if(!u(n))return"F";if(!e)return"E";v(n)}return n[m].objectID},getWeakData:function(n,e){if(!l(n,m)){if(!u(n))return!0;if(!e)return!1;v(n)}return n[m].weakData},onFreeze:function(n){return h&&f&&u(n)&&!l(n,m)&&v(n),n}};i[m]=!0},function(n,e,t){var r=t(2),a=t(11),i=t(27),o=t(273),l=Object.isExtensible,s=r((function(){l(1)}));n.exports=s||o?function(n){return!!a(n)&&((!o||"ArrayBuffer"!=i(n))&&(!l||l(n)))}:l},function(n,e,t){var r=t(2);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){"use strict";var r=t(1),a=t(0),i=t(8),o=t(3),l=t(16),s=t(7),c=t(52),d=t(2),u=t(9),p=t(36),h=t(10),f=t(20),m=t(88),g=t(12),v=t(48),b=t(35),y=t(89),E=t(61),x=t(189),k=t(92),w=t(37),T=t(13),A=t(118),S=t(122),B=t(14),I=t(51),C=t(90),_=t(69),P=t(86),z=t(6),j=t(190),L=t(191),O=t(276),D=t(62),M=t(38),R=t(60).forEach,F=C("hidden"),N=M.set,q=M.getterFor("Symbol"),U=Object.prototype,J=a.Symbol,H=J&&J.prototype,K=a.TypeError,V=a.QObject,G=w.f,$=T.f,W=x.f,Q=S.f,Y=o([].push),Z=I("symbols"),X=I("op-symbols"),nn=I("wks"),en=!V||!V.prototype||!V.prototype.findChild,tn=s&&d((function(){return 7!=b($({},"a",{get:function(){return $(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=G(U,e);r&&delete U[e],$(n,e,t),r&&n!==U&&$(U,e,r)}:$,rn=function(n,e){var t=Z[n]=b(H);return N(t,{type:"Symbol",tag:n,description:e}),s||(t.description=e),t},an=function(n,e,t){n===U&&an(X,e,t),h(n);var r=m(e);return h(t),u(Z,r)?(t.enumerable?(u(n,F)&&n[F][r]&&(n[F][r]=!1),t=b(t,{enumerable:v(0,!1)})):(u(n,F)||$(n,F,v(1,{})),n[F][r]=!0),tn(n,r,t)):$(n,r,t)},on=function(n,e){h(n);var t=f(e),r=y(t).concat(dn(t));return R(r,(function(e){s&&!i(ln,t,e)||an(n,e,t[e])})),n},ln=function(n){var e=m(n),t=i(Q,this,e);return!(this===U&&u(Z,e)&&!u(X,e))&&(!(t||!u(this,e)||!u(Z,e)||u(this,F)&&this[F][e])||t)},sn=function(n,e){var t=f(n),r=m(e);if(t!==U||!u(Z,r)||u(X,r)){var a=G(t,r);return!a||!u(Z,r)||u(t,F)&&t[F][r]||(a.enumerable=!0),a}},cn=function(n){var e=W(f(n)),t=[];return R(e,(function(n){u(Z,n)||u(_,n)||Y(t,n)})),t},dn=function(n){var e=n===U,t=W(e?X:f(n)),r=[];return R(t,(function(n){!u(Z,n)||e&&!u(U,n)||Y(r,Z[n])})),r};c||(B(H=(J=function(){if(p(H,this))throw K("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?g(arguments[0]):void 0,e=P(n),t=function(n){this===U&&i(t,X,n),u(this,F)&&u(this[F],e)&&(this[F][e]=!1),tn(this,e,v(1,n))};return s&&en&&tn(U,e,{configurable:!0,set:t}),rn(e,n)}).prototype,"toString",(function(){return q(this).tag})),B(J,"withoutSetter",(function(n){return rn(P(n),n)})),S.f=ln,T.f=an,A.f=on,w.f=sn,E.f=x.f=cn,k.f=dn,j.f=function(n){return rn(z(n),n)},s&&($(H,"description",{configurable:!0,get:function(){return q(this).description}}),l||B(U,"propertyIsEnumerable",ln,{unsafe:!0}))),r({global:!0,constructor:!0,wrap:!0,forced:!c,sham:!c},{Symbol:J}),R(y(nn),(function(n){L(n)})),r({target:"Symbol",stat:!0,forced:!c},{useSetter:function(){en=!0},useSimple:function(){en=!1}}),r({target:"Object",stat:!0,forced:!c,sham:!s},{create:function(n,e){return void 0===e?b(n):on(b(n),e)},defineProperty:an,defineProperties:on,getOwnPropertyDescriptor:sn}),r({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:cn}),O(),D(J,"Symbol"),_[F]=!0},function(n,e,t){var r=t(0);n.exports=r},function(n,e,t){var r=t(8),a=t(15),i=t(6),o=t(14);n.exports=function(){var n=a("Symbol"),e=n&&n.prototype,t=e&&e.valueOf,l=i("toPrimitive");e&&!e[l]&&o(e,l,(function(n){return r(t,this)}),{arity:1})}},function(n,e,t){var r=t(1),a=t(15),i=t(9),o=t(12),l=t(51),s=t(192),c=l("string-to-symbol-registry"),d=l("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!s},{for:function(n){var e=o(n);if(i(c,e))return c[e];var t=a("Symbol")(e);return c[e]=t,d[t]=e,t}})},function(n,e,t){var r=t(1),a=t(9),i=t(67),o=t(68),l=t(51),s=t(192),c=l("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!s},{keyFor:function(n){if(!i(n))throw TypeError(o(n)+" is not a symbol");if(a(c,n))return c[n]}})},function(n,e,t){var r=t(1),a=t(52),i=t(2),o=t(92),l=t(17);r({target:"Object",stat:!0,forced:!a||i((function(){o.f(1)}))},{getOwnPropertySymbols:function(n){var e=o.f;return e?e(l(n)):[]}})},function(n,e,t){"use strict";var r=t(0),a=t(59),i=t(8),o=t(17),l=t(281),s=t(174),c=t(94),d=t(24),u=t(76),p=t(151),h=t(111),f=r.Array;n.exports=function(n){var e=o(n),t=c(this),r=arguments.length,m=r>1?arguments[1]:void 0,g=void 0!==m;g&&(m=a(m,r>2?arguments[2]:void 0));var v,b,y,E,x,k,w=h(e),T=0;if(!w||this==f&&s(w))for(v=d(e),b=t?new this(v):f(v);v>T;T++)k=g?m(e[T],T):e[T],u(b,T,k);else for(x=(E=p(e,w)).next,b=t?new this:[];!(y=i(x,E)).done;T++)k=g?l(E,m,[y.value,T],!0):y.value,u(b,T,k);return b.length=T,b}},function(n,e,t){var r=t(10),a=t(175);n.exports=function(n,e,t,i){try{return i?e(r(t)[0],t[1]):e(t)}catch(e){a(n,"throw",e)}}},function(n,e,t){"use strict";var r=t(15),a=t(9),i=t(28),o=t(36),l=t(72),s=t(123),c=t(237),d=t(154),u=t(195),p=t(283),h=t(284),f=t(285),m=t(7),g=t(16);n.exports=function(n,e,t,v){var b=v?2:1,y=n.split("."),E=y[y.length-1],x=r.apply(null,y);if(x){var k=x.prototype;if(!g&&a(k,"cause")&&delete k.cause,!t)return x;var w=r("Error"),T=e((function(n,e){var t=u(v?e:n,void 0),r=v?new x(n):new x;return void 0!==t&&i(r,"message",t),f&&i(r,"stack",h(r.stack,2)),this&&o(k,this)&&d(r,this,T),arguments.length>b&&p(r,arguments[b]),r}));if(T.prototype=k,"Error"!==E?l?l(T,w):s(T,w,{name:!0}):m&&"stackTraceLimit"in x&&(c(T,x,"stackTraceLimit"),c(T,x,"prepareStackTrace")),s(T,x),!g)try{k.name!==E&&i(k,"name",E),k.constructor=T}catch(n){}return T}}},function(n,e,t){var r=t(11),a=t(28);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(3),a=Error,i=r("".replace),o=String(a("zxcasd").stack),l=/\n\s*at [^:]*:[^\n]*/,s=l.test(o);n.exports=function(n,e){if(s&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=i(n,l,"");return n}},function(n,e,t){var r=t(2),a=t(48);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(7),a=t(2),i=t(10),o=t(35),l=t(195),s=Error.prototype.toString,c=a((function(){if(r){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==s.call(n))return!0}return"2: 1"!==s.call({message:1,name:2})||"Error"!==s.call({})}));n.exports=c?function(){var n=i(this),e=l(n.name,"Error"),t=l(n.message);return e?t?e+": "+t:e:t}:s},function(n,e,t){var r=t(3),a=t(17),i=Math.floor,o=r("".charAt),l=r("".replace),s=r("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,d=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,r,u,p){var h=t+n.length,f=r.length,m=d;return void 0!==u&&(u=a(u),m=c),l(p,m,(function(a,l){var c;switch(o(l,0)){case"$":return"$";case"&":return n;case"`":return s(e,0,t);case"'":return s(e,h);case"<":c=u[s(l,1,-1)];break;default:var d=+l;if(0===d)return a;if(d>f){var p=i(d/10);return 0===p?a:p<=f?void 0===r[p-1]?o(l,1):r[p-1]+o(l,1):a}c=r[d-1]}return void 0===c?"":c}))}},function(n,e,t){var r=t(197),a=t(289);n.exports=function n(e,t,i,o,l){var s=-1,c=e.length;for(i||(i=a),l||(l=[]);++s<c;){var d=e[s];t>0&&i(d)?t>1?n(d,t-1,i,o,l):r(l,d):o||(l[l.length]=d)}return l}},function(n,e,t){var r=t(78),a=t(133),i=t(32),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||a(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(64),a=t(49);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(78),a=Object.prototype,i=a.hasOwnProperty,o=a.toString,l=r?r.toStringTag:void 0;n.exports=function(n){var e=i.call(n,l),t=n[l];try{n[l]=void 0;var r=!0}catch(n){}var a=o.call(n);return r&&(e?n[l]=t:delete n[l]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(294),a=t(350),i=t(141),o=t(32),l=t(361);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?a(n[0],n[1]):r(n):l(n)}},function(n,e,t){var r=t(295),a=t(349),i=t(214);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(199),a=t(203);n.exports=function(n,e,t,i){var o=t.length,l=o,s=!i;if(null==n)return!l;for(n=Object(n);o--;){var c=t[o];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<l;){var d=(c=t[o])[0],u=n[d],p=c[1];if(s&&c[2]){if(void 0===u&&!(d in n))return!1}else{var h=new r;if(i)var f=i(u,p,d,n,e,h);if(!(void 0===f?a(p,u,3,i,h):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(100),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(100);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(100);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(100);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(99);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(99),a=t(134),i=t(136);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!a||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(201),a=t(307),i=t(135),o=t(202),l=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||a(n))&&(r(n)?p:l).test(o(n))}},function(n,e,t){var r,a=t(308),i=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var r=t(34)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(311),a=t(99),i=t(134);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(i||a),string:new r}}},function(n,e,t){var r=t(312),a=t(313),i=t(314),o=t(315),l=t(316);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=a,s.prototype.get=i,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var r=t(101);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(101),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(101),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(101);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(102);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(102);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(102);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(102);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(199),a=t(204),i=t(326),o=t(329),l=t(345),s=t(32),c=t(208),d=t(210),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,h,f,m){var g=s(n),v=s(e),b=g?"[object Array]":l(n),y=v?"[object Array]":l(e),E=(b="[object Arguments]"==b?u:b)==u,x=(y="[object Arguments]"==y?u:y)==u,k=b==y;if(k&&c(n)){if(!c(e))return!1;g=!0,E=!1}if(k&&!E)return m||(m=new r),g||d(n)?a(n,e,t,h,f,m):i(n,e,b,t,h,f,m);if(!(1&t)){var w=E&&p.call(n,"__wrapped__"),T=x&&p.call(e,"__wrapped__");if(w||T){var A=w?n.value():n,S=T?e.value():e;return m||(m=new r),f(A,S,t,h,m)}}return!!k&&(m||(m=new r),o(n,e,t,h,f,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(78),a=t(327),i=t(200),o=t(204),l=t(328),s=t(137),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var h=l;case"[object Set]":var f=1&r;if(h||(h=s),n.size!=e.size&&!f)return!1;var m=p.get(n);if(m)return m==e;r|=2,p.set(n,e);var g=o(h(n),h(e),r,c,u,p);return p.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(34).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(330),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,l){var s=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!s)return!1;for(var u=d;u--;){var p=c[u];if(!(s?p in e:a.call(e,p)))return!1}var h=l.get(n),f=l.get(e);if(h&&f)return h==e&&f==n;var m=!0;l.set(n,e),l.set(e,n);for(var g=s;++u<d;){var v=n[p=c[u]],b=e[p];if(i)var y=s?i(b,v,p,e,n,l):i(v,b,p,n,e,l);if(!(void 0===y?v===b||o(v,b,t,i,l):y)){m=!1;break}g||(g="constructor"==p)}if(m&&!g){var E=n.constructor,x=e.constructor;E==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof E&&E instanceof E&&"function"==typeof x&&x instanceof x||(m=!1)}return l.delete(n),l.delete(e),m}},function(n,e,t){var r=t(331),a=t(332),i=t(207);n.exports=function(n){return r(n,i,a)}},function(n,e,t){var r=t(197),a=t(32);n.exports=function(n,e,t){var i=e(n);return a(n)?i:r(i,t(n))}},function(n,e,t){var r=t(333),a=t(334),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,l=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return i.call(n,e)})))}:a;n.exports=l},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,i=[];++t<r;){var o=n[t];e(o,t,n)&&(i[a++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(336),a=t(133),i=t(32),o=t(208),l=t(209),s=t(210),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),d=!t&&a(n),u=!t&&!d&&o(n),p=!t&&!d&&!u&&s(n),h=t||d||u||p,f=h?r(n.length,String):[],m=f.length;for(var g in n)!e&&!c.call(n,g)||h&&("length"==g||u&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||l(g,m))||f.push(g);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(64),a=t(138),i=t(49),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&a(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(198),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===a&&r.process,l=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=l}).call(this,t(155)(n))},function(n,e,t){var r=t(342),a=t(343),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(344)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(346),a=t(134),i=t(347),o=t(212),l=t(348),s=t(64),c=t(202),d=c(r),u=c(a),p=c(i),h=c(o),f=c(l),m=s;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=m(new a)||i&&"[object Promise]"!=m(i.resolve())||o&&"[object Set]"!=m(new o)||l&&"[object WeakMap]"!=m(new l))&&(m=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case h:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var r=t(41)(t(34),"DataView");n.exports=r},function(n,e,t){var r=t(41)(t(34),"Promise");n.exports=r},function(n,e,t){var r=t(41)(t(34),"WeakMap");n.exports=r},function(n,e,t){var r=t(213),a=t(207);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,r(o)]}return e}},function(n,e,t){var r=t(203),a=t(351),i=t(358),o=t(139),l=t(213),s=t(214),c=t(103);n.exports=function(n,e){return o(n)&&l(e)?s(c(n),e):function(t){var o=a(t,n);return void 0===o&&o===e?i(t,n):r(e,o,3)}}},function(n,e,t){var r=t(215);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(353),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(354);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(136);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],i=t.cache;if(i.has(a))return i.get(a);var o=n.apply(this,r);return t.cache=i.set(a,o)||i,o};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(356);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(78),a=t(357),i=t(32),o=t(140),l=r?r.prototype:void 0,s=l?l.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return a(e,n)+"";if(o(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(359),a=t(360);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(216),a=t(133),i=t(32),o=t(209),l=t(138),s=t(103);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,u=!1;++c<d;){var p=s(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&l(d)&&o(p,d)&&(i(n)||a(n))}},function(n,e,t){var r=t(362),a=t(363),i=t(139),o=t(103);n.exports=function(n){return i(n)?r(o(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(215);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(141),a=t(365),i=t(367);n.exports=function(n,e){return i(a(n,e,r),n+"")}},function(n,e,t){var r=t(366),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,l=a(i.length-e,0),s=Array(l);++o<l;)s[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(s),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(368),a=t(371)(r);n.exports=a},function(n,e,t){var r=t(369),a=t(370),i=t(141),o=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(41),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),i=16-(a-r);if(r=a,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(205),a=t(373),i=t(378),o=t(206),l=t(379),s=t(137);n.exports=function(n,e,t){var c=-1,d=a,u=n.length,p=!0,h=[],f=h;if(t)p=!1,d=i;else if(u>=200){var m=e?null:l(n);if(m)return s(m);p=!1,d=o,f=new r}else f=e?[]:h;n:for(;++c<u;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=f.length;b--;)if(f[b]===v)continue n;e&&f.push(v),h.push(g)}else d(f,v,t)||(f!==h&&f.push(v),h.push(g))}return h}},function(n,e,t){var r=t(374);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(375),a=t(376),i=t(377);n.exports=function(n,e,t){return e==e?i(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,i=t+(r?1:-1);r?i--:++i<a;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(212),a=t(380),i=t(137),o=r&&1/i(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(211),a=t(49);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){var r=t(1),a=t(0),i=t(217).setInterval;r({global:!0,bind:!0,forced:a.setInterval!==i},{setInterval:i})},function(n,e,t){var r=t(1),a=t(0),i=t(217).setTimeout;r({global:!0,bind:!0,forced:a.setTimeout!==i},{setTimeout:i})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(71).PROPER,a=t(2),i=t(158);n.exports=function(n){return a((function(){return!!i[n]()||"​᠎"!=="​᠎"[n]()||r&&i[n].name!==n}))}},function(n,e,t){var r=t(1),a=t(218);r({target:"Function",proto:!0,forced:Function.bind!==a},{bind:a})},function(n,e,t){var r=t(3);n.exports=r(1..valueOf)},function(n,e,t){var r=t(3),a=t(54),i=t(12),o=t(390),l=t(19),s=r(o),c=r("".slice),d=Math.ceil,u=function(n){return function(e,t,r){var o,u,p=i(l(e)),h=a(t),f=p.length,m=void 0===r?" ":i(r);return h<=f||""==m?p:((u=s(m,d((o=h-f)/m.length))).length>o&&(u=c(u,0,o)),n?p+u:u+p)}};n.exports={start:u(!1),end:u(!0)}},function(n,e,t){"use strict";var r=t(0),a=t(58),i=t(12),o=t(19),l=r.RangeError;n.exports=function(n){var e=i(o(this)),t="",r=a(n);if(r<0||r==1/0)throw l("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(e+=e))1&r&&(t+=e);return t}},function(n,e,t){var r=t(33);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){"use strict";t(220)},function(n,e,t){"use strict";t(221)},function(n,e,t){"use strict";var r=t(1),a=t(3),i=t(23),o=t(17),l=t(24),s=t(12),c=t(2),d=t(243),u=t(46),p=t(395),h=t(396),f=t(53),m=t(397),g=[],v=a(g.sort),b=a(g.push),y=c((function(){g.sort(void 0)})),E=c((function(){g.sort(null)})),x=u("sort"),k=!c((function(){if(f)return f<70;if(!(p&&p>3)){if(h)return!0;if(m)return m<603;var n,e,t,r,a="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)g.push({k:e+r,v:t})}for(g.sort((function(n,e){return e.v-n.v})),r=0;r<g.length;r++)e=g[r].k.charAt(0),a.charAt(a.length-1)!==e&&(a+=e);return"DGBEFHACIJK"!==a}}));r({target:"Array",proto:!0,forced:y||!E||!x||!k},{sort:function(n){void 0!==n&&i(n);var e=o(this);if(k)return void 0===n?v(e):v(e,n);var t,r,a=[],c=l(e);for(r=0;r<c;r++)r in e&&b(a,e[r]);for(d(a,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:s(e)>s(t)?1:-1}}(n)),t=a.length,r=0;r<t;)e[r]=a[r++];for(;r<c;)delete e[r++];return e}})},function(n,e,t){var r=t(33).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(33);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(33).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(1),a=t(2),i=t(20),o=t(37).f,l=t(7),s=a((function(){o(1)}));r({target:"Object",stat:!0,forced:!l||s,sham:!l},{getOwnPropertyDescriptor:function(n,e){return o(i(n),e)}})},function(n,e,t){var r=t(1),a=t(7),i=t(118).f;r({target:"Object",stat:!0,forced:Object.defineProperties!==i,sham:!a},{defineProperties:i})},function(n,e,t){t(1)({target:"Reflect",stat:!0},{ownKeys:t(124)})},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var a=n[r];"."===a?n.splice(r,1):".."===a?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,a=arguments.length-1;a>=-1&&!e;a--){var i=a>=0?arguments[a]:process.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(n=i+"/"+n,e="/"===i.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var i=e.isAbsolute(n),o="/"===a(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!i).join("/"))||i||(n="."),n&&o&&(n+="/"),(i?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var a=r(n.split("/")),i=r(t.split("/")),o=Math.min(a.length,i.length),l=o,s=0;s<o;s++)if(a[s]!==i[s]){l=s;break}var c=[];for(s=l;s<a.length;s++)c.push("..");return(c=c.concat(i.slice(l))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,a=!0,i=n.length-1;i>=1;--i)if(47===(e=n.charCodeAt(i))){if(!a){r=i;break}}else a=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,a=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!a){t=e+1;break}}else-1===r&&(a=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,a=!0,i=0,o=n.length-1;o>=0;--o){var l=n.charCodeAt(o);if(47!==l)-1===r&&(a=!1,r=o+1),46===l?-1===e?e=o:1!==i&&(i=1):-1!==e&&(i=-1);else if(!a){t=o+1;break}}return-1===e||-1===r||0===i||1===i&&e===r-1&&e===t+1?"":n.slice(e,r)};var a="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},i=/[&<>'"]/g;function o(n){return a[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(i,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var a=t[r];void 0!==e[a]&&(n[a]=e[a])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(224)},function(n,e,t){"use strict";t(225)},function(n,e,t){"use strict";t.r(e);t(149),t(250),t(263),t(265);var r=t(95),a=(t(147),t(42),t(5),t(22),t(26),t(44),t(25),Object.freeze({}));function i(n){return null==n}function o(n){return null!=n}function l(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function p(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function m(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var b=v("key,ref,slot,slot-scope,is");function y(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var E=Object.prototype.hasOwnProperty;function x(n,e){return E.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var w=/-(\w)/g,T=k((function(n){return n.replace(w,(function(n,e){return e?e.toUpperCase():""}))})),A=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,B=k((function(n){return n.replace(S,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function C(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function _(n,e){for(var t in e)n[t]=e[t];return n}function P(n){for(var e={},t=0;t<n.length;t++)n[t]&&_(e,n[t]);return e}function z(n,e,t){}var j=function(n,e,t){return!1},L=function(n){return n};function O(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),i=Array.isArray(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||i)return!1;var o=Object.keys(n),l=Object.keys(e);return o.length===l.length&&o.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function D(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function M(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var R=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:j,isReservedAttr:j,isUnknownElement:j,getTagNamespace:z,parsePlatformTagName:L,mustUseProp:j,async:!0,_lifecycleHooks:F},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var J=new RegExp("[^"+q.source+".$_\\d]");var H,K="__proto__"in{},V="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,$=G&&WXEnvironment.platform.toLowerCase(),W=V&&window.navigator.userAgent.toLowerCase(),Q=W&&/msie|trident/.test(W),Y=W&&W.indexOf("msie 9.0")>0,Z=W&&W.indexOf("edge/")>0,X=(W&&W.indexOf("android"),W&&/iphone|ipad|ipod|ios/.test(W)||"ios"===$),nn=(W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W),W&&W.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(V)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var an=function(){return void 0===H&&(H=!V&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),H},on=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,cn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);sn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=z,un=0,pn=function(){this.id=un++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){y(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var hn=[];function fn(n){hn.push(n),pn.target=n}function mn(){hn.pop(),pn.target=hn[hn.length-1]}var gn=function(n,e,t,r,a,i,o,l){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=l,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},vn={child:{configurable:!0}};vn.child.get=function(){return this.componentInstance},Object.defineProperties(gn.prototype,vn);var bn=function(n){void 0===n&&(n="");var e=new gn;return e.text=n,e.isComment=!0,e};function yn(n){return new gn(void 0,void 0,void 0,String(n))}function En(n){var e=new gn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var xn=Array.prototype,kn=Object.create(xn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=xn[n];U(kn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var a,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&o.observeArray(a),o.dep.notify(),i}))}));var wn=Object.getOwnPropertyNames(kn),Tn=!0;function An(n){Tn=n}var Sn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,U(n,"__ob__",this),Array.isArray(n)?(K?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var r=0,a=t.length;r<a;r++){var i=t[r];U(n,i,e[i])}}(n,kn,wn),this.observeArray(n)):this.walk(n)};function Bn(n,e){var t;if(c(n)&&!(n instanceof gn))return x(n,"__ob__")&&n.__ob__ instanceof Sn?t=n.__ob__:Tn&&!an()&&(Array.isArray(n)||u(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Sn(n)),e&&t&&t.vmCount++,t}function In(n,e,t,r,a){var i=new pn,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var l=o&&o.get,s=o&&o.set;l&&!s||2!==arguments.length||(t=n[e]);var c=!a&&Bn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return pn.target&&(i.depend(),c&&(c.dep.depend(),Array.isArray(e)&&Pn(e))),e},set:function(e){var r=l?l.call(n):t;e===r||e!=e&&r!=r||l&&!s||(s?s.call(n,e):t=e,c=!a&&Bn(e),i.notify())}})}}function Cn(n,e,t){if(Array.isArray(n)&&h(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(In(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function _n(n,e){if(Array.isArray(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||x(n,e)&&(delete n[e],t&&t.dep.notify())}}function Pn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Pn(e)}Sn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)In(n,e[t])},Sn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Bn(n[e])};var zn=N.optionMergeStrategies;function jn(n,e){if(!e)return n;for(var t,r,a,i=cn?Reflect.ownKeys(e):Object.keys(e),o=0;o<i.length;o++)"__ob__"!==(t=i[o])&&(r=n[t],a=e[t],x(n,t)?r!==a&&u(r)&&u(a)&&jn(r,a):Cn(n,t,a));return n}function Ln(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return r?jn(r,a):a}:e?n?function(){return jn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function On(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Dn(n,e,t,r){var a=Object.create(n||null);return e?_(a,e):a}zn.data=function(n,e,t){return t?Ln(n,e,t):e&&"function"!=typeof e?n:Ln(n,e)},F.forEach((function(n){zn[n]=On})),R.forEach((function(n){zn[n+"s"]=Dn})),zn.watch=function(n,e,t,r){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var i in _(a,n),e){var o=a[i],l=e[i];o&&!Array.isArray(o)&&(o=[o]),a[i]=o?o.concat(l):Array.isArray(l)?l:[l]}return a},zn.props=zn.methods=zn.inject=zn.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return _(a,n),e&&_(a,e),a},zn.provide=Ln;var Mn=function(n,e){return void 0===e?n:e};function Rn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,i={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(i[T(a)]={type:null});else if(u(t))for(var o in t)a=t[o],i[T(o)]=u(a)?a:{type:a};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(u(t))for(var i in t){var o=t[i];r[i]=u(o)?_({from:i},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Rn(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=Rn(n,e.mixins[r],t);var i,o={};for(i in n)l(i);for(i in e)x(n,i)||l(i);function l(r){var a=zn[r]||Mn;o[r]=a(n[r],e[r],t,r)}return o}function Fn(n,e,t,r){if("string"==typeof t){var a=n[e];if(x(a,t))return a[t];var i=T(t);if(x(a,i))return a[i];var o=A(i);return x(a,o)?a[o]:a[t]||a[i]||a[o]}}function Nn(n,e,t,r){var a=e[n],i=!x(t,n),o=t[n],l=Hn(Boolean,a.type);if(l>-1)if(i&&!x(a,"default"))o=!1;else if(""===o||o===B(n)){var s=Hn(String,a.type);(s<0||l<s)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!x(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Un(e.type)?r.call(n):r}(r,a,n);var c=Tn;An(!0),Bn(o),An(c)}return o}var qn=/^\s*function (\w+)/;function Un(n){var e=n&&n.toString().match(qn);return e?e[1]:""}function Jn(n,e){return Un(n)===Un(e)}function Hn(n,e){if(!Array.isArray(e))return Jn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Jn(e[t],n))return t;return-1}function Kn(n,e,t){fn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var i=0;i<a.length;i++)try{if(!1===a[i].call(r,n,e,t))return}catch(n){Gn(n,r,"errorCaptured hook")}}Gn(n,e,t)}finally{mn()}}function Vn(n,e,t,r,a){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&f(i)&&!i._handled&&(i.catch((function(n){return Kn(n,r,a+" (Promise/async)")})),i._handled=!0)}catch(n){Kn(n,r,a)}return i}function Gn(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&$n(e,null,"config.errorHandler")}$n(n,e,t)}function $n(n,e,t){if(!V&&!G||"undefined"==typeof console)throw n;console.error(n)}var Wn,Qn=!1,Yn=[],Zn=!1;function Xn(){Zn=!1;var n=Yn.slice(0);Yn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ne=Promise.resolve();Wn=function(){ne.then(Xn),X&&setTimeout(z)},Qn=!0}else if(Q||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Wn="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Xn)}:function(){setTimeout(Xn,0)};else{var ee=1,te=new MutationObserver(Xn),re=document.createTextNode(String(ee));te.observe(re,{characterData:!0}),Wn=function(){ee=(ee+1)%2,re.data=String(ee)},Qn=!0}function ae(n,e){var t;if(Yn.push((function(){if(n)try{n.call(e)}catch(n){Kn(n,e,"nextTick")}else t&&t(e)})),Zn||(Zn=!0,Wn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ie=new sn;function oe(n){!function n(e,t){var r,a,i=Array.isArray(e);if(!i&&!c(e)||Object.isFrozen(e)||e instanceof gn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(i)for(r=e.length;r--;)n(e[r],t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,ie),ie.clear()}var le=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function se(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Vn(r,null,arguments,e,"v-on handler");for(var a=r.slice(),i=0;i<a.length;i++)Vn(a[i],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,r,a,o){var s,c,d,u;for(s in n)c=n[s],d=e[s],u=le(s),i(c)||(i(d)?(i(c.fns)&&(c=n[s]=se(c,o)),l(u.once)&&(c=n[s]=a(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)i(n[s])&&r((u=le(s)).name,e[s],u.capture)}function de(n,e,t){var r;n instanceof gn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function s(){t.apply(this,arguments),y(r.fns,s)}i(a)?r=se([s]):o(a.fns)&&l(a.merged)?(r=a).fns.push(s):r=se([a,s]),r.merged=!0,n[e]=r}function ue(n,e,t,r,a){if(o(e)){if(x(e,t))return n[t]=e[t],a||delete e[t],!0;if(x(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function pe(n){return s(n)?[yn(n)]:Array.isArray(n)?function n(e,t){var r,a,c,d,u=[];for(r=0;r<e.length;r++)i(a=e[r])||"boolean"==typeof a||(c=u.length-1,d=u[c],Array.isArray(a)?a.length>0&&(he((a=n(a,(t||"")+"_"+r))[0])&&he(d)&&(u[c]=yn(d.text+a[0].text),a.shift()),u.push.apply(u,a)):s(a)?he(d)?u[c]=yn(d.text+a):""!==a&&u.push(yn(a)):he(a)&&he(d)?u[c]=yn(d.text+a.text):(l(e._isVList)&&o(a.tag)&&i(a.key)&&o(t)&&(a.key="__vlist"+t+"_"+r+"__"),u.push(a)));return u}(n):void 0}function he(n){return o(n)&&o(n.text)&&!1===n.isComment}function fe(n,e){if(n){for(var t=Object.create(null),r=cn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var i=r[a];if("__ob__"!==i){for(var o=n[i].from,l=e;l;){if(l._provided&&x(l._provided,o)){t[i]=l._provided[o];break}l=l.$parent}if(!l)if("default"in n[i]){var s=n[i].default;t[i]="function"==typeof s?s.call(e):s}else 0}}return t}}function me(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var i=n[r],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var l=o.slot,s=t[l]||(t[l]=[]);"template"===i.tag?s.push.apply(s,i.children||[]):s.push(i)}}for(var c in t)t[c].every(ge)&&delete t[c];return t}function ge(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var r,i=Object.keys(e).length>0,o=n?!!n.$stable:!i,l=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==a&&l===t.$key&&!i&&!t.$hasNormal)return t;for(var s in r={},n)n[s]&&"$"!==s[0]&&(r[s]=ye(e,s,n[s]))}else r={};for(var c in e)c in r||(r[c]=Ee(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),U(r,"$stable",o),U(r,"$key",l),U(r,"$hasNormal",i),r}function ye(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ve(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function Ee(n,e){return function(){return n[e]}}function xe(n,e){var t,r,a,i,l;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,a=n.length;r<a;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var s=n[Symbol.iterator](),d=s.next();!d.done;)t.push(e(d.value,t.length)),d=s.next()}else for(i=Object.keys(n),t=new Array(i.length),r=0,a=i.length;r<a;r++)l=i[r],t[r]=e(n[l],l,r);return o(t)||(t=[]),t._isVList=!0,t}function ke(n,e,t,r){var a,i=this.$scopedSlots[n];i?(t=t||{},r&&(t=_(_({},r),t)),a=i(t)||("function"==typeof e?e():e)):a=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},a):a}function we(n){return Fn(this.$options,"filters",n)||L}function Te(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Ae(n,e,t,r,a){var i=N.keyCodes[e]||t;return a&&r&&!N.keyCodes[e]?Te(a,r):i?Te(i,n):r?B(r)!==e:void 0===n}function Se(n,e,t,r,a){if(t)if(c(t)){var i;Array.isArray(t)&&(t=P(t));var o=function(o){if("class"===o||"style"===o||b(o))i=n;else{var l=n.attrs&&n.attrs.type;i=r||N.mustUseProp(e,l,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=T(o),c=B(o);s in i||c in i||(i[o]=t[o],a&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var l in t)o(l)}else;return n}function Be(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Ce(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Ie(n,e,t){return Ce(n,"__once__"+e+(t?"_"+t:""),!0),n}function Ce(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&_e(n[r],e+"_"+r,t);else _e(n,e,t)}function _e(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Pe(n,e){if(e)if(u(e)){var t=n.on=n.on?_({},n.on):{};for(var r in e){var a=t[r],i=e[r];t[r]=a?[].concat(a,i):i}}else;return n}function ze(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var i=n[a];Array.isArray(i)?ze(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function je(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Le(n,e){return"string"==typeof n?e+n:n}function Oe(n){n._o=Ie,n._n=g,n._s=m,n._l=xe,n._t=ke,n._q=O,n._i=D,n._m=Be,n._f=we,n._k=Ae,n._b=Se,n._v=yn,n._e=bn,n._u=ze,n._g=Pe,n._d=je,n._p=Le}function De(n,e,t,r,i){var o,s=this,c=i.options;x(r,"_uid")?(o=Object.create(r))._original=r:(o=r,r=r._original);var d=l(c._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||a,this.injections=fe(c.inject,r),this.slots=function(){return s.$slots||be(n.scopedSlots,s.$slots=me(t,r)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,a){var i=Je(o,n,e,t,a,u);return i&&!Array.isArray(i)&&(i.fnScopeId=c._scopeId,i.fnContext=r),i}:this._c=function(n,e,t,r){return Je(o,n,e,t,r,u)}}function Me(n,e,t,r,a){var i=En(n);return i.fnContext=t,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function Re(n,e){for(var t in e)n[T(t)]=e[t]}Oe(De.prototype);var Fe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Fe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ze)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){0;var o=r.data.scopedSlots,l=n.$scopedSlots,s=!!(o&&!o.$stable||l!==a&&!l.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||s);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=i,n.$attrs=r.data.attrs||a,n.$listeners=t||a,e&&n.$options.props){An(!1);for(var d=n._props,u=n.$options._propKeys||[],p=0;p<u.length;p++){var h=u[p],f=n.$options.props;d[h]=Nn(h,f,e,n)}An(!0),n.$options.propsData=e}t=t||a;var m=n.$options._parentListeners;n.$options._parentListeners=t,Ye(n,t,m),c&&(n.$slots=me(i,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,tt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,at.push(e)):et(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Ne=Object.keys(Fe);function qe(n,e,t,r,s){if(!i(n)){var d=t.$options._base;if(c(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(i(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Ke;t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(l(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],a=!0,s=null,d=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==s&&(clearTimeout(s),s=null),null!==d&&(clearTimeout(d),d=null))},p=M((function(t){n.resolved=Ve(t,e),a?r.length=0:u(!0)})),h=M((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),m=n(p,h);return c(m)&&(f(m)?i(n.resolved)&&m.then(p,h):f(m.component)&&(m.component.then(p,h),o(m.error)&&(n.errorComp=Ve(m.error,e)),o(m.loading)&&(n.loadingComp=Ve(m.loading,e),0===m.delay?n.loading=!0:s=setTimeout((function(){s=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,u(!1))}),m.delay||200)),o(m.timeout)&&(d=setTimeout((function(){d=null,i(n.resolved)&&h(null)}),m.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,r,a){var i=bn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:r,tag:a},i}(u,e,t,r,s);e=e||{},Tt(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),i=a[r],l=e.model.callback;o(i)?(Array.isArray(i)?-1===i.indexOf(l):i!==l)&&(a[r]=[l].concat(i)):a[r]=l}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!i(r)){var a={},l=n.attrs,s=n.props;if(o(l)||o(s))for(var c in r){var d=B(c);ue(a,s,c,d,!0)||ue(a,l,c,d,!1)}return a}}(e,n);if(l(n.options.functional))return function(n,e,t,r,i){var l=n.options,s={},c=l.props;if(o(c))for(var d in c)s[d]=Nn(d,c,e||a);else o(t.attrs)&&Re(s,t.attrs),o(t.props)&&Re(s,t.props);var u=new De(t,s,i,r,n),p=l.render.call(null,u._c,u);if(p instanceof gn)return Me(p,t,u.parent,l,u);if(Array.isArray(p)){for(var h=pe(p)||[],f=new Array(h.length),m=0;m<h.length;m++)f[m]=Me(h[m],t,u.parent,l,u);return f}}(n,p,e,t,r);var h=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var m=e.slot;e={},m&&(e.slot=m)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Ne.length;t++){var r=Ne[t],a=e[r],i=Fe[r];a===i||a&&a._merged||(e[r]=a?Ue(i,a):i)}}(e);var g=n.options.name||s;return new gn("vue-component-"+n.cid+(g?"-"+g:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:h,tag:s,children:r},u)}}}function Ue(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Je(n,e,t,r,a,d){return(Array.isArray(t)||s(t))&&(a=r,r=t,t=void 0),l(d)&&(a=2),function(n,e,t,r,a){if(o(t)&&o(t.__ob__))return bn();o(t)&&o(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===a?r=pe(r):1===a&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var s,d;if("string"==typeof e){var u;d=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),s=N.isReservedTag(e)?new gn(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(u=Fn(n.$options,"components",e))?new gn(e,t,r,void 0,void 0,n):qe(u,t,n,r,e)}else s=qe(e,t,n,r);return Array.isArray(s)?s:o(s)?(o(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var a=0,s=e.children.length;a<s;a++){var c=e.children[a];o(c.tag)&&(i(c.ns)||l(r)&&"svg"!==c.tag)&&n(c,t,r)}}(s,d),o(t)&&function(n){c(n.style)&&oe(n.style);c(n.class)&&oe(n.class)}(t),s):bn()}(n,e,t,r,a)}var He,Ke=null;function Ve(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Ge(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||ve(t)))return t}}function $e(n,e){He.$on(n,e)}function We(n,e){He.$off(n,e)}function Qe(n,e){var t=He;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Ye(n,e,t){He=n,ce(e,t||{},$e,We,Qe,n),He=void 0}var Ze=null;function Xe(n){var e=Ze;return Ze=n,function(){Ze=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){fn();var t=n.$options[e],r=e+" hook";if(t)for(var a=0,i=t.length;a<i;a++)Vn(t[a],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),mn()}var rt=[],at=[],it={},ot=!1,lt=!1,st=0;var ct=0,dt=Date.now;if(V&&!Q){var ut=window.performance;ut&&"function"==typeof ut.now&&dt()>document.createEvent("Event").timeStamp&&(dt=function(){return ut.now()})}function pt(){var n,e;for(ct=dt(),lt=!0,rt.sort((function(n,e){return n.id-e.id})),st=0;st<rt.length;st++)(n=rt[st]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=at.slice(),r=rt.slice();st=rt.length=at.length=0,it={},ot=lt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&tt(r,"updated")}}(r),on&&N.devtools&&on.emit("flush")}var ht=0,ft=function(n,e,t,r,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ht,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!J.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()};ft.prototype.get=function(){var n;fn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Kn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),mn(),this.cleanupDeps()}return n},ft.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ft.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ft.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==it[e]){if(it[e]=!0,lt){for(var t=rt.length-1;t>st&&rt[t].id>n.id;)t--;rt.splice(t+1,0,n)}else rt.push(n);ot||(ot=!0,ae(pt))}}(this)},ft.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Vn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ft.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ft.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ft.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var mt={enumerable:!0,configurable:!0,get:z,set:z};function gt(n,e,t){mt.get=function(){return this[e][t]},mt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,mt)}function vt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},a=n.$options._propKeys=[];n.$parent&&An(!1);var i=function(i){a.push(i);var o=Nn(i,e,t,n);In(r,i,o),i in n||gt(n,"_props",i)};for(var o in e)i(o);An(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:I(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;u(e=n._data="function"==typeof e?function(n,e){fn();try{return n.call(e,e)}catch(n){return Kn(n,e,"data()"),{}}finally{mn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var i=t[a];0,r&&x(r,i)||(o=void 0,36!==(o=(i+"").charCodeAt(0))&&95!==o&&gt(n,"_data",i))}var o;Bn(e,!0)}(n):Bn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=an();for(var a in e){var i=e[a],o="function"==typeof i?i:i.get;0,r||(t[a]=new ft(n,o||z,z,bt)),a in n||yt(n,a,i)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var a=0;a<r.length;a++)kt(n,t,r[a]);else kt(n,t,r)}}(n,e.watch)}var bt={lazy:!0};function yt(n,e,t){var r=!an();"function"==typeof t?(mt.get=r?Et(e):xt(t),mt.set=z):(mt.get=t.get?r&&!1!==t.cache?Et(e):xt(t.get):z,mt.set=t.set||z),Object.defineProperty(n,e,mt)}function Et(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function xt(n){return function(){return n.call(this,this)}}function kt(n,e,t,r){return u(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var wt=0;function Tt(n){var e=n.options;if(n.super){var t=Tt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&_(n.extendOptions,r),(e=n.options=Rn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function At(n){this._init(n)}function St(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var i=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Rn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)gt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,R.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=_({},o.options),a[r]=o,o}}function Bt(n){return n&&(n.Ctor.options.name||n.tag)}function It(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function Ct(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var i in t){var o=t[i];if(o){var l=o.name;l&&!e(l)&&_t(t,i,r,a)}}}function _t(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=wt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Rn(Tt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ye(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=me(e._renderChildren,r),n.$scopedSlots=a,n._c=function(e,t,r,a){return Je(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Je(n,e,t,r,a,!0)};var i=t&&t.data;In(n,"$attrs",i&&i.attrs||a,null,!0),In(n,"$listeners",e._parentListeners||a,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=fe(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){In(n,t,e[t])})),An(!0))}(e),vt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(At),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Cn,n.prototype.$delete=_n,n.prototype.$watch=function(n,e,t){if(u(e))return kt(this,n,e,t);(t=t||{}).user=!0;var r=new ft(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'+r.expression+'"';fn(),Vn(e,this,[r.value],this,a),mn()}return function(){r.teardown()}}}(At),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var a=0,i=n.length;a<i;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var i,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var l=o.length;l--;)if((i=o[l])===e||i.fn===e){o.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?C(t):t;for(var r=C(arguments,1),a='event handler for "'+n+'"',i=0,o=t.length;i<o;i++)Vn(t[i],e,r,e,a)}return e}}(At),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,i=Xe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),i(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(At),function(n){Oe(n.prototype),n.prototype.$nextTick=function(n){return ae(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&(e.$scopedSlots=be(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{Ke=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Kn(t,e,"render"),n=e._vnode}finally{Ke=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof gn||(n=bn()),n.parent=a,n}}(At);var Pt=[String,RegExp,Array],zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Pt,exclude:Pt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,i=t.componentInstance,o=t.componentOptions;n[r]={name:Bt(o),tag:a,componentInstance:i},e.push(r),this.max&&e.length>parseInt(this.max)&&_t(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)_t(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Ct(n,(function(n){return It(e,n)}))})),this.$watch("exclude",(function(e){Ct(n,(function(n){return!It(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ge(n),t=e&&e.componentOptions;if(t){var r=Bt(t),a=this.include,i=this.exclude;if(a&&(!r||!It(a,r))||i&&r&&It(i,r))return e;var o=this.cache,l=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[s]?(e.componentInstance=o[s].componentInstance,y(l,s),l.push(s)):(this.vnodeToCache=e,this.keyToCache=s),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:dn,extend:_,mergeOptions:Rn,defineReactive:In},n.set=Cn,n.delete=_n,n.nextTick=ae,n.observable=function(n){return Bn(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,_(n.options.components,zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=C(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Rn(this.options,n),this}}(n),St(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(At),Object.defineProperty(At.prototype,"$isServer",{get:an}),Object.defineProperty(At.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(At,"FunctionalRenderContext",{value:De}),At.version="2.6.14";var jt=v("style,class"),Lt=v("input,textarea,option,select,progress"),Ot=v("contenteditable,draggable,spellcheck"),Dt=v("events,caret,typing,plaintext-only"),Mt=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Rt="http://www.w3.org/1999/xlink",Ft=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Nt=function(n){return Ft(n)?n.slice(6,n.length):""},qt=function(n){return null==n||!1===n};function Ut(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Jt(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=Jt(e,t.data));return function(n,e){if(o(n)||o(e))return Ht(n,Kt(e));return""}(e.staticClass,e.class)}function Jt(n,e){return{staticClass:Ht(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function Ht(n,e){return n?e?n+" "+e:n:e||""}function Kt(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)o(e=Kt(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Vt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Gt=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),$t=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Wt=function(n){return Gt(n)||$t(n)};var Qt=Object.create(null);var Yt=v("text,number,password,search,email,tel,url");var Zt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Vt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Xt={create:function(n,e){nr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(nr(n,!0),nr(e))},destroy:function(n){nr(n,!0)}};function nr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,a=n.componentInstance||n.elm,i=r.$refs;e?Array.isArray(i[t])?y(i[t],a):i[t]===a&&(i[t]=void 0):n.data.refInFor?Array.isArray(i[t])?i[t].indexOf(a)<0&&i[t].push(a):i[t]=[a]:i[t]=a}}var er=new gn("",{},[]),tr=["create","activate","update","remove","destroy"];function rr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,a=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===a||Yt(r)&&Yt(a)}(n,e)||l(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function ar(n,e,t){var r,a,i={};for(r=e;r<=t;++r)o(a=n[r].key)&&(i[a]=r);return i}var ir={create:or,update:or,destroy:function(n){or(n,er)}};function or(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,i=n===er,o=e===er,l=sr(n.data.directives,n.context),s=sr(e.data.directives,e.context),c=[],d=[];for(t in s)r=l[t],a=s[t],r?(a.oldValue=r.value,a.oldArg=r.arg,dr(a,"update",e,n),a.def&&a.def.componentUpdated&&d.push(a)):(dr(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var u=function(){for(var t=0;t<c.length;t++)dr(c[t],"inserted",e,n)};i?de(e,"insert",u):u()}d.length&&de(e,"postpatch",(function(){for(var t=0;t<d.length;t++)dr(d[t],"componentUpdated",e,n)}));if(!i)for(t in l)s[t]||dr(l[t],"unbind",n,n,o)}(n,e)}var lr=Object.create(null);function sr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=lr),a[cr(r)]=r,r.def=Fn(e.$options,"directives",r.name);return a}function cr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function dr(n,e,t,r,a){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,r,a)}catch(r){Kn(r,t.context,"directive "+n.name+" "+e+" hook")}}var ur=[Xt,ir];function pr(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var r,a,l=e.elm,s=n.data.attrs||{},c=e.data.attrs||{};for(r in o(c.__ob__)&&(c=e.data.attrs=_({},c)),c)a=c[r],s[r]!==a&&hr(l,r,a,e.data.pre);for(r in(Q||Z)&&c.value!==s.value&&hr(l,"value",c.value),s)i(c[r])&&(Ft(r)?l.removeAttributeNS(Rt,Nt(r)):Ot(r)||l.removeAttribute(r))}}function hr(n,e,t,r){r||n.tagName.indexOf("-")>-1?fr(n,e,t):Mt(e)?qt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Ot(e)?n.setAttribute(e,function(n,e){return qt(e)||"false"===e?"false":"contenteditable"===n&&Dt(e)?e:"true"}(e,t)):Ft(e)?qt(t)?n.removeAttributeNS(Rt,Nt(e)):n.setAttributeNS(Rt,e,t):fr(n,e,t)}function fr(n,e,t){if(qt(t))n.removeAttribute(e);else{if(Q&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var mr={create:pr,update:pr};function gr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(i(r.staticClass)&&i(r.class)&&(i(a)||i(a.staticClass)&&i(a.class)))){var l=Ut(e),s=t._transitionClasses;o(s)&&(l=Ht(l,Kt(s))),l!==t._prevClass&&(t.setAttribute("class",l),t._prevClass=l)}}var vr,br={create:gr,update:gr};function yr(n,e,t){var r=vr;return function a(){var i=e.apply(null,arguments);null!==i&&kr(n,a,t,r)}}var Er=Qn&&!(nn&&Number(nn[1])<=53);function xr(n,e,t,r){if(Er){var a=ct,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}vr.addEventListener(n,e,tn?{capture:t,passive:r}:t)}function kr(n,e,t,r){(r||vr).removeEventListener(n,e._wrapper||e,t)}function wr(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},r=n.data.on||{};vr=e.elm,function(n){if(o(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,r,xr,kr,yr,e.context),vr=void 0}}var Tr,Ar={create:wr,update:wr};function Sr(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},s=e.data.domProps||{};for(t in o(s.__ob__)&&(s=e.data.domProps=_({},s)),l)t in s||(a[t]="");for(t in s){if(r=s[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var c=i(r)?"":String(r);Br(a,c)&&(a.value=c)}else if("innerHTML"===t&&$t(a.tagName)&&i(a.innerHTML)){(Tr=Tr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var d=Tr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;d.firstChild;)a.appendChild(d.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Br(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return g(t)!==g(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Ir={create:Sr,update:Sr},Cr=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function _r(n){var e=Pr(n.style);return n.staticStyle?_(n.staticStyle,e):e}function Pr(n){return Array.isArray(n)?P(n):"string"==typeof n?Cr(n):n}var zr,jr=/^--/,Lr=/\s*!important$/,Or=function(n,e,t){if(jr.test(e))n.style.setProperty(e,t);else if(Lr.test(t))n.style.setProperty(B(e),t.replace(Lr,""),"important");else{var r=Mr(e);if(Array.isArray(t))for(var a=0,i=t.length;a<i;a++)n.style[r]=t[a];else n.style[r]=t}},Dr=["Webkit","Moz","ms"],Mr=k((function(n){if(zr=zr||document.createElement("div").style,"filter"!==(n=T(n))&&n in zr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Dr.length;t++){var r=Dr[t]+e;if(r in zr)return r}}));function Rr(n,e){var t=e.data,r=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(r.staticStyle)&&i(r.style))){var a,l,s=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},u=c||d,p=Pr(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?_({},p):p;var h=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=_r(a.data))&&_(r,t);(t=_r(n.data))&&_(r,t);for(var i=n;i=i.parent;)i.data&&(t=_r(i.data))&&_(r,t);return r}(e,!0);for(l in u)i(h[l])&&Or(s,l,"");for(l in h)(a=h[l])!==u[l]&&Or(s,l,null==a?"":a)}}var Fr={create:Rr,update:Rr},Nr=/\s+/;function qr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Nr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Ur(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Nr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Jr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&_(e,Hr(n.name||"v")),_(e,n),e}return"string"==typeof n?Hr(n):void 0}}var Hr=k((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Kr=V&&!Y,Vr="transition",Gr="transitionend",$r="animation",Wr="animationend";Kr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Vr="WebkitTransition",Gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&($r="WebkitAnimation",Wr="webkitAnimationEnd"));var Qr=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Yr(n){Qr((function(){Qr(n)}))}function Zr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),qr(n,e))}function Xr(n,e){n._transitionClasses&&y(n._transitionClasses,e),Ur(n,e)}function na(n,e,t){var r=ta(n,e),a=r.type,i=r.timeout,o=r.propCount;if(!a)return t();var l="transition"===a?Gr:Wr,s=0,c=function(){n.removeEventListener(l,d),t()},d=function(e){e.target===n&&++s>=o&&c()};setTimeout((function(){s<o&&c()}),i+1),n.addEventListener(l,d)}var ea=/\b(transform|all)(,|$)/;function ta(n,e){var t,r=window.getComputedStyle(n),a=(r[Vr+"Delay"]||"").split(", "),i=(r[Vr+"Duration"]||"").split(", "),o=ra(a,i),l=(r[$r+"Delay"]||"").split(", "),s=(r[$r+"Duration"]||"").split(", "),c=ra(l,s),d=0,u=0;return"transition"===e?o>0&&(t="transition",d=o,u=i.length):"animation"===e?c>0&&(t="animation",d=c,u=s.length):u=(t=(d=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:s.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&ea.test(r[Vr+"Property"])}}function ra(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return aa(e)+aa(n[t])})))}function aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ia(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Jr(n.data.transition);if(!i(r)&&!o(t._enterCb)&&1===t.nodeType){for(var a=r.css,l=r.type,s=r.enterClass,d=r.enterToClass,u=r.enterActiveClass,p=r.appearClass,h=r.appearToClass,f=r.appearActiveClass,m=r.beforeEnter,v=r.enter,b=r.afterEnter,y=r.enterCancelled,E=r.beforeAppear,x=r.appear,k=r.afterAppear,w=r.appearCancelled,T=r.duration,A=Ze,S=Ze.$vnode;S&&S.parent;)A=S.context,S=S.parent;var B=!A._isMounted||!n.isRootInsert;if(!B||x||""===x){var I=B&&p?p:s,C=B&&f?f:u,_=B&&h?h:d,P=B&&E||m,z=B&&"function"==typeof x?x:v,j=B&&k||b,L=B&&w||y,O=g(c(T)?T.enter:T);0;var D=!1!==a&&!Y,R=sa(z),F=t._enterCb=M((function(){D&&(Xr(t,_),Xr(t,C)),F.cancelled?(D&&Xr(t,I),L&&L(t)):j&&j(t),t._enterCb=null}));n.data.show||de(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),z&&z(t,F)})),P&&P(t),D&&(Zr(t,I),Zr(t,C),Yr((function(){Xr(t,I),F.cancelled||(Zr(t,_),R||(la(O)?setTimeout(F,O):na(t,l,F)))}))),n.data.show&&(e&&e(),z&&z(t,F)),D||R||F()}}}function oa(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Jr(n.data.transition);if(i(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var a=r.css,l=r.type,s=r.leaveClass,d=r.leaveToClass,u=r.leaveActiveClass,p=r.beforeLeave,h=r.leave,f=r.afterLeave,m=r.leaveCancelled,v=r.delayLeave,b=r.duration,y=!1!==a&&!Y,E=sa(h),x=g(c(b)?b.leave:b);0;var k=t._leaveCb=M((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Xr(t,d),Xr(t,u)),k.cancelled?(y&&Xr(t,s),m&&m(t)):(e(),f&&f(t)),t._leaveCb=null}));v?v(w):w()}function w(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(Zr(t,s),Zr(t,u),Yr((function(){Xr(t,s),k.cancelled||(Zr(t,d),E||(la(x)?setTimeout(k,x):na(t,l,k)))}))),h&&h(t,k),y||E||k())}}function la(n){return"number"==typeof n&&!isNaN(n)}function sa(n){if(i(n))return!1;var e=n.fns;return o(e)?sa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ca(n,e){!0!==e.data.show&&ia(e)}var da=function(n){var e,t,r={},a=n.modules,c=n.nodeOps;for(e=0;e<tr.length;++e)for(r[tr[e]]=[],t=0;t<a.length;++t)o(a[t][tr[e]])&&r[tr[e]].push(a[t][tr[e]]);function d(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function u(n,e,t,a,i,s,d){if(o(n.elm)&&o(s)&&(n=s[d]=En(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(o(i)){var s=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return p(n,e),h(t,n.elm,a),l(s)&&function(n,e,t,a){var i,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,o(i=l.data)&&o(i=i.transition)){for(i=0;i<r.activate.length;++i)r.activate[i](er,l);e.push(l);break}h(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var u=n.data,m=n.children,v=n.tag;o(v)?(n.elm=n.ns?c.createElementNS(n.ns,v):c.createElement(v,n),b(n),f(n,m,e),o(u)&&g(n,e),h(t,n.elm,a)):l(n.isComment)?(n.elm=c.createComment(n.text),h(t,n.elm,a)):(n.elm=c.createTextNode(n.text),h(t,n.elm,a))}}function p(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,m(n)?(g(n,e),b(n)):(nr(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function f(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)u(e[r],t,n.elm,null,!0,e,r)}else s(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function m(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function g(n,t){for(var a=0;a<r.create.length;++a)r.create[a](er,n);o(e=n.data.hook)&&(o(e.create)&&e.create(er,n),o(e.insert)&&t.push(n))}function b(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Ze)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function y(n,e,t,r,a,i){for(;r<=a;++r)u(t[r],i,n,e,!1,t,r)}function E(n){var e,t,a=n.data;if(o(a))for(o(e=a.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)E(n.children[t])}function x(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(k(r),E(r)):d(r.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,a=r.remove.length+1;for(o(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,a),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function w(n,e,t,r){for(var a=t;a<r;a++){var i=e[a];if(o(i)&&rr(n,i))return a}}function T(n,e,t,a,s,d){if(n!==e){o(e.elm)&&o(a)&&(e=a[s]=En(e));var p=e.elm=n.elm;if(l(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?B(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var h,f=e.data;o(f)&&o(h=f.hook)&&o(h=h.prepatch)&&h(n,e);var g=n.children,v=e.children;if(o(f)&&m(e)){for(h=0;h<r.update.length;++h)r.update[h](n,e);o(h=f.hook)&&o(h=h.update)&&h(n,e)}i(e.text)?o(g)&&o(v)?g!==v&&function(n,e,t,r,a){var l,s,d,p=0,h=0,f=e.length-1,m=e[0],g=e[f],v=t.length-1,b=t[0],E=t[v],k=!a;for(0;p<=f&&h<=v;)i(m)?m=e[++p]:i(g)?g=e[--f]:rr(m,b)?(T(m,b,r,t,h),m=e[++p],b=t[++h]):rr(g,E)?(T(g,E,r,t,v),g=e[--f],E=t[--v]):rr(m,E)?(T(m,E,r,t,v),k&&c.insertBefore(n,m.elm,c.nextSibling(g.elm)),m=e[++p],E=t[--v]):rr(g,b)?(T(g,b,r,t,h),k&&c.insertBefore(n,g.elm,m.elm),g=e[--f],b=t[++h]):(i(l)&&(l=ar(e,p,f)),i(s=o(b.key)?l[b.key]:w(b,e,p,f))?u(b,r,n,m.elm,!1,t,h):rr(d=e[s],b)?(T(d,b,r,t,h),e[s]=void 0,k&&c.insertBefore(n,d.elm,m.elm)):u(b,r,n,m.elm,!1,t,h),b=t[++h]);p>f?y(n,i(t[v+1])?null:t[v+1].elm,t,h,v,r):h>v&&x(e,p,f)}(p,g,v,t,d):o(v)?(o(n.text)&&c.setTextContent(p,""),y(p,null,v,0,v.length-1,t)):o(g)?x(g,0,g.length-1):o(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),o(f)&&o(h=f.hook)&&o(h=h.postpatch)&&h(n,e)}}}function A(n,e,t){if(l(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=v("attrs,class,staticClass,staticStyle,key");function B(n,e,t,r){var a,i=e.tag,s=e.data,c=e.children;if(r=r||s&&s.pre,e.elm=n,l(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(s)&&(o(a=s.hook)&&o(a=a.init)&&a(e,!0),o(a=e.componentInstance)))return p(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(a=s)&&o(a=a.domProps)&&o(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,h=0;h<c.length;h++){if(!u||!B(u,c[h],t,r)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else f(e,c,t);if(o(s)){var m=!1;for(var v in s)if(!S(v)){m=!0,g(e,t);break}!m&&s.class&&oe(s.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!i(e)){var s,d=!1,p=[];if(i(n))d=!0,u(e,p);else{var h=o(n.nodeType);if(!h&&rr(n,e))T(n,e,p,null,null,a);else{if(h){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&B(n,e,p))return A(e,p,!0),n;s=n,n=new gn(c.tagName(s).toLowerCase(),{},[],void 0,s)}var f=n.elm,g=c.parentNode(f);if(u(e,p,f._leaveCb?null:g,c.nextSibling(f)),o(e.parent))for(var v=e.parent,b=m(e);v;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](v);if(v.elm=e.elm,b){for(var k=0;k<r.create.length;++k)r.create[k](er,v);var w=v.data.hook.insert;if(w.merged)for(var S=1;S<w.fns.length;S++)w.fns[S]()}else nr(v);v=v.parent}o(g)?x([n],0,0):o(n.tag)&&E(n)}}return A(e,p,d),e.elm}o(n)&&E(n)}}({nodeOps:Zt,modules:[mr,br,Ar,Ir,Fr,V?{create:ca,activate:ca,remove:function(n,e){!0!==n.data.show?oa(n,e):e()}}:{}].concat(ur)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&ba(n,"input")}));var ua={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?de(t,"postpatch",(function(){ua.componentUpdated(n,e,t)})):pa(n,e,t.context),n._vOptions=[].map.call(n.options,ma)):("textarea"===t.tag||Yt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",ga),n.addEventListener("compositionend",va),n.addEventListener("change",va),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){pa(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,ma);if(a.some((function(n,e){return!O(n,r[e])})))(n.multiple?e.value.some((function(n){return fa(n,a)})):e.value!==e.oldValue&&fa(e.value,a))&&ba(n,"change")}}};function pa(n,e,t){ha(n,e,t),(Q||Z)&&setTimeout((function(){ha(n,e,t)}),0)}function ha(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var i,o,l=0,s=n.options.length;l<s;l++)if(o=n.options[l],a)i=D(r,ma(o))>-1,o.selected!==i&&(o.selected=i);else if(O(ma(o),r))return void(n.selectedIndex!==l&&(n.selectedIndex=l));a||(n.selectedIndex=-1)}}function fa(n,e){return e.every((function(e){return!O(e,n)}))}function ma(n){return"_value"in n?n._value:n.value}function ga(n){n.target.composing=!0}function va(n){n.target.composing&&(n.target.composing=!1,ba(n.target,"input"))}function ba(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function ya(n){return!n.componentInstance||n.data&&n.data.transition?n:ya(n.componentInstance._vnode)}var Ea={model:ua,show:{bind:function(n,e,t){var r=e.value,a=(t=ya(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,ia(t,(function(){n.style.display=i}))):n.style.display=r?i:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=ya(t)).data&&t.data.transition?(t.data.show=!0,r?ia(t,(function(){n.style.display=n.__vOriginalDisplay})):oa(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},xa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ka(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?ka(Ge(e.children)):n}function wa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var i in a)e[T(i)]=a[i];return e}function Ta(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Aa=function(n){return n.tag||ve(n)},Sa=function(n){return"show"===n.name},Ba={name:"transition",props:xa,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Aa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var i=ka(a);if(!i)return a;if(this._leaving)return Ta(n,a);var o="__transition-"+this._uid+"-";i.key=null==i.key?i.isComment?o+"comment":o+i.tag:s(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var l=(i.data||(i.data={})).transition=wa(this),c=this._vnode,d=ka(c);if(i.data.directives&&i.data.directives.some(Sa)&&(i.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,d)&&!ve(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=_({},l);if("out-in"===r)return this._leaving=!0,de(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ta(n,a);if("in-out"===r){if(ve(i))return c;var p,h=function(){p()};de(l,"afterEnter",h),de(l,"enterCancelled",h),de(u,"delayLeave",(function(n){p=n}))}}return a}}},Ia=_({tag:String,moveClass:String},xa);function Ca(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function _a(n){n.data.newPos=n.elm.getBoundingClientRect()}function Pa(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate("+r+"px,"+a+"px)",i.transitionDuration="0s"}}delete Ia.mode;var za={Transition:Ba,TransitionGroup:{props:Ia,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],i=this.children=[],o=wa(this),l=0;l<a.length;l++){var s=a[l];if(s.tag)if(null!=s.key&&0!==String(s.key).indexOf("__vlist"))i.push(s),t[s.key]=s,(s.data||(s.data={})).transition=o;else;}if(r){for(var c=[],d=[],u=0;u<r.length;u++){var p=r[u];p.data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):d.push(p)}this.kept=n(e,null,c),this.removed=d}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ca),n.forEach(_a),n.forEach(Pa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Zr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Gr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Gr,n),t._moveCb=null,Xr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Kr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Ur(t,n)})),qr(t,e),t.style.display="none",this.$el.appendChild(t);var r=ta(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};At.config.mustUseProp=function(n,e,t){return"value"===t&&Lt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},At.config.isReservedTag=Wt,At.config.isReservedAttr=jt,At.config.getTagNamespace=function(n){return $t(n)?"svg":"math"===n?"math":void 0},At.config.isUnknownElement=function(n){if(!V)return!0;if(Wt(n))return!1;if(n=n.toLowerCase(),null!=Qt[n])return Qt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Qt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Qt[n]=/HTMLUnknownElement/.test(e.toString())},_(At.options.directives,Ea),_(At.options.components,za),At.prototype.__patch__=V?da:z,At.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=bn),tt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new ft(n,r,z,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},V&&setTimeout((function(){N.devtools&&on&&on.emit("init",At)}),0);var ja=At;
/*!
  * vue-router v3.5.4
  * (c) 2022 Evan You
  * @license MIT
  */function La(n,e){for(var t in e)n[t]=e[t];return n}var Oa=/[!'()*]/g,Da=function(n){return"%"+n.charCodeAt(0).toString(16)},Ma=/%2C/g,Ra=function(n){return encodeURIComponent(n).replace(Oa,Da).replace(Ma,",")};function Fa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Na=function(n){return null==n||"object"==typeof n?n:String(n)};function qa(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Fa(t.shift()),a=t.length>0?Fa(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function Ua(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Ra(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Ra(e)):r.push(Ra(e)+"="+Ra(n)))})),r.join("&")}return Ra(e)+"="+Ra(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Ja=/\/?$/;function Ha(n,e,t,r){var a=r&&r.options.stringifyQuery,i=e.query||{};try{i=Ka(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:$a(e,a),matched:n?Ga(n):[]};return t&&(o.redirectedFrom=$a(t,a)),Object.freeze(o)}function Ka(n){if(Array.isArray(n))return n.map(Ka);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Ka(n[t]);return e}return n}var Va=Ha(null,{path:"/"});function Ga(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function $a(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||Ua)(r)+a}function Wa(n,e,t){return e===Va?n===e:!!e&&(n.path&&e.path?n.path.replace(Ja,"")===e.path.replace(Ja,"")&&(t||n.hash===e.hash&&Qa(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Qa(n.query,e.query)&&Qa(n.params,e.params))))}function Qa(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var i=n[t];if(r[a]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?Qa(i,o):String(i)===String(o)}))}function Ya(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],i=t.enteredCbs[r];if(a&&i){delete t.enteredCbs[r];for(var o=0;o<i.length;o++)a._isBeingDestroyed||i[o](a)}}}}var Za={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var o=a.$createElement,l=t.name,s=a.$route,c=a._routerViewCache||(a._routerViewCache={}),d=0,u=!1;a&&a._routerRoot!==a;){var p=a.$vnode?a.$vnode.data:{};p.routerView&&d++,p.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(i.routerViewDepth=d,u){var h=c[l],f=h&&h.component;return f?(h.configProps&&Xa(f,i,h.route,h.configProps),o(f,i,r)):o()}var m=s.matched[d],g=m&&m.components[l];if(!m||!g)return c[l]=null,o();c[l]={component:g},i.registerRouteInstance=function(n,e){var t=m.instances[l];(e&&t!==n||!e&&t===n)&&(m.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){m.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[l]&&(m.instances[l]=n.componentInstance),Ya(s)};var v=m.props&&m.props[l];return v&&(La(c[l],{route:s,configProps:v}),Xa(g,i,s,v)),o(g,i,r)}};function Xa(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=La({},a);var i=e.attrs=e.attrs||{};for(var o in a)n.props&&o in n.props||(i[o]=a[o],delete a[o])}}function ni(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var l=i[o];".."===l?a.pop():"."!==l&&a.push(l)}return""!==a[0]&&a.unshift(""),a.join("/")}function ei(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ti=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ri=vi,ai=ci,ii=function(n,e){return ui(ci(n,e),e)},oi=ui,li=gi,si=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ci(n,e){for(var t,r=[],a=0,i=0,o="",l=e&&e.delimiter||"/";null!=(t=si.exec(n));){var s=t[0],c=t[1],d=t.index;if(o+=n.slice(i,d),i=d+s.length,c)o+=c[1];else{var u=n[i],p=t[2],h=t[3],f=t[4],m=t[5],g=t[6],v=t[7];o&&(r.push(o),o="");var b=null!=p&&null!=u&&u!==p,y="+"===g||"*"===g,E="?"===g||"*"===g,x=t[2]||l,k=f||m;r.push({name:h||a++,prefix:p||"",delimiter:x,optional:E,repeat:y,partial:b,asterisk:!!v,pattern:k?hi(k):v?".*":"[^"+pi(x)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&r.push(o),r}function di(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ui(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",mi(e)));return function(e,r){for(var a="",i=e||{},o=(r||{}).pretty?di:encodeURIComponent,l=0;l<n.length;l++){var s=n[l];if("string"!=typeof s){var c,d=i[s.name];if(null==d){if(s.optional){s.partial&&(a+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(ti(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=o(d[u]),!t[l].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===u?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(d),!t[l].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');a+=s.prefix+c}}else a+=s}return a}}function pi(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function hi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function fi(n,e){return n.keys=e,n}function mi(n){return n&&n.sensitive?"":"i"}function gi(n,e,t){ti(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,i="",o=0;o<n.length;o++){var l=n[o];if("string"==typeof l)i+=pi(l);else{var s=pi(l.prefix),c="(?:"+l.pattern+")";e.push(l),l.repeat&&(c+="(?:"+s+c+")*"),i+=c=l.optional?l.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=pi(t.delimiter||"/"),u=i.slice(-d.length)===d;return r||(i=(u?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=a?"$":r&&u?"":"(?="+d+"|$)",fi(new RegExp("^"+i,mi(t)),e)}function vi(n,e,t){return ti(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return fi(n,e)}(n,e):ti(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(vi(n[a],e,t).source);return fi(new RegExp("(?:"+r.join("|")+")",mi(t)),e)}(n,e,t):function(n,e,t){return gi(ci(n,t),e,t)}(n,e,t)}ri.parse=ai,ri.compile=ii,ri.tokensToFunction=oi,ri.tokensToRegExp=li;var bi=Object.create(null);function yi(n,e,t){e=e||{};try{var r=bi[n]||(bi[n]=ri.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ei(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=La({},n)).params;return i&&"object"==typeof i&&(a.params=La({},i)),a}if(!a.path&&a.params&&e){(a=La({},a))._normalized=!0;var o=La(La({},e.params),a.params);if(e.name)a.name=e.name,a.params=o;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;a.path=yi(l,o,e.path)}else 0;return a}var s=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",d=s.path?ni(s.path,c,t||a.append):c,u=function(n,e,t){void 0===e&&(e={});var r,a=t||qa;try{r=a(n||"")}catch(n){r={}}for(var i in e){var o=e[i];r[i]=Array.isArray(o)?o.map(Na):Na(o)}return r}(s.query,a.query,r&&r.options.parseQuery),p=a.hash||s.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var xi,ki=function(){},wi={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),i=a.location,o=a.route,l=a.href,s={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,h=null==this.activeClass?u:this.activeClass,f=null==this.exactActiveClass?p:this.exactActiveClass,m=o.redirectedFrom?Ha(null,Ei(o.redirectedFrom),null,t):o;s[f]=Wa(r,m,this.exactPath),s[h]=this.exact||this.exactPath?s[f]:function(n,e){return 0===n.path.replace(Ja,"/").indexOf(e.path.replace(Ja,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,m);var g=s[f]?this.ariaCurrentValue:null,v=function(n){Ti(n)&&(e.replace?t.replace(i,ki):t.push(i,ki))},b={click:Ti};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:s},E=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:o,navigate:v,isActive:s[h],isExactActive:s[f]});if(E){if(1===E.length)return E[0];if(E.length>1||!E.length)return 0===E.length?n():n("span",{},E)}if("a"===this.tag)y.on=b,y.attrs={href:l,"aria-current":g};else{var x=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var k=x.data=La({},x.data);for(var w in k.on=k.on||{},k.on){var T=k.on[w];w in b&&(k.on[w]=Array.isArray(T)?T:[T])}for(var A in b)A in k.on?k.on[A].push(b[A]):k.on[A]=v;var S=x.data.attrs=La({},x.data.attrs);S.href=l,S["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Ti(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ai="undefined"!=typeof window;function Si(n,e,t,r,a){var i=e||[],o=t||Object.create(null),l=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,i,o){var l=a.path,s=a.name;0;var c=a.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ei(e.path+"/"+n)}(l,i,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var u={path:d,regex:Bi(d,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:s,parent:i,matchAs:o,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var i=o?ei(o+"/"+a.path):void 0;n(e,t,r,a,u,i)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==a.alias)for(var p=Array.isArray(a.alias)?a.alias:[a.alias],h=0;h<p.length;++h){0;var f={path:p[h],children:a.children};n(e,t,r,f,i,u.path||"/")}s&&(r[s]||(r[s]=u))}(i,o,l,n,a)}));for(var s=0,c=i.length;s<c;s++)"*"===i[s]&&(i.push(i.splice(s,1)[0]),c--,s--);return{pathList:i,pathMap:o,nameMap:l}}function Bi(n,e){return ri(n,[],e)}function Ii(n,e){var t=Si(n),r=t.pathList,a=t.pathMap,i=t.nameMap;function o(n,t,o){var l=Ei(n,t,!1,e),c=l.name;if(c){var d=i[c];if(!d)return s(null,l);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof l.params&&(l.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in l.params)&&u.indexOf(p)>-1&&(l.params[p]=t.params[p]);return l.path=yi(d.path,l.params),s(d,l,o)}if(l.path){l.params={};for(var h=0;h<r.length;h++){var f=r[h],m=a[f];if(Ci(m.regex,l.path,l.params))return s(m,l,o)}}return s(null,l)}function l(n,t){var r=n.redirect,a="function"==typeof r?r(Ha(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return s(null,t);var l=a,c=l.name,d=l.path,u=t.query,p=t.hash,h=t.params;if(u=l.hasOwnProperty("query")?l.query:u,p=l.hasOwnProperty("hash")?l.hash:p,h=l.hasOwnProperty("params")?l.params:h,c){i[c];return o({_normalized:!0,name:c,query:u,hash:p,params:h},void 0,t)}if(d){var f=function(n,e){return ni(n,e.parent?e.parent.path:"/",!0)}(d,n);return o({_normalized:!0,path:yi(f,h),query:u,hash:p},void 0,t)}return s(null,t)}function s(n,t,r){return n&&n.redirect?l(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:yi(t,e.params)});if(r){var a=r.matched,i=a[a.length-1];return e.params=r.params,s(i,e)}return s(null,e)}(0,t,n.matchAs):Ha(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Si([e||n],r,a,i,t),t&&t.alias.length&&Si(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,i,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Si(n,r,a,i)}}}function Ci(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,i=r.length;a<i;++a){var o=n.keys[a-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[a]?Fa(r[a]):r[a])}return!0}var _i=Ai&&window.performance&&window.performance.now?window.performance:Date;function Pi(){return _i.now().toFixed(3)}var zi=Pi();function ji(){return zi}function Li(n){return zi=n}var Oi=Object.create(null);function Di(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=La({},window.history.state);return t.key=ji(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Fi),function(){window.removeEventListener("popstate",Fi)}}function Mi(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var i=function(){var n=ji();if(n)return Oi[n]}(),o=a.call(n,e,t,r?i:null);o&&("function"==typeof o.then?o.then((function(n){Hi(n,i)})).catch((function(n){0})):Hi(o,i))}))}}function Ri(){var n=ji();n&&(Oi[n]={x:window.pageXOffset,y:window.pageYOffset})}function Fi(n){Ri(),n.state&&n.state.key&&Li(n.state.key)}function Ni(n){return Ui(n.x)||Ui(n.y)}function qi(n){return{x:Ui(n.x)?n.x:window.pageXOffset,y:Ui(n.y)?n.y:window.pageYOffset}}function Ui(n){return"number"==typeof n}var Ji=/^#\d/;function Hi(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=Ji.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,i={x:Ui((t=i).x)?t.x:0,y:Ui(t.y)?t.y:0})}else Ni(n)&&(e=qi(n))}else r&&Ni(n)&&(e=qi(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Ki,Vi=Ai&&((-1===(Ki=window.navigator.userAgent).indexOf("Android 2.")&&-1===Ki.indexOf("Android 4.0")||-1===Ki.indexOf("Mobile Safari")||-1!==Ki.indexOf("Chrome")||-1!==Ki.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Gi(n,e){Ri();var t=window.history;try{if(e){var r=La({},t.state);r.key=ji(),t.replaceState(r,"",n)}else t.pushState({key:Li(Pi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function $i(n){Gi(n,!0)}function Wi(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var Qi={redirected:2,aborted:4,cancelled:8,duplicated:16};function Yi(n,e){return Xi(n,e,Qi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return no.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Zi(n,e){return Xi(n,e,Qi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Xi(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var no=["params","query","hash"];function eo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function to(n,e){return eo(n)&&n._isRouter&&(null==e||n.type===e)}function ro(n){return function(e,t,r){var a=!1,i=0,o=null;ao(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){a=!0,i++;var s,c=lo((function(e){var a;((a=e).__esModule||oo&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:xi.extend(e),t.components[l]=e,--i<=0&&r()})),d=lo((function(n){var e="Failed to resolve async component "+l+": "+n;o||(o=eo(n)?n:new Error(e),r(o))}));try{s=n(c,d)}catch(n){d(n)}if(s)if("function"==typeof s.then)s.then(c,d);else{var u=s.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),a||r()}}function ao(n,e){return io(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function io(n){return Array.prototype.concat.apply([],n)}var oo="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function lo(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var so=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ai){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Va,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function co(n,e,t,r){var a=ao(n,(function(n,r,a,i){var o=function(n,e){"function"!=typeof n&&(n=xi.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,a,i)})):t(o,r,a,i)}));return io(r?a.reverse():a)}function uo(n,e){if(e)return function(){return n.apply(e,arguments)}}so.prototype.listen=function(n){this.cb=n},so.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},so.prototype.onError=function(n){this.errorCbs.push(n)},so.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,i)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(to(n,Qi.redirected)&&i===Va||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},so.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var i,o,l=function(n){!to(n)&&eo(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=a.matched.length-1;if(Wa(n,a)&&s===c&&n.matched[s]===a.matched[c])return this.ensureURL(),n.hash&&Mi(this.router,a,n,!1),l(((o=Xi(i=a,n,Qi.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var d=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,h=d.activated,f=[].concat(function(n){return co(n,"beforeRouteLeave",uo,!0)}(p),this.router.beforeHooks,function(n){return co(n,"beforeRouteUpdate",uo)}(u),h.map((function(n){return n.beforeEnter})),ro(h)),m=function(e,t){if(r.pending!==n)return l(Zi(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),l(function(n,e){return Xi(n,e,Qi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):eo(e)?(r.ensureURL(!0),l(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(l(Yi(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){l(n)}};Wi(f,m,(function(){Wi(function(n){return co(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,i){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,r)}))}(h).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return l(Zi(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Ya(n)}))}))}))},so.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},so.prototype.setupListeners=function(){},so.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Va,this.pending=null};var po=function(n){function e(e,t){n.call(this,e,t),this._startLocation=ho(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Vi&&t;r&&this.listeners.push(Di());var a=function(){var t=n.current,a=ho(n.base);n.current===Va&&a===n._startLocation||n.transitionTo(a,(function(n){r&&Mi(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Gi(ei(r.base+n.fullPath)),Mi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){$i(ei(r.base+n.fullPath)),Mi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(ho(this.base)!==this.current.fullPath){var e=ei(this.base+this.current.fullPath);n?Gi(e):$i(e)}},e.prototype.getCurrentLocation=function(){return ho(this.base)},e}(so);function ho(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ei(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var fo=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=ho(n);if(!/^\/#/.test(e))return window.location.replace(ei(n+"/#"+e)),!0}(this.base)||mo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Vi&&e;t&&this.listeners.push(Di());var r=function(){var e=n.current;mo()&&n.transitionTo(go(),(function(r){t&&Mi(n.router,r,e,!0),Vi||yo(r.fullPath)}))},a=Vi?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){bo(n.fullPath),Mi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){yo(n.fullPath),Mi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;go()!==e&&(n?bo(e):yo(e))},e.prototype.getCurrentLocation=function(){return go()},e}(so);function mo(){var n=go();return"/"===n.charAt(0)||(yo("/"+n),!1)}function go(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function vo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function bo(n){Vi?Gi(vo(n)):window.location.hash=n}function yo(n){Vi?$i(vo(n)):window.location.replace(vo(n))}var Eo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){to(n,Qi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(so),xo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ii(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Vi&&!1!==n.fallback,this.fallback&&(e="hash"),Ai||(e="abstract"),this.mode=e,e){case"history":this.history=new po(this,n.base);break;case"hash":this.history=new fo(this,n.base,this.fallback);break;case"abstract":this.history=new Eo(this,n.base);break;default:0}},ko={currentRoute:{configurable:!0}};function wo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}xo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},ko.currentRoute.get=function(){return this.history&&this.history.current},xo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof po||t instanceof fo){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;Vi&&a&&"fullPath"in n&&Mi(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},xo.prototype.beforeEach=function(n){return wo(this.beforeHooks,n)},xo.prototype.beforeResolve=function(n){return wo(this.resolveHooks,n)},xo.prototype.afterEach=function(n){return wo(this.afterHooks,n)},xo.prototype.onReady=function(n,e){this.history.onReady(n,e)},xo.prototype.onError=function(n){this.history.onError(n)},xo.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},xo.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},xo.prototype.go=function(n){this.history.go(n)},xo.prototype.back=function(){this.go(-1)},xo.prototype.forward=function(){this.go(1)},xo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},xo.prototype.resolve=function(n,e,t){var r=Ei(n,e=e||this.history.current,t,this),a=this.match(r,e),i=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ei(n+"/"+r):r}(this.history.base,i,this.mode),normalizedTo:r,resolved:a}},xo.prototype.getRoutes=function(){return this.matcher.getRoutes()},xo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Va&&this.history.transitionTo(this.history.getCurrentLocation())},xo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Va&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(xo.prototype,ko),xo.install=function n(e){if(!n.installed||xi!==e){n.installed=!0,xi=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Za),e.component("RouterLink",wi);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},xo.version="3.5.4",xo.isNavigationFailure=to,xo.NavigationFailureType=Qi,xo.START_LOCATION=Va,Ai&&window.Vue&&window.Vue.use(xo);var To=xo;t(182),t(183),t(268),t(82),t(184),t(29),t(30),t(270);function Ao(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(77),t(97),t(131);function So(n){return(So="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Bo=t(79),Io=(t(196),t(18),t(45),t(238),t(239),t(40),t(31),{NotFound:function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,506))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,505))}}),Co={"v-36edf5bb":function(){return t.e(6).then(t.bind(null,508))},"v-7abe58c4":function(){return t.e(9).then(t.bind(null,509))},"v-10f5d0e5":function(){return t.e(7).then(t.bind(null,510))},"v-a612ff08":function(){return t.e(8).then(t.bind(null,511))},"v-8bf153e4":function(){return t.e(10).then(t.bind(null,512))},"v-0734374b":function(){return t.e(11).then(t.bind(null,513))},"v-57012c44":function(){return t.e(13).then(t.bind(null,514))},"v-4e1fd39c":function(){return t.e(12).then(t.bind(null,515))},"v-57b2551a":function(){return t.e(16).then(t.bind(null,516))},"v-d8a2f15c":function(){return t.e(14).then(t.bind(null,517))},"v-7f48b402":function(){return t.e(15).then(t.bind(null,518))},"v-d4e20148":function(){return t.e(17).then(t.bind(null,519))},"v-d32e07ea":function(){return t.e(18).then(t.bind(null,520))},"v-85b06162":function(){return t.e(19).then(t.bind(null,521))},"v-7665e30e":function(){return t.e(21).then(t.bind(null,522))},"v-4c273a66":function(){return t.e(20).then(t.bind(null,523))},"v-6ff6e2f0":function(){return t.e(22).then(t.bind(null,524))},"v-620ebadc":function(){return t.e(23).then(t.bind(null,525))},"v-5290507e":function(){return t.e(24).then(t.bind(null,526))},"v-6f5c6512":function(){return t.e(25).then(t.bind(null,527))},"v-75844e97":function(){return t.e(26).then(t.bind(null,528))},"v-1218fa85":function(){return t.e(27).then(t.bind(null,529))},"v-b21bbc4c":function(){return t.e(28).then(t.bind(null,530))},"v-45fc1217":function(){return t.e(29).then(t.bind(null,531))},"v-5390e3d4":function(){return t.e(30).then(t.bind(null,532))},"v-352f36cc":function(){return t.e(32).then(t.bind(null,533))},"v-4927c049":function(){return t.e(33).then(t.bind(null,534))},"v-1065f7be":function(){return t.e(35).then(t.bind(null,535))},"v-f5bcd180":function(){return t.e(34).then(t.bind(null,536))},"v-35324a50":function(){return t.e(31).then(t.bind(null,537))},"v-134f28dc":function(){return t.e(37).then(t.bind(null,538))},"v-03e420c4":function(){return t.e(38).then(t.bind(null,539))},"v-2dbdb772":function(){return t.e(36).then(t.bind(null,540))},"v-9baaad8e":function(){return t.e(41).then(t.bind(null,541))},"v-625fbeda":function(){return t.e(39).then(t.bind(null,542))},"v-7b2a2ed4":function(){return t.e(40).then(t.bind(null,543))},"v-75c00225":function(){return t.e(42).then(t.bind(null,544))},"v-083aef82":function(){return t.e(43).then(t.bind(null,545))},"v-f406b4e6":function(){return t.e(44).then(t.bind(null,546))},"v-af821fc8":function(){return t.e(46).then(t.bind(null,547))},"v-7cd97c82":function(){return t.e(45).then(t.bind(null,548))},"v-5474bec0":function(){return t.e(47).then(t.bind(null,549))},"v-0970cd54":function(){return t.e(48).then(t.bind(null,550))},"v-2de19204":function(){return t.e(49).then(t.bind(null,551))},"v-37fcb440":function(){return t.e(50).then(t.bind(null,552))},"v-15fba8f1":function(){return t.e(51).then(t.bind(null,553))},"v-28c1d6d9":function(){return t.e(52).then(t.bind(null,554))},"v-ba94c306":function(){return t.e(53).then(t.bind(null,555))},"v-88b087a6":function(){return t.e(54).then(t.bind(null,556))},"v-2d6ed001":function(){return t.e(55).then(t.bind(null,557))},"v-22a9eaef":function(){return t.e(56).then(t.bind(null,558))},"v-31509c80":function(){return t.e(57).then(t.bind(null,559))},"v-0564ba27":function(){return t.e(58).then(t.bind(null,560))},"v-34f8aaa2":function(){return t.e(59).then(t.bind(null,561))},"v-28deb9da":function(){return t.e(60).then(t.bind(null,562))},"v-5b0157cf":function(){return t.e(61).then(t.bind(null,563))},"v-64f1031c":function(){return t.e(62).then(t.bind(null,564))},"v-0a1d1fb4":function(){return t.e(64).then(t.bind(null,565))},"v-470b2fce":function(){return t.e(63).then(t.bind(null,566))},"v-6602e3da":function(){return t.e(65).then(t.bind(null,567))},"v-12717373":function(){return t.e(66).then(t.bind(null,568))},"v-5047727f":function(){return t.e(67).then(t.bind(null,569))},"v-feb79e02":function(){return t.e(68).then(t.bind(null,570))},"v-3890e0b4":function(){return t.e(69).then(t.bind(null,571))},"v-c0c0e5c8":function(){return t.e(71).then(t.bind(null,572))},"v-aa8887a4":function(){return t.e(72).then(t.bind(null,573))},"v-eb417bbe":function(){return t.e(70).then(t.bind(null,574))},"v-f886ba80":function(){return t.e(73).then(t.bind(null,575))},"v-75f6731c":function(){return t.e(76).then(t.bind(null,576))},"v-f8f98912":function(){return t.e(77).then(t.bind(null,577))},"v-9aa2c788":function(){return t.e(75).then(t.bind(null,578))},"v-df71a6e0":function(){return t.e(74).then(t.bind(null,579))},"v-63453344":function(){return t.e(78).then(t.bind(null,580))},"v-93120d3a":function(){return t.e(79).then(t.bind(null,581))},"v-3e902cd4":function(){return t.e(80).then(t.bind(null,582))},"v-74475c54":function(){return t.e(82).then(t.bind(null,583))},"v-730f9a6a":function(){return t.e(84).then(t.bind(null,584))},"v-52edac80":function(){return t.e(81).then(t.bind(null,585))},"v-0e7ed85a":function(){return t.e(83).then(t.bind(null,586))},"v-15fe5424":function(){return t.e(85).then(t.bind(null,587))},"v-01df2b5d":function(){return t.e(87).then(t.bind(null,588))},"v-7370facf":function(){return t.e(88).then(t.bind(null,589))},"v-7fc8ca51":function(){return t.e(86).then(t.bind(null,590))},"v-15ca313a":function(){return t.e(89).then(t.bind(null,591))},"v-7707a260":function(){return t.e(90).then(t.bind(null,592))},"v-a9abf6a0":function(){return t.e(91).then(t.bind(null,593))},"v-693fb010":function(){return t.e(92).then(t.bind(null,594))},"v-51f24219":function(){return t.e(93).then(t.bind(null,595))},"v-fe1405b0":function(){return t.e(95).then(t.bind(null,596))},"v-18f7a69e":function(){return t.e(94).then(t.bind(null,597))},"v-a0ab5810":function(){return t.e(96).then(t.bind(null,598))},"v-5a37154c":function(){return t.e(99).then(t.bind(null,599))},"v-262f2c87":function(){return t.e(98).then(t.bind(null,600))},"v-05845816":function(){return t.e(100).then(t.bind(null,601))},"v-32c73af0":function(){return t.e(97).then(t.bind(null,602))},"v-303058be":function(){return t.e(101).then(t.bind(null,603))},"v-1f69ea23":function(){return t.e(102).then(t.bind(null,604))},"v-f6bafd34":function(){return t.e(103).then(t.bind(null,605))},"v-129dffb8":function(){return t.e(104).then(t.bind(null,606))},"v-c875c5a4":function(){return t.e(106).then(t.bind(null,607))},"v-7abb1115":function(){return t.e(105).then(t.bind(null,608))},"v-1a49912a":function(){return t.e(108).then(t.bind(null,609))},"v-63719191":function(){return t.e(107).then(t.bind(null,610))},"v-85af5b9e":function(){return t.e(109).then(t.bind(null,611))},"v-1ea2064a":function(){return t.e(111).then(t.bind(null,612))},"v-8c3da672":function(){return t.e(110).then(t.bind(null,613))},"v-db80e4da":function(){return t.e(112).then(t.bind(null,614))},"v-e048e838":function(){return t.e(113).then(t.bind(null,615))},"v-d41ba7ec":function(){return t.e(114).then(t.bind(null,616))},"v-0c4b3c8a":function(){return t.e(115).then(t.bind(null,617))},"v-a380136c":function(){return t.e(119).then(t.bind(null,618))},"v-e66c56a0":function(){return t.e(118).then(t.bind(null,619))},"v-7193df75":function(){return t.e(116).then(t.bind(null,620))},"v-8228d7f2":function(){return t.e(120).then(t.bind(null,621))},"v-774fbc7c":function(){return t.e(122).then(t.bind(null,622))},"v-2680fed9":function(){return t.e(117).then(t.bind(null,623))},"v-e8b2cf00":function(){return t.e(121).then(t.bind(null,624))},"v-016a9bfe":function(){return t.e(123).then(t.bind(null,625))},"v-57b9b0cf":function(){return t.e(124).then(t.bind(null,626))},"v-13949e6a":function(){return t.e(125).then(t.bind(null,627))},"v-a406533a":function(){return t.e(126).then(t.bind(null,628))},"v-3bb878ba":function(){return t.e(127).then(t.bind(null,629))},"v-5c643de7":function(){return t.e(128).then(t.bind(null,630))},"v-24153295":function(){return t.e(129).then(t.bind(null,631))},"v-ca8a5a42":function(){return t.e(130).then(t.bind(null,632))},"v-ccd01cc4":function(){return t.e(131).then(t.bind(null,633))},"v-1fc84936":function(){return t.e(132).then(t.bind(null,634))},"v-13bddd54":function(){return t.e(133).then(t.bind(null,635))},"v-c85da526":function(){return t.e(134).then(t.bind(null,636))},"v-311026d5":function(){return t.e(135).then(t.bind(null,637))},"v-25d809ae":function(){return t.e(136).then(t.bind(null,638))},"v-f0f711c4":function(){return t.e(138).then(t.bind(null,639))},"v-824b776c":function(){return t.e(139).then(t.bind(null,640))},"v-674454ac":function(){return t.e(137).then(t.bind(null,641))},"v-6c681639":function(){return t.e(142).then(t.bind(null,642))},"v-7e02c4a1":function(){return t.e(140).then(t.bind(null,643))},"v-5b0e09c6":function(){return t.e(141).then(t.bind(null,644))},"v-c39c4fe2":function(){return t.e(143).then(t.bind(null,645))},"v-4ecddbec":function(){return t.e(145).then(t.bind(null,646))},"v-689e142a":function(){return t.e(144).then(t.bind(null,647))},"v-505fbe2e":function(){return t.e(146).then(t.bind(null,648))},"v-0dd47f09":function(){return t.e(147).then(t.bind(null,649))},"v-53bcbb7a":function(){return t.e(148).then(t.bind(null,650))},"v-c383b96e":function(){return t.e(149).then(t.bind(null,651))},"v-4cef944a":function(){return t.e(150).then(t.bind(null,652))},"v-ed0c93b8":function(){return t.e(151).then(t.bind(null,653))},"v-f3acaa1a":function(){return t.e(153).then(t.bind(null,654))},"v-d6bc240a":function(){return t.e(152).then(t.bind(null,655))},"v-ceed6ba6":function(){return t.e(154).then(t.bind(null,656))},"v-77790024":function(){return t.e(155).then(t.bind(null,657))},"v-76f5e79a":function(){return t.e(156).then(t.bind(null,658))},"v-0a7e6416":function(){return t.e(157).then(t.bind(null,659))},"v-6b967a6e":function(){return t.e(158).then(t.bind(null,660))},"v-d804fba0":function(){return t.e(159).then(t.bind(null,661))},"v-cb742458":function(){return t.e(160).then(t.bind(null,662))},"v-3e917471":function(){return t.e(161).then(t.bind(null,663))},"v-2c6b511c":function(){return t.e(164).then(t.bind(null,664))},"v-3d2fdd6a":function(){return t.e(165).then(t.bind(null,665))},"v-18b427a0":function(){return t.e(166).then(t.bind(null,666))},"v-c0bc7b7a":function(){return t.e(162).then(t.bind(null,667))},"v-7c214d00":function(){return t.e(163).then(t.bind(null,668))},"v-c2fe5e1a":function(){return t.e(168).then(t.bind(null,669))},"v-35718f4e":function(){return t.e(169).then(t.bind(null,670))},"v-6a45f68d":function(){return t.e(167).then(t.bind(null,671))},"v-57957421":function(){return t.e(170).then(t.bind(null,672))},"v-37f158ba":function(){return t.e(171).then(t.bind(null,673))},"v-02ea33c3":function(){return t.e(172).then(t.bind(null,674))},"v-be02b3c0":function(){return t.e(173).then(t.bind(null,675))},"v-5acdab4d":function(){return t.e(174).then(t.bind(null,676))},"v-073f22cd":function(){return t.e(175).then(t.bind(null,677))},"v-5157927c":function(){return t.e(177).then(t.bind(null,678))},"v-62f3fa3e":function(){return t.e(178).then(t.bind(null,679))},"v-bbcf6e5a":function(){return t.e(176).then(t.bind(null,680))},"v-6b32ada0":function(){return t.e(179).then(t.bind(null,681))},"v-7c0136cf":function(){return t.e(181).then(t.bind(null,682))},"v-0df39df8":function(){return t.e(180).then(t.bind(null,683))},"v-04af9e42":function(){return t.e(182).then(t.bind(null,684))},"v-0c440466":function(){return t.e(183).then(t.bind(null,685))},"v-a9558ec0":function(){return t.e(185).then(t.bind(null,686))},"v-684c4815":function(){return t.e(184).then(t.bind(null,687))},"v-164d9a94":function(){return t.e(186).then(t.bind(null,688))},"v-00fb6429":function(){return t.e(187).then(t.bind(null,689))},"v-5675b06b":function(){return t.e(188).then(t.bind(null,690))},"v-1d6b51b7":function(){return t.e(190).then(t.bind(null,691))},"v-f88544f4":function(){return t.e(189).then(t.bind(null,692))},"v-dca272ea":function(){return t.e(191).then(t.bind(null,693))},"v-5afa53ed":function(){return t.e(193).then(t.bind(null,694))},"v-2a52a762":function(){return t.e(194).then(t.bind(null,695))},"v-00dfea7c":function(){return t.e(192).then(t.bind(null,696))},"v-70bb01cc":function(){return t.e(197).then(t.bind(null,697))},"v-534e5ed0":function(){return t.e(198).then(t.bind(null,698))},"v-bd4d3ab8":function(){return t.e(199).then(t.bind(null,699))},"v-37ecc426":function(){return t.e(196).then(t.bind(null,700))},"v-1130f268":function(){return t.e(195).then(t.bind(null,701))},"v-6bbf2d35":function(){return t.e(200).then(t.bind(null,702))},"v-918dfaf8":function(){return t.e(202).then(t.bind(null,507))},"v-286c1812":function(){return t.e(201).then(t.bind(null,703))},"v-7ab50b9f":function(){return t.e(203).then(t.bind(null,704))},"v-09c150e6":function(){return t.e(204).then(t.bind(null,705))},"v-2db11cb2":function(){return t.e(208).then(t.bind(null,706))},"v-a5c5f278":function(){return t.e(209).then(t.bind(null,707))},"v-7d77d69c":function(){return t.e(210).then(t.bind(null,708))},"v-48f7eec0":function(){return t.e(205).then(t.bind(null,709))},"v-5f8dfe80":function(){return t.e(206).then(t.bind(null,710))},"v-64f9b920":function(){return t.e(207).then(t.bind(null,711))},"v-2cf94a0e":function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,712))}};function _o(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Po=/-(\w)/g,zo=_o((function(n){return n.replace(Po,(function(n,e){return e?e.toUpperCase():""}))})),jo=/\B([A-Z])/g,Lo=_o((function(n){return n.replace(jo,"-$1").toLowerCase()})),Oo=_o((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Do(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Oo(zo(e))):n(Oo(e))||n(Lo(e))}var Mo=Object.assign({},Io,Co),Ro=function(n){return Mo[n]},Fo=function(n){return Co[n]},No=function(n){return Io[n]},qo=function(n){return ja.component(n)};function Uo(n){return Do(Fo,n)}function Jo(n){return Do(No,n)}function Ho(n){return Do(Ro,n)}function Ko(n){return Do(qo,n)}function Vo(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Ko(e)||!Ho(e)){n.next=5;break}return n.next=3,Ho(e)();case 3:t=n.sent,ja.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Go(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var $o=t(143),Wo=(t(130),t(115),t(56),t(226)),Qo=t.n(Wo),Yo=t(227),Zo=t.n(Yo),Xo={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object($o.a)(n,1)[0]})).map((function(n){var e=Object($o.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Zo()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=el(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Bo.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=tl(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Qo()([{name:"description",content:this.$description}],n,this.siteMeta,rl)},updateCanonicalLink:function(){nl(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",el(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){tl(null,this.currentMetaTags),nl()}};function nl(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function el(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function tl(n,e){if(e&&Object(Bo.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function rl(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(144);var al=t(156),il={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(al)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+r,o=0;o<t.length;o++){var l=t[o],s=t[o+1],c=0===o&&0===r||r>=l.parentElement.offsetTop+10&&(!s||r<s.parentElement.offsetTop-10),d=decodeURIComponent(this.$route.hash);if(c&&d!==decodeURIComponent(l.hash)){var u=l;if(i===a)for(var p=o+1;p<t.length;p++)if(d===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(u.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},ol=(t(85),t(106)),ll=t.n(ol),sl={mounted:function(){var n=this;ll.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||ja.component(n.name)||ll.a.start(),t()})),this.$router.afterEach((function(){ll.a.done(),n.isSidebarOpen=!1}))}};t(81),t(57),t(84),t(384);function cl(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(104);function dl(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ul(n,e,t){return e&&dl(n.prototype,e),t&&dl(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(385);var pl=function(){function n(){cl(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ul(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,a=n.duration,i=void 0===a?3e3:a,o=document.createElement("div");o.className="message move-in",o.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(o),i>0&&setTimeout((function(){e.close(o)}),i)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),hl={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new pl).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(241),t(108),t(109),t(145),t(387);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var fl={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},ml={},gl=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},vl=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:fl[n]},bl=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,i=e.children;a.appendChild(n(t,r,i))})),a},yl=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},El=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),l={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};l.htmlTpl=gl(l.html),l.jsTpl=(t=l.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),l.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,i=[eval][0](a);return i.template=e,i}(l.js,l.html);var s=vl("vue");return l.jsLib.unshift(s),l},xl=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},kl=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function wl(){var n=yl(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=yl(n,"vuepress-plugin-demo-block__code"),t=yl(n,"vuepress-plugin-demo-block__display"),r=yl(n,"vuepress-plugin-demo-block__footer"),a=yl(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),l=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var s=e.querySelector("div").clientHeight,c="react"===l?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),i={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:kl(n),htmlTpl:gl("")},o=vl("react"),l=vl("reactDOM");return i.jsLib.unshift(o,l),i}(i,o):"vanilla"===l?xl(i,o):El(i,o),d=bl("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(d),d.addEventListener("click",Tl.bind(null,d,s,e,r)),vl("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,i=n.cssLib,o=a.concat(i).concat(vl("cssLib")).concat(vl("jsLib")).join(",");return bl("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),vl("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(vl("jsLib")).join(";"),css_external:i.concat(vl("cssLib")).join(";"),layout:vl("codepenLayout"),js_pre_processor:vl("codepenJsProcessor"),editors:vl("codepenEditors")});return bl("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:vl("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!ml[n]){var e=bl("style",{innerHTML:n});document.body.appendChild(e),ml[n]=!0}}(c.css),"react"===l)ReactDOM.render(React.createElement(c.js),a);else if("vue"===l){var p=(new(Vue.extend(c.script))).$mount();a.appendChild(p.$el)}else"vanilla"===l&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){wl()}),300)}function Tl(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var Al={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},wl()},updated:function(){wl()}},Sl=(t(231),"auto"),Bl="zoom-in",Il="zoom-out",Cl="grab",_l="move";function Pl(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function zl(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function jl(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ll(n,e,t){!function(n){var e=Ol,t=Dl;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var i in e)t&&(a[i]=r[i]||""),r[i]=e[i];return a}var Ol="transition",Dl="transform",Ml="transform",Rl="transitionend";var Fl=function(){},Nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Fl,onClose:Fl,onGrab:Fl,onMove:Fl,onRelease:Fl,onBeforeOpen:Fl,onBeforeClose:Fl,onBeforeGrab:Fl,onBeforeRelease:Fl,onImageLoading:Fl,onImageLoaded:Fl},ql={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Jl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(a)>=i||Math.abs(r)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Ul(n)&&!Jl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Ul(n)&&!Jl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Ul(n){return 0===n.button}function Jl(n){return n.metaKey||n.ctrlKey}var Hl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ll(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Pl(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ll(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Kl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Vl=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Gl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},$l={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=jl(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Cl:Il,transition:Ml+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ll(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ll(this.el,{transform:"none"})},grab:function(n,e,t){var r=Wl(),a=r.x-n,i=r.y-e;Ll(this.el,{cursor:_l,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Wl(),a=r.x-n,i=r.y-e;Ll(this.el,{transition:Ml,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ll(this.el,this.styleClose)},restoreOpenStyle:function(){Ll(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Wl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,i=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":Kl(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var o=this.rect.width/2,l=this.rect.height/2,s=Wl(),c={x:s.x-o,y:s.y-l},d=c.x/o,u=c.y/l,p=i+Math.min(d,u);if(a&&"string"==typeof a){var h=t||this.el.naturalWidth,f=e||this.el.naturalHeight,m=parseFloat(a)*h/(100*this.rect.width),g=parseFloat(a)*f/(100*this.rect.height);if(p>m||p>g)return{x:m,y:g}}return{x:p,y:p}}};function Wl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Ql(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Pl(n,r,e[r],t)}))}var Yl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create($l),this.overlay=Object.create(Hl),this.handler=Object.create(ql),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Gl({},Nl,e),this.overlay.init(this),this.handler.init(this)}return Vl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Bl,Pl(n,"click",this.handler.click),this.options.preloadImage&&zl(jl(n)));return this}},{key:"config",value:function(n){return n?(Gl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),zl(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Pl(document,"scroll",this.handler.scroll),Pl(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Pl(window,"resize",this.handler.resizeWindow);var i=function n(){Pl(r,Rl,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Ql(document,e.handler,!0),t(r)};return Pl(r,Rl,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Sl,this.overlay.fadeOut(),this.target.zoomOut(),Pl(document,"scroll",this.handler.scroll,!1),Pl(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Pl(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Pl(t,Rl,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Ql(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Pl(t,Rl,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var i=function n(){Pl(a,Rl,n,!1),r(a)};return Pl(a,Rl,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=_l,this.target.move(n,e,t);var a=this.target.el,i=function n(){Pl(a,Rl,n,!1),r(a)};return Pl(a,Rl,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Sl,this.target.restoreOpenStyle();var r=function r(){Pl(t,Rl,r,!1),n.lock=!1,n.released=!0,e(t)};return Pl(t,Rl,r),this}}}]),n}(),Zl=".theme-vdoing-content img:not(.no-zoom)",Xl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ns=Number("500"),es=function(){function n(){cl(this,n),this.instance=new Yl(Xl)}return ul(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Zl;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Zl,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ns;setTimeout((function(){return n.update(e)}),t)}}]),n}(),ts=[Xo,il,sl,hl,Al,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new es,this.$vuepress.zooming.updateDelay()}}],rs={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Go("layout",n),ja.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},as=t(21),is=Object(as.a)(rs,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(Bo.a)(t));break;default:throw new Error("Unknown option name.")}}(is,"mixins",ts);var os=[{name:"v-36edf5bb",path:"/java/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-36edf5bb").then(t)}},{path:"/java/index.html",redirect:"/java/"},{path:"/00.目录页/01.Java相关.html",redirect:"/java/"},{name:"v-7abe58c4",path:"/middleware/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7abe58c4").then(t)}},{path:"/middleware/index.html",redirect:"/middleware/"},{path:"/00.目录页/04.中间件.html",redirect:"/middleware/"},{name:"v-10f5d0e5",path:"/basic/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-10f5d0e5").then(t)}},{path:"/basic/index.html",redirect:"/basic/"},{path:"/00.目录页/02.计算机基础.html",redirect:"/basic/"},{name:"v-a612ff08",path:"/database/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-a612ff08").then(t)}},{path:"/database/index.html",redirect:"/database/"},{path:"/00.目录页/03.数据库.html",redirect:"/database/"},{name:"v-8bf153e4",path:"/pages/a030ff/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-8bf153e4").then(t)}},{path:"/pages/a030ff/index.html",redirect:"/pages/a030ff/"},{path:"/01.Java相关/10.基础/001.Java 异常有哪些类型？.html",redirect:"/pages/a030ff/"},{name:"v-0734374b",path:"/pages/d1c564/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0734374b").then(t)}},{path:"/pages/d1c564/index.html",redirect:"/pages/d1c564/"},{path:"/01.Java相关/10.基础/010.HashMap 与 ConcurrentHashMap 的实现原理是怎样的？.html",redirect:"/pages/d1c564/"},{name:"v-57012c44",path:"/pages/0d22ad/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-57012c44").then(t)}},{path:"/pages/0d22ad/index.html",redirect:"/pages/0d22ad/"},{path:"/01.Java相关/10.基础/030.为什么重写 equals 必须重写 hashcode ？.html",redirect:"/pages/0d22ad/"},{name:"v-4e1fd39c",path:"/pages/826c8b/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-4e1fd39c").then(t)}},{path:"/pages/826c8b/index.html",redirect:"/pages/826c8b/"},{path:"/01.Java相关/10.基础/020.Java 中接口和抽象类的区别.html",redirect:"/pages/826c8b/"},{name:"v-57b2551a",path:"/pages/305919/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-57b2551a").then(t)}},{path:"/pages/305919/index.html",redirect:"/pages/305919/"},{path:"/01.Java相关/10.基础/060.简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度.html",redirect:"/pages/305919/"},{name:"v-d8a2f15c",path:"/pages/06b28a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-d8a2f15c").then(t)}},{path:"/pages/06b28a/index.html",redirect:"/pages/06b28a/"},{path:"/01.Java相关/10.基础/040.== 和 equals() 的区别？.html",redirect:"/pages/06b28a/"},{name:"v-7f48b402",path:"/pages/211d8c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7f48b402").then(t)}},{path:"/pages/211d8c/index.html",redirect:"/pages/211d8c/"},{path:"/01.Java相关/10.基础/050.String，StringBuffer，StringBuilder 之间有什么区别？.html",redirect:"/pages/211d8c/"},{name:"v-d4e20148",path:"/pages/276740/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-d4e20148").then(t)}},{path:"/pages/276740/index.html",redirect:"/pages/276740/"},{path:"/01.Java相关/10.基础/070.简述 BIO, NIO, AIO 的区别.html",redirect:"/pages/276740/"},{name:"v-d32e07ea",path:"/pages/56314c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-d32e07ea").then(t)}},{path:"/pages/56314c/index.html",redirect:"/pages/56314c/"},{path:"/01.Java相关/10.基础/080.在一个静态方法内调用一个非静态成员为什么是非法的？.html",redirect:"/pages/56314c/"},{name:"v-85b06162",path:"/pages/fae5d5/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-85b06162").then(t)}},{path:"/pages/fae5d5/index.html",redirect:"/pages/fae5d5/"},{path:"/01.Java相关/10.基础/090.简述 Java 的反射机制及其应用场景.html",redirect:"/pages/fae5d5/"},{name:"v-7665e30e",path:"/pages/38bcaf/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7665e30e").then(t)}},{path:"/pages/38bcaf/index.html",redirect:"/pages/38bcaf/"},{path:"/01.Java相关/10.基础/110.什么是双亲委派机制？.html",redirect:"/pages/38bcaf/"},{name:"v-4c273a66",path:"/pages/33c5d6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-4c273a66").then(t)}},{path:"/pages/33c5d6/index.html",redirect:"/pages/33c5d6/"},{path:"/01.Java相关/10.基础/100.Java 类的加载流程是怎样的？.html",redirect:"/pages/33c5d6/"},{name:"v-6ff6e2f0",path:"/pages/d69890/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-6ff6e2f0").then(t)}},{path:"/pages/d69890/index.html",redirect:"/pages/d69890/"},{path:"/01.Java相关/10.基础/120.Java 中 sleep() 与 wait() 的区别 .html",redirect:"/pages/d69890/"},{name:"v-620ebadc",path:"/pages/2b00a3/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-620ebadc").then(t)}},{path:"/pages/2b00a3/index.html",redirect:"/pages/2b00a3/"},{path:"/01.Java相关/10.基础/130.简述 Java 中 final 关键字的作用.html",redirect:"/pages/2b00a3/"},{name:"v-5290507e",path:"/pages/73113f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5290507e").then(t)}},{path:"/pages/73113f/index.html",redirect:"/pages/73113f/"},{path:"/01.Java相关/10.基础/140.String 类能不能被继承？为什么？.html",redirect:"/pages/73113f/"},{name:"v-6f5c6512",path:"/pages/115772/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-6f5c6512").then(t)}},{path:"/pages/115772/index.html",redirect:"/pages/115772/"},{path:"/01.Java相关/10.基础/150.Java 缓冲流 buffer 的用途和原理是什么？.html",redirect:"/pages/115772/"},{name:"v-75844e97",path:"/pages/37dba4/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-75844e97").then(t)}},{path:"/pages/37dba4/index.html",redirect:"/pages/37dba4/"},{path:"/01.Java相关/10.基础/160.简述动态代理与静态代理 .html",redirect:"/pages/37dba4/"},{name:"v-1218fa85",path:"/pages/e9ce4e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-1218fa85").then(t)}},{path:"/pages/e9ce4e/index.html",redirect:"/pages/e9ce4e/"},{path:"/01.Java相关/10.基础/170.阻塞队列都有哪几种，有什么区别？.html",redirect:"/pages/e9ce4e/"},{name:"v-b21bbc4c",path:"/pages/75552c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-b21bbc4c").then(t)}},{path:"/pages/75552c/index.html",redirect:"/pages/75552c/"},{path:"/01.Java相关/10.基础/180.简述 HashSet 实现原理.html",redirect:"/pages/75552c/"},{name:"v-45fc1217",path:"/pages/0da4b0/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-45fc1217").then(t)}},{path:"/pages/0da4b0/index.html",redirect:"/pages/0da4b0/"},{path:"/01.Java相关/20.并发/001.线程池是如何实现的？.html",redirect:"/pages/0da4b0/"},{name:"v-5390e3d4",path:"/pages/3356c6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5390e3d4").then(t)}},{path:"/pages/3356c6/index.html",redirect:"/pages/3356c6/"},{path:"/01.Java相关/20.并发/020.简述 CAS 原理，什么是 ABA 问题，怎么解决？.html",redirect:"/pages/3356c6/"},{name:"v-352f36cc",path:"/pages/d5d161/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-352f36cc").then(t)}},{path:"/pages/d5d161/index.html",redirect:"/pages/d5d161/"},{path:"/01.Java相关/20.并发/040.Synchronized 关键字底层是如何实现的？.html",redirect:"/pages/d5d161/"},{name:"v-4927c049",path:"/pages/9b59d1/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-4927c049").then(t)}},{path:"/pages/9b59d1/index.html",redirect:"/pages/9b59d1/"},{path:"/01.Java相关/20.并发/050.重入锁是如何实现的？.html",redirect:"/pages/9b59d1/"},{name:"v-1065f7be",path:"/pages/ff0616/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-1065f7be").then(t)}},{path:"/pages/ff0616/index.html",redirect:"/pages/ff0616/"},{path:"/01.Java相关/20.并发/070.简述 Java 锁升级的机制.html",redirect:"/pages/ff0616/"},{name:"v-f5bcd180",path:"/pages/383264/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-f5bcd180").then(t)}},{path:"/pages/383264/index.html",redirect:"/pages/383264/"},{path:"/01.Java相关/20.并发/060.volatile 关键字解决了什么问题，它的实现原理是什么？.html",redirect:"/pages/383264/"},{name:"v-35324a50",path:"/pages/97245f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-35324a50").then(t)}},{path:"/pages/97245f/index.html",redirect:"/pages/97245f/"},{path:"/01.Java相关/20.并发/030.简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点.html",redirect:"/pages/97245f/"},{name:"v-134f28dc",path:"/pages/fd6a59/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-134f28dc").then(t)}},{path:"/pages/fd6a59/index.html",redirect:"/pages/fd6a59/"},{path:"/01.Java相关/20.并发/090.什么是公平锁？什么是非公平锁？.html",redirect:"/pages/fd6a59/"},{name:"v-03e420c4",path:"/pages/52483b/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-03e420c4").then(t)}},{path:"/pages/52483b/index.html",redirect:"/pages/52483b/"},{path:"/01.Java相关/20.并发/100.Java 的线程有哪些状态，转换关系是怎么样的？.html",redirect:"/pages/52483b/"},{name:"v-2dbdb772",path:"/pages/52a687/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-2dbdb772").then(t)}},{path:"/pages/52a687/index.html",redirect:"/pages/52a687/"},{path:"/01.Java相关/20.并发/080.简述 Java AQS 的原理以及使用场景.html",redirect:"/pages/52a687/"},{name:"v-9baaad8e",path:"/pages/13856f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-9baaad8e").then(t)}},{path:"/pages/13856f/index.html",redirect:"/pages/13856f/"},{path:"/01.Java相关/20.并发/120.为什么我们不能直接调用 run() 方法？.html",redirect:"/pages/13856f/"},{name:"v-625fbeda",path:"/pages/c1f760/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-625fbeda").then(t)}},{path:"/pages/c1f760/index.html",redirect:"/pages/c1f760/"},{path:"/01.Java相关/20.并发/110.Java 是如何实现线程安全的，哪些数据结构是线程安全的？.html",redirect:"/pages/c1f760/"},{name:"v-7b2a2ed4",path:"/pages/ce292c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7b2a2ed4").then(t)}},{path:"/pages/ce292c/index.html",redirect:"/pages/ce292c/"},{path:"/01.Java相关/20.并发/115.手写死锁.html",redirect:"/pages/ce292c/"},{name:"v-75c00225",path:"/pages/a6c84e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-75c00225").then(t)}},{path:"/pages/a6c84e/index.html",redirect:"/pages/a6c84e/"},{path:"/01.Java相关/20.并发/130.Java 线程有哪些常用方法？.html",redirect:"/pages/a6c84e/"},{name:"v-083aef82",path:"/pages/2b8c6e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-083aef82").then(t)}},{path:"/pages/2b8c6e/index.html",redirect:"/pages/2b8c6e/"},{path:"/01.Java相关/20.并发/140.手写生产者消费者模型.html",redirect:"/pages/2b8c6e/"},{name:"v-f406b4e6",path:"/pages/b3e720/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-f406b4e6").then(t)}},{path:"/pages/b3e720/index.html",redirect:"/pages/b3e720/"},{path:"/01.Java相关/20.并发/150.ThreadLocal 实现原理是什么？为什么要使用弱引用？.html",redirect:"/pages/b3e720/"},{name:"v-af821fc8",path:"/pages/9b26e8/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-af821fc8").then(t)}},{path:"/pages/9b26e8/index.html",redirect:"/pages/9b26e8/"},{path:"/01.Java相关/30.JVM/010.常见的 GC 回收算法有哪些？.html",redirect:"/pages/9b26e8/"},{name:"v-7cd97c82",path:"/pages/948850/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7cd97c82").then(t)}},{path:"/pages/948850/index.html",redirect:"/pages/948850/"},{path:"/01.Java相关/30.JVM/001.Java 中垃圾回收机制中如何判断对象需要回收？.html",redirect:"/pages/948850/"},{name:"v-5474bec0",path:"/pages/07a030/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5474bec0").then(t)}},{path:"/pages/07a030/index.html",redirect:"/pages/07a030/"},{path:"/01.Java相关/30.JVM/020.Java 中如何进行 GC 调优？.html",redirect:"/pages/07a030/"},{name:"v-0970cd54",path:"/pages/c8e6cb/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0970cd54").then(t)}},{path:"/pages/c8e6cb/index.html",redirect:"/pages/c8e6cb/"},{path:"/01.Java相关/30.JVM/030.JMM 中内存模型是怎样的？什么是指令序列重排序？.html",redirect:"/pages/c8e6cb/"},{name:"v-2de19204",path:"/pages/da65e7/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-2de19204").then(t)}},{path:"/pages/da65e7/index.html",redirect:"/pages/da65e7/"},{path:"/01.Java相关/30.JVM/040.JVM 内存是如何对应到操作系统内存的？.html",redirect:"/pages/da65e7/"},{name:"v-37fcb440",path:"/pages/d730dd/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-37fcb440").then(t)}},{path:"/pages/d730dd/index.html",redirect:"/pages/d730dd/"},{path:"/01.Java相关/30.JVM/050.JVM 是怎么去调优的？了解哪些参数和指令？.html",redirect:"/pages/d730dd/"},{name:"v-15fba8f1",path:"/pages/3ab5f5/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-15fba8f1").then(t)}},{path:"/pages/3ab5f5/index.html",redirect:"/pages/3ab5f5/"},{path:"/01.Java相关/30.JVM/060.什么是内存泄漏，怎么确定内存泄漏？.html",redirect:"/pages/3ab5f5/"},{name:"v-28c1d6d9",path:"/pages/be69af/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-28c1d6d9").then(t)}},{path:"/pages/be69af/index.html",redirect:"/pages/be69af/"},{path:"/01.Java相关/30.JVM/070.简述 CMS 与 G1 机制的区别.html",redirect:"/pages/be69af/"},{name:"v-ba94c306",path:"/pages/b37ad7/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-ba94c306").then(t)}},{path:"/pages/b37ad7/index.html",redirect:"/pages/b37ad7/"},{path:"/01.Java相关/40.设计模式/002.实现单例设计模式（懒汉，饿汉）.html",redirect:"/pages/b37ad7/"},{name:"v-88b087a6",path:"/pages/3d768c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-88b087a6").then(t)}},{path:"/pages/3d768c/index.html",redirect:"/pages/3d768c/"},{path:"/01.Java相关/40.设计模式/003.什么是设计模式 .html",redirect:"/pages/3d768c/"},{name:"v-2d6ed001",path:"/pages/f15489/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-2d6ed001").then(t)}},{path:"/pages/f15489/index.html",redirect:"/pages/f15489/"},{path:"/01.Java相关/40.设计模式/004.工厂模式使用场景 能举个例子吗.html",redirect:"/pages/f15489/"},{name:"v-22a9eaef",path:"/pages/47a4e3/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-22a9eaef").then(t)}},{path:"/pages/47a4e3/index.html",redirect:"/pages/47a4e3/"},{path:"/01.Java相关/40.设计模式/005.装饰者模式.html",redirect:"/pages/47a4e3/"},{name:"v-31509c80",path:"/pages/827fc4/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-31509c80").then(t)}},{path:"/pages/827fc4/index.html",redirect:"/pages/827fc4/"},{path:"/01.Java相关/40.设计模式/010.适配器模式.html",redirect:"/pages/827fc4/"},{name:"v-0564ba27",path:"/pages/dd3a6f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0564ba27").then(t)}},{path:"/pages/dd3a6f/index.html",redirect:"/pages/dd3a6f/"},{path:"/01.Java相关/40.设计模式/020.代理模式.html",redirect:"/pages/dd3a6f/"},{name:"v-34f8aaa2",path:"/pages/d3ff35/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-34f8aaa2").then(t)}},{path:"/pages/d3ff35/index.html",redirect:"/pages/d3ff35/"},{path:"/01.Java相关/40.设计模式/030.责任链模式.html",redirect:"/pages/d3ff35/"},{name:"v-28deb9da",path:"/pages/43b656/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-28deb9da").then(t)}},{path:"/pages/43b656/index.html",redirect:"/pages/43b656/"},{path:"/01.Java相关/40.设计模式/040.模板方法模式.html",redirect:"/pages/43b656/"},{name:"v-5b0157cf",path:"/pages/78c7aa/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5b0157cf").then(t)}},{path:"/pages/78c7aa/index.html",redirect:"/pages/78c7aa/"},{path:"/01.Java相关/40.设计模式/050.策略模式.html",redirect:"/pages/78c7aa/"},{name:"v-64f1031c",path:"/pages/cbff3c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-64f1031c").then(t)}},{path:"/pages/cbff3c/index.html",redirect:"/pages/cbff3c/"},{path:"/01.Java相关/40.设计模式/060.观察模式.html",redirect:"/pages/cbff3c/"},{name:"v-0a1d1fb4",path:"/pages/f33310/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0a1d1fb4").then(t)}},{path:"/pages/f33310/index.html",redirect:"/pages/f33310/"},{path:"/02.计算机基础/10.计算机网络/010.简述常见的 HTTP 状态码的含义.html",redirect:"/pages/f33310/"},{name:"v-470b2fce",path:"/pages/e00207/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-470b2fce").then(t)}},{path:"/pages/e00207/index.html",redirect:"/pages/e00207/"},{path:"/02.计算机基础/10.计算机网络/01.简述 TCP 三次握手以及四次挥手.html",redirect:"/pages/e00207/"},{name:"v-6602e3da",path:"/pages/ab48ba/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-6602e3da").then(t)}},{path:"/pages/ab48ba/index.html",redirect:"/pages/ab48ba/"},{path:"/02.计算机基础/10.计算机网络/020.从输入 URL 到展现页面的全过程.html",redirect:"/pages/ab48ba/"},{name:"v-12717373",path:"/pages/a0e400/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-12717373").then(t)}},{path:"/pages/a0e400/index.html",redirect:"/pages/a0e400/"},{path:"/02.计算机基础/10.计算机网络/030.HTTP 中 GET 和 POST 区别.html",redirect:"/pages/a0e400/"},{name:"v-5047727f",path:"/pages/5fcc49/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5047727f").then(t)}},{path:"/pages/5fcc49/index.html",redirect:"/pages/5fcc49/"},{path:"/02.计算机基础/10.计算机网络/040.TCP 怎么保证可靠传输.html",redirect:"/pages/5fcc49/"},{name:"v-feb79e02",path:"/pages/2822ac/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-feb79e02").then(t)}},{path:"/pages/2822ac/index.html",redirect:"/pages/2822ac/"},{path:"/02.计算机基础/10.计算机网络/050.什么是 TCP 粘包和拆包？.html",redirect:"/pages/2822ac/"},{name:"v-3890e0b4",path:"/pages/12c0cc/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-3890e0b4").then(t)}},{path:"/pages/12c0cc/index.html",redirect:"/pages/12c0cc/"},{path:"/02.计算机基础/10.计算机网络/060.简述 HTTPS 的加密与认证过程.html",redirect:"/pages/12c0cc/"},{name:"v-c0c0e5c8",path:"/pages/cc4b24/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-c0c0e5c8").then(t)}},{path:"/pages/cc4b24/index.html",redirect:"/pages/cc4b24/"},{path:"/02.计算机基础/10.计算机网络/080.TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？.html",redirect:"/pages/cc4b24/"},{name:"v-aa8887a4",path:"/pages/a656a9/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-aa8887a4").then(t)}},{path:"/pages/a656a9/index.html",redirect:"/pages/a656a9/"},{path:"/02.计算机基础/10.计算机网络/090.如何解决 TCP 传输丢包问题？.html",redirect:"/pages/a656a9/"},{name:"v-eb417bbe",path:"/pages/057092/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-eb417bbe").then(t)}},{path:"/pages/057092/index.html",redirect:"/pages/057092/"},{path:"/02.计算机基础/10.计算机网络/070.简述对称与非对称加密的概念.html",redirect:"/pages/057092/"},{name:"v-f886ba80",path:"/pages/dda19e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-f886ba80").then(t)}},{path:"/pages/dda19e/index.html",redirect:"/pages/dda19e/"},{path:"/02.计算机基础/10.计算机网络/100.TCP 长连接和短连接有那么不同的使用场景？.html",redirect:"/pages/dda19e/"},{name:"v-75f6731c",path:"/pages/9ccc31/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-75f6731c").then(t)}},{path:"/pages/9ccc31/index.html",redirect:"/pages/9ccc31/"},{path:"/02.计算机基础/10.计算机网络/130.TCP 中常见的拥塞控制算法有哪些？.html",redirect:"/pages/9ccc31/"},{name:"v-f8f98912",path:"/pages/f50b70/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-f8f98912").then(t)}},{path:"/pages/f50b70/index.html",redirect:"/pages/f50b70/"},{path:"/02.计算机基础/10.计算机网络/140.简述 HTTP 1.0，1.1，2.0 的主要区别 .html",redirect:"/pages/f50b70/"},{name:"v-9aa2c788",path:"/pages/253334/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-9aa2c788").then(t)}},{path:"/pages/253334/index.html",redirect:"/pages/253334/"},{path:"/02.计算机基础/10.计算机网络/120.HTTP 与 HTTPS 有哪些区别？.html",redirect:"/pages/253334/"},{name:"v-df71a6e0",path:"/pages/212438/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-df71a6e0").then(t)}},{path:"/pages/212438/index.html",redirect:"/pages/212438/"},{path:"/02.计算机基础/10.计算机网络/110.TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？.html",redirect:"/pages/212438/"},{name:"v-63453344",path:"/pages/e57cfe/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-63453344").then(t)}},{path:"/pages/e57cfe/index.html",redirect:"/pages/e57cfe/"},{path:"/02.计算机基础/10.计算机网络/150.从系统层面上，UDP如何保证尽量可靠？.html",redirect:"/pages/e57cfe/"},{name:"v-93120d3a",path:"/pages/15d37a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-93120d3a").then(t)}},{path:"/pages/15d37a/index.html",redirect:"/pages/15d37a/"},{path:"/02.计算机基础/10.计算机网络/160.TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？.html",redirect:"/pages/15d37a/"},{name:"v-3e902cd4",path:"/pages/dae451/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-3e902cd4").then(t)}},{path:"/pages/dae451/index.html",redirect:"/pages/dae451/"},{path:"/02.计算机基础/10.计算机网络/170.简述 TCP 滑动窗口.html",redirect:"/pages/dae451/"},{name:"v-74475c54",path:"/pages/34d064/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-74475c54").then(t)}},{path:"/pages/34d064/index.html",redirect:"/pages/34d064/"},{path:"/02.计算机基础/10.计算机网络/180.简述 JWT 的原理和校验机制.html",redirect:"/pages/34d064/"},{name:"v-730f9a6a",path:"/pages/6a2e50/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-730f9a6a").then(t)}},{path:"/pages/6a2e50/index.html",redirect:"/pages/6a2e50/"},{path:"/02.计算机基础/10.计算机网络/200.简述 iPv4 和 iPv6 的区别.html",redirect:"/pages/6a2e50/"},{name:"v-52edac80",path:"/pages/a219df/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-52edac80").then(t)}},{path:"/pages/a219df/index.html",redirect:"/pages/a219df/"},{path:"/02.计算机基础/10.计算机网络/171. 简述TCP重传机制.html",redirect:"/pages/a219df/"},{name:"v-0e7ed85a",path:"/pages/68d6c8/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0e7ed85a").then(t)}},{path:"/pages/68d6c8/index.html",redirect:"/pages/68d6c8/"},{path:"/02.计算机基础/10.计算机网络/190.为什么需要序列化？有什么序列化的方式？.html",redirect:"/pages/68d6c8/"},{name:"v-15fe5424",path:"/pages/d0c6d3/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-15fe5424").then(t)}},{path:"/pages/d0c6d3/index.html",redirect:"/pages/d0c6d3/"},{path:"/02.计算机基础/10.计算机网络/210.TCP 中 SYN 攻击是什么？如何防止？.html",redirect:"/pages/d0c6d3/"},{name:"v-01df2b5d",path:"/pages/665162/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-01df2b5d").then(t)}},{path:"/pages/665162/index.html",redirect:"/pages/665162/"},{path:"/02.计算机基础/10.计算机网络/230.什么是 ARP 协议？简述其使用场景.html",redirect:"/pages/665162/"},{name:"v-7370facf",path:"/pages/eadd05/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7370facf").then(t)}},{path:"/pages/eadd05/index.html",redirect:"/pages/eadd05/"},{path:"/02.计算机基础/10.计算机网络/240.什么是跨域，什么情况下会发生跨域请求？.html",redirect:"/pages/eadd05/"},{name:"v-7fc8ca51",path:"/pages/056828/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7fc8ca51").then(t)}},{path:"/pages/056828/index.html",redirect:"/pages/056828/"},{path:"/02.计算机基础/10.计算机网络/220.简述 DDOS 攻击原理，如何防范它？.html",redirect:"/pages/056828/"},{name:"v-15ca313a",path:"/pages/980cc7/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-15ca313a").then(t)}},{path:"/pages/980cc7/index.html",redirect:"/pages/980cc7/"},{path:"/02.计算机基础/10.计算机网络/250.Cookie 和 Session 的关系和区别是什么？.html",redirect:"/pages/980cc7/"},{name:"v-7707a260",path:"/pages/172129/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7707a260").then(t)}},{path:"/pages/172129/index.html",redirect:"/pages/172129/"},{path:"/02.计算机基础/10.计算机网络/260.简述 WebSocket 是如何进行传输的.html",redirect:"/pages/172129/"},{name:"v-a9abf6a0",path:"/pages/017113/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-a9abf6a0").then(t)}},{path:"/pages/017113/index.html",redirect:"/pages/017113/"},{path:"/02.计算机基础/10.计算机网络/270.DNS 查询服务器的基本流程是什么？DNS 劫持是什么？.html",redirect:"/pages/017113/"},{name:"v-693fb010",path:"/pages/c08bb6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-693fb010").then(t)}},{path:"/pages/c08bb6/index.html",redirect:"/pages/c08bb6/"},{path:"/02.计算机基础/10.计算机网络/280.RestFul 是什么？RestFul 请求的 URL 有什么特点？.html",redirect:"/pages/c08bb6/"},{name:"v-51f24219",path:"/pages/dfb780/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-51f24219").then(t)}},{path:"/pages/dfb780/index.html",redirect:"/pages/dfb780/"},{path:"/02.计算机基础/10.计算机网络/290.简述 HTTP 报文头部的组成结构.html",redirect:"/pages/dfb780/"},{name:"v-fe1405b0",path:"/pages/9e6232/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-fe1405b0").then(t)}},{path:"/pages/9e6232/index.html",redirect:"/pages/9e6232/"},{path:"/02.计算机基础/20.操作系统/010.简述自旋锁与互斥锁的使用场景.html",redirect:"/pages/9e6232/"},{name:"v-18f7a69e",path:"/pages/e5f2d7/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-18f7a69e").then(t)}},{path:"/pages/e5f2d7/index.html",redirect:"/pages/e5f2d7/"},{path:"/02.计算机基础/20.操作系统/01.进程间有哪些通信方式？.html",redirect:"/pages/e5f2d7/"},{name:"v-a0ab5810",path:"/pages/c2fd8a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-a0ab5810").then(t)}},{path:"/pages/c2fd8a/index.html",redirect:"/pages/c2fd8a/"},{path:"/02.计算机基础/20.操作系统/020.进程和线程之间有什么区别？.html",redirect:"/pages/c2fd8a/"},{name:"v-5a37154c",path:"/pages/68ea00/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5a37154c").then(t)}},{path:"/pages/68ea00/index.html",redirect:"/pages/68ea00/"},{path:"/02.计算机基础/20.操作系统/070.简述 select, poll, epoll 的使用场景以及区别.html",redirect:"/pages/68ea00/"},{name:"v-262f2c87",path:"/pages/165ea8/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-262f2c87").then(t)}},{path:"/pages/165ea8/index.html",redirect:"/pages/165ea8/"},{path:"/02.计算机基础/20.操作系统/060.进程有多少种状态？.html",redirect:"/pages/165ea8/"},{name:"v-05845816",path:"/pages/b043a6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-05845816").then(t)}},{path:"/pages/b043a6/index.html",redirect:"/pages/b043a6/"},{path:"/02.计算机基础/20.操作系统/080.Linux 下如何排查 CPU 以及 内存占用过多？.html",redirect:"/pages/b043a6/"},{name:"v-32c73af0",path:"/pages/198887/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-32c73af0").then(t)}},{path:"/pages/198887/index.html",redirect:"/pages/198887/"},{path:"/02.计算机基础/20.操作系统/030.简述几个常用的 Linux 命令以及他们的功能.html",redirect:"/pages/198887/"},{name:"v-303058be",path:"/pages/8e880a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-303058be").then(t)}},{path:"/pages/8e880a/index.html",redirect:"/pages/8e880a/"},{path:"/02.计算机基础/20.操作系统/090.进程通信中的管道实现原理是什么？.html",redirect:"/pages/8e880a/"},{name:"v-1f69ea23",path:"/pages/326cf9/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-1f69ea23").then(t)}},{path:"/pages/326cf9/index.html",redirect:"/pages/326cf9/"},{path:"/02.计算机基础/20.操作系统/100.Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？.html",redirect:"/pages/326cf9/"},{name:"v-f6bafd34",path:"/pages/3653a2/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-f6bafd34").then(t)}},{path:"/pages/3653a2/index.html",redirect:"/pages/3653a2/"},{path:"/02.计算机基础/20.操作系统/110.如何调试服务器内存占用过高的问题？.html",redirect:"/pages/3653a2/"},{name:"v-129dffb8",path:"/pages/f6e4d2/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-129dffb8").then(t)}},{path:"/pages/f6e4d2/index.html",redirect:"/pages/f6e4d2/"},{path:"/02.计算机基础/20.操作系统/120.Linux 如何查看实时的滚动日志？.html",redirect:"/pages/f6e4d2/"},{name:"v-c875c5a4",path:"/pages/773d64/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-c875c5a4").then(t)}},{path:"/pages/773d64/index.html",redirect:"/pages/773d64/"},{path:"/02.计算机基础/20.操作系统/140.为什么进程切换慢，线程切换快？.html",redirect:"/pages/773d64/"},{name:"v-7abb1115",path:"/pages/b43547/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7abb1115").then(t)}},{path:"/pages/b43547/index.html",redirect:"/pages/b43547/"},{path:"/02.计算机基础/20.操作系统/130.简述 Linux 零拷贝的原理.html",redirect:"/pages/b43547/"},{name:"v-1a49912a",path:"/pages/93b870/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-1a49912a").then(t)}},{path:"/pages/93b870/index.html",redirect:"/pages/93b870/"},{path:"/02.计算机基础/20.操作系统/160.简述 Linux 虚拟内存的页面置换算法.html",redirect:"/pages/93b870/"},{name:"v-63719191",path:"/pages/c64d20/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-63719191").then(t)}},{path:"/pages/c64d20/index.html",redirect:"/pages/c64d20/"},{path:"/02.计算机基础/20.操作系统/150.简述创建进程的流程.html",redirect:"/pages/c64d20/"},{name:"v-85af5b9e",path:"/pages/36fd29/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-85af5b9e").then(t)}},{path:"/pages/36fd29/index.html",redirect:"/pages/36fd29/"},{path:"/02.计算机基础/20.操作系统/170.简述 Linux 进程调度的算法.html",redirect:"/pages/36fd29/"},{name:"v-1ea2064a",path:"/pages/4c2d8e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-1ea2064a").then(t)}},{path:"/pages/4c2d8e/index.html",redirect:"/pages/4c2d8e/"},{path:"/02.计算机基础/20.操作系统/190.Linux 下如何查看端口被哪个进程占用？.html",redirect:"/pages/4c2d8e/"},{name:"v-8c3da672",path:"/pages/b84950/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-8c3da672").then(t)}},{path:"/pages/b84950/index.html",redirect:"/pages/b84950/"},{path:"/02.计算机基础/20.操作系统/180.什么时候会由用户态陷入内核态？.html",redirect:"/pages/b84950/"},{name:"v-db80e4da",path:"/pages/3bab8c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-db80e4da").then(t)}},{path:"/pages/3bab8c/index.html",redirect:"/pages/3bab8c/"},{path:"/02.计算机基础/20.操作系统/200.Linux 中虚拟内存和物理内存有什么区别？有什么优点？.html",redirect:"/pages/3bab8c/"},{name:"v-e048e838",path:"/pages/655f8f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-e048e838").then(t)}},{path:"/pages/655f8f/index.html",redirect:"/pages/655f8f/"},{path:"/02.计算机基础/20.操作系统/210.简述 traceroute 命令的原理.html",redirect:"/pages/655f8f/"},{name:"v-d41ba7ec",path:"/pages/782c23/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-d41ba7ec").then(t)}},{path:"/pages/782c23/index.html",redirect:"/pages/782c23/"},{path:"/02.计算机基础/20.操作系统/220.简述IO模型.html",redirect:"/pages/782c23/"},{name:"v-0c4b3c8a",path:"/pages/a25c3a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0c4b3c8a").then(t)}},{path:"/pages/a25c3a/index.html",redirect:"/pages/a25c3a/"},{path:"/02.计算机基础/30.数据结构/01.数组.html",redirect:"/pages/a25c3a/"},{name:"v-a380136c",path:"/pages/c29bff/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-a380136c").then(t)}},{path:"/pages/c29bff/index.html",redirect:"/pages/c29bff/"},{path:"/02.计算机基础/30.数据结构/30.树.html",redirect:"/pages/c29bff/"},{name:"v-e66c56a0",path:"/pages/308e3b/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-e66c56a0").then(t)}},{path:"/pages/308e3b/index.html",redirect:"/pages/308e3b/"},{path:"/02.计算机基础/30.数据结构/20.队列.html",redirect:"/pages/308e3b/"},{name:"v-7193df75",path:"/pages/f376bd/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7193df75").then(t)}},{path:"/pages/f376bd/index.html",redirect:"/pages/f376bd/"},{path:"/02.计算机基础/30.数据结构/02.链表.html",redirect:"/pages/f376bd/"},{name:"v-8228d7f2",path:"/pages/83330c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-8228d7f2").then(t)}},{path:"/pages/83330c/index.html",redirect:"/pages/83330c/"},{path:"/02.计算机基础/30.数据结构/40.图.html",redirect:"/pages/83330c/"},{name:"v-774fbc7c",path:"/pages/92288a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-774fbc7c").then(t)}},{path:"/pages/92288a/index.html",redirect:"/pages/92288a/"},{path:"/02.计算机基础/40.算法/01.递归.html",redirect:"/pages/92288a/"},{name:"v-2680fed9",path:"/pages/f27af6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-2680fed9").then(t)}},{path:"/pages/f27af6/index.html",redirect:"/pages/f27af6/"},{path:"/02.计算机基础/30.数据结构/10.栈.html",redirect:"/pages/f27af6/"},{name:"v-e8b2cf00",path:"/pages/6db356/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-e8b2cf00").then(t)}},{path:"/pages/6db356/index.html",redirect:"/pages/6db356/"},{path:"/02.计算机基础/30.数据结构/50堆.html",redirect:"/pages/6db356/"},{name:"v-016a9bfe",path:"/pages/fd9be6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-016a9bfe").then(t)}},{path:"/pages/fd9be6/index.html",redirect:"/pages/fd9be6/"},{path:"/02.计算机基础/40.算法/10.时间复杂度.html",redirect:"/pages/fd9be6/"},{name:"v-57b9b0cf",path:"/pages/3205b9/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-57b9b0cf").then(t)}},{path:"/pages/3205b9/index.html",redirect:"/pages/3205b9/"},{path:"/02.计算机基础/40.算法/20.排序.html",redirect:"/pages/3205b9/"},{name:"v-13949e6a",path:"/pages/e53094/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-13949e6a").then(t)}},{path:"/pages/e53094/index.html",redirect:"/pages/e53094/"},{path:"/02.计算机基础/40.算法/30.二分查找.html",redirect:"/pages/e53094/"},{name:"v-a406533a",path:"/pages/30153a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-a406533a").then(t)}},{path:"/pages/30153a/index.html",redirect:"/pages/30153a/"},{path:"/02.计算机基础/40.算法/40.双指针.html",redirect:"/pages/30153a/"},{name:"v-3bb878ba",path:"/pages/5fd35f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-3bb878ba").then(t)}},{path:"/pages/5fd35f/index.html",redirect:"/pages/5fd35f/"},{path:"/02.计算机基础/50.剑指Offer题解/01.数组与矩阵.html",redirect:"/pages/5fd35f/"},{name:"v-5c643de7",path:"/pages/8d145e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5c643de7").then(t)}},{path:"/pages/8d145e/index.html",redirect:"/pages/8d145e/"},{path:"/02.计算机基础/50.剑指Offer题解/05.栈队列堆.html",redirect:"/pages/8d145e/"},{name:"v-24153295",path:"/pages/4b7917/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-24153295").then(t)}},{path:"/pages/4b7917/index.html",redirect:"/pages/4b7917/"},{path:"/02.计算机基础/50.剑指Offer题解/06.双指针.html",redirect:"/pages/4b7917/"},{name:"v-ca8a5a42",path:"/pages/f55bff/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-ca8a5a42").then(t)}},{path:"/pages/f55bff/index.html",redirect:"/pages/f55bff/"},{path:"/02.计算机基础/50.剑指Offer题解/10.链表.html",redirect:"/pages/f55bff/"},{name:"v-ccd01cc4",path:"/pages/873a10/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-ccd01cc4").then(t)}},{path:"/pages/873a10/index.html",redirect:"/pages/873a10/"},{path:"/02.计算机基础/50.剑指Offer题解/15.树.html",redirect:"/pages/873a10/"},{name:"v-1fc84936",path:"/pages/b54770/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-1fc84936").then(t)}},{path:"/pages/b54770/index.html",redirect:"/pages/b54770/"},{path:"/02.计算机基础/50.剑指Offer题解/20.贪心.html",redirect:"/pages/b54770/"},{name:"v-13bddd54",path:"/pages/87a843/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-13bddd54").then(t)}},{path:"/pages/87a843/index.html",redirect:"/pages/87a843/"},{path:"/02.计算机基础/50.剑指Offer题解/25.分治.html",redirect:"/pages/87a843/"},{name:"v-c85da526",path:"/pages/d3dd7b/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-c85da526").then(t)}},{path:"/pages/d3dd7b/index.html",redirect:"/pages/d3dd7b/"},{path:"/02.计算机基础/50.剑指Offer题解/30.排序.html",redirect:"/pages/d3dd7b/"},{name:"v-311026d5",path:"/pages/6546a2/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-311026d5").then(t)}},{path:"/pages/6546a2/index.html",redirect:"/pages/6546a2/"},{path:"/02.计算机基础/50.剑指Offer题解/35.动态规划.html",redirect:"/pages/6546a2/"},{name:"v-25d809ae",path:"/pages/9c176f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-25d809ae").then(t)}},{path:"/pages/9c176f/index.html",redirect:"/pages/9c176f/"},{path:"/02.计算机基础/50.剑指Offer题解/40.数学.html",redirect:"/pages/9c176f/"},{name:"v-f0f711c4",path:"/pages/a5adb0/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-f0f711c4").then(t)}},{path:"/pages/a5adb0/index.html",redirect:"/pages/a5adb0/"},{path:"/03.数据库/01.MYSQL相关/006.聚簇索引和非聚簇索引有什么区别？.html",redirect:"/pages/a5adb0/"},{name:"v-824b776c",path:"/pages/17b014/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-824b776c").then(t)}},{path:"/pages/17b014/index.html",redirect:"/pages/17b014/"},{path:"/03.数据库/01.MYSQL相关/007.简述 MySQL 常见索引类型，介绍一下覆盖索引.html",redirect:"/pages/17b014/"},{name:"v-674454ac",path:"/pages/3a8659/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-674454ac").then(t)}},{path:"/pages/3a8659/index.html",redirect:"/pages/3a8659/"},{path:"/03.数据库/01.MYSQL相关/001.MySQL中 InnoDB 和 MylSAM 的区别是什么？.html",redirect:"/pages/3a8659/"},{name:"v-6c681639",path:"/pages/bc5538/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-6c681639").then(t)}},{path:"/pages/bc5538/index.html",redirect:"/pages/bc5538/"},{path:"/03.数据库/01.MYSQL相关/020.MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么.html",redirect:"/pages/bc5538/"},{name:"v-7e02c4a1",path:"/pages/9f2936/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7e02c4a1").then(t)}},{path:"/pages/9f2936/index.html",redirect:"/pages/9f2936/"},{path:"/03.数据库/01.MYSQL相关/010.简述Mysql的事务隔离级别.html",redirect:"/pages/9f2936/"},{name:"v-5b0e09c6",path:"/pages/b17e88/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5b0e09c6").then(t)}},{path:"/pages/b17e88/index.html",redirect:"/pages/b17e88/"},{path:"/03.数据库/01.MYSQL相关/015.说一下Mysql锁.html",redirect:"/pages/b17e88/"},{name:"v-c39c4fe2",path:"/pages/57561d/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-c39c4fe2").then(t)}},{path:"/pages/57561d/index.html",redirect:"/pages/57561d/"},{path:"/03.数据库/01.MYSQL相关/030.简述乐观锁以及悲观锁的区别以及使用场景.html",redirect:"/pages/57561d/"},{name:"v-4ecddbec",path:"/pages/7a1f1e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-4ecddbec").then(t)}},{path:"/pages/7a1f1e/index.html",redirect:"/pages/7a1f1e/"},{path:"/03.数据库/01.MYSQL相关/050.简述什么是最左匹配原则.html",redirect:"/pages/7a1f1e/"},{name:"v-689e142a",path:"/pages/36672c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-689e142a").then(t)}},{path:"/pages/36672c/index.html",redirect:"/pages/36672c/"},{path:"/03.数据库/01.MYSQL相关/040.简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？.html",redirect:"/pages/36672c/"},{name:"v-505fbe2e",path:"/pages/52773a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-505fbe2e").then(t)}},{path:"/pages/52773a/index.html",redirect:"/pages/52773a/"},{path:"/03.数据库/01.MYSQL相关/060.MySQL 联合索引底层原理是什么？.html",redirect:"/pages/52773a/"},{name:"v-0dd47f09",path:"/pages/f4cf50/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0dd47f09").then(t)}},{path:"/pages/f4cf50/index.html",redirect:"/pages/f4cf50/"},{path:"/03.数据库/01.MYSQL相关/070.产生死锁的必要条件有哪些？如何解决死锁？.html",redirect:"/pages/f4cf50/"},{name:"v-53bcbb7a",path:"/pages/f2dbbe/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-53bcbb7a").then(t)}},{path:"/pages/f2dbbe/index.html",redirect:"/pages/f2dbbe/"},{path:"/03.数据库/01.MYSQL相关/080.简述常见的负载均衡算法.html",redirect:"/pages/f2dbbe/"},{name:"v-c383b96e",path:"/pages/1ac30e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-c383b96e").then(t)}},{path:"/pages/1ac30e/index.html",redirect:"/pages/1ac30e/"},{path:"/03.数据库/01.MYSQL相关/090.简述 MySQL 的主从同步机制，如果同步失败会怎么样？.html",redirect:"/pages/1ac30e/"},{name:"v-4cef944a",path:"/pages/a8eb47/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-4cef944a").then(t)}},{path:"/pages/a8eb47/index.html",redirect:"/pages/a8eb47/"},{path:"/03.数据库/01.MYSQL相关/100.如何设计数据库压测方案？.html",redirect:"/pages/a8eb47/"},{name:"v-ed0c93b8",path:"/pages/ac0bb8/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-ed0c93b8").then(t)}},{path:"/pages/ac0bb8/index.html",redirect:"/pages/ac0bb8/"},{path:"/03.数据库/01.MYSQL相关/110.简述数据库中什么情况下进行分库，什么情况下进行分表？.html",redirect:"/pages/ac0bb8/"},{name:"v-f3acaa1a",path:"/pages/7bbbf6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-f3acaa1a").then(t)}},{path:"/pages/7bbbf6/index.html",redirect:"/pages/7bbbf6/"},{path:"/03.数据库/01.MYSQL相关/130.简述 undo log 和 redo log 的作用.html",redirect:"/pages/7bbbf6/"},{name:"v-d6bc240a",path:"/pages/f62359/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-d6bc240a").then(t)}},{path:"/pages/f62359/index.html",redirect:"/pages/f62359/"},{path:"/03.数据库/01.MYSQL相关/120.数据库的读写分离的作用是什么？如何实现？.html",redirect:"/pages/f62359/"},{name:"v-ceed6ba6",path:"/pages/b4338e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-ceed6ba6").then(t)}},{path:"/pages/b4338e/index.html",redirect:"/pages/b4338e/"},{path:"/03.数据库/01.MYSQL相关/140.什么是 SQL 注入攻击？如何防止这类攻击？.html",redirect:"/pages/b4338e/"},{name:"v-77790024",path:"/pages/429100/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-77790024").then(t)}},{path:"/pages/429100/index.html",redirect:"/pages/429100/"},{path:"/03.数据库/01.MYSQL相关/150.MySQL 中 join 与 left join 的区别是什么？.html",redirect:"/pages/429100/"},{name:"v-76f5e79a",path:"/pages/1656d8/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-76f5e79a").then(t)}},{path:"/pages/1656d8/index.html",redirect:"/pages/1656d8/"},{path:"/03.数据库/01.MYSQL相关/160.简述 MySQL MVCC 的实现原理 .html",redirect:"/pages/1656d8/"},{name:"v-0a7e6416",path:"/pages/d97948/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0a7e6416").then(t)}},{path:"/pages/d97948/index.html",redirect:"/pages/d97948/"},{path:"/03.数据库/01.MYSQL相关/170.MySQL 中 varchar 和 char 的区别是什么？.html",redirect:"/pages/d97948/"},{name:"v-6b967a6e",path:"/pages/32696d/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-6b967a6e").then(t)}},{path:"/pages/32696d/index.html",redirect:"/pages/32696d/"},{path:"/03.数据库/01.MYSQL相关/180.模糊查询是如何实现的？.html",redirect:"/pages/32696d/"},{name:"v-d804fba0",path:"/pages/d70c1f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-d804fba0").then(t)}},{path:"/pages/d70c1f/index.html",redirect:"/pages/d70c1f/"},{path:"/03.数据库/02.REDIS相关/001.Redis 有几种数据结构？Zset 是如何实现的？.html",redirect:"/pages/d70c1f/"},{name:"v-cb742458",path:"/pages/d66211/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-cb742458").then(t)}},{path:"/pages/d66211/index.html",redirect:"/pages/d66211/"},{path:"/03.数据库/02.REDIS相关/002.为什么 Redis 在单线程下能如此快？.html",redirect:"/pages/d66211/"},{name:"v-3e917471",path:"/pages/34aec2/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-3e917471").then(t)}},{path:"/pages/34aec2/index.html",redirect:"/pages/34aec2/"},{path:"/03.数据库/02.REDIS相关/005.简述 Redis 字符串的底层结构.html",redirect:"/pages/34aec2/"},{name:"v-2c6b511c",path:"/pages/656f46/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-2c6b511c").then(t)}},{path:"/pages/656f46/index.html",redirect:"/pages/656f46/"},{path:"/03.数据库/02.REDIS相关/030.Redis 如何实现分布式锁？.html",redirect:"/pages/656f46/"},{name:"v-3d2fdd6a",path:"/pages/338e30/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-3d2fdd6a").then(t)}},{path:"/pages/338e30/index.html",redirect:"/pages/338e30/"},{path:"/03.数据库/02.REDIS相关/040.简述 Redis 集群配置以及基础原理.html",redirect:"/pages/338e30/"},{name:"v-18b427a0",path:"/pages/a42826/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-18b427a0").then(t)}},{path:"/pages/a42826/index.html",redirect:"/pages/a42826/"},{path:"/03.数据库/02.REDIS相关/050.简述 Redis 中跳表的应用以及优缺点.html",redirect:"/pages/a42826/"},{name:"v-c0bc7b7a",path:"/pages/9326cc/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-c0bc7b7a").then(t)}},{path:"/pages/9326cc/index.html",redirect:"/pages/9326cc/"},{path:"/03.数据库/02.REDIS相关/010.Redis的缓存淘汰策略有哪些？.html",redirect:"/pages/9326cc/"},{name:"v-7c214d00",path:"/pages/7e708d/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7c214d00").then(t)}},{path:"/pages/7e708d/index.html",redirect:"/pages/7e708d/"},{path:"/03.数据库/02.REDIS相关/020.简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点.html",redirect:"/pages/7e708d/"},{name:"v-c2fe5e1a",path:"/pages/03cd25/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-c2fe5e1a").then(t)}},{path:"/pages/03cd25/index.html",redirect:"/pages/03cd25/"},{path:"/03.数据库/02.REDIS相关/070.简述 Redis 中如何防止缓存雪崩和缓存击穿.html",redirect:"/pages/03cd25/"},{name:"v-35718f4e",path:"/pages/9c28c9/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-35718f4e").then(t)}},{path:"/pages/9c28c9/index.html",redirect:"/pages/9c28c9/"},{path:"/03.数据库/02.REDIS相关/080.简述 Redis 的线程模型以及底层架构设计.html",redirect:"/pages/9c28c9/"},{name:"v-6a45f68d",path:"/pages/e2e910/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-6a45f68d").then(t)}},{path:"/pages/e2e910/index.html",redirect:"/pages/e2e910/"},{path:"/03.数据库/02.REDIS相关/060.Redis 中，sentinel 和 cluster 的区别和适用场景是什么？.html",redirect:"/pages/e2e910/"},{name:"v-57957421",path:"/pages/cc8507/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-57957421").then(t)}},{path:"/pages/cc8507/index.html",redirect:"/pages/cc8507/"},{path:"/03.数据库/02.REDIS相关/100.简述 Redis 的哨兵机制.html",redirect:"/pages/cc8507/"},{name:"v-37f158ba",path:"/pages/795c09/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-37f158ba").then(t)}},{path:"/pages/795c09/index.html",redirect:"/pages/795c09/"},{path:"/03.数据库/02.REDIS相关/110.简述 Redis 如何处理热点 key 访问.html",redirect:"/pages/795c09/"},{name:"v-02ea33c3",path:"/pages/0d3c6b/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-02ea33c3").then(t)}},{path:"/pages/0d3c6b/index.html",redirect:"/pages/0d3c6b/"},{path:"/03.数据库/02.REDIS相关/120.Redis 序列化有哪些方式？.html",redirect:"/pages/0d3c6b/"},{name:"v-be02b3c0",path:"/pages/40f3c9/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-be02b3c0").then(t)}},{path:"/pages/40f3c9/index.html",redirect:"/pages/40f3c9/"},{path:"/04.中间件/10.Netty/001.你熟悉哪些IO模型？.html",redirect:"/pages/40f3c9/"},{name:"v-5acdab4d",path:"/pages/3db019/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5acdab4d").then(t)}},{path:"/pages/3db019/index.html",redirect:"/pages/3db019/"},{path:"/04.中间件/10.Netty/010.TCP粘包拆包问题的解决之道.html",redirect:"/pages/3db019/"},{name:"v-073f22cd",path:"/pages/59089d/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-073f22cd").then(t)}},{path:"/pages/59089d/index.html",redirect:"/pages/59089d/"},{path:"/04.中间件/10.Netty/015.Netty中有哪些解码器？.html",redirect:"/pages/59089d/"},{name:"v-5157927c",path:"/pages/f851b6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5157927c").then(t)}},{path:"/pages/f851b6/index.html",redirect:"/pages/f851b6/"},{path:"/04.中间件/10.Netty/030.ChannelPipeline和ChannelHandler.html",redirect:"/pages/f851b6/"},{name:"v-62f3fa3e",path:"/pages/e7aa60/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-62f3fa3e").then(t)}},{path:"/pages/e7aa60/index.html",redirect:"/pages/e7aa60/"},{path:"/04.中间件/10.Netty/040.EventLoop和EventLoopGroup.html",redirect:"/pages/e7aa60/"},{name:"v-bbcf6e5a",path:"/pages/ef17ee/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-bbcf6e5a").then(t)}},{path:"/pages/ef17ee/index.html",redirect:"/pages/ef17ee/"},{path:"/04.中间件/10.Netty/020.为什么Netty要自己写一个ByteBuf.html",redirect:"/pages/ef17ee/"},{name:"v-6b32ada0",path:"/pages/bfdcc8/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-6b32ada0").then(t)}},{path:"/pages/bfdcc8/index.html",redirect:"/pages/bfdcc8/"},{path:"/04.中间件/10.Netty/050.Java NIO了解吗？.html",redirect:"/pages/bfdcc8/"},{name:"v-7c0136cf",path:"/pages/fe7ca2/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7c0136cf").then(t)}},{path:"/pages/fe7ca2/index.html",redirect:"/pages/fe7ca2/"},{path:"/04.中间件/40.Kafka/010.生产者.html",redirect:"/pages/fe7ca2/"},{name:"v-0df39df8",path:"/pages/561f34/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0df39df8").then(t)}},{path:"/pages/561f34/index.html",redirect:"/pages/561f34/"},{path:"/04.中间件/40.Kafka/001.Kafka包含那几部分.html",redirect:"/pages/561f34/"},{name:"v-04af9e42",path:"/pages/fed167/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-04af9e42").then(t)}},{path:"/pages/fed167/index.html",redirect:"/pages/fed167/"},{path:"/04.中间件/40.Kafka/020.消费者.html",redirect:"/pages/fed167/"},{name:"v-0c440466",path:"/pages/8d1d04/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-0c440466").then(t)}},{path:"/pages/8d1d04/index.html",redirect:"/pages/8d1d04/"},{path:"/04.中间件/40.Kafka/030.集群下的Kafka要考虑哪些事情.html",redirect:"/pages/8d1d04/"},{name:"v-a9558ec0",path:"/pages/01b9b2/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-a9558ec0").then(t)}},{path:"/pages/01b9b2/index.html",redirect:"/pages/01b9b2/"},{path:"/08.系统设计/001.系统设计.html",redirect:"/pages/01b9b2/"},{name:"v-684c4815",path:"/pages/76a94c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-684c4815").then(t)}},{path:"/pages/76a94c/index.html",redirect:"/pages/76a94c/"},{path:"/04.中间件/40.Kafka/040.如何保证Kafka的可靠性.html",redirect:"/pages/76a94c/"},{name:"v-164d9a94",path:"/pages/379160/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-164d9a94").then(t)}},{path:"/pages/379160/index.html",redirect:"/pages/379160/"},{path:"/08.系统设计/005.电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？.html",redirect:"/pages/379160/"},{name:"v-00fb6429",path:"/pages/ac945d/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-00fb6429").then(t)}},{path:"/pages/ac945d/index.html",redirect:"/pages/ac945d/"},{path:"/08.系统设计/006.如何解决缓存与数据库不一致的问题？.html",redirect:"/pages/ac945d/"},{name:"v-5675b06b",path:"/pages/20c647/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5675b06b").then(t)}},{path:"/pages/20c647/index.html",redirect:"/pages/20c647/"},{path:"/08.系统设计/010.什么是 CAP ？什么是最终一致性？什么是幂等操作？.html",redirect:"/pages/20c647/"},{name:"v-1d6b51b7",path:"/pages/7c8753/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-1d6b51b7").then(t)}},{path:"/pages/7c8753/index.html",redirect:"/pages/7c8753/"},{path:"/08.系统设计/021.设计 Tiny URL 系统.html",redirect:"/pages/7c8753/"},{name:"v-f88544f4",path:"/pages/4eae5b/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-f88544f4").then(t)}},{path:"/pages/4eae5b/index.html",redirect:"/pages/4eae5b/"},{path:"/08.系统设计/020.简述什么是两阶段提交？.html",redirect:"/pages/4eae5b/"},{name:"v-dca272ea",path:"/pages/e5252b/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-dca272ea").then(t)}},{path:"/pages/e5252b/index.html",redirect:"/pages/e5252b/"},{path:"/08.系统设计/022.如何实现唯一的分布式 ID.html",redirect:"/pages/e5252b/"},{name:"v-5afa53ed",path:"/pages/bb7e83/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5afa53ed").then(t)}},{path:"/pages/bb7e83/index.html",redirect:"/pages/bb7e83/"},{path:"/08.系统设计/024.电商-商品系统设计.html",redirect:"/pages/bb7e83/"},{name:"v-2a52a762",path:"/pages/5e507a/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-2a52a762").then(t)}},{path:"/pages/5e507a/index.html",redirect:"/pages/5e507a/"},{path:"/10.非技术/01.非技术问题.html",redirect:"/pages/5e507a/"},{name:"v-00dfea7c",path:"/pages/d01475/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-00dfea7c").then(t)}},{path:"/pages/d01475/index.html",redirect:"/pages/d01475/"},{path:"/08.系统设计/023.如何设计定时任务系统.html",redirect:"/pages/d01475/"},{name:"v-70bb01cc",path:"/pages/c7084e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-70bb01cc").then(t)}},{path:"/pages/c7084e/index.html",redirect:"/pages/c7084e/"},{path:"/10.非技术/04.如何提升技术水平？.html",redirect:"/pages/c7084e/"},{name:"v-534e5ed0",path:"/pages/83653c/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-534e5ed0").then(t)}},{path:"/pages/83653c/index.html",redirect:"/pages/83653c/"},{path:"/10.非技术/05.上级让下级干活的4中方式.html",redirect:"/pages/83653c/"},{name:"v-bd4d3ab8",path:"/pages/ea7ab6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-bd4d3ab8").then(t)}},{path:"/pages/ea7ab6/index.html",redirect:"/pages/ea7ab6/"},{path:"/10.非技术/06.正确认识Backup.html",redirect:"/pages/ea7ab6/"},{name:"v-37ecc426",path:"/pages/fe4651/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-37ecc426").then(t)}},{path:"/pages/fe4651/index.html",redirect:"/pages/fe4651/"},{path:"/10.非技术/03.能力差的人是什么样的？.html",redirect:"/pages/fe4651/"},{name:"v-1130f268",path:"/pages/a734ce/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-1130f268").then(t)}},{path:"/pages/a734ce/index.html",redirect:"/pages/a734ce/"},{path:"/10.非技术/02.关于空降兵的思考.html",redirect:"/pages/a734ce/"},{name:"v-6bbf2d35",path:"/pages/74395b/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-6bbf2d35").then(t)}},{path:"/pages/74395b/index.html",redirect:"/pages/74395b/"},{path:"/10.非技术/07.对事不对人 vs 对人不对事.html",redirect:"/pages/74395b/"},{name:"v-918dfaf8",path:"/about/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-918dfaf8").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/15.关于/01.关于.html",redirect:"/about/"},{name:"v-286c1812",path:"/pages/6ac68e/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-286c1812").then(t)}},{path:"/pages/6ac68e/index.html",redirect:"/pages/6ac68e/"},{path:"/10.非技术/08.关于如何写OKR.html",redirect:"/pages/6ac68e/"},{name:"v-7ab50b9f",path:"/pages/beb6c0bd8a66cea6/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7ab50b9f").then(t)}},{path:"/pages/beb6c0bd8a66cea6/index.html",redirect:"/pages/beb6c0bd8a66cea6/"},{path:"/@pages/20.收藏夹/01.网站.html",redirect:"/pages/beb6c0bd8a66cea6/"},{name:"v-09c150e6",path:"/pages/47cf96/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-09c150e6").then(t)}},{path:"/pages/47cf96/index.html",redirect:"/pages/47cf96/"},{path:"/@pages/20.收藏夹/02.常用的前端轮子.html",redirect:"/pages/47cf96/"},{name:"v-2db11cb2",path:"/pages/f2e63f/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-2db11cb2").then(t)}},{path:"/pages/f2e63f/index.html",redirect:"/pages/f2e63f/"},{path:"/_posts/随笔/你知道的越多，不知道的也就越多.html",redirect:"/pages/f2e63f/"},{name:"v-a5c5f278",path:"/pages/829589/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-a5c5f278").then(t)}},{path:"/pages/829589/index.html",redirect:"/pages/829589/"},{path:"/_posts/随笔/我做了一个手写春联小网页，祝大家虎年暴富.html",redirect:"/pages/829589/"},{name:"v-7d77d69c",path:"/pages/cd8bde/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-7d77d69c").then(t)}},{path:"/pages/cd8bde/index.html",redirect:"/pages/cd8bde/"},{path:"/_posts/随笔/拥抱生活，拥抱快乐.html",redirect:"/pages/cd8bde/"},{name:"v-48f7eec0",path:"/archives/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-48f7eec0").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-5f8dfe80",path:"/categories/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-5f8dfe80").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-64f9b920",path:"/tags/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-64f9b920").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-2cf94a0e",path:"/",component:is,beforeEnter:function(n,e,t){Vo("Layout","v-2cf94a0e").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:is}],ls={title:"",description:"",base:"/JavaDriver/",headTags:[["link",{rel:"icon",href:"/JavaDriver/img/JAVADRIVER.png"}],["meta",{name:"keywords",content:"Java相关技术"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"Java相关",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.Java相关",imgUrl:"/img/web.png",description:"Java基础、JVM、并发、设计模式"}},title:"Java相关",date:"2020-03-11T21:50:53.000Z",permalink:"/java",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.Java%E7%9B%B8%E5%85%B3.html",relativePath:"00.目录页/01.Java相关.md",key:"v-36edf5bb",path:"/java/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"中间件",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.中间件",imgUrl:"/img/more.png",description:"Dubbo、Mybatis"}},title:"中间件",date:"2020-03-11T21:50:56.000Z",permalink:"/middleware",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E4%B8%AD%E9%97%B4%E4%BB%B6.html",relativePath:"00.目录页/04.中间件.md",key:"v-7abe58c4",path:"/middleware/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"计算机基础",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.计算机基础",imgUrl:"/img/ui.png",description:"计算机网络、数据结构、"}},title:"计算机基础",date:"2020-03-11T21:50:54.000Z",permalink:"/basic",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html",relativePath:"00.目录页/02.计算机基础.md",key:"v-10f5d0e5",path:"/basic/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"数据库",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.数据库",imgUrl:"/img/other.png",description:"Mysql、Redis"}},title:"数据库",date:"2020-03-11T21:50:55.000Z",permalink:"/database",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%95%B0%E6%8D%AE%E5%BA%93.html",relativePath:"00.目录页/03.数据库.md",key:"v-a612ff08",path:"/database/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Java 异常有哪些类型？",frontmatter:{title:"Java 异常有哪些类型？",date:"2022-03-11T00:42:02.000Z",permalink:"/pages/a030ff/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/001.Java%20%E5%BC%82%E5%B8%B8%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/001.Java 异常有哪些类型？.md",key:"v-8bf153e4",path:"/pages/a030ff/",headers:[{level:2,title:"Java 异常有哪些类型？",slug:"java-异常有哪些类型",normalizedTitle:"java 异常有哪些类型？",charIndex:2}],headersStr:"Java 异常有哪些类型？",content:"# Java 异常有哪些类型？\n\n\n\n图片来自：https://chercher.tech/java-programming/exceptions-java\n\n\n\n * 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。\n * Exception 能被程序本身处理(try-catch)， Error 是无法处理的(只能尽量避免)。\n * Exception有区分checked、unchecked异常，其中checked类型的异常强制处理（try-catch或者throw）",normalizedContent:"# java 异常有哪些类型？\n\n\n\n图片来自：https://chercher.tech/java-programming/exceptions-java\n\n\n\n * 在 java 中，所有的异常都有一个共同的祖先 java.lang 包中的 throwable 类。\n * exception 能被程序本身处理(try-catch)， error 是无法处理的(只能尽量避免)。\n * exception有区分checked、unchecked异常，其中checked类型的异常强制处理（try-catch或者throw）",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"HashMap 与 ConcurrentHashMap 的实现原理是怎样的？",frontmatter:{title:"HashMap 与 ConcurrentHashMap 的实现原理是怎样的？",date:"2022-04-04T14:21:18.000Z",permalink:"/pages/d1c564/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/010.HashMap%20%E4%B8%8E%20ConcurrentHashMap%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/010.HashMap 与 ConcurrentHashMap 的实现原理是怎样的？.md",key:"v-0734374b",path:"/pages/d1c564/",headers:[{level:2,title:"HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？",slug:"hashmap-与-concurrenthashmap-的实现原理是怎样的-concurrenthashmap-是如何保证线程安全的",normalizedTitle:"hashmap 与 concurrenthashmap 的实现原理是怎样的？concurrenthashmap 是如何保证线程安全的？",charIndex:2}],headersStr:"HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？",content:"# HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？\n\n                 HASHMAP     CONCURRENTHASHMAP\n是否线程安全           不安全         安全\nJDK1.7-数据结构      数组+链表       数组+链表+Segment\nJDK1.7-数据结构-图示               \n锁粒度              ---         对segment加锁，最大并发修改线程数=segment数量\n---              ---         ---\nJDK1.8-数据结构      数组+链表+红黑树   数组+链表+红黑树\nJDK1.8-数据结构-图示               \n锁粒度              ---         HashEntry（首节点），最大并发修改线程数=数组.size\n\n> Q1：ConcurrentHashMap 中变量使用 final 和 volatile 修饰有什么用呢？\n> A：Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。\n> Node的元素val和指针next是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。\n\n> Q2：ConcurrentHashMap在JDK 7和8之间的区别\n> A:去掉了Segment这种数据结构\n> 增加了红黑树结构来优化链表，解决了长链表遍历慢的问题",normalizedContent:"# hashmap 与 concurrenthashmap 的实现原理是怎样的？concurrenthashmap 是如何保证线程安全的？\n\n                 hashmap     concurrenthashmap\n是否线程安全           不安全         安全\njdk1.7-数据结构      数组+链表       数组+链表+segment\njdk1.7-数据结构-图示               \n锁粒度              ---         对segment加锁，最大并发修改线程数=segment数量\n---              ---         ---\njdk1.8-数据结构      数组+链表+红黑树   数组+链表+红黑树\njdk1.8-数据结构-图示               \n锁粒度              ---         hashentry（首节点），最大并发修改线程数=数组.size\n\n> q1：concurrenthashmap 中变量使用 final 和 volatile 修饰有什么用呢？\n> a：final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。\n> node的元素val和指针next是用 volatile 修饰的，在多线程环境下线程a修改结点的val或者新增节点的时候是对线程b可见的。\n\n> q2：concurrenthashmap在jdk 7和8之间的区别\n> a:去掉了segment这种数据结构\n> 增加了红黑树结构来优化链表，解决了长链表遍历慢的问题",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"为什么重写 equals 必须重写 hashcode ？",frontmatter:{title:"为什么重写 equals 必须重写 hashcode ？",date:"2022-04-04T14:23:08.000Z",permalink:"/pages/0d22ad/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/030.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99%20equals%20%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99%20hashcode%20%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/030.为什么重写 equals 必须重写 hashcode ？.md",key:"v-57012c44",path:"/pages/0d22ad/",headers:[{level:2,title:"为什么重写 equals 必须重写 hashcode ？",slug:"为什么重写-equals-必须重写-hashcode",normalizedTitle:"为什么重写 equals 必须重写 hashcode ？",charIndex:2}],headersStr:"为什么重写 equals 必须重写 hashcode ？",content:"# 为什么重写 equals 必须重写 hashcode ？\n\n如果 我们重写了 equals 没有重写 hashcode 会导致HashSet 里面可以存储重复的元素。\n\n\n以 HashSet 为例来说\nHashSet 底层是数组结构 存储的元素不重复（ O1和O2重复的意思是O1.equals(O2)==true ）\nadd 一个元素进来放在哪里呢？\n是根据元素的hash值（即 hashcode ）来确定数组下标 将元素放在里面。\n如果 我们重写了 equals 没有重写 hashcode\n那么 可能会产生这样的数据： O1.equals(O2)==true 但是O1.hashcode()!=O2.hashcode()\n导致 HashSet 里面可以存储重复的元素。",normalizedContent:"# 为什么重写 equals 必须重写 hashcode ？\n\n如果 我们重写了 equals 没有重写 hashcode 会导致hashset 里面可以存储重复的元素。\n\n\n以 hashset 为例来说\nhashset 底层是数组结构 存储的元素不重复（ o1和o2重复的意思是o1.equals(o2)==true ）\nadd 一个元素进来放在哪里呢？\n是根据元素的hash值（即 hashcode ）来确定数组下标 将元素放在里面。\n如果 我们重写了 equals 没有重写 hashcode\n那么 可能会产生这样的数据： o1.equals(o2)==true 但是o1.hashcode()!=o2.hashcode()\n导致 hashset 里面可以存储重复的元素。",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Java 中接口和抽象类的区别",frontmatter:{title:"Java 中接口和抽象类的区别",date:"2022-04-04T14:22:16.000Z",permalink:"/pages/826c8b/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/020.Java%20%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"01.Java相关/10.基础/020.Java 中接口和抽象类的区别.md",key:"v-4e1fd39c",path:"/pages/826c8b/",headers:[{level:2,title:"Java 中接口和抽象类的区别",slug:"java-中接口和抽象类的区别",normalizedTitle:"java 中接口和抽象类的区别",charIndex:2}],headersStr:"Java 中接口和抽象类的区别",content:"# Java 中接口和抽象类的区别\n\n          抽象类                     接口\n修饰符       abstract                interface\n从设计层面来说   是一种模板设计,抽象类要被子类继承       是一种行为的规范，接口要被类实现\n使用场景      在代码实现方面发挥作用，可以实现代码的重用   在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约\n\n抽象类-经典使用场景: StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类\n\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    /**\n     * The value is used for character storage.\n     */\n    char[] value;\n\n    /**\n     * The count is the number of characters used.\n     */\n    int count;\n\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"# java 中接口和抽象类的区别\n\n          抽象类                     接口\n修饰符       abstract                interface\n从设计层面来说   是一种模板设计,抽象类要被子类继承       是一种行为的规范，接口要被类实现\n使用场景      在代码实现方面发挥作用，可以实现代码的重用   在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约\n\n抽象类-经典使用场景: stringbuilder 与 stringbuffer 都继承自 abstractstringbuilder 类\n\nabstract class abstractstringbuilder implements appendable, charsequence {\n    /**\n     * the value is used for character storage.\n     */\n    char[] value;\n\n    /**\n     * the count is the number of characters used.\n     */\n    int count;\n\n    abstractstringbuilder(int capacity) {\n        value = new char[capacity];\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",frontmatter:{title:"简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",date:"2022-04-04T14:24:34.000Z",permalink:"/pages/305919/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/060.%E7%AE%80%E8%BF%B0%20ArrayList%20%E4%B8%8E%20LinkedList%20%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html",relativePath:"01.Java相关/10.基础/060.简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度.md",key:"v-57b2551a",path:"/pages/305919/",headers:[{level:2,title:"简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",slug:"简述-arraylist-与-linkedlist-的底层实现以及常见操作的时间复杂度",normalizedTitle:"简述 arraylist 与 linkedlist 的底层实现以及常见操作的时间复杂度",charIndex:2}],headersStr:"简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",content:"# 简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度\n\n        ARRAYLIST                                   LINKEDLIST\n线程安全    不安全                                         不安全\n底层结构    Object 数组                                   双向链表\n适用场景    按照数组下表快速访问元素 时间复杂度就是 O(1)                   顺序访问元素\n不适用场景   在指定位置n插入、删除, 会导致位置n后面的元素移动 时间复杂度就是 O(n-1)   随机访问元素",normalizedContent:"# 简述 arraylist 与 linkedlist 的底层实现以及常见操作的时间复杂度\n\n        arraylist                                   linkedlist\n线程安全    不安全                                         不安全\n底层结构    object 数组                                   双向链表\n适用场景    按照数组下表快速访问元素 时间复杂度就是 o(1)                   顺序访问元素\n不适用场景   在指定位置n插入、删除, 会导致位置n后面的元素移动 时间复杂度就是 o(n-1)   随机访问元素",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"== 和 equals() 的区别？",frontmatter:{title:"== 和 equals() 的区别？",date:"2022-04-04T14:23:40.000Z",permalink:"/pages/06b28a/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/040.==%20%E5%92%8C%20equals()%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/040.== 和 equals() 的区别？.md",key:"v-d8a2f15c",path:"/pages/06b28a/",headers:[{level:2,title:"== 和 equals() 的区别？",slug:"和-equals-的区别",normalizedTitle:"== 和 equals() 的区别？",charIndex:2}],headersStr:"== 和 equals() 的区别？",content:'# == 和 equals() 的区别？\n\n * == : 基本数据类型==比较的是值，引用数据类型==比较的是内存地址。\n * 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n\npublic static void main(String[] args) {\n\t\tString s1 = new String("hello"); // s1 为一个引用\n        String s2 = new String("hello"); // s2和s1内容一样\n        String s3 = "world"; // 放在常量池中\n        String s4 = "world"; // 从常量池中查找\n        String o1 = new Object(); // o1 为一个引用\n        String o2 = new Object(); // o2 为另一个引用\n        if (aa == bb) // true 都是常量池的地址\n            System.out.println("aa==bb");\n        if (s1 == s2) // false，比较地址，s1 s2是两次new出来的对象，地址肯定不同\n            System.out.println("a==b");\n        if (s1.equals(s2)) // true String的equals方法被重写了 比较的是内容\n            System.out.println("aEQb");\n        if (o1 == o2) // false Object没有重写equals 比较地址\n            System.out.println("aa==bb");\n        if (o1.equals(o2)) // false 比较地址 Object没有重写equals 比较地址\n            System.out.println("a==b");\n        if (55 == 55L) { // true 基本数据类型  比较的是数值\n            System.out.println("true");\n        } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# == 和 equals() 的区别？\n\n * == : 基本数据类型==比较的是值，引用数据类型==比较的是内存地址。\n * 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n\npublic static void main(string[] args) {\n\t\tstring s1 = new string("hello"); // s1 为一个引用\n        string s2 = new string("hello"); // s2和s1内容一样\n        string s3 = "world"; // 放在常量池中\n        string s4 = "world"; // 从常量池中查找\n        string o1 = new object(); // o1 为一个引用\n        string o2 = new object(); // o2 为另一个引用\n        if (aa == bb) // true 都是常量池的地址\n            system.out.println("aa==bb");\n        if (s1 == s2) // false，比较地址，s1 s2是两次new出来的对象，地址肯定不同\n            system.out.println("a==b");\n        if (s1.equals(s2)) // true string的equals方法被重写了 比较的是内容\n            system.out.println("aeqb");\n        if (o1 == o2) // false object没有重写equals 比较地址\n            system.out.println("aa==bb");\n        if (o1.equals(o2)) // false 比较地址 object没有重写equals 比较地址\n            system.out.println("a==b");\n        if (55 == 55l) { // true 基本数据类型  比较的是数值\n            system.out.println("true");\n        } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"String，StringBuffer，StringBuilder 之间有什么区别？",frontmatter:{title:"String，StringBuffer，StringBuilder 之间有什么区别？",date:"2022-04-04T14:24:07.000Z",permalink:"/pages/211d8c/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/050.String%EF%BC%8CStringBuffer%EF%BC%8CStringBuilder%20%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/050.String，StringBuffer，StringBuilder 之间有什么区别？.md",key:"v-7f48b402",path:"/pages/211d8c/",headers:[{level:2,title:"String，StringBuffer，StringBuilder 之间有什么区别？",slug:"string-stringbuffer-stringbuilder-之间有什么区别",normalizedTitle:"string，stringbuffer，stringbuilder 之间有什么区别？",charIndex:2}],headersStr:"String，StringBuffer，StringBuilder 之间有什么区别？",content:"# String，StringBuffer，StringBuilder 之间有什么区别？\n\n * String 对象是不可变的。String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]。\n * StringBuffer，StringBuilder是可变的\n * StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 是线程不安全的。\n\n        STRING   STRINGBUFFER         STRINGBUILDER\n可变性     不可变      可变                   可变\n线程安全性   安全       安全                   不安全\n使用场景    操作少量数据   多线程操作字符串缓冲区下操作大量数据   单线程操作字符串缓冲区下操作大量数据",normalizedContent:"# string，stringbuffer，stringbuilder 之间有什么区别？\n\n * string 对象是不可变的。string 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]。\n * stringbuffer，stringbuilder是可变的\n * stringbuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。stringbuilder 是线程不安全的。\n\n        string   stringbuffer         stringbuilder\n可变性     不可变      可变                   可变\n线程安全性   安全       安全                   不安全\n使用场景    操作少量数据   多线程操作字符串缓冲区下操作大量数据   单线程操作字符串缓冲区下操作大量数据",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 BIO, NIO, AIO 的区别",frontmatter:{title:"简述 BIO, NIO, AIO 的区别",date:"2022-04-04T14:25:08.000Z",permalink:"/pages/276740/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/070.%E7%AE%80%E8%BF%B0%20BIO,%20NIO,%20AIO%20%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"01.Java相关/10.基础/070.简述 BIO, NIO, AIO 的区别.md",key:"v-d4e20148",path:"/pages/276740/",headers:[{level:2,title:"简述 BIO, NIO, AIO 的区别",slug:"简述-bio-nio-aio-的区别",normalizedTitle:"简述 bio, nio, aio 的区别",charIndex:2}],headersStr:"简述 BIO, NIO, AIO 的区别",content:"# 简述 BIO, NIO, AIO 的区别\n\nlinux中所有的外部设备都是一个文件，socket也是一个文件，有文件描述符（fd）指向它。\n\n       BIO (BLOCKING I/O)                NIO (NON-BLOCKING/NEW I/O)           AIO (ASYNCHRONOUS I/O)\n描述     在用户进程空间调用recvfrom,直到有数据才读取数据并返回   轮训调用recvfrom，直到有数据                   通知内核数据读取操作即可。用户进程不需要等待并读取数据。\n图示                                                                            \n使用场景   活动连接数不是特别高（小于单机 1000）的情况          对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发   我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。",normalizedContent:"# 简述 bio, nio, aio 的区别\n\nlinux中所有的外部设备都是一个文件，socket也是一个文件，有文件描述符（fd）指向它。\n\n       bio (blocking i/o)                nio (non-blocking/new i/o)           aio (asynchronous i/o)\n描述     在用户进程空间调用recvfrom,直到有数据才读取数据并返回   轮训调用recvfrom，直到有数据                   通知内核数据读取操作即可。用户进程不需要等待并读取数据。\n图示                                                                            \n使用场景   活动连接数不是特别高（小于单机 1000）的情况          对于高负载、高并发的（网络）应用，应使用 nio 的非阻塞模式来开发   我发现就目前来说 aio 的应用还不是很广泛，netty 之前也尝试使用过 aio，不过又放弃了。",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"在一个静态方法内调用一个非静态成员为什么是非法的？",frontmatter:{title:"在一个静态方法内调用一个非静态成员为什么是非法的？",date:"2022-04-04T14:25:35.000Z",permalink:"/pages/56314c/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/080.%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/080.在一个静态方法内调用一个非静态成员为什么是非法的？.md",key:"v-d32e07ea",path:"/pages/56314c/",headers:[{level:2,title:"在一个静态方法内调用一个非静态成员为什么是非法的？",slug:"在一个静态方法内调用一个非静态成员为什么是非法的",normalizedTitle:"在一个静态方法内调用一个非静态成员为什么是非法的？",charIndex:2}],headersStr:"在一个静态方法内调用一个非静态成员为什么是非法的？",content:"# 在一个静态方法内调用一个非静态成员为什么是非法的？\n\n从java的生命周期角度来说，静态方法的初始化早于非静态方法。\n\n        静态方法   非静态成员\n初始化阶段   准备     使用",normalizedContent:"# 在一个静态方法内调用一个非静态成员为什么是非法的？\n\n从java的生命周期角度来说，静态方法的初始化早于非静态方法。\n\n        静态方法   非静态成员\n初始化阶段   准备     使用",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 Java 的反射机制及其应用场景",frontmatter:{title:"简述 Java 的反射机制及其应用场景",date:"2022-04-04T14:25:59.000Z",permalink:"/pages/fae5d5/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/090.%E7%AE%80%E8%BF%B0%20Java%20%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"01.Java相关/10.基础/090.简述 Java 的反射机制及其应用场景.md",key:"v-85b06162",path:"/pages/fae5d5/",headers:[{level:2,title:"简述 Java 的反射机制及其应用场景",slug:"简述-java-的反射机制及其应用场景",normalizedTitle:"简述 java 的反射机制及其应用场景",charIndex:2}],headersStr:"简述 Java 的反射机制及其应用场景",content:"# 简述 Java 的反射机制及其应用场景\n\n*** Java 的反射机制 ***\n这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息\n包括其modifiers(诸如public, static 等)、superclass(例如Object)、实现之interfaces(例如Cloneable)，也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。\nJava反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。\n换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。\n\n\n*** 应用场景 ***\nArthas\nRPC框架中的 动态代理\nSpring 加载 XML\nJava 动态代理\nJDBC 驱动加载\n",normalizedContent:"# 简述 java 的反射机制及其应用场景\n\n*** java 的反射机制 ***\n这个机制允许程序在运行时透过reflection apis取得任何一个已知名称的class的内部信息\n包括其modifiers(诸如public, static 等)、superclass(例如object)、实现之interfaces(例如cloneable)，也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。\njava反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。\n换言之，java可以加载一个运行时才得知名称的class，获得其完整结构。\n\n\n*** 应用场景 ***\narthas\nrpc框架中的 动态代理\nspring 加载 xml\njava 动态代理\njdbc 驱动加载\n",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"什么是双亲委派机制？",frontmatter:{title:"什么是双亲委派机制？",date:"2022-04-04T14:26:57.000Z",permalink:"/pages/38bcaf/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/110.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/110.什么是双亲委派机制？.md",key:"v-7665e30e",path:"/pages/38bcaf/",headers:[{level:2,title:"什么是双亲委派机制？",slug:"什么是双亲委派机制",normalizedTitle:"什么是双亲委派机制？",charIndex:2}],headersStr:"什么是双亲委派机制？",content:'# 什么是双亲委派机制？\n\n双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。\n\n\n\n加载器                       加载哪些类\nbootstrap classloader     加载jre/lib/rt.jar\nextension classloader     jre/lib/ext/*.jar\napplication classloader   加载应用程序目录\n自定义ClassLoader            定制化加载\n\n再来读一下java.lang.ClassLoader这段代码 是不是通透了许多？\n\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n    //              -----??-----\n    protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n            // 首先，检查是否已经被类加载器加载过\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                try {\n                    // 存在父加载器，递归的交由父加载器\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        // 直到最上面的Bootstrap类加载器\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n \n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    c = findClass(name);\n                }\n            }\n            return c;\n    }\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> Q1：使用双亲委派有什么好处？\n> A：双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。\n> 考虑到安全因素。\n> 假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。\n\n> Q2：什么场景需要破坏双亲委派？\n> 双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载）\n> 基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API 但没有绝对，如果基础类调用会用户的代码怎么办呢？ 比如JDBC驱动加载。 这种场景就需要用到SPI机制，是不符合双亲委派的。\n\n> Q3：JDBC、Tomcat中为什么要破坏双亲委派模型\n> A：JDBC\n> 先来回顾一下JDBC的用法\n\nString url = "jdbc:mysql:///consult?serverTimezone=UTC";\nString user = "root";\nString password = "root";\n\nClass.forName("com.mysql.jdbc.Driver");\nConnection connection = DriverManager.getConnection(url, user, password);\n\n\n1\n2\n3\n4\n5\n6\n\n\n> DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，DriverManager位于 JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载.\n> JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包位于服务商MySQL提供的 Jar 中包含Driver的实现，按照双亲委派模型应该由application classloader加载\n> 实际上却是由BootStrap类加载器加载。\n> 这是因为：根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。\n> 这就破坏了双亲委派模型。\n\nTomcat\n每个webappClassLoader加载自己目录下的class文件\n\n> Tomcat支持部署多个Web应用，多个Web应用可能使用不同版本的JDK、也可能在应用内部定义全限定名一样的类，所以要做到应用隔离。',normalizedContent:'# 什么是双亲委派机制？\n\n双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。\n\n\n\n加载器                       加载哪些类\nbootstrap classloader     加载jre/lib/rt.jar\nextension classloader     jre/lib/ext/*.jar\napplication classloader   加载应用程序目录\n自定义classloader            定制化加载\n\n再来读一下java.lang.classloader这段代码 是不是通透了许多？\n\n    public class<?> loadclass(string name) throws classnotfoundexception {\n        return loadclass(name, false);\n    }\n    //              -----??-----\n    protected class<?> loadclass(string name, boolean resolve)\n        throws classnotfoundexception\n    {\n            // 首先，检查是否已经被类加载器加载过\n            class<?> c = findloadedclass(name);\n            if (c == null) {\n                try {\n                    // 存在父加载器，递归的交由父加载器\n                    if (parent != null) {\n                        c = parent.loadclass(name, false);\n                    } else {\n                        // 直到最上面的bootstrap类加载器\n                        c = findbootstrapclassornull(name);\n                    }\n                } catch (classnotfoundexception e) {\n                    // classnotfoundexception thrown if class not found\n                    // from the non-null parent class loader\n                }\n \n                if (c == null) {\n                    // if still not found, then invoke findclass in order\n                    // to find the class.\n                    c = findclass(name);\n                }\n            }\n            return c;\n    }\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> q1：使用双亲委派有什么好处？\n> a：双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。\n> 考虑到安全因素。\n> 假设通过网络传递一个名为java.lang.integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心java api发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.integer，而直接返回已加载过的integer.class，这样便可以防止核心api库被随意篡改。\n\n> q2：什么场景需要破坏双亲委派？\n> 双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载）\n> 基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的api 但没有绝对，如果基础类调用会用户的代码怎么办呢？ 比如jdbc驱动加载。 这种场景就需要用到spi机制，是不符合双亲委派的。\n\n> q3：jdbc、tomcat中为什么要破坏双亲委派模型\n> a：jdbc\n> 先来回顾一下jdbc的用法\n\nstring url = "jdbc:mysql:///consult?servertimezone=utc";\nstring user = "root";\nstring password = "root";\n\nclass.forname("com.mysql.jdbc.driver");\nconnection connection = drivermanager.getconnection(url, user, password);\n\n\n1\n2\n3\n4\n5\n6\n\n\n> drivermanager 类中要加载各个实现了driver接口的类，然后进行管理，drivermanager位于 java_home中jre/lib/rt.jar 包，由bootstrap类加载器加载.\n> jdbc的driver接口定义在jdk中，其实现由各个数据库的服务商来提供，比如mysql驱动包位于服务商mysql提供的 jar 中包含driver的实现，按照双亲委派模型应该由application classloader加载\n> 实际上却是由bootstrap类加载器加载。\n> 这是因为：根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。\n> 这就破坏了双亲委派模型。\n\ntomcat\n每个webappclassloader加载自己目录下的class文件\n\n> tomcat支持部署多个web应用，多个web应用可能使用不同版本的jdk、也可能在应用内部定义全限定名一样的类，所以要做到应用隔离。',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Java 类的加载流程是怎样的？",frontmatter:{title:"Java 类的加载流程是怎样的？",date:"2022-04-04T14:26:24.000Z",permalink:"/pages/33c5d6/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/100.Java%20%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/100.Java 类的加载流程是怎样的？.md",key:"v-4c273a66",path:"/pages/33c5d6/",headers:[{level:2,title:"Java 类的加载流程是怎样的？",slug:"java-类的加载流程是怎样的",normalizedTitle:"java 类的加载流程是怎样的？",charIndex:2}],headersStr:"Java 类的加载流程是怎样的？",content:"# Java 类的加载流程是怎样的？\n\n类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。 其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。\n\n      做什么\n加载    类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例\n验证    验证类数据信息是否符合JVM规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等\n准备    为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）\n      被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在ConstantValue属性，则在准备阶段，其值就是ConstantValue的值\n解析    可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)\n初始化   初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。",normalizedContent:"# java 类的加载流程是怎样的？\n\n类从被加载到jvm中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。 其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。\n\n      做什么\n加载    类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到jvm内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.class对象实例\n验证    验证类数据信息是否符合jvm规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等\n准备    为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）\n      被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在constantvalue属性，则在准备阶段，其值就是constantvalue的值\n解析    可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)\n初始化   初始化，为类的静态变量赋予正确的初始值，jvm负责对类进行初始化，主要对类变量进行初始化。",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Java 中 sleep() 与 wait() 的区别",frontmatter:{title:"Java 中 sleep() 与 wait() 的区别",date:"2022-04-04T14:27:16.000Z",permalink:"/pages/d69890/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/120.Java%20%E4%B8%AD%20sleep()%20%E4%B8%8E%20wait()%20%E7%9A%84%E5%8C%BA%E5%88%AB%20.html",relativePath:"01.Java相关/10.基础/120.Java 中 sleep() 与 wait() 的区别 .md",key:"v-6ff6e2f0",path:"/pages/d69890/",headers:[{level:2,title:"Java 中 sleep() 与 wait() 的区别",slug:"java-中-sleep-与-wait-的区别",normalizedTitle:"java 中 sleep() 与 wait() 的区别",charIndex:2}],headersStr:"Java 中 sleep() 与 wait() 的区别",content:'# Java 中 sleep() 与 wait() 的区别\n\n两者都可以暂停线程的执行。区别如下：\n\n\n       SLEEP()                                       WAIT()\n       不让出锁                                          让出锁\n使用场景   用于暂停执行                                        用于线程间交互/通信\n唤醒方式   线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒   需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法\n\nyield() 和 join() 你了解吗？\n\n       YIELD()                                                 JOIN()\n描述     调用yield方法，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。   在线程A中调用线程B.join(),那么线程A会等待，cpu时间片给线程B执行，让线程B先执行，然后A再执行。\n使用场景   很少使用                                                    使异步执行的线程变成同步执行，底层是wait方法\n\npublic class JoinTest {\n\tpublic static void main(String[] args) {\n\t\tThread t = new Thread(new ThreadImp());\n\t\tt.start();\n\t\ttry {\n\t\t\tt.join(1000);//主程序等待t结束,只等1s\n\t\t\tif(t.isAlive()){\n\t\t\t\tSystem.out.println("t has not finished");\n\t\t\t}else{\n\t\t\t\tSystem.out.println("t has finished");\n\t\t\t}\n\t\t\tSystem.out.println("Joinfinished");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'# java 中 sleep() 与 wait() 的区别\n\n两者都可以暂停线程的执行。区别如下：\n\n\n       sleep()                                       wait()\n       不让出锁                                          让出锁\n使用场景   用于暂停执行                                        用于线程间交互/通信\n唤醒方式   线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒   需要别的线程调用同一个对象上的 notify() 或者 notifyall() 方法\n\nyield() 和 join() 你了解吗？\n\n       yield()                                                 join()\n描述     调用yield方法，会给线程调度器一个当前线程愿意让出cpu使用的暗示，但是线程调度器可能会忽略这个暗示。   在线程a中调用线程b.join(),那么线程a会等待，cpu时间片给线程b执行，让线程b先执行，然后a再执行。\n使用场景   很少使用                                                    使异步执行的线程变成同步执行，底层是wait方法\n\npublic class jointest {\n\tpublic static void main(string[] args) {\n\t\tthread t = new thread(new threadimp());\n\t\tt.start();\n\t\ttry {\n\t\t\tt.join(1000);//主程序等待t结束,只等1s\n\t\t\tif(t.isalive()){\n\t\t\t\tsystem.out.println("t has not finished");\n\t\t\t}else{\n\t\t\t\tsystem.out.println("t has finished");\n\t\t\t}\n\t\t\tsystem.out.println("joinfinished");\n\t\t} catch (exception e) {\n\t\t\tsystem.out.println(e);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 Java 中 final 关键字的作用",frontmatter:{title:"简述 Java 中 final 关键字的作用",date:"2022-04-04T14:27:44.000Z",permalink:"/pages/2b00a3/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/130.%E7%AE%80%E8%BF%B0%20Java%20%E4%B8%AD%20final%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8.html",relativePath:"01.Java相关/10.基础/130.简述 Java 中 final 关键字的作用.md",key:"v-620ebadc",path:"/pages/2b00a3/",headers:[{level:2,title:"简述 Java 中 final 关键字的作用",slug:"简述-java-中-final-关键字的作用",normalizedTitle:"简述 java 中 final 关键字的作用",charIndex:2}],headersStr:"简述 Java 中 final 关键字的作用",content:"# 简述 Java 中 final 关键字的作用\n\n\nfinal 关键字主要用在三个地方：变量、方法、类。\n\n\n修饰对象   限制                                     使用场景\n类      被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改   Java的一些核心的API都是final类，例如String、Integer、Math等\n方法     子类不可以重写父类中被final修饰的方法                  比如 模板方法，可以用来固定算法\n成员变量   被修饰的成员变量必须在定义时或者构造器中进行初始化赋值，且不可再修改     \n局部变量   final修饰局部变量时只能初始化(赋值)一次，但也可以不初始化       \n方法参数   final修饰方法参数时，是在调用方法传递参数时候初始化的          \n\n> final修饰变量要说明几点：\n> 1.修饰基本类型数据，final会将值变为一个常数（创建后不能被修改）；\n> 2.修饰的是引用类型，引用的指向 是不可变，但对象里面的属性可以改变 。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。\n> 3.方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值。\n\n//这段代码可以正常编译运行 因为final修饰的是引用类型，引用的指向 是不可变，但对象里面的属性可以改变\npublic class Test {\n    public static void main(String[] args)  {\n        final MyClass myClass = new MyClass();\n        System.out.println(++myClass.i); \n \n    }\n}\n\nclass MyClass {\n    public int i = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"# 简述 java 中 final 关键字的作用\n\n\nfinal 关键字主要用在三个地方：变量、方法、类。\n\n\n修饰对象   限制                                     使用场景\n类      被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改   java的一些核心的api都是final类，例如string、integer、math等\n方法     子类不可以重写父类中被final修饰的方法                  比如 模板方法，可以用来固定算法\n成员变量   被修饰的成员变量必须在定义时或者构造器中进行初始化赋值，且不可再修改     \n局部变量   final修饰局部变量时只能初始化(赋值)一次，但也可以不初始化       \n方法参数   final修饰方法参数时，是在调用方法传递参数时候初始化的          \n\n> final修饰变量要说明几点：\n> 1.修饰基本类型数据，final会将值变为一个常数（创建后不能被修改）；\n> 2.修饰的是引用类型，引用的指向 是不可变，但对象里面的属性可以改变 。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。\n> 3.方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值。\n\n//这段代码可以正常编译运行 因为final修饰的是引用类型，引用的指向 是不可变，但对象里面的属性可以改变\npublic class test {\n    public static void main(string[] args)  {\n        final myclass myclass = new myclass();\n        system.out.println(++myclass.i); \n \n    }\n}\n\nclass myclass {\n    public int i = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"String 类能不能被继承？为什么？",frontmatter:{title:"String 类能不能被继承？为什么？",date:"2022-04-04T14:28:11.000Z",permalink:"/pages/73113f/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/140.String%20%E7%B1%BB%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/140.String 类能不能被继承？为什么？.md",key:"v-5290507e",path:"/pages/73113f/",headers:[{level:2,title:"String 类能不能被继承？为什么？",slug:"string-类能不能被继承-为什么",normalizedTitle:"string 类能不能被继承？为什么？",charIndex:2}],headersStr:"String 类能不能被继承？为什么？",content:"# String 类能不能被继承？为什么？\n\n不可以，String 是被final修饰的。\n\n\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence {\n    // 省略...　\n}\n\n\n1\n2\n3\n\n\n> Q:String 为什么是 final 类型？\n> A:被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改",normalizedContent:"# string 类能不能被继承？为什么？\n\n不可以，string 是被final修饰的。\n\n\npublic final class string implements java.io.serializable, comparable<string>, charsequence {\n    // 省略...　\n}\n\n\n1\n2\n3\n\n\n> q:string 为什么是 final 类型？\n> a:被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Java 缓冲流 buffer 的用途和原理是什么？",frontmatter:{title:"Java 缓冲流 buffer 的用途和原理是什么？",date:"2022-04-04T14:29:13.000Z",permalink:"/pages/115772/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/150.Java%20%E7%BC%93%E5%86%B2%E6%B5%81%20buffer%20%E7%9A%84%E7%94%A8%E9%80%94%E5%92%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/150.Java 缓冲流 buffer 的用途和原理是什么？.md",key:"v-6f5c6512",path:"/pages/115772/",headers:[{level:2,title:"Java 缓冲流 buffer 的用途和原理是什么？",slug:"java-缓冲流-buffer-的用途和原理是什么",normalizedTitle:"java 缓冲流 buffer 的用途和原理是什么？",charIndex:2}],headersStr:"Java 缓冲流 buffer 的用途和原理是什么？",content:'# Java 缓冲流 buffer 的用途和原理是什么？\n\nbuffer本质是一个字节数组（ByteBuff），同时提供数据的结构化访问以及维护读写位置。\n而运用BufferedInputStream，则可以一次性读n个字节到内存中的缓冲区，这样在内存中读取数据会快很多。 1.流是单向的 所以会有输入流、输出流\n2.字节流一般用于处理文件、视频、音频等，字符流一般用于处理文本数据。\n3.原理：维护一个数组、一个指针\n\n\npublic class BufferedInputStream extends FilterInputStream{\n    private static int DEFAULT_BUFFER_SIZE = 8192;\n    private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n    // 缓冲数组\n    protected volatile byte buf[];\n    // bufUpdater提供buf的compareAndSet方法，这是必要的，因为close()可以是异步的，可以将buf是否为null作为是否close的主要指标。\n    private static final AtomicReferenceFieldUpdater<BufferedInputStream, byte[]> bufUpdater =\n        AtomicReferenceFieldUpdater.newUpdater(BufferedInputStream.class,  byte[].class, "buf");\n    // buf中的有效字节数\n    protected int count;\n    // buf中的当前字节位置\n    protected int pos;\n    \n    public BufferedInputStream(InputStream in) {\n        this(in, DEFAULT_BUFFER_SIZE);\n    }\n\n    public BufferedInputStream(InputStream in, int size) {\n        super(in);\n        if (size <= 0) {\n            throw new IllegalArgumentException("Buffer size <= 0");\n        }\n        buf = new byte[size];\n    }\n\n   //读方法 -> 数据写入到数组buf中\n    public synchronized int read() throws IOException {\n        // 当读完buf中的数据后，就需要把InputStream的数据重新填充到buf\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        // 返回buf的下一个字节 指针后移\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',normalizedContent:'# java 缓冲流 buffer 的用途和原理是什么？\n\nbuffer本质是一个字节数组（bytebuff），同时提供数据的结构化访问以及维护读写位置。\n而运用bufferedinputstream，则可以一次性读n个字节到内存中的缓冲区，这样在内存中读取数据会快很多。 1.流是单向的 所以会有输入流、输出流\n2.字节流一般用于处理文件、视频、音频等，字符流一般用于处理文本数据。\n3.原理：维护一个数组、一个指针\n\n\npublic class bufferedinputstream extends filterinputstream{\n    private static int default_buffer_size = 8192;\n    private static int max_buffer_size = integer.max_value - 8;\n    // 缓冲数组\n    protected volatile byte buf[];\n    // bufupdater提供buf的compareandset方法，这是必要的，因为close()可以是异步的，可以将buf是否为null作为是否close的主要指标。\n    private static final atomicreferencefieldupdater<bufferedinputstream, byte[]> bufupdater =\n        atomicreferencefieldupdater.newupdater(bufferedinputstream.class,  byte[].class, "buf");\n    // buf中的有效字节数\n    protected int count;\n    // buf中的当前字节位置\n    protected int pos;\n    \n    public bufferedinputstream(inputstream in) {\n        this(in, default_buffer_size);\n    }\n\n    public bufferedinputstream(inputstream in, int size) {\n        super(in);\n        if (size <= 0) {\n            throw new illegalargumentexception("buffer size <= 0");\n        }\n        buf = new byte[size];\n    }\n\n   //读方法 -> 数据写入到数组buf中\n    public synchronized int read() throws ioexception {\n        // 当读完buf中的数据后，就需要把inputstream的数据重新填充到buf\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        // 返回buf的下一个字节 指针后移\n        return getbufifopen()[pos++] & 0xff;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述动态代理与静态代理",frontmatter:{title:"简述动态代理与静态代理",date:"2022-04-04T14:29:39.000Z",permalink:"/pages/37dba4/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/160.%E7%AE%80%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%20.html",relativePath:"01.Java相关/10.基础/160.简述动态代理与静态代理 .md",key:"v-75844e97",path:"/pages/37dba4/",headers:[{level:2,title:"简述动态代理与静态代理",slug:"简述动态代理与静态代理",normalizedTitle:"简述动态代理与静态代理",charIndex:2}],headersStr:"简述动态代理与静态代理",content:"# 简述动态代理与静态代理\n\n       静态代理                                                                                                      动态代理\n       由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的 .class 文件就已经存在了                                                     在程序运行时运用反射机制动态创建而成，动态就是在程序运行时生成的，而不是编译时。\n应用场景   AspectJ AOP                                                                                               Spring AOP、RPC 框架\n优点     在不修改目标对象的前提下，可以通过代理对象对目标对象功能扩展                                                                            不会会产生很多静态类，通过一个代理类完成全部的代理功能\n缺点     1.代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。   \n       2.代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n\n> 1.AspectJ 的底层技术就是静态代理，用一种 AspectJ 支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。\n> 2.JDK 动态代理：\n> \n> \n>  * 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理\n>    \n>  * 代理对象的生成，是通过 JDK 的 API（反射机制），动态的在内存中构建代理对象，在 Java 中要想实现动态代理机制，需要 java.lang.reflect.InvocationHandler 接口和 java.lang.reflect.Proxy 类的支持\n>    3.cglib 代理:\n>  * 静态代理和 JDK 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。\n>    *cglib (opens new window)(Code Generation Library)是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。cglib 通过继承方式实现代理。它广泛的被许多 AOP 的框架使用，比如我们的 Spring AOP。\n>    *cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。\n>    *cglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。\n>    ",normalizedContent:"# 简述动态代理与静态代理\n\n       静态代理                                                                                                      动态代理\n       由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的 .class 文件就已经存在了                                                     在程序运行时运用反射机制动态创建而成，动态就是在程序运行时生成的，而不是编译时。\n应用场景   aspectj aop                                                                                               spring aop、rpc 框架\n优点     在不修改目标对象的前提下，可以通过代理对象对目标对象功能扩展                                                                            不会会产生很多静态类，通过一个代理类完成全部的代理功能\n缺点     1.代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。   \n       2.代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n\n> 1.aspectj 的底层技术就是静态代理，用一种 aspectj 支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。\n> 2.jdk 动态代理：\n> \n> \n>  * 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理\n>    \n>  * 代理对象的生成，是通过 jdk 的 api（反射机制），动态的在内存中构建代理对象，在 java 中要想实现动态代理机制，需要 java.lang.reflect.invocationhandler 接口和 java.lang.reflect.proxy 类的支持\n>    3.cglib 代理:\n>  * 静态代理和 jdk 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。\n>    *cglib (opens new window)(code generation library)是一个基于 asm 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。cglib 通过继承方式实现代理。它广泛的被许多 aop 的框架使用，比如我们的 spring aop。\n>    *cglib 包的底层是通过使用字节码处理框架 asm 来转换字节码并生成新的类。\n>    *cglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。\n>    ",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"阻塞队列都有哪几种，有什么区别？",frontmatter:{title:"阻塞队列都有哪几种，有什么区别？",date:"2022-04-04T14:30:18.000Z",permalink:"/pages/e9ce4e/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/170.%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E9%83%BD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.html",relativePath:"01.Java相关/10.基础/170.阻塞队列都有哪几种，有什么区别？.md",key:"v-1218fa85",path:"/pages/e9ce4e/",headers:[{level:2,title:"阻塞队列都有哪几种，有什么区别？",slug:"阻塞队列都有哪几种-有什么区别",normalizedTitle:"阻塞队列都有哪几种，有什么区别？",charIndex:2}],headersStr:"阻塞队列都有哪几种，有什么区别？",content:"# 阻塞队列都有哪几种，有什么区别？\n\njava.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：\n\n\nFIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）\n优先级队列 ：PriorityBlockingQueue\n延时队列 ： DelayQueue\n同步队列 ： SynchronousQueue\n\n\njava.util.concurrent.BlockingQueue提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。\n\n\n                        \nLinkedBlockingQueue     1.内部是用链表实现的\n                        2.默认容量是 Integer.MAX_VALUE\n                        3.队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能\n                        4.会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响\n                        5.在无界的情况下，可能会造成内存溢出等问题。\nArrayBlockingQueue      1.ArrayBlockingQueue 是最典型的有界队列\n                        2.其内部是用数组存储元素的\n                        3.利用 ReentrantLock 实现线程安全,添加操作和移除操作采用的同一个ReenterLock锁\n                        4.在创建它的时候就需要指定它的容量，之后也不可以再扩容了\n                        5.构造函数中我们同样可以指定是否是公平的\nPriorityBlockingQueue   1.无界阻塞队列\n                        2. 支持优先级,可以通过自定义类实现 compareTo() 方法来指定元素排序规则\nDelayQueue              1.无界队列\n                        2.放入的元素必须实现 Delayed 接口\n                        3.内部使用了 PriorityQueue 的能力来进行排序\nSynchronousQueue        容量为\n                        0,所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取",normalizedContent:"# 阻塞队列都有哪几种，有什么区别？\n\njava.util.concurrent.blockingqueue 接口有以下阻塞队列的实现：\n\n\nfifo 队列 ：linkedblockingqueue、arrayblockingqueue（固定长度）\n优先级队列 ：priorityblockingqueue\n延时队列 ： delayqueue\n同步队列 ： synchronousqueue\n\n\njava.util.concurrent.blockingqueue提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。\n\n\n                        \nlinkedblockingqueue     1.内部是用链表实现的\n                        2.默认容量是 integer.max_value\n                        3.队列中的锁是分离的，其添加采用的是putlock，移除采用的则是takelock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能\n                        4.会生成一个额外的node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于gc可能存在较大影响\n                        5.在无界的情况下，可能会造成内存溢出等问题。\narrayblockingqueue      1.arrayblockingqueue 是最典型的有界队列\n                        2.其内部是用数组存储元素的\n                        3.利用 reentrantlock 实现线程安全,添加操作和移除操作采用的同一个reenterlock锁\n                        4.在创建它的时候就需要指定它的容量，之后也不可以再扩容了\n                        5.构造函数中我们同样可以指定是否是公平的\npriorityblockingqueue   1.无界阻塞队列\n                        2. 支持优先级,可以通过自定义类实现 compareto() 方法来指定元素排序规则\ndelayqueue              1.无界队列\n                        2.放入的元素必须实现 delayed 接口\n                        3.内部使用了 priorityqueue 的能力来进行排序\nsynchronousqueue        容量为\n                        0,所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 HashSet 实现原理",frontmatter:{title:"简述 HashSet 实现原理",date:"2022-04-04T14:30:47.000Z",permalink:"/pages/75552c/",categories:["Java相关","基础"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/180.%E7%AE%80%E8%BF%B0%20HashSet%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",relativePath:"01.Java相关/10.基础/180.简述 HashSet 实现原理.md",key:"v-b21bbc4c",path:"/pages/75552c/",headers:[{level:2,title:"简述 HashSet 实现原理",slug:"简述-hashset-实现原理",normalizedTitle:"简述 hashset 实现原理",charIndex:2}],headersStr:"简述 HashSet 实现原理",content:"# 简述 HashSet 实现原理\n\n底层结构是 HashMap 。value都是存放同一个虚拟对象。\n\npublic class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable {\n    static final long serialVersionUID = -5024744406713321676L;\n \n    private transient HashMap<E,Object> map;\n \n    // 虚拟对象\n    private static final Object PRESENT = new Object();\n \n    // 无参构造\n    public HashSet() {\n        map = new HashMap<>();\n    }\n \n    // 集合构造\n    public HashSet(Collection<? extends E> c) {\n        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));\n        addAll(c);\n    }\n \n    // 初始化容量及负载因子构造\n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap<>(initialCapacity, loadFactor);\n    }\n \n    // 初始化容量构造\n    public HashSet(int initialCapacity) {\n        map = new HashMap<>(initialCapacity);\n    }\n \n    // 由于默认修饰符，同包可访问，我们用不到，在LinkedLinkedHashMap中有具体应用，后期会讲解\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap<>(initialCapacity, loadFactor);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",normalizedContent:"# 简述 hashset 实现原理\n\n底层结构是 hashmap 。value都是存放同一个虚拟对象。\n\npublic class hashset<e> extends abstractset<e> implements set<e>, cloneable, java.io.serializable {\n    static final long serialversionuid = -5024744406713321676l;\n \n    private transient hashmap<e,object> map;\n \n    // 虚拟对象\n    private static final object present = new object();\n \n    // 无参构造\n    public hashset() {\n        map = new hashmap<>();\n    }\n \n    // 集合构造\n    public hashset(collection<? extends e> c) {\n        map = new hashmap<>(math.max((int) (c.size()/.75f) + 1, 16));\n        addall(c);\n    }\n \n    // 初始化容量及负载因子构造\n    public hashset(int initialcapacity, float loadfactor) {\n        map = new hashmap<>(initialcapacity, loadfactor);\n    }\n \n    // 初始化容量构造\n    public hashset(int initialcapacity) {\n        map = new hashmap<>(initialcapacity);\n    }\n \n    // 由于默认修饰符，同包可访问，我们用不到，在linkedlinkedhashmap中有具体应用，后期会讲解\n    hashset(int initialcapacity, float loadfactor, boolean dummy) {\n        map = new linkedhashmap<>(initialcapacity, loadfactor);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"线程池是如何实现的？",frontmatter:{title:"线程池是如何实现的？",date:"2022-04-04T14:38:19.000Z",permalink:"/pages/0da4b0/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/001.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/001.线程池是如何实现的？.md",key:"v-45fc1217",path:"/pages/0da4b0/",headers:[{level:3,title:"使用线程池有哪些好处",slug:"使用线程池有哪些好处",normalizedTitle:"使用线程池有哪些好处",charIndex:2},{level:3,title:"线程池的创建",slug:"线程池的创建",normalizedTitle:"线程池的创建",charIndex:163},{level:3,title:"向线程池提交一个任务后，线程池是如何处理这个任务的呢？",slug:"向线程池提交一个任务后-线程池是如何处理这个任务的呢",normalizedTitle:"向线程池提交一个任务后，线程池是如何处理这个任务的呢？",charIndex:1987},{level:3,title:"线程池是如何工作的呢？",slug:"线程池是如何工作的呢",normalizedTitle:"线程池是如何工作的呢？",charIndex:3296},{level:3,title:"向线程池提交任务",slug:"向线程池提交任务",normalizedTitle:"向线程池提交任务",charIndex:5167},{level:3,title:"关闭线程池",slug:"关闭线程池",normalizedTitle:"关闭线程池",charIndex:6580},{level:3,title:"合理的配置线程池",slug:"合理的配置线程池",normalizedTitle:"合理的配置线程池",charIndex:6963}],headersStr:"使用线程池有哪些好处 线程池的创建 向线程池提交一个任务后，线程池是如何处理这个任务的呢？ 线程池是如何工作的呢？ 向线程池提交任务 关闭线程池 合理的配置线程池",content:'# 使用线程池有哪些好处\n\n 1. 降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁的消耗。\n 2. 提高相应速度。当任务到达时，任务可以不需要线程创建就可以执行。\n 3. 提高线程的可管理性。线程是稀缺资源、如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性。使用线程池可以统一分配、调优和监控。\n\n\n# 线程池的创建\n\n我们可以通过 ThreadPoolExecutor 来创建一个线程池\n\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {//...}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建一个线程池需要传入如下几个参数：\n\n * corePoolSize： 线程池中的常驻核心线程数。\n   当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建线程。当线程池中的线程数量到达 corePoolSize 时就不再创建。如果调用了线程池的 prestartAllCoreThread()方法，线程池会在启动后就创建所有核心线程。\n\n * workQueue： 存放任务的阻塞队列，被提交但尚未被执行的任务。\n   可以选择如下几个阻塞队列： 1.ArrayBlockingQueue 2.LinkedBlockingQueue:吞吐量高于LinkedBlockingQueue，是 Executors.newFixedThreadPool()创建的线程池的默认队列。 3.SynchronousQueue:一个不存储元素的队列。每个提交的任务都必须等到线程来执行，否则阻塞提交。是 Executors.newCachedThreadPool()创建的线程池的默认队列。 4.PriorityBlockingQueue:一个具有优先级的无限阻塞队列。\n\n * maximumPoolSize： 线程池最大线程数量。\n   如果队列满了并且已经创建的线程数量小于最大线程数量，则线程池会再继续创建新的线程执行任务。值得注意的是如果使用无界队列 (比如LinkedBlockingQueue)这个参数就没有意义了。\n\n * threadFactory： 用于设置创建线程的工厂\n   可以给创建的线程设置有意义的名字，可方便排查问题\n\n * handler： 拒绝策略，表示当队列满了且工作线程都满了如何来拒绝请求执行的线程的策略，默认是AbortPolicy策略，主要有四种类型。\n\n 1. AbortPolicy 直接抛出RegectedExcutionException 异常阻止系统正常进行，默认策略\n\n 2. DiscardPolicy 直接丢弃任务，不予任何处理也不抛出异常，如果允许任务丢失，这是最好的一种方案\n\n 3. DiscardOldestPolicy 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务\n\n 4. CallerRunsPolicy 交给线程池调用所在的线程进行处理，“调用者运行”的一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量\n\n以上内置拒绝策略均实现了 RejectExcutionHandler 接口，我们也可以实现接口RejectExcutionHandler来自定义策略，如记录日志或者持久化不能拒绝的任务。\n\n * keepAliveTime： 非核心线程存活时间\n   线程池中非核心线程空闲的存活时间 当前线程池数量超过 corePoolSize 时，当空闲时间达到 keepAliveTime 值时，非核心线程会被销毁直到只剩下 corePoolSize 个线程为止。\n   \n\n> tips:如果任务很多并且任务执行时间比较短，可以调大 keepAliveTime ，提高线程利用率。\n\n * unit： keepAliveTime 的时间单位\n   \n\n\n# 向线程池提交一个任务后，线程池是如何处理这个任务的呢？\n\n\n\n 1. 如果当前运行的线程数<corePoolSize，则创建新线程来执行任务（这一步骤需要获取全局锁）。\n 2. 如果当前运行的线程数>=corePoolSize，则将任务加入阻塞队列。\n 3. 如果队列已满或者不能加入，接下来的处理分两种情况：\n    1. 线程池中的线程是否都处于工作状态。创建新的线程来执行任务（这一步骤需要获取全局锁）。\n    2. 线程池中有空闲的线程，则用其来执行任务。\n 4. 如果创建新线程会导致线程数量>maximumPoolSize，则执行拒绝策略。\n\n我们再从源码的角度来理解下这个过程：\nThreadPoolExecutor#execute(Runnble command) 方法\n\npublic void execute(Runnable command) {\n  // 参数校验\n    if (command == null)\n        throw new NullPointerException();\n        \n    // 从 c 的值可以判断出线程池的状态, 以及线程池中线程的数量\n    int c = ctl.get();\n    // 1. 如果线程池的线程数量 小于 核心线程数\n    if (workerCountOf(c) < corePoolSize) {\n        // 添加一个核心线程 command 表示一个具体的任务， true 表示为核心线程\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 2. 如果线程池处于 RUNNING 状态（只有处于此状态，才能接受新的任务）\n    // 并且线程池的数量大于核心线程数, 就把任务添加到阻塞队列\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 3. 如果队列也满了，就创建一个非核心线程（core==false）\n    else if (!addWorker(command, false))\n        // 如果创建失败，就执行拒绝策略\n        reject(command);\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 线程池是如何工作的呢？\n\n线程池中有一个 workers 集合，里面记录了所有的工作线程，只有拿到 mainLock 锁的线程才能访问。 ThreadPoolExecutor#workers 属性\n\nprivate final HashSet<Worker> workers = new HashSet<Worker>();\n\n\n1\n\n\n线程池创建线程时，会将线程包装成 Worker ，Worker 在执行任务后还会循环获取队里里的任务。我们可以从 Worker 类的 run() 方法看到这一点。\n\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码关键点是while循环和getTask()方法，通过循环不断的调用getTask()从阻塞队列中获取任务，通过这个方法，它与阻塞队列建立桥梁。\n\n\n# 向线程池提交任务\n\n有两个方法提交任务，分别是execute(),submit()\n\n\n * execute()：execute只能提交Runnable类型的任务,用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。如果遇到异常会直接抛出。使用方法如下：\n\npublic static void main(String[] args) throws Exception{\n        ExecutorService es = Executors.newSingleThreadExecutor();\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println("Runnable线程处理开始...");\n            }\n        };\n        es.execute(runnable);\n        es.shutdown();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * submit()：submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务，会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。如果遇到异常不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常。使用方法：\n\npublic static void main(String[] args) throws Exception{\n        ExecutorService es = Executors.newSingleThreadExecutor();\n        Callable callable = new Callable() {\n            @Override\n            public String call() throws Exception {\n                System.out.println("线程处理开始...");\n                return "hello world";\n            }\n        };\n        Future<String> future = es.submit(callable);\n        while(true) {\n            //idDone:如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。\n            if(future.isDone()) {\n                System.out.println("任务执行完成：" + future.get());\n                break;\n            }\n        }\n        es.shutdown();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 关闭线程池\n\n可以通过shutdown和shutdownNow方法来关闭线程池。他们的原理是遍历线程池的中工作线程，调用其interrupt()方法来中断线程，所以，无法相应中断的任务永远无法被终止。但是他们也存在一定的区别：\n\n * shutdown：将线程的状态设置为 SHUTDOWN 状态，然后中断没有执行任务的线程。\n * shutdownNow：首先将线程的状态设置为 STOP ，然后尝试停止所有正在执行或者暂停任务的线程，并返回队列中的待执行任务。\n\n只要调用了这两个方法中的任意一个，isShutdown()方法就会返回true，当所有任务都关闭后，才表示线程池关闭成功，这是调用isTerminaed()方法才会返回 true 。\n\n\n通常调用 shutdown 来关闭线程池，如果不需要等任务执行完可以调用 shutdownNow 。\n\n\n# 合理的配置线程池\n\n 1. 最大线程数 maximumPoolSize 的是指可参考如下规则：\n    * CPU 密集型任务应该配置尽可能小的线程，如cpu数量+1。\n    * IO密集型任务线程并不是一直占用cpu，则应该适度更多的配置线程，如2*cpu数量\n    * 可以通过 Runtime.getRuntime().availableProcessors() 获得当前设备的 cpu 个数。\n 2. 建议使用有界队列。如果任务执行速度变慢，线程池不断向队列中 add 元素，会有内存溢出的风险。',normalizedContent:'# 使用线程池有哪些好处\n\n 1. 降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁的消耗。\n 2. 提高相应速度。当任务到达时，任务可以不需要线程创建就可以执行。\n 3. 提高线程的可管理性。线程是稀缺资源、如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性。使用线程池可以统一分配、调优和监控。\n\n\n# 线程池的创建\n\n我们可以通过 threadpoolexecutor 来创建一个线程池\n\npublic threadpoolexecutor(int corepoolsize,\n                              int maximumpoolsize,\n                              long keepalivetime,\n                              timeunit unit,\n                              blockingqueue<runnable> workqueue,\n                              threadfactory threadfactory,\n                              rejectedexecutionhandler handler) {//...}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建一个线程池需要传入如下几个参数：\n\n * corepoolsize： 线程池中的常驻核心线程数。\n   当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建线程。当线程池中的线程数量到达 corepoolsize 时就不再创建。如果调用了线程池的 prestartallcorethread()方法，线程池会在启动后就创建所有核心线程。\n\n * workqueue： 存放任务的阻塞队列，被提交但尚未被执行的任务。\n   可以选择如下几个阻塞队列： 1.arrayblockingqueue 2.linkedblockingqueue:吞吐量高于linkedblockingqueue，是 executors.newfixedthreadpool()创建的线程池的默认队列。 3.synchronousqueue:一个不存储元素的队列。每个提交的任务都必须等到线程来执行，否则阻塞提交。是 executors.newcachedthreadpool()创建的线程池的默认队列。 4.priorityblockingqueue:一个具有优先级的无限阻塞队列。\n\n * maximumpoolsize： 线程池最大线程数量。\n   如果队列满了并且已经创建的线程数量小于最大线程数量，则线程池会再继续创建新的线程执行任务。值得注意的是如果使用无界队列 (比如linkedblockingqueue)这个参数就没有意义了。\n\n * threadfactory： 用于设置创建线程的工厂\n   可以给创建的线程设置有意义的名字，可方便排查问题\n\n * handler： 拒绝策略，表示当队列满了且工作线程都满了如何来拒绝请求执行的线程的策略，默认是abortpolicy策略，主要有四种类型。\n\n 1. abortpolicy 直接抛出regectedexcutionexception 异常阻止系统正常进行，默认策略\n\n 2. discardpolicy 直接丢弃任务，不予任何处理也不抛出异常，如果允许任务丢失，这是最好的一种方案\n\n 3. discardoldestpolicy 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务\n\n 4. callerrunspolicy 交给线程池调用所在的线程进行处理，“调用者运行”的一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量\n\n以上内置拒绝策略均实现了 rejectexcutionhandler 接口，我们也可以实现接口rejectexcutionhandler来自定义策略，如记录日志或者持久化不能拒绝的任务。\n\n * keepalivetime： 非核心线程存活时间\n   线程池中非核心线程空闲的存活时间 当前线程池数量超过 corepoolsize 时，当空闲时间达到 keepalivetime 值时，非核心线程会被销毁直到只剩下 corepoolsize 个线程为止。\n   \n\n> tips:如果任务很多并且任务执行时间比较短，可以调大 keepalivetime ，提高线程利用率。\n\n * unit： keepalivetime 的时间单位\n   \n\n\n# 向线程池提交一个任务后，线程池是如何处理这个任务的呢？\n\n\n\n 1. 如果当前运行的线程数<corepoolsize，则创建新线程来执行任务（这一步骤需要获取全局锁）。\n 2. 如果当前运行的线程数>=corepoolsize，则将任务加入阻塞队列。\n 3. 如果队列已满或者不能加入，接下来的处理分两种情况：\n    1. 线程池中的线程是否都处于工作状态。创建新的线程来执行任务（这一步骤需要获取全局锁）。\n    2. 线程池中有空闲的线程，则用其来执行任务。\n 4. 如果创建新线程会导致线程数量>maximumpoolsize，则执行拒绝策略。\n\n我们再从源码的角度来理解下这个过程：\nthreadpoolexecutor#execute(runnble command) 方法\n\npublic void execute(runnable command) {\n  // 参数校验\n    if (command == null)\n        throw new nullpointerexception();\n        \n    // 从 c 的值可以判断出线程池的状态, 以及线程池中线程的数量\n    int c = ctl.get();\n    // 1. 如果线程池的线程数量 小于 核心线程数\n    if (workercountof(c) < corepoolsize) {\n        // 添加一个核心线程 command 表示一个具体的任务， true 表示为核心线程\n        if (addworker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 2. 如果线程池处于 running 状态（只有处于此状态，才能接受新的任务）\n    // 并且线程池的数量大于核心线程数, 就把任务添加到阻塞队列\n    if (isrunning(c) && workqueue.offer(command)) {\n        int recheck = ctl.get();\n        if (! isrunning(recheck) && remove(command))\n            reject(command);\n        else if (workercountof(recheck) == 0)\n            addworker(null, false);\n    }\n    // 3. 如果队列也满了，就创建一个非核心线程（core==false）\n    else if (!addworker(command, false))\n        // 如果创建失败，就执行拒绝策略\n        reject(command);\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 线程池是如何工作的呢？\n\n线程池中有一个 workers 集合，里面记录了所有的工作线程，只有拿到 mainlock 锁的线程才能访问。 threadpoolexecutor#workers 属性\n\nprivate final hashset<worker> workers = new hashset<worker>();\n\n\n1\n\n\n线程池创建线程时，会将线程包装成 worker ，worker 在执行任务后还会循环获取队里里的任务。我们可以从 worker 类的 run() 方法看到这一点。\n\nfinal void runworker(worker w) {\n        thread wt = thread.currentthread();\n        runnable task = w.firsttask;\n        w.firsttask = null;\n        w.unlock(); // allow interrupts\n        boolean completedabruptly = true;\n        try {\n            while (task != null || (task = gettask()) != null) {\n                w.lock();\n                if ((runstateatleast(ctl.get(), stop) ||\n                     (thread.interrupted() &&\n                      runstateatleast(ctl.get(), stop))) &&\n                    !wt.isinterrupted())\n                    wt.interrupt();\n                try {\n                    beforeexecute(wt, task);\n                    throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (runtimeexception x) {\n                        thrown = x; throw x;\n                    } catch (error x) {\n                        thrown = x; throw x;\n                    } catch (throwable x) {\n                        thrown = x; throw new error(x);\n                    } finally {\n                        afterexecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedtasks++;\n                    w.unlock();\n                }\n            }\n            completedabruptly = false;\n        } finally {\n            processworkerexit(w, completedabruptly);\n        }\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码关键点是while循环和gettask()方法，通过循环不断的调用gettask()从阻塞队列中获取任务，通过这个方法，它与阻塞队列建立桥梁。\n\n\n# 向线程池提交任务\n\n有两个方法提交任务，分别是execute(),submit()\n\n\n * execute()：execute只能提交runnable类型的任务,用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。如果遇到异常会直接抛出。使用方法如下：\n\npublic static void main(string[] args) throws exception{\n        executorservice es = executors.newsinglethreadexecutor();\n        runnable runnable = new runnable() {\n            @override\n            public void run() {\n                system.out.println("runnable线程处理开始...");\n            }\n        };\n        es.execute(runnable);\n        es.shutdown();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * submit()：submit既可以提交runnable类型的任务，也可以提交callable类型的任务，会有一个类型为future的返回值，但当任务类型为runnable时，返回值为null。如果遇到异常不会直接抛出，只有在使用future的get方法获取返回值时，才会抛出异常。使用方法：\n\npublic static void main(string[] args) throws exception{\n        executorservice es = executors.newsinglethreadexecutor();\n        callable callable = new callable() {\n            @override\n            public string call() throws exception {\n                system.out.println("线程处理开始...");\n                return "hello world";\n            }\n        };\n        future<string> future = es.submit(callable);\n        while(true) {\n            //iddone:如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。\n            if(future.isdone()) {\n                system.out.println("任务执行完成：" + future.get());\n                break;\n            }\n        }\n        es.shutdown();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 关闭线程池\n\n可以通过shutdown和shutdownnow方法来关闭线程池。他们的原理是遍历线程池的中工作线程，调用其interrupt()方法来中断线程，所以，无法相应中断的任务永远无法被终止。但是他们也存在一定的区别：\n\n * shutdown：将线程的状态设置为 shutdown 状态，然后中断没有执行任务的线程。\n * shutdownnow：首先将线程的状态设置为 stop ，然后尝试停止所有正在执行或者暂停任务的线程，并返回队列中的待执行任务。\n\n只要调用了这两个方法中的任意一个，isshutdown()方法就会返回true，当所有任务都关闭后，才表示线程池关闭成功，这是调用isterminaed()方法才会返回 true 。\n\n\n通常调用 shutdown 来关闭线程池，如果不需要等任务执行完可以调用 shutdownnow 。\n\n\n# 合理的配置线程池\n\n 1. 最大线程数 maximumpoolsize 的是指可参考如下规则：\n    * cpu 密集型任务应该配置尽可能小的线程，如cpu数量+1。\n    * io密集型任务线程并不是一直占用cpu，则应该适度更多的配置线程，如2*cpu数量\n    * 可以通过 runtime.getruntime().availableprocessors() 获得当前设备的 cpu 个数。\n 2. 建议使用有界队列。如果任务执行速度变慢，线程池不断向队列中 add 元素，会有内存溢出的风险。',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 CAS 原理，什么是 ABA 问题，怎么解决？",frontmatter:{title:"简述 CAS 原理，什么是 ABA 问题，怎么解决？",date:"2022-04-04T14:32:48.000Z",permalink:"/pages/3356c6/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/020.%E7%AE%80%E8%BF%B0%20CAS%20%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%20ABA%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/020.简述 CAS 原理，什么是 ABA 问题，怎么解决？.md",key:"v-5390e3d4",path:"/pages/3356c6/",headers:[{level:2,title:"简述 CAS 原理，什么是 ABA 问题，怎么解决？",slug:"简述-cas-原理-什么是-aba-问题-怎么解决",normalizedTitle:"简述 cas 原理，什么是 aba 问题，怎么解决？",charIndex:2},{level:3,title:"CAS实现原子操作",slug:"cas实现原子操作",normalizedTitle:"cas实现原子操作",charIndex:33},{level:3,title:"ABA问题",slug:"aba问题",normalizedTitle:"aba问题",charIndex:256}],headersStr:"简述 CAS 原理，什么是 ABA 问题，怎么解决？ CAS实现原子操作 ABA问题",content:"# 简述 CAS 原理，什么是 ABA 问题，怎么解决？\n\n\n# CAS实现原子操作\n\nCAS理论是 juc 包实现的基石，在intel的CPU中，CAS 通过调用本地方法（JNI）使用cmpxchg指令来实现的非阻塞算法。对比于synchronized阻塞算法，基于 CAS 实现的 juc 在性能上有了很大的提升。\n\nCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。\n\n\n# ABA问题\n\n * 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n\n * ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n\n * 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。",normalizedContent:"# 简述 cas 原理，什么是 aba 问题，怎么解决？\n\n\n# cas实现原子操作\n\ncas理论是 juc 包实现的基石，在intel的cpu中，cas 通过调用本地方法（jni）使用cmpxchg指令来实现的非阻塞算法。对比于synchronized阻塞算法，基于 cas 实现的 juc 在性能上有了很大的提升。\n\ncas 操作包含三个操作数 —— 内存位置（v）、预期原值（a）和新值(b)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。\n\n\n# aba问题\n\n * 因为cas需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是a，变成了b，又变成了a，那么使用cas进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n\n * aba问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么a－b－a 就会变成1a-2b－3a。\n\n * 从java1.5开始jdk的atomic包里提供了一个类atomicstampedreference来解决aba问题。这个类的compareandset方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Synchronized 与 Lock 相比优缺点分别是什么？",frontmatter:{title:"Synchronized 与 Lock 相比优缺点分别是什么？",date:"2022-04-04T14:33:27.000Z",permalink:"/pages/d5d161/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/040.Synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/040.Synchronized 关键字底层是如何实现的？.md",key:"v-352f36cc",path:"/pages/d5d161/",headers:[{level:2,title:"Lock 接口 VS Synchronized",slug:"lock-接口-vs-synchronized",normalizedTitle:"lock 接口 vs synchronized",charIndex:286},{level:2,title:"Lock 锁的常规用法",slug:"lock-锁的常规用法",normalizedTitle:"lock 锁的常规用法",charIndex:751},{level:2,title:"Lock 锁的API",slug:"lock-锁的api",normalizedTitle:"lock 锁的api",charIndex:928}],headersStr:"Lock 接口 VS Synchronized Lock 锁的常规用法 Lock 锁的API",content:"Lock 实现提供比使用 synchronized 方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition 。\n\n虽然 synchronized 方法和语句的范围机制使得使用监视器锁更容易编程，并且有助于避免涉及锁的许多常见编程错误，但是有时您需要以更灵活的方式处理锁。\n\n例如，您获取节点A的锁定，然后获取节点B，然后释放A并获取C，然后释放B并获得D等。\n\n所述的实施方式中Lock接口通过允许获得并在不同的范围释放的锁，并允许获得并以任何顺序释放多个锁使得能够使用这样的技术。\n\n\n# Lock 接口 VS Synchronized\n\nJava SE 5之后，juc 包中增加了 Lock 接口，在此之前 Java 是靠 Synchronized 关键字来实现锁功能的，二者具有相同的内存同步语义，区别如下：\n\n            SYNCHRONIZED      LOCK接口\n加锁、解锁       隐式的加锁、解锁          显式的加锁、解锁\n是否异常自动释放锁   是                 不是，必须手动unlock来释放锁\n是否支持相应中断    只能等待锁的释放，不能响应中断   等待锁过程中可以用interrupt来中断等待\n适用场景                          比如这种场景：先获得A锁，再获取B锁，获取到B锁释放A锁同时获取C锁，获得C锁后释放B锁在获取D锁。这种场景用Synchronized就不好实现了。\n\nLock 相比于 Synchronized 还有如下特性：\n\n * 尝试非阻塞获取锁\n * 能被中断的获取锁\n * 超时获取锁\n\n\n# Lock 锁的常规用法\n\n    Lock l = ...; \n    l.lock(); \n    try {\n        // access the resource protected by this lock }\n    finally { \n        l.unlock(); \n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Lock 锁的API\n\nLock 接口定义了所得获取和释放的基本操作， Lock的API如下：\n\n方法                                          描述\nvoid lock()                                 获得锁\nvoid lockInterruptibly()                    获取锁定，除非当前线程是 interrupted 。\nCondition newCondition()                    返回一个新Condition绑定到该实例Lock实例。\nboolean tryLock()                           只有在调用时才可以获得锁。\nboolean tryLock(long time, TimeUnit unit)   如果在给定的等待时间内是空闲的，并且当前的线程尚未得到 interrupted，则获取该锁\nvoid unlock()                               释放锁。",normalizedContent:"lock 实现提供比使用 synchronized 方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象condition 。\n\n虽然 synchronized 方法和语句的范围机制使得使用监视器锁更容易编程，并且有助于避免涉及锁的许多常见编程错误，但是有时您需要以更灵活的方式处理锁。\n\n例如，您获取节点a的锁定，然后获取节点b，然后释放a并获取c，然后释放b并获得d等。\n\n所述的实施方式中lock接口通过允许获得并在不同的范围释放的锁，并允许获得并以任何顺序释放多个锁使得能够使用这样的技术。\n\n\n# lock 接口 vs synchronized\n\njava se 5之后，juc 包中增加了 lock 接口，在此之前 java 是靠 synchronized 关键字来实现锁功能的，二者具有相同的内存同步语义，区别如下：\n\n            synchronized      lock接口\n加锁、解锁       隐式的加锁、解锁          显式的加锁、解锁\n是否异常自动释放锁   是                 不是，必须手动unlock来释放锁\n是否支持相应中断    只能等待锁的释放，不能响应中断   等待锁过程中可以用interrupt来中断等待\n适用场景                          比如这种场景：先获得a锁，再获取b锁，获取到b锁释放a锁同时获取c锁，获得c锁后释放b锁在获取d锁。这种场景用synchronized就不好实现了。\n\nlock 相比于 synchronized 还有如下特性：\n\n * 尝试非阻塞获取锁\n * 能被中断的获取锁\n * 超时获取锁\n\n\n# lock 锁的常规用法\n\n    lock l = ...; \n    l.lock(); \n    try {\n        // access the resource protected by this lock }\n    finally { \n        l.unlock(); \n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# lock 锁的api\n\nlock 接口定义了所得获取和释放的基本操作， lock的api如下：\n\n方法                                          描述\nvoid lock()                                 获得锁\nvoid lockinterruptibly()                    获取锁定，除非当前线程是 interrupted 。\ncondition newcondition()                    返回一个新condition绑定到该实例lock实例。\nboolean trylock()                           只有在调用时才可以获得锁。\nboolean trylock(long time, timeunit unit)   如果在给定的等待时间内是空闲的，并且当前的线程尚未得到 interrupted，则获取该锁\nvoid unlock()                               释放锁。",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"重入锁是如何实现的？",frontmatter:{title:"重入锁是如何实现的？",date:"2022-04-04T14:33:48.000Z",permalink:"/pages/9b59d1/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/050.%E9%87%8D%E5%85%A5%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/050.重入锁是如何实现的？.md",key:"v-4927c049",path:"/pages/9b59d1/",headers:[{level:2,title:"什么是重入锁？",slug:"什么是重入锁",normalizedTitle:"什么是重入锁？",charIndex:2},{level:2,title:"ReentrantLock - 重入锁加锁",slug:"reentrantlock-重入锁加锁",normalizedTitle:"reentrantlock - 重入锁加锁",charIndex:362},{level:2,title:"ReentrantLock - 重入锁解锁",slug:"reentrantlock-重入锁解锁",normalizedTitle:"reentrantlock - 重入锁解锁",charIndex:1186}],headersStr:"什么是重入锁？ ReentrantLock - 重入锁加锁 ReentrantLock - 重入锁解锁",content:'# 什么是重入锁？\n\nReentrantLock，重入锁，是JDK5中添加在并发包下的一个高性能的工具。顾名思义，ReentrantLock支持同一个线程在未释放锁的情况下重复获取锁。\n\n既然已经有了元老级的synchronized，而且synchronized也支持重入，为什么Doug Lea还要专门写一个ReentrantLock呢？\n\n这是因为：当存在大量线程竞争锁时，多数情况下ReentrantLock的性能优于synchronized。\n\n因为在JDK6中对synchronized做了优化，在锁竞争不激烈的时候，多数情况下锁会停留在偏向锁和轻量级锁阶段，这两个阶段性能是很好的。当存在大量竞争时，可能会膨胀为重量级锁，性能下降，此时的ReentrantLock应该是优于synchronized的。\n\n\n# ReentrantLock - 重入锁加锁\n\n// acquires的值是1\nfinal boolean nonfairTryAcquire(int acquires) {\n  // 获取当前线程\n  final Thread current = Thread.currentThread();\n  // 获取state的值\n  int c = getState();\n  // 如果state的值等于0，表示当前没有线程持有锁\n  // 尝试将state的值改为1，如果修改成功，则成功获取锁，并设置当前线程为持有锁的线程，返回true\n  if (c == 0) {\n    if (compareAndSetState(0, acquires)) {\n      setExclusiveOwnerThread(current);\n      return true;\n    }\n  }\n  // state的值不等于0，表示已经有其他线程持有锁\n  // 判断当前线程是否等于持有锁的线程，如果等于，将state的值+1，并设置到state上，获取锁成功，返回true\n  // 如果不是当前线程，获取锁失败，返回false\n  else if (current == getExclusiveOwnerThread()) {\n    int nextc = c + acquires;\n    if (nextc < 0) // overflow\n      throw new Error("Maximum lock count exceeded");\n    setState(nextc);\n    return true;\n  }\n  return false;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# ReentrantLock - 重入锁解锁\n\npublic void unlock() {\n    // 调用AQS的release方法释放资源\n    sync.release(1);\n}\n\n\n1\n2\n3\n4\n\n\npublic final boolean release(int arg) {\n    // tryRelease也是模板方法，在Sync中实现\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            // 成功释放锁后，唤醒同步队列中的下一个节点，使之可以重新竞争锁\n            // 注意此时不会唤醒队列第一个节点之后的节点，这些节点此时还是无法竞争锁\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nprotected final boolean tryRelease(int releases) {\n    // 将state的值-1，如果-1之后等于0，释放锁成功\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# 什么是重入锁？\n\nreentrantlock，重入锁，是jdk5中添加在并发包下的一个高性能的工具。顾名思义，reentrantlock支持同一个线程在未释放锁的情况下重复获取锁。\n\n既然已经有了元老级的synchronized，而且synchronized也支持重入，为什么doug lea还要专门写一个reentrantlock呢？\n\n这是因为：当存在大量线程竞争锁时，多数情况下reentrantlock的性能优于synchronized。\n\n因为在jdk6中对synchronized做了优化，在锁竞争不激烈的时候，多数情况下锁会停留在偏向锁和轻量级锁阶段，这两个阶段性能是很好的。当存在大量竞争时，可能会膨胀为重量级锁，性能下降，此时的reentrantlock应该是优于synchronized的。\n\n\n# reentrantlock - 重入锁加锁\n\n// acquires的值是1\nfinal boolean nonfairtryacquire(int acquires) {\n  // 获取当前线程\n  final thread current = thread.currentthread();\n  // 获取state的值\n  int c = getstate();\n  // 如果state的值等于0，表示当前没有线程持有锁\n  // 尝试将state的值改为1，如果修改成功，则成功获取锁，并设置当前线程为持有锁的线程，返回true\n  if (c == 0) {\n    if (compareandsetstate(0, acquires)) {\n      setexclusiveownerthread(current);\n      return true;\n    }\n  }\n  // state的值不等于0，表示已经有其他线程持有锁\n  // 判断当前线程是否等于持有锁的线程，如果等于，将state的值+1，并设置到state上，获取锁成功，返回true\n  // 如果不是当前线程，获取锁失败，返回false\n  else if (current == getexclusiveownerthread()) {\n    int nextc = c + acquires;\n    if (nextc < 0) // overflow\n      throw new error("maximum lock count exceeded");\n    setstate(nextc);\n    return true;\n  }\n  return false;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# reentrantlock - 重入锁解锁\n\npublic void unlock() {\n    // 调用aqs的release方法释放资源\n    sync.release(1);\n}\n\n\n1\n2\n3\n4\n\n\npublic final boolean release(int arg) {\n    // tryrelease也是模板方法，在sync中实现\n    if (tryrelease(arg)) {\n        node h = head;\n        if (h != null && h.waitstatus != 0)\n            // 成功释放锁后，唤醒同步队列中的下一个节点，使之可以重新竞争锁\n            // 注意此时不会唤醒队列第一个节点之后的节点，这些节点此时还是无法竞争锁\n            unparksuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nprotected final boolean tryrelease(int releases) {\n    // 将state的值-1，如果-1之后等于0，释放锁成功\n    int c = getstate() - releases;\n    if (thread.currentthread() != getexclusiveownerthread())\n        throw new illegalmonitorstateexception();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setexclusiveownerthread(null);\n    }\n    setstate(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 Java 锁升级的机制",frontmatter:{title:"简述 Java 锁升级的机制",date:"2022-04-04T14:34:27.000Z",permalink:"/pages/ff0616/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/070.%E7%AE%80%E8%BF%B0%20Java%20%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%9C%BA%E5%88%B6.html",relativePath:"01.Java相关/20.并发/070.简述 Java 锁升级的机制.md",key:"v-1065f7be",path:"/pages/ff0616/",headers:[{level:3,title:"偏向锁",slug:"偏向锁",normalizedTitle:"偏向锁",charIndex:83},{level:3,title:"轻量级锁",slug:"轻量级锁",normalizedTitle:"轻量级锁",charIndex:94},{level:3,title:"重量级锁",slug:"重量级锁",normalizedTitle:"重量级锁",charIndex:18},{level:3,title:"锁升级",slug:"锁升级",normalizedTitle:"锁升级",charIndex:659},{level:3,title:"锁的优缺点对比",slug:"锁的优缺点对比",normalizedTitle:"锁的优缺点对比",charIndex:910}],headersStr:"偏向锁 轻量级锁 重量级锁 锁升级 锁的优缺点对比",content:"Synchronized 一直被称为重量级锁。但是在JDK 1.6之后它已经变得不那么重了。JDK 1.6 对Synchronized 的优化点在于：\n\n * 引入了偏向锁\n\n * 引入了轻量级锁\n\n在JDK 1.6 中，Synchronized 锁有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。\n\n\n这几个状态会随着锁竞争升级，但是不可以降级。\n\n\n# 偏向锁\n\n为什么引入偏向锁?\n\n\n不存锁竞争，或者总是由同一线程多次获得锁的场景，偏向锁的代价更低。\n\n当一个线程访问同步块并获取到锁时，在锁对象头记录该线程的id，以后该线程进入和退出该同步块时不需要CAS来加锁和解锁。\n\n偏向锁何时释放？\n\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n\n\n\n偏向锁一定起到正面作用吗？\n\n\n不是的。\n\n\n偏向锁的适用场景是：不存锁竞争，或者总是由同一线程多次获得锁的场景。\n\n如果你确定你的程序中 锁通常处于竞争状态，可以通过JVM参数关闭偏向锁。关闭后，程序回魔人进入轻量级锁状态。\n\n\n-XX:UseBiasedLocking=false\n\n\n\n1\n2\n3\n\n\n\n# 轻量级锁\n\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。\n\n轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n轻量级锁何时升级为重量级锁?\n\n\n若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。\n\n另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。\n\n\n# 重量级锁\n\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。\n\n重量级锁的获取是释放一般会有线程上下文切换，代价是比较大的，所以说是重量级锁。\n\n\n# 锁升级\n\n\n\n\n# 锁的优缺点对比\n\n",normalizedContent:"synchronized 一直被称为重量级锁。但是在jdk 1.6之后它已经变得不那么重了。jdk 1.6 对synchronized 的优化点在于：\n\n * 引入了偏向锁\n\n * 引入了轻量级锁\n\n在jdk 1.6 中，synchronized 锁有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。\n\n\n这几个状态会随着锁竞争升级，但是不可以降级。\n\n\n# 偏向锁\n\n为什么引入偏向锁?\n\n\n不存锁竞争，或者总是由同一线程多次获得锁的场景，偏向锁的代价更低。\n\n当一个线程访问同步块并获取到锁时，在锁对象头记录该线程的id，以后该线程进入和退出该同步块时不需要cas来加锁和解锁。\n\n偏向锁何时释放？\n\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n\n\n\n偏向锁一定起到正面作用吗？\n\n\n不是的。\n\n\n偏向锁的适用场景是：不存锁竞争，或者总是由同一线程多次获得锁的场景。\n\n如果你确定你的程序中 锁通常处于竞争状态，可以通过jvm参数关闭偏向锁。关闭后，程序回魔人进入轻量级锁状态。\n\n\n-xx:usebiasedlocking=false\n\n\n\n1\n2\n3\n\n\n\n# 轻量级锁\n\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。\n\n轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n轻量级锁何时升级为重量级锁?\n\n\n若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。\n\n另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。\n\n\n# 重量级锁\n\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。\n\n重量级锁的获取是释放一般会有线程上下文切换，代价是比较大的，所以说是重量级锁。\n\n\n# 锁升级\n\n\n\n\n# 锁的优缺点对比\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"volatile 关键字解决了什么问题，它的实现原理是什么？",frontmatter:{title:"volatile 关键字解决了什么问题，它的实现原理是什么？",date:"2022-04-04T14:34:07.000Z",permalink:"/pages/383264/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/060.volatile%20%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/060.volatile 关键字解决了什么问题，它的实现原理是什么？.md",key:"v-f5bcd180",path:"/pages/383264/",headers:[{level:2,title:"Java中的内存可见性",slug:"java中的内存可见性",normalizedTitle:"java中的内存可见性",charIndex:129},{level:2,title:"Volatile 的实现原理",slug:"volatile-的实现原理",normalizedTitle:"volatile 的实现原理",charIndex:335}],headersStr:"Java中的内存可见性 Volatile 的实现原理",content:"volatile 能保证 Java 中的内存可见性。 可见性的意思是：当线程A修改共享变量的值后，线程B能立刻读到这个修改后的值。\n\n\nVolatile 不会引起线程上下文的切换和调度，如果使用的恰当，会比 Synchronized 执行成本更低。\n\n\n# Java中的内存可见性\n\n * 可见性：一个线程对共享变量值的修改，能够及时被其他线程看到。\n\n * 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那这个变量就是这几个线程的共享变量。\n\n * Java内存的规定：\n\n-线程对共享变量的所有操作都必须在自己的工作内存中进行，不可直接从主内存中读写； -不同线程之间无法直接访问其他线程工作内存中的变量，线程间的变量值的传递需要通过主内存。\n\n\n\n\n# Volatile 的实现原理\n\n如果对用 Volatile 修饰的变量写操作，JVM 会向处理器发出一条 Lock 前缀的指令，Lock 前缀的指令在多核处理器下会引发两件事情：\n\n 1. 将当前处理器缓存行的数据写会到系统内存\n\n 2. 这个写会内存的操作会使其他缓存中的该内存地址的数据无效",normalizedContent:"volatile 能保证 java 中的内存可见性。 可见性的意思是：当线程a修改共享变量的值后，线程b能立刻读到这个修改后的值。\n\n\nvolatile 不会引起线程上下文的切换和调度，如果使用的恰当，会比 synchronized 执行成本更低。\n\n\n# java中的内存可见性\n\n * 可见性：一个线程对共享变量值的修改，能够及时被其他线程看到。\n\n * 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那这个变量就是这几个线程的共享变量。\n\n * java内存的规定：\n\n-线程对共享变量的所有操作都必须在自己的工作内存中进行，不可直接从主内存中读写； -不同线程之间无法直接访问其他线程工作内存中的变量，线程间的变量值的传递需要通过主内存。\n\n\n\n\n# volatile 的实现原理\n\n如果对用 volatile 修饰的变量写操作，jvm 会向处理器发出一条 lock 前缀的指令，lock 前缀的指令在多核处理器下会引发两件事情：\n\n 1. 将当前处理器缓存行的数据写会到系统内存\n\n 2. 这个写会内存的操作会使其他缓存中的该内存地址的数据无效",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点",frontmatter:{title:"简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点",date:"2022-04-04T14:33:06.000Z",permalink:"/pages/97245f/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/030.%E7%AE%80%E8%BF%B0%20Synchronized%EF%BC%8CVolatile%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9.html",relativePath:"01.Java相关/20.并发/030.简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点.md",key:"v-35324a50",path:"/pages/97245f/",headers:[{level:2,title:"Java中的内存可见性",slug:"java中的内存可见性",normalizedTitle:"java中的内存可见性",charIndex:198},{level:2,title:"Volatile 的实现原理",slug:"volatile-的实现原理",normalizedTitle:"volatile 的实现原理",charIndex:404},{level:2,title:"Synchronized 的用法",slug:"synchronized-的用法",normalizedTitle:"synchronized 的用法",charIndex:556},{level:2,title:"Synchronized 的锁存储在哪里？",slug:"synchronized-的锁存储在哪里",normalizedTitle:"synchronized 的锁存储在哪里？",charIndex:837},{level:2,title:"为什么Java中每个对象都可以作为锁？",slug:"为什么java中每个对象都可以作为锁",normalizedTitle:"为什么java中每个对象都可以作为锁？",charIndex:1068},{level:2,title:"Synchronized 锁升级",slug:"synchronized-锁升级",normalizedTitle:"synchronized 锁升级",charIndex:1374},{level:3,title:"偏向锁",slug:"偏向锁",normalizedTitle:"偏向锁",charIndex:1012},{level:3,title:"轻量级锁",slug:"轻量级锁",normalizedTitle:"轻量级锁",charIndex:996},{level:3,title:"重量级锁",slug:"重量级锁",normalizedTitle:"重量级锁",charIndex:1001},{level:3,title:"锁升级",slug:"锁升级",normalizedTitle:"锁升级",charIndex:1387},{level:3,title:"锁的优缺点对比",slug:"锁的优缺点对比",normalizedTitle:"锁的优缺点对比",charIndex:2302},{level:2,title:"Java如何实现原子操作",slug:"java如何实现原子操作",normalizedTitle:"java如何实现原子操作",charIndex:2316},{level:3,title:"CAS实现原子操作",slug:"cas实现原子操作",normalizedTitle:"cas实现原子操作",charIndex:2400},{level:3,title:"CAS 存在的三个问题",slug:"cas-存在的三个问题",normalizedTitle:"cas 存在的三个问题",charIndex:2623},{level:3,title:"锁机制实现原子操作",slug:"锁机制实现原子操作",normalizedTitle:"锁机制实现原子操作",charIndex:3081}],headersStr:"Java中的内存可见性 Volatile 的实现原理 Synchronized 的用法 Synchronized 的锁存储在哪里？ 为什么Java中每个对象都可以作为锁？ Synchronized 锁升级 偏向锁 轻量级锁 重量级锁 锁升级 锁的优缺点对比 Java如何实现原子操作 CAS实现原子操作 CAS 存在的三个问题 锁机制实现原子操作",content:"在多线程编程中 Synchronized，Volatile 都扮演着重要角色, 都已用来实现原子操作。 Volatile 是轻量级的 Synchronized ，保证了共享变量的可见性。\n\n\n可见性的意思是：当线程A修改共享变量的值后，线程B能立刻读到这个修改后的值。\n\n\nVolatile 不会引起线程上下文的切换和调度，如果使用的恰当，会比 Synchronized 执行成本更低。\n\n\n# Java中的内存可见性\n\n * 可见性：一个线程对共享变量值的修改，能够及时被其他线程看到。\n\n * 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那这个变量就是这几个线程的共享变量。\n\n * Java内存的规定：\n\n-线程对共享变量的所有操作都必须在自己的工作内存中进行，不可直接从主内存中读写； -不同线程之间无法直接访问其他线程工作内存中的变量，线程间的变量值的传递需要通过主内存。\n\n\n\n\n# Volatile 的实现原理\n\n如果对用 Volatile 修饰的变量写操作，JVM 会向处理器发出一条 Lock 前缀的指令，Lock 前缀的指令在多核处理器下会引发两件事情：\n\n 1. 将当前处理器缓存行的数据写会到系统内存\n\n 2. 这个写会内存的操作会使其他缓存中的该内存地址的数据无效\n\n\n# Synchronized 的用法\n\n 1. 普通同步方法：锁当前实例对象\n\n\npublic synchronized void method() {\n\n}\n\n\n\n1\n2\n3\n4\n5\n\n 2. 静态同步方法：锁当前类的Class对象\n\n\npublic synchronized static void method() {\n\n}\n\n\n\n1\n2\n3\n4\n5\n\n 3. 同步代码块：锁括号里对象\n\n\npublic void method()\n\n{\n\nsynchronized(this) {\n\n}\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Synchronized 的锁存储在哪里？\n\nSynchronized的锁存储在Java的对象头里。\n\n\n\nJava 对象头里的 Mark Word 用于存储对象的 HashCode 、分代年龄和锁标记位。\n\n\n32位虚拟机中， Mark Word 的存储结构如下：\n\n\n\n在运行期， Mark Word 有四种状态：轻量级锁、重量级锁、GC 标记、偏向锁，各状态下的存储结构如下图：\n\n\n\n在64位虚拟机下，Mark Word 的存储结构如下图：\n\n\n\n\n# 为什么Java中每个对象都可以作为锁？\n\n任何对象都有一个 monitor 与之关联，当一个 monitor 被持有后，他将处于锁定状态。monitor 是用 C++ 实现的。\n\n同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\n\nmonitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到同步块的结束处和异常处，JVM 要保证每个 monitorenter 都有 monitorexit 与之配对。\n\n\n# Synchronized 锁升级\n\nSynchronized 一直被称为重量级锁。但是在JDK 1.6之后它已经变得不那么重了。JDK 1.6 对Synchronized 的优化点在于：\n\n * 引入了偏向锁\n\n * 引入了轻量级锁\n\n在JDK 1.6 中，Synchronized 锁有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。\n\n\n这几个状态会随着锁竞争升级，但是不可以降级。\n\n\n# 偏向锁\n\n为什么引入偏向锁?\n\n\n不存锁竞争，或者总是由同一线程多次获得锁的场景，偏向锁的代价更低。\n\n当一个线程访问同步块并获取到锁时，在锁对象头记录该线程的id，以后该线程进入和退出该同步块时不需要CAS来加锁和解锁。\n\n偏向锁何时释放？\n\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n\n\n\n偏向锁一定起到正面作用吗？\n\n\n不是的。\n\n\n偏向锁的适用场景是：不存锁竞争，或者总是由同一线程多次获得锁的场景。\n\n如果你确定你的程序中 锁通常处于竞争状态，可以通过JVM参数关闭偏向锁。关闭后，程序回魔人进入轻量级锁状态。\n\n\n-XX:UseBiasedLocking=false\n\n\n\n1\n2\n3\n\n\n\n# 轻量级锁\n\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。\n\n轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n轻量级锁何时升级为重量级锁?\n\n\n若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。\n\n另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。\n\n\n# 重量级锁\n\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。\n\n重量级锁的获取是释放一般会有线程上下文切换，代价是比较大的，所以说是重量级锁。\n\n\n# 锁升级\n\n\n\n\n# 锁的优缺点对比\n\n\n\n\n# Java如何实现原子操作\n\n原子操作：不可被中断的一个或一系列操作。\n\n\nJava 有两种实现原子操作的方式：CAS（compare and swap）、锁。\n\n\n# CAS实现原子操作\n\nCAS理论是 juc 包实现的基石，在intel的CPU中，CAS 通过调用本地方法（JNI）使用cmpxchg指令来实现的非阻塞算法。对比于synchronized阻塞算法，基于 CAS 实现的 juc 在性能上有了很大的提升。\n\nCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。\n\n\n# CAS 存在的三个问题\n\n 1. ABA问题\n\n * 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n\n * ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n\n * 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\n\n 2. 循环时间长开销大\n\n 3. 只能保证一个共享变量的原子操作\n\n从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。\n\n\n# 锁机制实现原子操作\n\n锁机制保证了只有获得锁的线程才能操作指定的内存区域。除了偏向锁，JVM实现锁的方式都使用了循环CAS。",normalizedContent:"在多线程编程中 synchronized，volatile 都扮演着重要角色, 都已用来实现原子操作。 volatile 是轻量级的 synchronized ，保证了共享变量的可见性。\n\n\n可见性的意思是：当线程a修改共享变量的值后，线程b能立刻读到这个修改后的值。\n\n\nvolatile 不会引起线程上下文的切换和调度，如果使用的恰当，会比 synchronized 执行成本更低。\n\n\n# java中的内存可见性\n\n * 可见性：一个线程对共享变量值的修改，能够及时被其他线程看到。\n\n * 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那这个变量就是这几个线程的共享变量。\n\n * java内存的规定：\n\n-线程对共享变量的所有操作都必须在自己的工作内存中进行，不可直接从主内存中读写； -不同线程之间无法直接访问其他线程工作内存中的变量，线程间的变量值的传递需要通过主内存。\n\n\n\n\n# volatile 的实现原理\n\n如果对用 volatile 修饰的变量写操作，jvm 会向处理器发出一条 lock 前缀的指令，lock 前缀的指令在多核处理器下会引发两件事情：\n\n 1. 将当前处理器缓存行的数据写会到系统内存\n\n 2. 这个写会内存的操作会使其他缓存中的该内存地址的数据无效\n\n\n# synchronized 的用法\n\n 1. 普通同步方法：锁当前实例对象\n\n\npublic synchronized void method() {\n\n}\n\n\n\n1\n2\n3\n4\n5\n\n 2. 静态同步方法：锁当前类的class对象\n\n\npublic synchronized static void method() {\n\n}\n\n\n\n1\n2\n3\n4\n5\n\n 3. 同步代码块：锁括号里对象\n\n\npublic void method()\n\n{\n\nsynchronized(this) {\n\n}\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# synchronized 的锁存储在哪里？\n\nsynchronized的锁存储在java的对象头里。\n\n\n\njava 对象头里的 mark word 用于存储对象的 hashcode 、分代年龄和锁标记位。\n\n\n32位虚拟机中， mark word 的存储结构如下：\n\n\n\n在运行期， mark word 有四种状态：轻量级锁、重量级锁、gc 标记、偏向锁，各状态下的存储结构如下图：\n\n\n\n在64位虚拟机下，mark word 的存储结构如下图：\n\n\n\n\n# 为什么java中每个对象都可以作为锁？\n\n任何对象都有一个 monitor 与之关联，当一个 monitor 被持有后，他将处于锁定状态。monitor 是用 c++ 实现的。\n\n同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\n\nmonitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到同步块的结束处和异常处，jvm 要保证每个 monitorenter 都有 monitorexit 与之配对。\n\n\n# synchronized 锁升级\n\nsynchronized 一直被称为重量级锁。但是在jdk 1.6之后它已经变得不那么重了。jdk 1.6 对synchronized 的优化点在于：\n\n * 引入了偏向锁\n\n * 引入了轻量级锁\n\n在jdk 1.6 中，synchronized 锁有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。\n\n\n这几个状态会随着锁竞争升级，但是不可以降级。\n\n\n# 偏向锁\n\n为什么引入偏向锁?\n\n\n不存锁竞争，或者总是由同一线程多次获得锁的场景，偏向锁的代价更低。\n\n当一个线程访问同步块并获取到锁时，在锁对象头记录该线程的id，以后该线程进入和退出该同步块时不需要cas来加锁和解锁。\n\n偏向锁何时释放？\n\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n\n\n\n偏向锁一定起到正面作用吗？\n\n\n不是的。\n\n\n偏向锁的适用场景是：不存锁竞争，或者总是由同一线程多次获得锁的场景。\n\n如果你确定你的程序中 锁通常处于竞争状态，可以通过jvm参数关闭偏向锁。关闭后，程序回魔人进入轻量级锁状态。\n\n\n-xx:usebiasedlocking=false\n\n\n\n1\n2\n3\n\n\n\n# 轻量级锁\n\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。\n\n轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n轻量级锁何时升级为重量级锁?\n\n\n若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。\n\n另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。\n\n\n# 重量级锁\n\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。\n\n重量级锁的获取是释放一般会有线程上下文切换，代价是比较大的，所以说是重量级锁。\n\n\n# 锁升级\n\n\n\n\n# 锁的优缺点对比\n\n\n\n\n# java如何实现原子操作\n\n原子操作：不可被中断的一个或一系列操作。\n\n\njava 有两种实现原子操作的方式：cas（compare and swap）、锁。\n\n\n# cas实现原子操作\n\ncas理论是 juc 包实现的基石，在intel的cpu中，cas 通过调用本地方法（jni）使用cmpxchg指令来实现的非阻塞算法。对比于synchronized阻塞算法，基于 cas 实现的 juc 在性能上有了很大的提升。\n\ncas 操作包含三个操作数 —— 内存位置（v）、预期原值（a）和新值(b)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。\n\n\n# cas 存在的三个问题\n\n 1. aba问题\n\n * 因为cas需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是a，变成了b，又变成了a，那么使用cas进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n\n * aba问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么a－b－a 就会变成1a-2b－3a。\n\n * 从java1.5开始jdk的atomic包里提供了一个类atomicstampedreference来解决aba问题。这个类的compareandset方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\n\n 2. 循环时间长开销大\n\n 3. 只能保证一个共享变量的原子操作\n\n从java1.5开始jdk提供了atomicreference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行cas操作。\n\n\n# 锁机制实现原子操作\n\n锁机制保证了只有获得锁的线程才能操作指定的内存区域。除了偏向锁，jvm实现锁的方式都使用了循环cas。",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"什么是公平锁？什么是非公平锁？",frontmatter:{title:"什么是公平锁？什么是非公平锁？",date:"2022-04-04T14:35:15.000Z",permalink:"/pages/fd6a59/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/090.%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/090.什么是公平锁？什么是非公平锁？.md",key:"v-134f28dc",path:"/pages/fd6a59/",headers:[{level:2,title:"什么是公平锁？什么是非公平锁？",slug:"什么是公平锁-什么是非公平锁",normalizedTitle:"什么是公平锁？什么是非公平锁？",charIndex:2}],headersStr:"什么是公平锁？什么是非公平锁？",content:"# 什么是公平锁？什么是非公平锁？\n\n其中sync是AbstractQueuedSynchronizer的实现，我们知道，ReentrantLock支持公平锁和非公平锁，其实现类分别是FairSync和NonfairSync，我们看看公平锁和非公平锁分别是怎么实现的\n\n// FairSync 公平锁的实现\nfinal void lock() {\n    acquire(1);\n}\n\n// NonfairSync 非公平锁的实现\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到，非公平锁的实现仅仅是多了一个步骤：通过CAS的方式(compareAndSetState)尝试改变state的状态，修改成功后设置当前线程以独占的方式获取了锁，修改失败执行的逻辑和公平锁一样。\n\n从这段代码中可以看到，独占锁加锁的核心逻辑就是acquire方法，接下来就看看这个方法\n\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个方法是 AQS 的核心代码。",normalizedContent:"# 什么是公平锁？什么是非公平锁？\n\n其中sync是abstractqueuedsynchronizer的实现，我们知道，reentrantlock支持公平锁和非公平锁，其实现类分别是fairsync和nonfairsync，我们看看公平锁和非公平锁分别是怎么实现的\n\n// fairsync 公平锁的实现\nfinal void lock() {\n    acquire(1);\n}\n\n// nonfairsync 非公平锁的实现\nfinal void lock() {\n    if (compareandsetstate(0, 1))\n        setexclusiveownerthread(thread.currentthread());\n    else\n        acquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到，非公平锁的实现仅仅是多了一个步骤：通过cas的方式(compareandsetstate)尝试改变state的状态，修改成功后设置当前线程以独占的方式获取了锁，修改失败执行的逻辑和公平锁一样。\n\n从这段代码中可以看到，独占锁加锁的核心逻辑就是acquire方法，接下来就看看这个方法\n\npublic final void acquire(int arg) {\n    if (!tryacquire(arg) &&\n        acquirequeued(addwaiter(node.exclusive), arg))\n        selfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个方法是 aqs 的核心代码。",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Java 的线程有哪些状态，转换关系是怎么样的？",frontmatter:{title:"Java 的线程有哪些状态，转换关系是怎么样的？",date:"2022-04-04T14:35:37.000Z",permalink:"/pages/52483b/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/100.Java%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/100.Java 的线程有哪些状态，转换关系是怎么样的？.md",key:"v-03e420c4",path:"/pages/52483b/",headers:[{level:2,title:"Java 的线程有哪些状态，转换关系是怎么样的？",slug:"java-的线程有哪些状态-转换关系是怎么样的",normalizedTitle:"java 的线程有哪些状态，转换关系是怎么样的？",charIndex:2},{level:2,title:"我的 Java 进程中有哪些线程？他们处于什么状态？",slug:"我的-java-进程中有哪些线程-他们处于什么状态",normalizedTitle:"我的 java 进程中有哪些线程？他们处于什么状态？",charIndex:855},{level:3,title:"jstack 命令",slug:"jstack-命令",normalizedTitle:"jstack 命令",charIndex:891},{level:3,title:"Arthas",slug:"arthas",normalizedTitle:"arthas",charIndex:901}],headersStr:"Java 的线程有哪些状态，转换关系是怎么样的？ 我的 Java 进程中有哪些线程？他们处于什么状态？ jstack 命令 Arthas",content:'# Java 的线程有哪些状态，转换关系是怎么样的？\n\nJava 线程状态转换如下：\n\n * 初始化（NEW）: 调用new Thread()方法后，线程处于初始化状态\n * 运行中（RUNNING）:调用thread.start()方法后，线程处于运行中（RUNNING）状态。运行中（RUNNING）状态的含义是当前线程获得了CPU时间片。\n * 就绪（READY）: 调用thread.yield()方法后，线程处于就绪（READY）状态。thread.yield()方法的含义是当前线程愿意让出CPU时间片给其他线程；当CPU空闲时，操作系统的线程调度程序会在就绪（READY）状态的线程中挑选一个线程运行。\n * 等待（WAITING）: 线程阻塞在进入JUC包下的Lock接口的线程，是等待（WAITING）状态，因为JUC包下的Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法\n * 超时等待（TIMED_WAITING）: 是在等待（WAITING）的基础上增加了超时限制，含义是在超时时间到达后，线程返回就绪（READY）状态。\n * 阻塞（BLOCKED) : 线程阻塞在进入synchronized同步块的线程，是阻塞（BLOCKED) 状态\n * 终止（TERMINATED）:\n\n这里涉及几个与线程同步以及线程调度相关的方法：\n\n * wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\n * sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；\n * notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；\n * notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n\n# 我的 Java 进程中有哪些线程？他们处于什么状态？\n\n这里介绍两个工具jstack 命令、Arthas工具。\n\n\n# jstack 命令\n\nJstack是Jdk自带的线程跟踪工具，用于打印指定Java进程的线程堆栈信息。\n\njstack -l [pid]\n\n\n1\n\n\n[pid] 可以通过 jps 命令查看\n\n举例\n\njstack -l 9008 >jstack.txt\n\n\n1\n\n\n导出jstack.txt文件如下：\n\nFull thread dump Java HotSpot(TM) Client VM (20.45-b01 mixed mode, sharing):\n\n"Attach Listener" daemon prio=10 tid=0x08251400 nid=0x11bd runnable [0x00000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n        - None\n\n"DestroyJavaVM" prio=10 tid=0xb3a0a800 nid=0xffa waiting on condition [0x00000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n        - None\n\n"Query Listener" prio=10 tid=0xb3a09800 nid=0x1023 runnable [0xb3b72000]\n   java.lang.Thread.State: RUNNABLE\n        at java.net.PlainSocketImpl.socketAccept(Native Method)\n        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:408)\n        - locked <0x70a84430> (a java.net.SocksSocketImpl)\n        at java.net.ServerSocket.implAccept(ServerSocket.java:462)\n        at java.net.ServerSocket.accept(ServerSocket.java:430)\n        at com.sun.tools.hat.internal.server.QueryListener.waitForRequests(QueryListener.java:76)\n        at com.sun.tools.hat.internal.server.QueryListener.run(QueryListener.java:65)\n        at java.lang.Thread.run(Thread.java:662)\nLocked ownable synchronizers:\n        - None\n\n"d&a-3588" daemon waiting for monitor entry [0x000000006e5d5000]\n  java.lang.Thread.State: BLOCKED (on object monitor)\n      at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()\n      - waiting to lock <0x0000000602f38e90> (a java.lang.Object)\n      at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()\n\n\n"Finalizer" daemon prio=10 tid=0x0820bc00 nid=0xffd in Object.wait() [0xb5075000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n- waiting on <0x7a2b6f50> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)\n        - locked <0x7a2b6f50> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:134)\n        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:171)\n\n   Locked ownable synchronizers:\n        - None\n\n"Reference Handler" daemon prio=10 tid=0x0820a400 nid=0xffc in Object.wait() [0xb50c7000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x7a2b6fe0> (a java.lang.ref.Reference$Lock)\n        at java.lang.Object.wait(Object.java:485)\n        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)\n        - locked <0x7a2b6fe0> (a java.lang.ref.Reference$Lock)\n\n   Locked ownable synchronizers:\n        - None\n\n"VM Thread" prio=10 tid=0x08200000 nid=0xffb runnable\n\n"VM Periodic Task Thread" prio=10 tid=0x08222400 nid=0x1001 waiting on condition\n\nJNI global references: 1317\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# Arthas\n\nArthas中文文档：https://arthas.aliyun.com/doc/\n\nArthas 功能强大 我们如果想查看线程状态，只需要使用命令 dashboard.\n\n$ dashboard\nID     NAME                   GROUP          PRIORI STATE  %CPU    TIME   INTERRU DAEMON\n17     pool-2-thread-1        system         5      WAITIN 67      0:0    false   false\n27     Timer-for-arthas-dashb system         10     RUNNAB 32      0:0    false   true\n11     AsyncAppender-Worker-a system         9      WAITIN 0       0:0    false   true\n9      Attach Listener        system         9      RUNNAB 0       0:0    false   true\n3      Finalizer              system         8      WAITIN 0       0:0    false   true\n2      Reference Handler      system         10     WAITIN 0       0:0    false   true\n4      Signal Dispatcher      system         9      RUNNAB 0       0:0    false   true\n26     as-command-execute-dae system         10     TIMED_ 0       0:0    false   true\n13     job-timeout            system         9      TIMED_ 0       0:0    false   true\n1      main                   main           5      TIMED_ 0       0:0    false   false\n14     nioEventLoopGroup-2-1  system         10     RUNNAB 0       0:0    false   false\n18     nioEventLoopGroup-2-2  system         10     RUNNAB 0       0:0    false   false\n23     nioEventLoopGroup-2-3  system         10     RUNNAB 0       0:0    false   false\n15     nioEventLoopGroup-3-1  system         10     RUNNAB 0       0:0    false   false\nMemory             used   total max    usage GC\nheap               32M    155M  1820M  1.77% gc.ps_scavenge.count  4\nps_eden_space      14M    65M   672M   2.21% gc.ps_scavenge.time(m 166\nps_survivor_space  4M     5M    5M           s)\nps_old_gen         12M    85M   1365M  0.91% gc.ps_marksweep.count 0\nnonheap            20M    23M   -1           gc.ps_marksweep.time( 0\ncode_cache         3M     5M    240M   1.32% ms )\nRuntime\nos.name                Mac OS X\nos.version             10.13.4\njava.version           1.8.0_162\njava.home              /Library/Java/JavaVir\n                       tualMachines/jdk1.8.0\n                       _162.jdk/Contents/Hom\n                       e/jre\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',normalizedContent:'# java 的线程有哪些状态，转换关系是怎么样的？\n\njava 线程状态转换如下：\n\n * 初始化（new）: 调用new thread()方法后，线程处于初始化状态\n * 运行中（running）:调用thread.start()方法后，线程处于运行中（running）状态。运行中（running）状态的含义是当前线程获得了cpu时间片。\n * 就绪（ready）: 调用thread.yield()方法后，线程处于就绪（ready）状态。thread.yield()方法的含义是当前线程愿意让出cpu时间片给其他线程；当cpu空闲时，操作系统的线程调度程序会在就绪（ready）状态的线程中挑选一个线程运行。\n * 等待（waiting）: 线程阻塞在进入juc包下的lock接口的线程，是等待（waiting）状态，因为juc包下的lock接口对于阻塞的实现均使用了locksupport类中的相关方法\n * 超时等待（timed_waiting）: 是在等待（waiting）的基础上增加了超时限制，含义是在超时时间到达后，线程返回就绪（ready）状态。\n * 阻塞（blocked) : 线程阻塞在进入synchronized同步块的线程，是阻塞（blocked) 状态\n * 终止（terminated）:\n\n这里涉及几个与线程同步以及线程调度相关的方法：\n\n * wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\n * sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理interruptedexception异常；\n * notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由jvm确定唤醒哪个线程，而且与优先级无关；\n * notityall()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n\n# 我的 java 进程中有哪些线程？他们处于什么状态？\n\n这里介绍两个工具jstack 命令、arthas工具。\n\n\n# jstack 命令\n\njstack是jdk自带的线程跟踪工具，用于打印指定java进程的线程堆栈信息。\n\njstack -l [pid]\n\n\n1\n\n\n[pid] 可以通过 jps 命令查看\n\n举例\n\njstack -l 9008 >jstack.txt\n\n\n1\n\n\n导出jstack.txt文件如下：\n\nfull thread dump java hotspot(tm) client vm (20.45-b01 mixed mode, sharing):\n\n"attach listener" daemon prio=10 tid=0x08251400 nid=0x11bd runnable [0x00000000]\n   java.lang.thread.state: runnable\n\n   locked ownable synchronizers:\n        - none\n\n"destroyjavavm" prio=10 tid=0xb3a0a800 nid=0xffa waiting on condition [0x00000000]\n   java.lang.thread.state: runnable\n\n   locked ownable synchronizers:\n        - none\n\n"query listener" prio=10 tid=0xb3a09800 nid=0x1023 runnable [0xb3b72000]\n   java.lang.thread.state: runnable\n        at java.net.plainsocketimpl.socketaccept(native method)\n        at java.net.plainsocketimpl.accept(plainsocketimpl.java:408)\n        - locked <0x70a84430> (a java.net.sockssocketimpl)\n        at java.net.serversocket.implaccept(serversocket.java:462)\n        at java.net.serversocket.accept(serversocket.java:430)\n        at com.sun.tools.hat.internal.server.querylistener.waitforrequests(querylistener.java:76)\n        at com.sun.tools.hat.internal.server.querylistener.run(querylistener.java:65)\n        at java.lang.thread.run(thread.java:662)\nlocked ownable synchronizers:\n        - none\n\n"d&a-3588" daemon waiting for monitor entry [0x000000006e5d5000]\n  java.lang.thread.state: blocked (on object monitor)\n      at com.jiuqi.dna.bap.authority.service.userservice$loginhandler.handle()\n      - waiting to lock <0x0000000602f38e90> (a java.lang.object)\n      at com.jiuqi.dna.bap.authority.service.userservice$loginhandler.handle()\n\n\n"finalizer" daemon prio=10 tid=0x0820bc00 nid=0xffd in object.wait() [0xb5075000]\n   java.lang.thread.state: waiting (on object monitor)\n        at java.lang.object.wait(native method)\n- waiting on <0x7a2b6f50> (a java.lang.ref.referencequeue$lock)\n        at java.lang.ref.referencequeue.remove(referencequeue.java:118)\n        - locked <0x7a2b6f50> (a java.lang.ref.referencequeue$lock)\n        at java.lang.ref.referencequeue.remove(referencequeue.java:134)\n        at java.lang.ref.finalizer$finalizerthread.run(finalizer.java:171)\n\n   locked ownable synchronizers:\n        - none\n\n"reference handler" daemon prio=10 tid=0x0820a400 nid=0xffc in object.wait() [0xb50c7000]\n   java.lang.thread.state: waiting (on object monitor)\n        at java.lang.object.wait(native method)\n        - waiting on <0x7a2b6fe0> (a java.lang.ref.reference$lock)\n        at java.lang.object.wait(object.java:485)\n        at java.lang.ref.reference$referencehandler.run(reference.java:116)\n        - locked <0x7a2b6fe0> (a java.lang.ref.reference$lock)\n\n   locked ownable synchronizers:\n        - none\n\n"vm thread" prio=10 tid=0x08200000 nid=0xffb runnable\n\n"vm periodic task thread" prio=10 tid=0x08222400 nid=0x1001 waiting on condition\n\njni global references: 1317\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# arthas\n\narthas中文文档：https://arthas.aliyun.com/doc/\n\narthas 功能强大 我们如果想查看线程状态，只需要使用命令 dashboard.\n\n$ dashboard\nid     name                   group          priori state  %cpu    time   interru daemon\n17     pool-2-thread-1        system         5      waitin 67      0:0    false   false\n27     timer-for-arthas-dashb system         10     runnab 32      0:0    false   true\n11     asyncappender-worker-a system         9      waitin 0       0:0    false   true\n9      attach listener        system         9      runnab 0       0:0    false   true\n3      finalizer              system         8      waitin 0       0:0    false   true\n2      reference handler      system         10     waitin 0       0:0    false   true\n4      signal dispatcher      system         9      runnab 0       0:0    false   true\n26     as-command-execute-dae system         10     timed_ 0       0:0    false   true\n13     job-timeout            system         9      timed_ 0       0:0    false   true\n1      main                   main           5      timed_ 0       0:0    false   false\n14     nioeventloopgroup-2-1  system         10     runnab 0       0:0    false   false\n18     nioeventloopgroup-2-2  system         10     runnab 0       0:0    false   false\n23     nioeventloopgroup-2-3  system         10     runnab 0       0:0    false   false\n15     nioeventloopgroup-3-1  system         10     runnab 0       0:0    false   false\nmemory             used   total max    usage gc\nheap               32m    155m  1820m  1.77% gc.ps_scavenge.count  4\nps_eden_space      14m    65m   672m   2.21% gc.ps_scavenge.time(m 166\nps_survivor_space  4m     5m    5m           s)\nps_old_gen         12m    85m   1365m  0.91% gc.ps_marksweep.count 0\nnonheap            20m    23m   -1           gc.ps_marksweep.time( 0\ncode_cache         3m     5m    240m   1.32% ms )\nruntime\nos.name                mac os x\nos.version             10.13.4\njava.version           1.8.0_162\njava.home              /library/java/javavir\n                       tualmachines/jdk1.8.0\n                       _162.jdk/contents/hom\n                       e/jre\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"简述 Java AQS 的原理以及使用场景",frontmatter:{title:"简述 Java AQS 的原理以及使用场景",date:"2022-04-04T14:34:53.000Z",permalink:"/pages/52a687/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/080.%E7%AE%80%E8%BF%B0%20Java%20AQS%20%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"01.Java相关/20.并发/080.简述 Java AQS 的原理以及使用场景.md",key:"v-2dbdb772",path:"/pages/52a687/",headers:[{level:2,title:"简述 Java AQS 的原理以及使用场景",slug:"简述-java-aqs-的原理以及使用场景",normalizedTitle:"简述 java aqs 的原理以及使用场景",charIndex:2},{level:2,title:"AbstractQueuedSynchronizer 是什么",slug:"abstractqueuedsynchronizer-是什么",normalizedTitle:"abstractqueuedsynchronizer 是什么",charIndex:28},{level:2,title:"AbstractQueuedSynchronizer 是如何实现的",slug:"abstractqueuedsynchronizer-是如何实现的",normalizedTitle:"abstractqueuedsynchronizer 是如何实现的",charIndex:480},{level:2,title:"如何用 AQS 实现一个排他锁",slug:"如何用-aqs-实现一个排他锁",normalizedTitle:"如何用 aqs 实现一个排他锁",charIndex:1157},{level:2,title:"AQS原理 - 排它锁-加锁",slug:"aqs原理-排它锁-加锁",normalizedTitle:"aqs原理 - 排它锁-加锁",charIndex:3195},{level:3,title:"尝试获取锁 tryAcquire(arg)",slug:"尝试获取锁-tryacquire-arg",normalizedTitle:"尝试获取锁 tryacquire(arg)",charIndex:3686},{level:3,title:"加入sync队列 addWaiter(Node.EXCLUSIVE)",slug:"加入sync队列-addwaiter-node-exclusive",normalizedTitle:"加入sync队列 addwaiter(node.exclusive)",charIndex:4588},{level:3,title:"排队 acquireQueued(Node,arg)",slug:"排队-acquirequeued-node-arg",normalizedTitle:"排队 acquirequeued(node,arg)",charIndex:5587},{level:3,title:"AQS原理 - 获取排它锁流程图",slug:"aqs原理-获取排它锁流程图",normalizedTitle:"aqs原理 - 获取排它锁流程图",charIndex:8358},{level:2,title:"AQS原理 - 排它锁-解锁",slug:"aqs原理-排它锁-解锁",normalizedTitle:"aqs原理 - 排它锁-解锁",charIndex:8723},{level:2,title:"AQS原理 - 共享锁-加锁",slug:"aqs原理-共享锁-加锁",normalizedTitle:"aqs原理 - 共享锁-加锁",charIndex:9580},{level:2,title:"AQS原理 - 共享锁-解锁",slug:"aqs原理-共享锁-解锁",normalizedTitle:"aqs原理 - 共享锁-解锁",charIndex:10197}],headersStr:"简述 Java AQS 的原理以及使用场景 AbstractQueuedSynchronizer 是什么 AbstractQueuedSynchronizer 是如何实现的 如何用 AQS 实现一个排他锁 AQS原理 - 排它锁-加锁 尝试获取锁 tryAcquire(arg) 加入sync队列 addWaiter(Node.EXCLUSIVE) 排队 acquireQueued(Node,arg) AQS原理 - 获取排它锁流程图 AQS原理 - 排它锁-解锁 AQS原理 - 共享锁-加锁 AQS原理 - 共享锁-解锁",content:'# 简述 Java AQS 的原理以及使用场景\n\n\n# AbstractQueuedSynchronizer 是什么\n\nAbstractQueuedSynchronizer（AQS） 提供一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。\n\n该类被设计为大多数类型的同步器的依据，这些同步器依赖于单个原子int值来表示状态。\n\nAQS的子类通过继承并实现它的抽象方法来实现管理同步状态，子类可以通过 AQS 提供的是三个方法来 修改状态值\n\n * getState()\n * setState(int)\n * compareAndSetState(int, int)\n\n因为这三个方法能保证状态的修改是安全的。\n\nAQS采用模板方法，内部实现了获取锁失败后加入等待队列的机制，大大降低了四线一个自定义同步组件的门槛。\n\nCountDownLatch、Semaphore、ReentrantLock等等常见的工具类都是由AQS来实现的。所以不管是面试也好，还是自己研究底层实现也好，AQS类都是必须要重点关注的。\n\n\n# AbstractQueuedSynchronizer 是如何实现的\n\n同步器的开始提到了其实现依赖于一个FIFO队列，那么队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。Node的主要包含以下成员变量：\n\nNode {\n//表示节点的状态。\n    int waitStatus;\n    //前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。\n    Node prev;\n    //后继节点。\n    Node next;\n    //存储condition队列中的后继节点。\n    Node nextWaiter;\n    //入队列时的当前线程。\n    Thread thread;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nwaitStatus取值有5个枚举：\n\n * CANCELLED，值为1，表示当前的线程被取消；\n * SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；\n * CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；\n * PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；\n * 值为0，表示当前节点在sync队列中，等待着获取锁。\n\nAQS（同步器） 和 其持有的FIFO队列的关系如上图，AQS 持有队列的头结点和尾结点，竞争锁失败的线程会被放到队列的后面，排队获取锁。\n\n\n# 如何用 AQS 实现一个排他锁\n\n排他锁的实现，顾名思义，一次只能一个线程获取到锁。 伪代码的获取:\n\nwhile(获取锁) {\n  if (获取到) {\n    退出while循环\n  } else {\n    if(当前线程没有入队列) {\n      那么入队列\n    }\n    阻塞当前线程\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n伪代码的释放:\n\nif (释放成功) {\n  删除头结点\n  激活原头结点的后继节点\n}\n\n\n1\n2\n3\n4\n\n\n通过AQS 实现:\n\nclass Mutex implements Lock, java.io.Serializable {\n   // 内部类，自定义同步器\n   private static class Sync extends AbstractQueuedSynchronizer {\n     // 是否处于占用状态\n     protected boolean isHeldExclusively() {\n       return getState() == 1;\n     }\n     // 当状态为0的时候获取锁\n     public boolean tryAcquire(int acquires) {\n       assert acquires == 1; // Otherwise unused\n       if (compareAndSetState(0, 1)) {\n         setExclusiveOwnerThread(Thread.currentThread());\n         return true;\n       }\n       return false;\n     }\n     // 释放锁，将状态设置为0\n     protected boolean tryRelease(int releases) {\n       assert releases == 1; // Otherwise unused\n       if (getState() == 0) throw new IllegalMonitorStateException();\n       setExclusiveOwnerThread(null);\n       setState(0);\n       return true;\n     }\n     // 返回一个Condition，每个condition都包含了一个condition队列\n     Condition newCondition() { return new ConditionObject(); }\n   }\n   // 仅需要将操作代理到Sync上即可\n   private final Sync sync = new Sync();\n   public void lock()                { sync.acquire(1); }\n   public boolean tryLock()          { return sync.tryAcquire(1); }\n   public void unlock()              { sync.release(1); }\n   public Condition newCondition()   { return sync.newCondition(); }\n   public boolean isLocked()         { return sync.isHeldExclusively(); }\n   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }\n   public void lockInterruptibly() throws InterruptedException {\n     sync.acquireInterruptibly(1);\n   }\n   public boolean tryLock(long timeout, TimeUnit unit)\n       throws InterruptedException {\n     return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n   }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n可以看到Mutex将Lock接口均代理给了同步器的实现。\n\n\n# AQS原理 - 排它锁-加锁\n\nAQS 中的 public final void acquire(int arg)以非阻塞的方式获取排它锁，实现 synchronized 语义，可以说是 AQS 中最重要的方法。\n\npublic final void acquire(int arg) {\n        if (!tryAcquire(arg) &amp;&amp;\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n这段代码逻辑做了三件事情：\n\n 1. 尝试获取锁 ;tryAcquire(arg)\n 2. 加入sync队列。如果获取不到，将当前线程构造成节点Node并加入sync队列；addWaiter(Node.EXCLUSIVE)\n 3. 排队。再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态 ;acquireQueued(Node,arg)\n\n下面我们逐步来看下这三个过程\n\n\n# 尝试获取锁 tryAcquire(arg)\n\n整个方法需要子类实现，比如公平锁、非公平锁就是在这个方法中做的逻辑。 我们来看下公平锁的实现：\n\nprotected final boolean tryAcquire(int acquires) {\n  // 当前线程\n    final Thread current = Thread.currentThread();\n    // 获取state状态，0表示未锁定，大于1表示重入\n    int c = getState();\n    // 0表示没有线程获取锁\n    if (c == 0) {\n    // 没有比当前线程等待更久的线程了，通过CAS的方式修改state\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            // 成功之后，设置当前拥有独占访问权的线程\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    // 独占访问权的线程就是当前线程，重入，此处就是【可重入性】的实现\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error("Maximum lock count exceeded");\n        // 直接修改state\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 加入sync队列 addWaiter(Node.EXCLUSIVE)\n\nprivate Node addWaiter(Node mode) {\n  Node node = new Node(Thread.currentThread(), mode);\n  Node pred = tail;\n    // 如果队列不为空 快速尝试在尾部添加 那么node节点的前继节点是tail\n  if (pred != null) {\n    node.prev = pred;\n        //CAS操作 将node设置为尾结点 （多线程竞争的情况下，这里可能会失败）\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n            //快速尝试在尾部添加成功 返回\n      return node;\n    }\n  }\n    //队列为空 或者 快速尝试在尾部添加失败 程序会走到这里\n  enq(node);\n  return node;\n}\n\n//在循环中 CAS入队列\nprivate Node enq(final Node node) {\n  for (;;) {\n    Node t = tail;\n    if (t == null) { // 如果队列为空 先初始化\n      if (compareAndSetHead(new Node()))\n        tail = head;\n    } else {// 如果队列不为空 CAS入队列\n      node.prev = t;\n      if (compareAndSetTail(t, node)) {\n      t.next = node;\n      return t;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上述逻辑主要包括：\n\n 1. 如果队列不为空 快速尝试在尾部添加,一次CAS\n 2. 队列为空 或者 快速尝试在尾部添加失败 程序进入循环判断3、4步\n 3. 如果队列为空 先初始化\n 4. 如果队列不为空 CAS入队列\n\n\n# 排队 acquireQueued(Node,arg)\n\n线程挂起之前 循环尝试获取锁；\n\nfinal boolean acquireQueued(final Node node, int arg) {\n  boolean failed = true;\n  try {\n    boolean interrupted = false;\n    for (;;) {\n      final Node p = node.predecessor();\n            //如果本线程已经是头结点了 tryAcquire(arg)下 尝试获取锁\n      if (p == head && tryAcquire(arg)) {\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n                //获取到了 退出循环\n        return interrupted;\n      }\n            //没获取到 判断要不要挂起\n      if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n        interrupted = true;\n                }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上述逻辑主要包括：\n\n 1. 如果本线程已经是头结点了 tryAcquire(arg)下 尝试获取锁，获取到了 退出循环，没获取到 判断要不要挂起\n 2. 挂起前，循环执行第一步\n\n如何判断要不要挂起呢，我们再来看下shouldParkAfterFailedAcquire(p, node):\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n// 获取pred前置节点的等待状态\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n/* 前置节点状态是signal，那当前节点可以安全阻塞，因为前置节点承诺执行完之后会通知唤醒当前\n* 节点\n*/\n            return true;\n        if (ws > 0) {\n \n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n// 前置节点如果已经被取消了，则一直往前遍历直到前置节点不是取消状态，与此同时会修改链表关系\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don\'t park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n// 前置节点是0或者propagate状态，这里通过CAS把前置节点状态改成signal\n// 这里不返回true让当前节点阻塞，而是返回false，目的是让调用者再check一下当前线程是否能\n// 成功获取锁，失败的话再阻塞，这里说实话我也不是特别理解这么做的原因\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n这段代码用来检测是否挂起当先线程,分三种情况,\n\n 1. 第一种情况是前驱节点的 ws = singal,表示前驱节点释放同步状态的时候会唤醒当前节点,可以安全挂起当前线程;\n 2. 第二种情况是前驱节点被取消,那就从前驱节点继续往前遍历,直到往前找到第一个ws <= 0 的节点;\n 3. 第三种是前驱节点的 ws = 0,表示前驱节点获取到同步状态,当前线程不能挂起,应该尝试去获取同步状态,前驱节点的同步状态的释放正好可以让当前节点进行获取,所以使用CAS把前驱节点的ws设为singal,另外如果 ws =PROPAGATE,说明正以共享模式进行传播,也需要使用CAS把ws设为singal.\n\n如何挂起线程呢?我们来看下parkAndCheckInterrupt()：\n\nprivate final boolean parkAndCheckInterrupt() {\n        // 阻塞当前线程，监事是当前sync对象\n        LockSupport.park(this);\n        // 阻塞返回后，返回当前线程是否被中断\n        return Thread.interrupted();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# AQS原理 - 获取排它锁流程图\n\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n首先执行tryAcquire方法用于尝试获取锁，成功后就直接返回，失败后就通过addWaiter方法把当前线程封装成一个Node，加到队列的尾部，再通过acquireQueued方法尝试获取同步锁，成功获取锁的线程的Node节点会被移出队列。\n\n如果以上条件都满足，会执行selfInterrupt方法中断当前线程。\n\n最后 我们再用一张流程图来回顾下这整个流程\n\n\n# AQS原理 - 排它锁-解锁\n\n我们已经知道了sync是AQS的实现，所以直接查看AQS中的release方法\n\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n      // 尝试释放锁\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n          // 头节点已经释放，唤醒后继节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ntryRelease 同样是模板方法：\n\nprotected final boolean tryRelease(int releases) {\n  // 计算剩余的重入次数\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    // 是否完全的释放了锁（针对可重入性）\n    boolean free = false;\n    if (c == 0) {\n      // 表示完全释放了锁\n        free = true;\n        // 设置独占锁的持有者为null\n        setExclusiveOwnerThread(null);\n    }\n    // 设置AQS的state\n    setState(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# AQS原理 - 共享锁-加锁\n\nprotected int tryAcquireShared(int acquires) {\n    for (;;) {\n      // 自旋\n        if (hasQueuedPredecessors())\n          // 如果有线程排在自己的前面（公平锁排队），直接返回\n            return -1;\n        // 获取同步状态的值\n        int available = getState();\n        // 可用的（许可）减去申请的，等于剩余的\n        int remaining = available - acquires;\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            // 如果剩余的小于0，或者设置状态成功，就返回，如果设置失败，则进入下一次循环\n            // 如果剩余小于0，返回负数，表示失败\n            // 如果设置状态成功，表示申请许可成功，返回正数\n            return remaining;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# AQS原理 - 共享锁-解锁\n\nreleaseShared()\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ntryReleaseShared()\n\nprotected final boolean tryReleaseShared(int releases) {\n    for (;;) {\n      // 自旋\n      // 获取同步状态的值\n        int current = getState();\n        // 可用的（许可）加上释放的，等于剩余的\n        int next = current + releases;\n        if (next < current) // overflow\n            throw new Error("Maximum permit count exceeded");\n        if (compareAndSetState(current, next))\n          // CAS的方式设置同步状态\n            return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndoReleaseShared()\n\n/**\n * Release action for shared mode -- signals successor and ensures\n * propagation. (Note: For exclusive mode, release just amounts\n * to calling unparkSuccessor of head if it needs signal.)\n */\nprivate void doReleaseShared() {\n    /*\n     * Ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  This proceeds in the usual\n     * way of trying to unparkSuccessor of head if it needs\n     * signal. But if it does not, status is set to PROPAGATE to\n     * ensure that upon release, propagation continues.\n     * Additionally, we must loop in case a new node is added\n     * while we are doing this. Also, unlike other uses of\n     * unparkSuccessor, we need to know if CAS to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n      // 自旋\n      // 记录头节点\n        Node h = head;\n        if (h != null && h != tail) {\n          // 头节点不为null，且不等于尾结点，说明队列中还有节点\n          // 获取头节点等待状态\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n              // 头节点等待状态是SIGNAL\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                  // 如果修改节点等待状态失败，进入下一次循环\n                    continue;            // loop to recheck cases\n                // 修改成功后，唤醒后继节点，unparkSuccessor前文讲过\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n',normalizedContent:'# 简述 java aqs 的原理以及使用场景\n\n\n# abstractqueuedsynchronizer 是什么\n\nabstractqueuedsynchronizer（aqs） 提供一个框架，用于实现依赖先进先出（fifo）等待队列的阻塞锁和相关同步器（信号量，事件等）。\n\n该类被设计为大多数类型的同步器的依据，这些同步器依赖于单个原子int值来表示状态。\n\naqs的子类通过继承并实现它的抽象方法来实现管理同步状态，子类可以通过 aqs 提供的是三个方法来 修改状态值\n\n * getstate()\n * setstate(int)\n * compareandsetstate(int, int)\n\n因为这三个方法能保证状态的修改是安全的。\n\naqs采用模板方法，内部实现了获取锁失败后加入等待队列的机制，大大降低了四线一个自定义同步组件的门槛。\n\ncountdownlatch、semaphore、reentrantlock等等常见的工具类都是由aqs来实现的。所以不管是面试也好，还是自己研究底层实现也好，aqs类都是必须要重点关注的。\n\n\n# abstractqueuedsynchronizer 是如何实现的\n\n同步器的开始提到了其实现依赖于一个fifo队列，那么队列中的元素node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。node的主要包含以下成员变量：\n\nnode {\n//表示节点的状态。\n    int waitstatus;\n    //前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。\n    node prev;\n    //后继节点。\n    node next;\n    //存储condition队列中的后继节点。\n    node nextwaiter;\n    //入队列时的当前线程。\n    thread thread;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nwaitstatus取值有5个枚举：\n\n * cancelled，值为1，表示当前的线程被取消；\n * signal，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；\n * condition，值为-2，表示当前节点在等待condition，也就是在condition队列中；\n * propagate，值为-3，表示当前场景下后续的acquireshared能够得以执行；\n * 值为0，表示当前节点在sync队列中，等待着获取锁。\n\naqs（同步器） 和 其持有的fifo队列的关系如上图，aqs 持有队列的头结点和尾结点，竞争锁失败的线程会被放到队列的后面，排队获取锁。\n\n\n# 如何用 aqs 实现一个排他锁\n\n排他锁的实现，顾名思义，一次只能一个线程获取到锁。 伪代码的获取:\n\nwhile(获取锁) {\n  if (获取到) {\n    退出while循环\n  } else {\n    if(当前线程没有入队列) {\n      那么入队列\n    }\n    阻塞当前线程\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n伪代码的释放:\n\nif (释放成功) {\n  删除头结点\n  激活原头结点的后继节点\n}\n\n\n1\n2\n3\n4\n\n\n通过aqs 实现:\n\nclass mutex implements lock, java.io.serializable {\n   // 内部类，自定义同步器\n   private static class sync extends abstractqueuedsynchronizer {\n     // 是否处于占用状态\n     protected boolean isheldexclusively() {\n       return getstate() == 1;\n     }\n     // 当状态为0的时候获取锁\n     public boolean tryacquire(int acquires) {\n       assert acquires == 1; // otherwise unused\n       if (compareandsetstate(0, 1)) {\n         setexclusiveownerthread(thread.currentthread());\n         return true;\n       }\n       return false;\n     }\n     // 释放锁，将状态设置为0\n     protected boolean tryrelease(int releases) {\n       assert releases == 1; // otherwise unused\n       if (getstate() == 0) throw new illegalmonitorstateexception();\n       setexclusiveownerthread(null);\n       setstate(0);\n       return true;\n     }\n     // 返回一个condition，每个condition都包含了一个condition队列\n     condition newcondition() { return new conditionobject(); }\n   }\n   // 仅需要将操作代理到sync上即可\n   private final sync sync = new sync();\n   public void lock()                { sync.acquire(1); }\n   public boolean trylock()          { return sync.tryacquire(1); }\n   public void unlock()              { sync.release(1); }\n   public condition newcondition()   { return sync.newcondition(); }\n   public boolean islocked()         { return sync.isheldexclusively(); }\n   public boolean hasqueuedthreads() { return sync.hasqueuedthreads(); }\n   public void lockinterruptibly() throws interruptedexception {\n     sync.acquireinterruptibly(1);\n   }\n   public boolean trylock(long timeout, timeunit unit)\n       throws interruptedexception {\n     return sync.tryacquirenanos(1, unit.tonanos(timeout));\n   }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n可以看到mutex将lock接口均代理给了同步器的实现。\n\n\n# aqs原理 - 排它锁-加锁\n\naqs 中的 public final void acquire(int arg)以非阻塞的方式获取排它锁，实现 synchronized 语义，可以说是 aqs 中最重要的方法。\n\npublic final void acquire(int arg) {\n        if (!tryacquire(arg) &amp;&amp;\n            acquirequeued(addwaiter(node.exclusive), arg))\n            selfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n这段代码逻辑做了三件事情：\n\n 1. 尝试获取锁 ;tryacquire(arg)\n 2. 加入sync队列。如果获取不到，将当前线程构造成节点node并加入sync队列；addwaiter(node.exclusive)\n 3. 排队。再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态 ;acquirequeued(node,arg)\n\n下面我们逐步来看下这三个过程\n\n\n# 尝试获取锁 tryacquire(arg)\n\n整个方法需要子类实现，比如公平锁、非公平锁就是在这个方法中做的逻辑。 我们来看下公平锁的实现：\n\nprotected final boolean tryacquire(int acquires) {\n  // 当前线程\n    final thread current = thread.currentthread();\n    // 获取state状态，0表示未锁定，大于1表示重入\n    int c = getstate();\n    // 0表示没有线程获取锁\n    if (c == 0) {\n    // 没有比当前线程等待更久的线程了，通过cas的方式修改state\n        if (!hasqueuedpredecessors() &&\n            compareandsetstate(0, acquires)) {\n            // 成功之后，设置当前拥有独占访问权的线程\n            setexclusiveownerthread(current);\n            return true;\n        }\n    }\n    // 独占访问权的线程就是当前线程，重入，此处就是【可重入性】的实现\n    else if (current == getexclusiveownerthread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new error("maximum lock count exceeded");\n        // 直接修改state\n        setstate(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 加入sync队列 addwaiter(node.exclusive)\n\nprivate node addwaiter(node mode) {\n  node node = new node(thread.currentthread(), mode);\n  node pred = tail;\n    // 如果队列不为空 快速尝试在尾部添加 那么node节点的前继节点是tail\n  if (pred != null) {\n    node.prev = pred;\n        //cas操作 将node设置为尾结点 （多线程竞争的情况下，这里可能会失败）\n    if (compareandsettail(pred, node)) {\n      pred.next = node;\n            //快速尝试在尾部添加成功 返回\n      return node;\n    }\n  }\n    //队列为空 或者 快速尝试在尾部添加失败 程序会走到这里\n  enq(node);\n  return node;\n}\n\n//在循环中 cas入队列\nprivate node enq(final node node) {\n  for (;;) {\n    node t = tail;\n    if (t == null) { // 如果队列为空 先初始化\n      if (compareandsethead(new node()))\n        tail = head;\n    } else {// 如果队列不为空 cas入队列\n      node.prev = t;\n      if (compareandsettail(t, node)) {\n      t.next = node;\n      return t;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上述逻辑主要包括：\n\n 1. 如果队列不为空 快速尝试在尾部添加,一次cas\n 2. 队列为空 或者 快速尝试在尾部添加失败 程序进入循环判断3、4步\n 3. 如果队列为空 先初始化\n 4. 如果队列不为空 cas入队列\n\n\n# 排队 acquirequeued(node,arg)\n\n线程挂起之前 循环尝试获取锁；\n\nfinal boolean acquirequeued(final node node, int arg) {\n  boolean failed = true;\n  try {\n    boolean interrupted = false;\n    for (;;) {\n      final node p = node.predecessor();\n            //如果本线程已经是头结点了 tryacquire(arg)下 尝试获取锁\n      if (p == head && tryacquire(arg)) {\n        sethead(node);\n        p.next = null; // help gc\n        failed = false;\n                //获取到了 退出循环\n        return interrupted;\n      }\n            //没获取到 判断要不要挂起\n      if (shouldparkafterfailedacquire(p, node) &&\n                    parkandcheckinterrupt())\n        interrupted = true;\n                }\n  } finally {\n    if (failed)\n      cancelacquire(node);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上述逻辑主要包括：\n\n 1. 如果本线程已经是头结点了 tryacquire(arg)下 尝试获取锁，获取到了 退出循环，没获取到 判断要不要挂起\n 2. 挂起前，循环执行第一步\n\n如何判断要不要挂起呢，我们再来看下shouldparkafterfailedacquire(p, node):\n\nprivate static boolean shouldparkafterfailedacquire(node pred, node node) {\n// 获取pred前置节点的等待状态\n        int ws = pred.waitstatus;\n        if (ws == node.signal)\n            /*\n             * this node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n/* 前置节点状态是signal，那当前节点可以安全阻塞，因为前置节点承诺执行完之后会通知唤醒当前\n* 节点\n*/\n            return true;\n        if (ws > 0) {\n \n            /*\n             * predecessor was cancelled. skip over predecessors and\n             * indicate retry.\n             */\n// 前置节点如果已经被取消了，则一直往前遍历直到前置节点不是取消状态，与此同时会修改链表关系\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitstatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitstatus must be 0 or propagate.  indicate that we\n             * need a signal, but don\'t park yet.  caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n// 前置节点是0或者propagate状态，这里通过cas把前置节点状态改成signal\n// 这里不返回true让当前节点阻塞，而是返回false，目的是让调用者再check一下当前线程是否能\n// 成功获取锁，失败的话再阻塞，这里说实话我也不是特别理解这么做的原因\n            compareandsetwaitstatus(pred, ws, node.signal);\n        }\n        return false;\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n这段代码用来检测是否挂起当先线程,分三种情况,\n\n 1. 第一种情况是前驱节点的 ws = singal,表示前驱节点释放同步状态的时候会唤醒当前节点,可以安全挂起当前线程;\n 2. 第二种情况是前驱节点被取消,那就从前驱节点继续往前遍历,直到往前找到第一个ws <= 0 的节点;\n 3. 第三种是前驱节点的 ws = 0,表示前驱节点获取到同步状态,当前线程不能挂起,应该尝试去获取同步状态,前驱节点的同步状态的释放正好可以让当前节点进行获取,所以使用cas把前驱节点的ws设为singal,另外如果 ws =propagate,说明正以共享模式进行传播,也需要使用cas把ws设为singal.\n\n如何挂起线程呢?我们来看下parkandcheckinterrupt()：\n\nprivate final boolean parkandcheckinterrupt() {\n        // 阻塞当前线程，监事是当前sync对象\n        locksupport.park(this);\n        // 阻塞返回后，返回当前线程是否被中断\n        return thread.interrupted();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# aqs原理 - 获取排它锁流程图\n\npublic final void acquire(int arg) {\n    if (!tryacquire(arg) &&\n        acquirequeued(addwaiter(node.exclusive), arg))\n        selfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n首先执行tryacquire方法用于尝试获取锁，成功后就直接返回，失败后就通过addwaiter方法把当前线程封装成一个node，加到队列的尾部，再通过acquirequeued方法尝试获取同步锁，成功获取锁的线程的node节点会被移出队列。\n\n如果以上条件都满足，会执行selfinterrupt方法中断当前线程。\n\n最后 我们再用一张流程图来回顾下这整个流程\n\n\n# aqs原理 - 排它锁-解锁\n\n我们已经知道了sync是aqs的实现，所以直接查看aqs中的release方法\n\npublic final boolean release(int arg) {\n    if (tryrelease(arg)) {\n      // 尝试释放锁\n        node h = head;\n        if (h != null && h.waitstatus != 0)\n          // 头节点已经释放，唤醒后继节点\n            unparksuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ntryrelease 同样是模板方法：\n\nprotected final boolean tryrelease(int releases) {\n  // 计算剩余的重入次数\n    int c = getstate() - releases;\n    if (thread.currentthread() != getexclusiveownerthread())\n        throw new illegalmonitorstateexception();\n    // 是否完全的释放了锁（针对可重入性）\n    boolean free = false;\n    if (c == 0) {\n      // 表示完全释放了锁\n        free = true;\n        // 设置独占锁的持有者为null\n        setexclusiveownerthread(null);\n    }\n    // 设置aqs的state\n    setstate(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# aqs原理 - 共享锁-加锁\n\nprotected int tryacquireshared(int acquires) {\n    for (;;) {\n      // 自旋\n        if (hasqueuedpredecessors())\n          // 如果有线程排在自己的前面（公平锁排队），直接返回\n            return -1;\n        // 获取同步状态的值\n        int available = getstate();\n        // 可用的（许可）减去申请的，等于剩余的\n        int remaining = available - acquires;\n        if (remaining < 0 ||\n            compareandsetstate(available, remaining))\n            // 如果剩余的小于0，或者设置状态成功，就返回，如果设置失败，则进入下一次循环\n            // 如果剩余小于0，返回负数，表示失败\n            // 如果设置状态成功，表示申请许可成功，返回正数\n            return remaining;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# aqs原理 - 共享锁-解锁\n\nreleaseshared()\n\npublic final boolean releaseshared(int arg) {\n    if (tryreleaseshared(arg)) {\n        doreleaseshared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ntryreleaseshared()\n\nprotected final boolean tryreleaseshared(int releases) {\n    for (;;) {\n      // 自旋\n      // 获取同步状态的值\n        int current = getstate();\n        // 可用的（许可）加上释放的，等于剩余的\n        int next = current + releases;\n        if (next < current) // overflow\n            throw new error("maximum permit count exceeded");\n        if (compareandsetstate(current, next))\n          // cas的方式设置同步状态\n            return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndoreleaseshared()\n\n/**\n * release action for shared mode -- signals successor and ensures\n * propagation. (note: for exclusive mode, release just amounts\n * to calling unparksuccessor of head if it needs signal.)\n */\nprivate void doreleaseshared() {\n    /*\n     * ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  this proceeds in the usual\n     * way of trying to unparksuccessor of head if it needs\n     * signal. but if it does not, status is set to propagate to\n     * ensure that upon release, propagation continues.\n     * additionally, we must loop in case a new node is added\n     * while we are doing this. also, unlike other uses of\n     * unparksuccessor, we need to know if cas to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n      // 自旋\n      // 记录头节点\n        node h = head;\n        if (h != null && h != tail) {\n          // 头节点不为null，且不等于尾结点，说明队列中还有节点\n          // 获取头节点等待状态\n            int ws = h.waitstatus;\n            if (ws == node.signal) {\n              // 头节点等待状态是signal\n                if (!compareandsetwaitstatus(h, node.signal, 0))\n                  // 如果修改节点等待状态失败，进入下一次循环\n                    continue;            // loop to recheck cases\n                // 修改成功后，唤醒后继节点，unparksuccessor前文讲过\n                unparksuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareandsetwaitstatus(h, 0, node.propagate))\n                continue;                // loop on failed cas\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"为什么我们不能直接调用 run() 方法？",frontmatter:{title:"为什么我们不能直接调用 run() 方法？",date:"2022-04-04T14:36:29.000Z",permalink:"/pages/13856f/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/120.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%20run()%20%E6%96%B9%E6%B3%95%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/120.为什么我们不能直接调用 run() 方法？.md",key:"v-9baaad8e",path:"/pages/13856f/",headers:[{level:2,title:"为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？",slug:"为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法",normalizedTitle:"为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？",charIndex:null}],headersStr:"为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？",content:'# 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run()方法？\n\n如果我们直接调用 run() 方法 是不会创建新线程的。\nstart() 源代码：\n\n/**\n     * Causes this thread to begin execution; the Java Virtual Machine\n     * calls the <code>run</code> method of this thread.\n     * <p>线程被执行，JVM调用run方法\n     * The result is that two threads are running concurrently: the\n     * current thread (which returns from the call to the\n     * <code>start</code> method) and the other thread (which executes its\n     * <code>run</code> method).\n     * <p>\n     * It is never legal to start a thread more than once.多次调用start方法启动一个线程是非法的\n     * In particular, a thread may not be restarted once it has completed\n     * execution.\n     *\n     * @exception  IllegalThreadStateException  if the thread was already已经启动的线程再次start，异常\n     *               started.\n     * @see        #run()\n     * @see        #stop()\n     */\n    public synchronized void start() {\n        /**\n         * This method is not invoked for the main method thread or "system"\n         * group threads created/set up by the VM. Any new functionality added\n         * to this method in the future may have to also be added to the VM.\n         *\n         * A zero status value corresponds to state "NEW".\n         */\n        if (threadStatus != 0)//状态校验  0：NEW 新建状态\n            throw new IllegalThreadStateException();\n\n        /* Notify the group that this thread is about to be started\n         * so that it can be added to the group\'s list of threads\n         * and the group\'s unstarted count can be decremented. */\n        group.add(this);//添加进线程组\n\n        boolean started = false;\n        try {\n            start0();//调用native方法执行线程run方法\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadStartFailed(this);//启动失败，从线程组中移除当前前程。\n                }\n            } catch (Throwable ignore) {\n                /* do nothing. If start0 threw a Throwable then\n                  it will be passed up the call stack */\n            }\n        }\n    }\n\n    private native void start0();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n通过源码我们可以看到，在start()中调用了native方法 start0()，在start0()中会创建一个新的线程调用run()。 所以，如果我们直接调用 run() 方法 是不会创建新线程的。',normalizedContent:'# 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run()方法？\n\n如果我们直接调用 run() 方法 是不会创建新线程的。\nstart() 源代码：\n\n/**\n     * causes this thread to begin execution; the java virtual machine\n     * calls the <code>run</code> method of this thread.\n     * <p>线程被执行，jvm调用run方法\n     * the result is that two threads are running concurrently: the\n     * current thread (which returns from the call to the\n     * <code>start</code> method) and the other thread (which executes its\n     * <code>run</code> method).\n     * <p>\n     * it is never legal to start a thread more than once.多次调用start方法启动一个线程是非法的\n     * in particular, a thread may not be restarted once it has completed\n     * execution.\n     *\n     * @exception  illegalthreadstateexception  if the thread was already已经启动的线程再次start，异常\n     *               started.\n     * @see        #run()\n     * @see        #stop()\n     */\n    public synchronized void start() {\n        /**\n         * this method is not invoked for the main method thread or "system"\n         * group threads created/set up by the vm. any new functionality added\n         * to this method in the future may have to also be added to the vm.\n         *\n         * a zero status value corresponds to state "new".\n         */\n        if (threadstatus != 0)//状态校验  0：new 新建状态\n            throw new illegalthreadstateexception();\n\n        /* notify the group that this thread is about to be started\n         * so that it can be added to the group\'s list of threads\n         * and the group\'s unstarted count can be decremented. */\n        group.add(this);//添加进线程组\n\n        boolean started = false;\n        try {\n            start0();//调用native方法执行线程run方法\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadstartfailed(this);//启动失败，从线程组中移除当前前程。\n                }\n            } catch (throwable ignore) {\n                /* do nothing. if start0 threw a throwable then\n                  it will be passed up the call stack */\n            }\n        }\n    }\n\n    private native void start0();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n通过源码我们可以看到，在start()中调用了native方法 start0()，在start0()中会创建一个新的线程调用run()。 所以，如果我们直接调用 run() 方法 是不会创建新线程的。',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Java 是如何实现线程安全的，哪些数据结构是线程安全的？",frontmatter:{title:"Java 是如何实现线程安全的，哪些数据结构是线程安全的？",date:"2022-04-04T14:35:56.000Z",permalink:"/pages/c1f760/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/110.Java%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/110.Java 是如何实现线程安全的，哪些数据结构是线程安全的？.md",key:"v-625fbeda",path:"/pages/c1f760/",headers:[{level:2,title:"Java 是如何实现线程安全的，哪些数据结构是线程安全的？",slug:"java-是如何实现线程安全的-哪些数据结构是线程安全的",normalizedTitle:"java 是如何实现线程安全的，哪些数据结构是线程安全的？",charIndex:2},{level:2,title:"synchronized 来实现售票场景",slug:"synchronized-来实现售票场景",normalizedTitle:"synchronized 来实现售票场景",charIndex:167},{level:2,title:"Lock 接口来实现售票场景",slug:"lock-接口来实现售票场景",normalizedTitle:"lock 接口来实现售票场景",charIndex:1352},{level:2,title:"哪些数据结构是线程安全的？",slug:"哪些数据结构是线程安全的",normalizedTitle:"哪些数据结构是线程安全的？",charIndex:18}],headersStr:"Java 是如何实现线程安全的，哪些数据结构是线程安全的？ synchronized 来实现售票场景 Lock 接口来实现售票场景 哪些数据结构是线程安全的？",content:'# Java 是如何实现线程安全的，哪些数据结构是线程安全的？\n\n如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。\n\nJava 中实现线程安全的方式有两个：\n\n * synchronized\n * Lock接口\n\n举例一个售票场景：火车站4个窗口同时售票，共有3张票，不能超卖。\n\n\n# synchronized 来实现售票场景\n\npublic class ThreadSynchronizedSecurity {\n \n    static int tickets = 3;\n \n    class SellTickets implements Runnable {\n        @Override\n        public void run() {\n            // 同步代码块\n            synchronized (this) {\n                if (tickets <= 0) {\n                    System.out.println(Thread.currentThread().getName() + "---\x3e票已售罄！");\n                    return;\n                }\n                System.out.println(Thread.currentThread().getName() + "---\x3e售出第：  " + tickets + " 张票");\n                tickets--;\n            }\n        }\n    }\n \n    public static void main(String[] args) {\n        SellTickets sell = new ThreadSynchronizedSecurity().new SellTickets();\n        Thread thread1 = new Thread(sell, "1号窗口");\n        Thread thread2 = new Thread(sell, "2号窗口");\n        Thread thread3 = new Thread(sell, "3号窗口");\n        Thread thread4 = new Thread(sell, "4号窗口");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n输出：\n\n1号窗口---\x3e售出第： 3 张票\n2号窗口---\x3e售出第： 2 张票\n3号窗口---\x3e售出第： 3 张票\n4号窗口---\x3e票已售罄！\n\n\n1\n2\n3\n4\n\n\n\n# Lock 接口来实现售票场景\n\npackage com.my.annotate.thread;\n \nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \npublic class ThreadLockSecurity {\n    static int tickets = 3;\n \n    class SellTickets implements Runnable {\n        Lock lock = new ReentrantLock();\n        @Override\n        public void run() {\n            // Lock锁机制\n            if (tickets > 0) {\n                try {\n                    lock.lock();\n                    if (tickets <= 0) {\n                        return;\n                    }\n                    System.out.println(Thread.currentThread().getName() + "---\x3e售出第：  " + tickets + " 票");\n                    tickets--;\n                } catch (Exception e1) {\n                    // TODO Auto-generated catch block\n                    e1.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n            if (tickets <= 0) {\n                System.out.println(Thread.currentThread().getName() + "---\x3e票已售罄！");\n            }\n \n        }\n    }\n \n \n    public static void main(String[] args) {\n        SellTickets sell = new ThreadLockSecurity().new SellTickets();\n        Thread thread1 = new Thread(sell, "1号窗口");\n        Thread thread2 = new Thread(sell, "2号窗口");\n        Thread thread3 = new Thread(sell, "3号窗口");\n        Thread thread4 = new Thread(sell, "4号窗口");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n输出：\n\n1号窗口---\x3e售出第： 3 张票\n2号窗口---\x3e售出第： 2 张票\n3号窗口---\x3e售出第： 3 张票\n4号窗口---\x3e票已售罄！\n\n\n1\n2\n3\n4\n\n\n\n# 哪些数据结构是线程安全的？\n\nJDK已经为大家准备好了一批好用的线程安全容器类，可以大大减少开发工作量，例如HashTable，ConcurrentHashMap，CopyOnWriteArrayList，CopyOnWriteArraySet，ConcurrentLinkedQueue，Vector，StringBuffer等。\n\n 1. HashTable\n\nHashTable实现了Map接口，为此其本身也是一个散列表，它存储的内容是基于key-value的键值对映射。\n\nHashTable中的key、value都不可以为null；具有无序特性；由于其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。\n\nHashTable使用synchronized来修饰方法函数来保证线程安全，但是在多线程运行环境下效率表现非常低下。\n\n因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会粗线阻塞状态。\n\n比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率。\n\n 2. ConcurrentHashMap\n\n我们知道HashMap是线程不安全的，ConcurrentHashMap是HashMap的线程安全版。\n\n但是与HashTable相比，ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。\n\nConcurrentHashMap允许多个修改操作并发运行，其原因在于使用了锁分段技术：首先讲Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。这样就保证了每一把锁只是用于锁住一部分数据，那么当多线程访问Map里的不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率。\n\n上述的处理机制明显区别于HashTable是给整体数据分配了一把锁的处理方法。\n\n为此，在多线程环境下，常用ConcurrentHashMap在需要保证数据安全的场景中去替换HashMap，而不会去使用HashTable，同时在最新版的JDK中已经推荐废弃使用HashTable。\n\n 3. CopyOnWriteArrayList\n\nCopyOnWriteArrayList实现了List接口，提供的数据更新操作都使用了ReentrantLock的lock()方法来加锁，unlock()方法来解锁。\n\n当增加元素的时候，首先使用Arrays.copyOf()来拷贝形成新的副本，在副本上增加元素，然后改变原引用指向副本。读操作不需要加锁，而写操作类实现中对其进行了加锁。因此，CopyOnWriteArrayList类是一个线程安全的List接口的实现，在高并发的情况下，可以提供高性能的并发读取，并且保证读取的内容一定是正确的，这对于读操作远远多于写操作的应用非常适合（注意： 如上述更新操作会带来较大的空间与性能开销，如果更新操太过频繁，反而不太合适使用）。\n\n 4. CopyOnWriteArraySet\n\nCopyOnWriteArraySet是对CopyOnWriteArrayList使用了装饰模式后的具体实现。所以CopyOnWriteArrayList的实现机理适用于CopyOnWriteArraySet，此处不再赘述。\n\nJava里的List和Set的之间的特性比较结论同样适用于CopyOnWriteArrayList与CopyOnWriteArraySet之间的比较；此外，CopyOnWriteArrayList与CopyOnWriteArraySet都是线程安全的。\n\n 5. ConcurrentLinkedQueue\n\nConcurrentLinkedQueue可以被看作是一个线程安全的LinkedList，使用了非阻塞算法实现的一个高效、线程安全的并发队列；其本质是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当添加一个元素时会添加到队列的尾部；当获取一个元素时，会返回队列头部的元素。\n\nConcurrentLinkedQueue应该算是在高并发环境中性能最好的队列，没有之一。\n\n 6. Vector\n\nVector通过数组保存数据，继承了Abstract，实现了List；所以，其本质上是一个队列。\n\n但是和ArrayList不同，Vector中的操作是线程安全的，它是利用synchronized同步锁机制进行实现，其实现方式与HashTable类似。\n\n 7. StringBuffer与StringBuilder\n\n在Java里面，字符串操作应该是最频繁的操作了，为此有必要把StringBuffer与StringBuilder两个方法类比较一下。\n\n首先，对于频繁的字符串拼接操作，是不推荐采用效率低下的“+”操作的。一般是采用StringBuffer与StringBuilder来实现上述功能。但是，这两者也是有区别的：前者线程安全，后者不是线程安全的。\n\nStringBuffer是通过对方法函数进行synchronized修饰实现其线程安全特性，实现方式与HashTable、Vector类似。',normalizedContent:'# java 是如何实现线程安全的，哪些数据结构是线程安全的？\n\n如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。\n\njava 中实现线程安全的方式有两个：\n\n * synchronized\n * lock接口\n\n举例一个售票场景：火车站4个窗口同时售票，共有3张票，不能超卖。\n\n\n# synchronized 来实现售票场景\n\npublic class threadsynchronizedsecurity {\n \n    static int tickets = 3;\n \n    class selltickets implements runnable {\n        @override\n        public void run() {\n            // 同步代码块\n            synchronized (this) {\n                if (tickets <= 0) {\n                    system.out.println(thread.currentthread().getname() + "---\x3e票已售罄！");\n                    return;\n                }\n                system.out.println(thread.currentthread().getname() + "---\x3e售出第：  " + tickets + " 张票");\n                tickets--;\n            }\n        }\n    }\n \n    public static void main(string[] args) {\n        selltickets sell = new threadsynchronizedsecurity().new selltickets();\n        thread thread1 = new thread(sell, "1号窗口");\n        thread thread2 = new thread(sell, "2号窗口");\n        thread thread3 = new thread(sell, "3号窗口");\n        thread thread4 = new thread(sell, "4号窗口");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n输出：\n\n1号窗口---\x3e售出第： 3 张票\n2号窗口---\x3e售出第： 2 张票\n3号窗口---\x3e售出第： 3 张票\n4号窗口---\x3e票已售罄！\n\n\n1\n2\n3\n4\n\n\n\n# lock 接口来实现售票场景\n\npackage com.my.annotate.thread;\n \nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n \npublic class threadlocksecurity {\n    static int tickets = 3;\n \n    class selltickets implements runnable {\n        lock lock = new reentrantlock();\n        @override\n        public void run() {\n            // lock锁机制\n            if (tickets > 0) {\n                try {\n                    lock.lock();\n                    if (tickets <= 0) {\n                        return;\n                    }\n                    system.out.println(thread.currentthread().getname() + "---\x3e售出第：  " + tickets + " 票");\n                    tickets--;\n                } catch (exception e1) {\n                    // todo auto-generated catch block\n                    e1.printstacktrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n            if (tickets <= 0) {\n                system.out.println(thread.currentthread().getname() + "---\x3e票已售罄！");\n            }\n \n        }\n    }\n \n \n    public static void main(string[] args) {\n        selltickets sell = new threadlocksecurity().new selltickets();\n        thread thread1 = new thread(sell, "1号窗口");\n        thread thread2 = new thread(sell, "2号窗口");\n        thread thread3 = new thread(sell, "3号窗口");\n        thread thread4 = new thread(sell, "4号窗口");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n输出：\n\n1号窗口---\x3e售出第： 3 张票\n2号窗口---\x3e售出第： 2 张票\n3号窗口---\x3e售出第： 3 张票\n4号窗口---\x3e票已售罄！\n\n\n1\n2\n3\n4\n\n\n\n# 哪些数据结构是线程安全的？\n\njdk已经为大家准备好了一批好用的线程安全容器类，可以大大减少开发工作量，例如hashtable，concurrenthashmap，copyonwritearraylist，copyonwritearrayset，concurrentlinkedqueue，vector，stringbuffer等。\n\n 1. hashtable\n\nhashtable实现了map接口，为此其本身也是一个散列表，它存储的内容是基于key-value的键值对映射。\n\nhashtable中的key、value都不可以为null；具有无序特性；由于其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。\n\nhashtable使用synchronized来修饰方法函数来保证线程安全，但是在多线程运行环境下效率表现非常低下。\n\n因为当一个线程访问hashtable的同步方法时，其他线程也访问同步方法就会粗线阻塞状态。\n\n比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率。\n\n 2. concurrenthashmap\n\n我们知道hashmap是线程不安全的，concurrenthashmap是hashmap的线程安全版。\n\n但是与hashtable相比，concurrenthashmap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。\n\nconcurrenthashmap允许多个修改操作并发运行，其原因在于使用了锁分段技术：首先讲map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。这样就保证了每一把锁只是用于锁住一部分数据，那么当多线程访问map里的不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率。\n\n上述的处理机制明显区别于hashtable是给整体数据分配了一把锁的处理方法。\n\n为此，在多线程环境下，常用concurrenthashmap在需要保证数据安全的场景中去替换hashmap，而不会去使用hashtable，同时在最新版的jdk中已经推荐废弃使用hashtable。\n\n 3. copyonwritearraylist\n\ncopyonwritearraylist实现了list接口，提供的数据更新操作都使用了reentrantlock的lock()方法来加锁，unlock()方法来解锁。\n\n当增加元素的时候，首先使用arrays.copyof()来拷贝形成新的副本，在副本上增加元素，然后改变原引用指向副本。读操作不需要加锁，而写操作类实现中对其进行了加锁。因此，copyonwritearraylist类是一个线程安全的list接口的实现，在高并发的情况下，可以提供高性能的并发读取，并且保证读取的内容一定是正确的，这对于读操作远远多于写操作的应用非常适合（注意： 如上述更新操作会带来较大的空间与性能开销，如果更新操太过频繁，反而不太合适使用）。\n\n 4. copyonwritearrayset\n\ncopyonwritearrayset是对copyonwritearraylist使用了装饰模式后的具体实现。所以copyonwritearraylist的实现机理适用于copyonwritearrayset，此处不再赘述。\n\njava里的list和set的之间的特性比较结论同样适用于copyonwritearraylist与copyonwritearrayset之间的比较；此外，copyonwritearraylist与copyonwritearrayset都是线程安全的。\n\n 5. concurrentlinkedqueue\n\nconcurrentlinkedqueue可以被看作是一个线程安全的linkedlist，使用了非阻塞算法实现的一个高效、线程安全的并发队列；其本质是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当添加一个元素时会添加到队列的尾部；当获取一个元素时，会返回队列头部的元素。\n\nconcurrentlinkedqueue应该算是在高并发环境中性能最好的队列，没有之一。\n\n 6. vector\n\nvector通过数组保存数据，继承了abstract，实现了list；所以，其本质上是一个队列。\n\n但是和arraylist不同，vector中的操作是线程安全的，它是利用synchronized同步锁机制进行实现，其实现方式与hashtable类似。\n\n 7. stringbuffer与stringbuilder\n\n在java里面，字符串操作应该是最频繁的操作了，为此有必要把stringbuffer与stringbuilder两个方法类比较一下。\n\n首先，对于频繁的字符串拼接操作，是不推荐采用效率低下的“+”操作的。一般是采用stringbuffer与stringbuilder来实现上述功能。但是，这两者也是有区别的：前者线程安全，后者不是线程安全的。\n\nstringbuffer是通过对方法函数进行synchronized修饰实现其线程安全特性，实现方式与hashtable、vector类似。',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"手写死锁",frontmatter:{title:"手写死锁",date:"2022-04-09T13:51:43.000Z",permalink:"/pages/ce292c/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/115.%E6%89%8B%E5%86%99%E6%AD%BB%E9%94%81.html",relativePath:"01.Java相关/20.并发/115.手写死锁.md",key:"v-7b2a2ed4",path:"/pages/ce292c/",headers:[{level:2,title:"产生死锁的条件",slug:"产生死锁的条件",normalizedTitle:"产生死锁的条件",charIndex:2},{level:2,title:"手写死锁例子",slug:"手写死锁例子",normalizedTitle:"手写死锁例子",charIndex:170}],headersStr:"产生死锁的条件 手写死锁例子",content:'# 产生死锁的条件\n\n一般来说，要出现死锁问题需要满足以下条件：\n\n * 互斥条件：一个资源每次只能被一个线程使用。\n * 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n * 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。\n * 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n\n# 手写死锁例子\n\n//可能发生静态锁顺序死锁的代码\nclass StaticLockOrderDeadLock {\n  private final Object lockA = new Object();\n  private final Object lockB = new Object();\n  public void a() {\n    synchronized (lockA) {\n      synchronized (lockB) {\n        System.out.println("function a");\n      }\n    }\n  }\n  \n  public void b() {\n    synchronized (lockB) {\n      synchronized (lockA) {\n        System.out.println("function b");\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * a和b两个方法都需要获得A锁和B锁。一个线程执行a方法且已经获得了A锁，在等待B锁；\n * 另一个线程执行了b方法且已经获得了B锁，在等待A锁。\n\n这种状态，就是发生了静态的锁顺序死锁。\n解决办法： 所有需要多个锁的线程，都要以相同的顺序来获得锁。\n\n\n//正确的代码\nclass StaticLockOrderDeadLock {\n  private final Object lockA = new Object();\n  private final Object lockB = new Object();\n  public void a() {\n    synchronized (lockA) {\n      synchronized (lockB) {\n        System.out.println("function a");\n      }\n    }\n  }\n  \n  public void b() {\n    synchronized (lockA) {\n      synchronized (lockB) {\n        System.out.println("function b");\n      }\n    }\n  }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',normalizedContent:'# 产生死锁的条件\n\n一般来说，要出现死锁问题需要满足以下条件：\n\n * 互斥条件：一个资源每次只能被一个线程使用。\n * 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n * 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。\n * 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n\n# 手写死锁例子\n\n//可能发生静态锁顺序死锁的代码\nclass staticlockorderdeadlock {\n  private final object locka = new object();\n  private final object lockb = new object();\n  public void a() {\n    synchronized (locka) {\n      synchronized (lockb) {\n        system.out.println("function a");\n      }\n    }\n  }\n  \n  public void b() {\n    synchronized (lockb) {\n      synchronized (locka) {\n        system.out.println("function b");\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * a和b两个方法都需要获得a锁和b锁。一个线程执行a方法且已经获得了a锁，在等待b锁；\n * 另一个线程执行了b方法且已经获得了b锁，在等待a锁。\n\n这种状态，就是发生了静态的锁顺序死锁。\n解决办法： 所有需要多个锁的线程，都要以相同的顺序来获得锁。\n\n\n//正确的代码\nclass staticlockorderdeadlock {\n  private final object locka = new object();\n  private final object lockb = new object();\n  public void a() {\n    synchronized (locka) {\n      synchronized (lockb) {\n        system.out.println("function a");\n      }\n    }\n  }\n  \n  public void b() {\n    synchronized (locka) {\n      synchronized (lockb) {\n        system.out.println("function b");\n      }\n    }\n  }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Java 线程有哪些常用方法？",frontmatter:{title:"Java 线程有哪些常用方法？",date:"2022-04-04T14:36:48.000Z",permalink:"/pages/a6c84e/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/130.Java%20%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/130.Java 线程有哪些常用方法？.md",key:"v-75c00225",path:"/pages/a6c84e/",headers:[{level:2,title:"Java 线程如何启动？如何终止？",slug:"java-线程如何启动-如何终止",normalizedTitle:"java 线程如何启动？如何终止？",charIndex:2},{level:2,title:"构造线程",slug:"构造线程",normalizedTitle:"构造线程",charIndex:97},{level:2,title:"启动线程",slug:"启动线程",normalizedTitle:"启动线程",charIndex:637},{level:2,title:"理解中断",slug:"理解中断",normalizedTitle:"理解中断",charIndex:1259},{level:2,title:"已不建议使用的方法：suspend(),resume(),stop()",slug:"已不建议使用的方法-suspend-resume-stop",normalizedTitle:"已不建议使用的方法：suspend(),resume(),stop()",charIndex:1581},{level:2,title:"安全的终止线程",slug:"安全的终止线程",normalizedTitle:"安全的终止线程",charIndex:1813}],headersStr:"Java 线程如何启动？如何终止？ 构造线程 启动线程 理解中断 已不建议使用的方法：suspend(),resume(),stop() 安全的终止线程",content:'# Java 线程如何启动？如何终止？\n\n线程随着start()方法的调用而启动，随着run()方法调用结束而终止。 但是这其中还会涉及到线程的构造、中断、暂停、恢复，我们来一一看下。\n\n\n# 构造线程\n\n在运行一个线程之前 肯定要先构造一个线程对象，构造线程对象需要提供所需属性：如线程所属组，线程优先级，是否deamon等。\n\nprivate void init(ThreadGroup g, Runnable target, String name,\n                  long stackSize, AccessControlContext acc) {\n    //1.设置线程名\n    if (name == null) {\n        throw new NullPointerException("name cannot be null");\n    }\n\n    this.name = name;\n    //2.设置线程的线程组，如果未指定，则此线程的线程组为当前初始化线程的线程组\n    Thread parent = currentThread();\n    ...\n    if (g == null) {\n        //这里有一段注释说，安卓不支持SecurityManager，所以删除了相关代码\n        g = parent.getThreadGroup();\n    }\n\n    //所属线程组未启动线程计数+1\n    g.addUnstarted();\n\n    this.group = g;\n    //3.设置线程的其他属性\n    //线程是否是守护线程以及优先级都继承自当前线程\n    this.daemon = parent.isDaemon();\n    this.priority = parent.getPriority();\n    this.target = target;\n    //4.调用init2 执行剩余初始化操作\n    init2(parent);\n    //5.设置线程的堆栈大小。但是否生效要看虚拟机。那么在art虚拟机上是否生效呢，我们后续再说\n    /* Stash the specified stack size in case the VM cares */\n    this.stackSize = stackSize;\n\n    //6.设置当前线程id\n    tid = nextThreadID();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n到这里为止，我们的thread就已经初始化完毕了。在堆内存中等待这被执行start()方法开始运行。\n\n\n# 启动线程\n\n调用start()方法开始启动线程。\n\n\n# 理解中断\n\n如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立刻结束运行。\n\n中断可以理解为线程的一个标志位属性，调用interrupt()方法中断线程仅仅是把中断标志位置为true，线程可以通过检查自身的标志位来判断是否被中断了。\n\n另外还有两点需要注意的：\n\n * 如果线程处于终结状态，即使线程被中断过，其中断标识位依然是false\n * 许多声明抛出InterruptException的方法（如Thread.sleep(long millis)），在抛出InterruptException之前会将中断标识位置为false。\n\n\n# 已不建议使用的方法：suspend(),resume(),stop()\n\nsuspend(),resume(),stop()完成了线程的暂停、恢复、停止。但是这些方法过期了 不建议继续使用，原因是：\n\n 1. suspend()暂停线程是不会释放资源（比如锁），而是占着资源入睡 ，这样容易引发死锁\n 2. stop() 终止线程时没有给线程清理资源的机会，导致程序运行在不确定状态\n\n取而代之的是wait()和notify()/notifyAll()。\n\n\n# 安全的终止线程\n\n可以通过interrupt()或者标识位来优雅的停止线程。\n\npublic class MyRunner implements Runnable {\n  private volatile boolean on = true;\n    public void run() {\n        while(on){\n          System.out.println("Running...");\n        }\n        System.out.println("Stoped!");\n    }\n\n    public void cancel(){\n      on  = false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n通过标识位来停止线程\n\npublic class ShutdownThread {\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new MyRunner().start();\n          t1.cancel();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过interrupt()来停止线程\n\npublic class ShutdownThread {\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new MyRunner().start();\n          t1.interrupt();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# java 线程如何启动？如何终止？\n\n线程随着start()方法的调用而启动，随着run()方法调用结束而终止。 但是这其中还会涉及到线程的构造、中断、暂停、恢复，我们来一一看下。\n\n\n# 构造线程\n\n在运行一个线程之前 肯定要先构造一个线程对象，构造线程对象需要提供所需属性：如线程所属组，线程优先级，是否deamon等。\n\nprivate void init(threadgroup g, runnable target, string name,\n                  long stacksize, accesscontrolcontext acc) {\n    //1.设置线程名\n    if (name == null) {\n        throw new nullpointerexception("name cannot be null");\n    }\n\n    this.name = name;\n    //2.设置线程的线程组，如果未指定，则此线程的线程组为当前初始化线程的线程组\n    thread parent = currentthread();\n    ...\n    if (g == null) {\n        //这里有一段注释说，安卓不支持securitymanager，所以删除了相关代码\n        g = parent.getthreadgroup();\n    }\n\n    //所属线程组未启动线程计数+1\n    g.addunstarted();\n\n    this.group = g;\n    //3.设置线程的其他属性\n    //线程是否是守护线程以及优先级都继承自当前线程\n    this.daemon = parent.isdaemon();\n    this.priority = parent.getpriority();\n    this.target = target;\n    //4.调用init2 执行剩余初始化操作\n    init2(parent);\n    //5.设置线程的堆栈大小。但是否生效要看虚拟机。那么在art虚拟机上是否生效呢，我们后续再说\n    /* stash the specified stack size in case the vm cares */\n    this.stacksize = stacksize;\n\n    //6.设置当前线程id\n    tid = nextthreadid();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n到这里为止，我们的thread就已经初始化完毕了。在堆内存中等待这被执行start()方法开始运行。\n\n\n# 启动线程\n\n调用start()方法开始启动线程。\n\n\n# 理解中断\n\n如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立刻结束运行。\n\n中断可以理解为线程的一个标志位属性，调用interrupt()方法中断线程仅仅是把中断标志位置为true，线程可以通过检查自身的标志位来判断是否被中断了。\n\n另外还有两点需要注意的：\n\n * 如果线程处于终结状态，即使线程被中断过，其中断标识位依然是false\n * 许多声明抛出interruptexception的方法（如thread.sleep(long millis)），在抛出interruptexception之前会将中断标识位置为false。\n\n\n# 已不建议使用的方法：suspend(),resume(),stop()\n\nsuspend(),resume(),stop()完成了线程的暂停、恢复、停止。但是这些方法过期了 不建议继续使用，原因是：\n\n 1. suspend()暂停线程是不会释放资源（比如锁），而是占着资源入睡 ，这样容易引发死锁\n 2. stop() 终止线程时没有给线程清理资源的机会，导致程序运行在不确定状态\n\n取而代之的是wait()和notify()/notifyall()。\n\n\n# 安全的终止线程\n\n可以通过interrupt()或者标识位来优雅的停止线程。\n\npublic class myrunner implements runnable {\n  private volatile boolean on = true;\n    public void run() {\n        while(on){\n          system.out.println("running...");\n        }\n        system.out.println("stoped!");\n    }\n\n    public void cancel(){\n      on  = false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n通过标识位来停止线程\n\npublic class shutdownthread {\n\n    public static void main(string[] args) {\n        thread t1 = new thread(new myrunner().start();\n          t1.cancel();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过interrupt()来停止线程\n\npublic class shutdownthread {\n\n    public static void main(string[] args) {\n        thread t1 = new thread(new myrunner().start();\n          t1.interrupt();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"手写生产者消费者模型",frontmatter:{title:"手写生产者消费者模型",date:"2022-04-04T14:37:07.000Z",permalink:"/pages/2b8c6e/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/140.%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.html",relativePath:"01.Java相关/20.并发/140.手写生产者消费者模型.md",key:"v-083aef82",path:"/pages/2b8c6e/",headers:[{level:2,title:"生产者消费者模式说明：",slug:"生产者消费者模式说明",normalizedTitle:"生产者消费者模式说明：",charIndex:2},{level:2,title:"实现的关键：",slug:"实现的关键",normalizedTitle:"实现的关键：",charIndex:78},{level:2,title:"代码实现：",slug:"代码实现",normalizedTitle:"代码实现：",charIndex:187},{level:3,title:"仓库代码",slug:"仓库代码",normalizedTitle:"仓库代码",charIndex:226},{level:3,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:207},{level:3,title:"生产者",slug:"生产者",normalizedTitle:"生产者",charIndex:2},{level:3,title:"消费者",slug:"消费者",normalizedTitle:"消费者",charIndex:5},{level:3,title:"测试类",slug:"测试类",normalizedTitle:"测试类",charIndex:218},{level:3,title:"测试类",slug:"测试类-2",normalizedTitle:"测试类",charIndex:218},{level:2,title:"代码关键点分析",slug:"代码关键点分析",normalizedTitle:"代码关键点分析",charIndex:4098},{level:3,title:"锁问题",slug:"锁问题",normalizedTitle:"锁问题",charIndex:4110},{level:3,title:"线程的等待与重启",slug:"线程的等待与重启",normalizedTitle:"线程的等待与重启",charIndex:4299},{level:3,title:"循环放置在Producer和Consumer类的run方法中",slug:"循环放置在producer和consumer类的run方法中",normalizedTitle:"循环放置在producer和consumer类的run方法中",charIndex:4874},{level:3,title:"时间延迟问题",slug:"时间延迟问题",normalizedTitle:"时间延迟问题",charIndex:5171}],headersStr:"生产者消费者模式说明： 实现的关键： 代码实现： 仓库代码 产品 生产者 消费者 测试类 测试类 代码关键点分析 锁问题 线程的等待与重启 循环放置在Producer和Consumer类的run方法中 时间延迟问题",content:'# 生产者消费者模式说明：\n\n生产者只在仓库未满时进行生产，仓库满时生产者进程被阻塞； 消费者只在仓库非空时进行消费，仓库为空时消费者进程被阻塞；\n\n\n# 实现的关键：\n\n共享内存中的两个同步方法，及同步方法中wait()方法的调用。\n\nsynchronized 保证了对象只能被一个线程占用。 wait 保证了当线程在等待过程中释放锁，使得其他对象有机会获得锁。\n\n\n# 代码实现：\n\n代码包含这几个部分：仓库、产品、生产者、消费者、测试类\n\n\n# 仓库代码\n\n仓库代码核心方法\n\n * public synchronized void produce(T item):生产商品\n * public synchronized T consume():消费商品\n\n/**\n * 仓库类，用于管理产品的生产、消费和存储。\n */\npublic class Storage<T> {\n    private int index = 0;\n    private static final int MAX = 10;//最大容量\n    private List<T> storages = new ArrayList<T>(MAX);//存储集合\n\n    public synchronized void produce(T item) {\n        while (index >= MAX) {// 判断仓库满了，则等待。\n            try {\n                System.out.println("仓库满了，等待中...");\n                this.wait();\n                System.out.println("仓库不满了，开始生产");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println("生产>>" + item.toString());\n        storages.add(item);\n        index++;   //先添加item，在进行加1操作\n        notify();  //生产完 唤醒在此对象监视器上等待的单个线程，即消费者线程\n    }\n\n    public synchronized T consume() {\n        while (index <= 0) {// 判断仓库空了，则等待。\n            try {\n                System.out.println("仓库为空，等待中...");\n                this.wait();\n                System.out.println("仓库不为空，开始消费");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        index--;//先进行减1操作，再remove\n        T item = storages.remove(index);\n        System.out.println("消费>>" + item.toString());\n        notify();\n        return item;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 产品\n\npublic class Phone {\n\n    private int id;// 手机编号\n\n    public Phone(int id) {\n        this.id = id;\n    }\n\n    @Override\n    public String toString() {\n        return "手机编号：" + id;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 生产者\n\npublic class Producer implements Runnable {\n\n    private Storage<Phone> storage;\n    \n    public Producer(Storage<Phone> storage) {\n        this.storage = storage;\n    }\n\n    public void run() {\n        for(int i = 0;i<20;i++){\n            storage.produce(new Phone(i));\n            \n            try {\n                Thread.sleep(10);//每隔10毫秒生产一个产品\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 消费者\n\npublic class Consumer implements Runnable {\n\n    private Storage<Phone> storage;\n    \n    public Consumer(Storage<Phone> storage) {\n        this.storage = storage;\n    }\n\n    public void run() {\n        for(int i = 0;i<20;i++){\n            storage.consume();\n            try {\n                Thread.sleep(100);//每隔100毫秒消费一个\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 测试类\n\npublic class ProducerAndConsumer {\n\n    public static void main(String[] args) {\n        Storage<Phone> storage = new Storage<Phone>();\n        \n        new Thread(new Producer(storage)).start();\n        new Thread(new Consumer(storage)).start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 测试类\n\n生产>>手机编号：0\n消费>>手机编号：0\n生产>>手机编号：1\n生产>>手机编号：2\n生产>>手机编号：3\n生产>>手机编号：4\n生产>>手机编号：5\n生产>>手机编号：6\n生产>>手机编号：7\n生产>>手机编号：8\n生产>>手机编号：9\n消费>>手机编号：9\n生产>>手机编号：10\n生产>>手机编号：11\n仓库满了，等待中...\n消费>>手机编号：11\n仓库不满了，开始生产\n生产>>手机编号：12\n仓库满了，等待中...\n消费>>手机编号：12\n仓库不满了，开始生产\n生产>>手机编号：13\n仓库满了，等待中...\n消费>>手机编号：13\n仓库不满了，开始生产\n生产>>手机编号：14\n仓库满了，等待中...\n消费>>手机编号：14\n仓库不满了，开始生产\n生产>>手机编号：15\n仓库满了，等待中...\n消费>>手机编号：15\n仓库不满了，开始生产\n生产>>手机编号：16\n仓库满了，等待中...\n消费>>手机编号：16\n仓库不满了，开始生产\n生产>>手机编号：17\n仓库满了，等待中...\n消费>>手机编号：17\n仓库不满了，开始生产\n生产>>手机编号：18\n仓库满了，等待中...\n消费>>手机编号：18\n仓库不满了，开始生产\n生产>>手机编号：19\n消费>>手机编号：19\n消费>>手机编号：10\n消费>>手机编号：8\n消费>>手机编号：7\n消费>>手机编号：6\n消费>>手机编号：5\n消费>>手机编号：4\n消费>>手机编号：3\n消费>>手机编号：2\n消费>>手机编号：1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 代码关键点分析\n\n\n# 锁问题\n\n仓库类 Storage 中 方法produce(T item) 和consume()要使用关键字synchronized修饰。使得变量index在多线程环境下的修改时线程安全的。\n\n * public synchronized void produce(T item):生产商品\n * public synchronized T consume():消费商品\n\n\n# 线程的等待与重启\n\n生产者线程的等待： 在生产时达到仓库的最大值后，要停止生产，此时需要调用 wait()方法。\n\nwhile (index >= MAX) {// 判断仓库满了，则等待。\n            try {\n                System.out.println("仓库满了，等待中...");\n                this.wait();\n                System.out.println("仓库不满了，开始生产");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n生产者线程的重启：消费后，调用notify()方法 唤醒 等待当前锁的线程。\n\n        index--;//先进行减1操作，再remove\n        T item = storages.remove(index);\n        System.out.println("消费>>" + item.toString());\n        notify();\n\n\n1\n2\n3\n4\n\n\n\n# 循环放置在Producer和Consumer类的run方法中\n\n模拟多次生产/消费。\n\nfor(int i = 0;i<20;i++){\n            storage.consume();\n            try {\n                Thread.sleep(100);//每隔100毫秒消费一个\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 时间延迟问题\n\nThread.sleep(10);s设置每隔10毫秒生产一个产品， 模拟生产和消费的随机过程，还要设置时间延迟，否则会发生只有生产达到最大值后才会开始消费。\n\npublic void run() {\n        for(int i = 0;i<20;i++){\n            storage.produce(new Phone(i));\n            \n            try {\n                Thread.sleep(10);//每隔10毫秒生产一个产品\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',normalizedContent:'# 生产者消费者模式说明：\n\n生产者只在仓库未满时进行生产，仓库满时生产者进程被阻塞； 消费者只在仓库非空时进行消费，仓库为空时消费者进程被阻塞；\n\n\n# 实现的关键：\n\n共享内存中的两个同步方法，及同步方法中wait()方法的调用。\n\nsynchronized 保证了对象只能被一个线程占用。 wait 保证了当线程在等待过程中释放锁，使得其他对象有机会获得锁。\n\n\n# 代码实现：\n\n代码包含这几个部分：仓库、产品、生产者、消费者、测试类\n\n\n# 仓库代码\n\n仓库代码核心方法\n\n * public synchronized void produce(t item):生产商品\n * public synchronized t consume():消费商品\n\n/**\n * 仓库类，用于管理产品的生产、消费和存储。\n */\npublic class storage<t> {\n    private int index = 0;\n    private static final int max = 10;//最大容量\n    private list<t> storages = new arraylist<t>(max);//存储集合\n\n    public synchronized void produce(t item) {\n        while (index >= max) {// 判断仓库满了，则等待。\n            try {\n                system.out.println("仓库满了，等待中...");\n                this.wait();\n                system.out.println("仓库不满了，开始生产");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n        system.out.println("生产>>" + item.tostring());\n        storages.add(item);\n        index++;   //先添加item，在进行加1操作\n        notify();  //生产完 唤醒在此对象监视器上等待的单个线程，即消费者线程\n    }\n\n    public synchronized t consume() {\n        while (index <= 0) {// 判断仓库空了，则等待。\n            try {\n                system.out.println("仓库为空，等待中...");\n                this.wait();\n                system.out.println("仓库不为空，开始消费");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n\n        index--;//先进行减1操作，再remove\n        t item = storages.remove(index);\n        system.out.println("消费>>" + item.tostring());\n        notify();\n        return item;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 产品\n\npublic class phone {\n\n    private int id;// 手机编号\n\n    public phone(int id) {\n        this.id = id;\n    }\n\n    @override\n    public string tostring() {\n        return "手机编号：" + id;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 生产者\n\npublic class producer implements runnable {\n\n    private storage<phone> storage;\n    \n    public producer(storage<phone> storage) {\n        this.storage = storage;\n    }\n\n    public void run() {\n        for(int i = 0;i<20;i++){\n            storage.produce(new phone(i));\n            \n            try {\n                thread.sleep(10);//每隔10毫秒生产一个产品\n            } catch (interruptedexception e) {\n                // todo auto-generated catch block\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 消费者\n\npublic class consumer implements runnable {\n\n    private storage<phone> storage;\n    \n    public consumer(storage<phone> storage) {\n        this.storage = storage;\n    }\n\n    public void run() {\n        for(int i = 0;i<20;i++){\n            storage.consume();\n            try {\n                thread.sleep(100);//每隔100毫秒消费一个\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 测试类\n\npublic class producerandconsumer {\n\n    public static void main(string[] args) {\n        storage<phone> storage = new storage<phone>();\n        \n        new thread(new producer(storage)).start();\n        new thread(new consumer(storage)).start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 测试类\n\n生产>>手机编号：0\n消费>>手机编号：0\n生产>>手机编号：1\n生产>>手机编号：2\n生产>>手机编号：3\n生产>>手机编号：4\n生产>>手机编号：5\n生产>>手机编号：6\n生产>>手机编号：7\n生产>>手机编号：8\n生产>>手机编号：9\n消费>>手机编号：9\n生产>>手机编号：10\n生产>>手机编号：11\n仓库满了，等待中...\n消费>>手机编号：11\n仓库不满了，开始生产\n生产>>手机编号：12\n仓库满了，等待中...\n消费>>手机编号：12\n仓库不满了，开始生产\n生产>>手机编号：13\n仓库满了，等待中...\n消费>>手机编号：13\n仓库不满了，开始生产\n生产>>手机编号：14\n仓库满了，等待中...\n消费>>手机编号：14\n仓库不满了，开始生产\n生产>>手机编号：15\n仓库满了，等待中...\n消费>>手机编号：15\n仓库不满了，开始生产\n生产>>手机编号：16\n仓库满了，等待中...\n消费>>手机编号：16\n仓库不满了，开始生产\n生产>>手机编号：17\n仓库满了，等待中...\n消费>>手机编号：17\n仓库不满了，开始生产\n生产>>手机编号：18\n仓库满了，等待中...\n消费>>手机编号：18\n仓库不满了，开始生产\n生产>>手机编号：19\n消费>>手机编号：19\n消费>>手机编号：10\n消费>>手机编号：8\n消费>>手机编号：7\n消费>>手机编号：6\n消费>>手机编号：5\n消费>>手机编号：4\n消费>>手机编号：3\n消费>>手机编号：2\n消费>>手机编号：1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 代码关键点分析\n\n\n# 锁问题\n\n仓库类 storage 中 方法produce(t item) 和consume()要使用关键字synchronized修饰。使得变量index在多线程环境下的修改时线程安全的。\n\n * public synchronized void produce(t item):生产商品\n * public synchronized t consume():消费商品\n\n\n# 线程的等待与重启\n\n生产者线程的等待： 在生产时达到仓库的最大值后，要停止生产，此时需要调用 wait()方法。\n\nwhile (index >= max) {// 判断仓库满了，则等待。\n            try {\n                system.out.println("仓库满了，等待中...");\n                this.wait();\n                system.out.println("仓库不满了，开始生产");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n生产者线程的重启：消费后，调用notify()方法 唤醒 等待当前锁的线程。\n\n        index--;//先进行减1操作，再remove\n        t item = storages.remove(index);\n        system.out.println("消费>>" + item.tostring());\n        notify();\n\n\n1\n2\n3\n4\n\n\n\n# 循环放置在producer和consumer类的run方法中\n\n模拟多次生产/消费。\n\nfor(int i = 0;i<20;i++){\n            storage.consume();\n            try {\n                thread.sleep(100);//每隔100毫秒消费一个\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 时间延迟问题\n\nthread.sleep(10);s设置每隔10毫秒生产一个产品， 模拟生产和消费的随机过程，还要设置时间延迟，否则会发生只有生产达到最大值后才会开始消费。\n\npublic void run() {\n        for(int i = 0;i<20;i++){\n            storage.produce(new phone(i));\n            \n            try {\n                thread.sleep(10);//每隔10毫秒生产一个产品\n            } catch (interruptedexception e) {\n                // todo auto-generated catch block\n                e.printstacktrace();\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"ThreadLocal 实现原理是什么？为什么要使用弱引用？",frontmatter:{title:"ThreadLocal 实现原理是什么？为什么要使用弱引用？",date:"2022-03-11T00:45:50.000Z",permalink:"/pages/b3e720/",categories:["Java相关","并发"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/150.ThreadLocal%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F.html",relativePath:"01.Java相关/20.并发/150.ThreadLocal 实现原理是什么？为什么要使用弱引用？.md",key:"v-f406b4e6",path:"/pages/b3e720/",headers:[{level:2,title:"ThreadLocal 实现原理是什么？为什么要使用弱引用？",slug:"threadlocal-实现原理是什么-为什么要使用弱引用",normalizedTitle:"threadlocal 实现原理是什么？为什么要使用弱引用？",charIndex:2},{level:2,title:"ThreadLocal解决什么问题？",slug:"threadlocal解决什么问题",normalizedTitle:"threadlocal解决什么问题？",charIndex:57},{level:2,title:"ThreadLocal底层是什么数据结构？",slug:"threadlocal底层是什么数据结构",normalizedTitle:"threadlocal底层是什么数据结构？",charIndex:382},{level:2,title:"ThreadLocal有什么应用场景？",slug:"threadlocal有什么应用场景",normalizedTitle:"threadlocal有什么应用场景？",charIndex:1520},{level:2,title:"为什么要使用弱引用？",slug:"为什么要使用弱引用",normalizedTitle:"为什么要使用弱引用？",charIndex:22},{level:2,title:"子线程可以从父线程继承 ThreadLocal 吗？",slug:"子线程可以从父线程继承-threadlocal-吗",normalizedTitle:"子线程可以从父线程继承 threadlocal 吗？",charIndex:109},{level:2,title:"ThreadLocal使用不当会有内存泄漏是怎么回事？",slug:"threadlocal使用不当会有内存泄漏是怎么回事",normalizedTitle:"threadlocal使用不当会有内存泄漏是怎么回事？",charIndex:135},{level:2,title:"使用 ThreadLocal 如何防止内存泄漏 ？",slug:"使用-threadlocal-如何防止内存泄漏",normalizedTitle:"使用 threadlocal 如何防止内存泄漏 ？",charIndex:3009},{level:2,title:"Netty 的FastThreadLocal fast在哪里？",slug:"netty-的fastthreadlocal-fast在哪里",normalizedTitle:"netty 的fastthreadlocal fast在哪里？",charIndex:171},{level:2,title:"FastThreadLocal 性能 比 ThreadLocal 高多少？",slug:"fastthreadlocal-性能-比-threadlocal-高多少",normalizedTitle:"fastthreadlocal 性能 比 threadlocal 高多少？",charIndex:4196}],headersStr:"ThreadLocal 实现原理是什么？为什么要使用弱引用？ ThreadLocal解决什么问题？ ThreadLocal底层是什么数据结构？ ThreadLocal有什么应用场景？ 为什么要使用弱引用？ 子线程可以从父线程继承 ThreadLocal 吗？ ThreadLocal使用不当会有内存泄漏是怎么回事？ 使用 ThreadLocal 如何防止内存泄漏 ？ Netty 的FastThreadLocal fast在哪里？ FastThreadLocal 性能 比 ThreadLocal 高多少？",content:'# ThreadLocal 实现原理是什么？为什么要使用弱引用？\n\nThreadLocal可以问的点有很多，比如：ThreadLocal解决什么问题？底层结构是什么？实现原理是什么？有什么应用场景？为什么要使用弱引用？子线程可以从父线程继承 ThreadLocal 吗？ThreadLocal使用不当会有内存泄漏是怎么回事？正确的使用姿势是？Netty 的FastThreadLocal fast在哪里？\n下面我们一个个来看下这些问题。\n\n\n\n# ThreadLocal解决什么问题？\n\n\n通常情况下，我们创建的变量任何线程来读取读到的都是同一个值，如果想实现每一个线程都有自己的专属值该如何解决呢\n？JDK中提供的ThreadLocal类正是为了解决这样的问题。\n比如SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本\n\n\n\n# ThreadLocal底层是什么数据结构？\n\n\n实际上是Map，Key为ThreadLocal变量、value为值。\n\n\n\n\n我们先看下Thread类的源码\n\npublic class Thread implements Runnable {\n ......\n//与此线程有关的ThreadLocal值。由ThreadLocal类维护\nThreadLocal.ThreadLocalMap threadLocals = null;\n\n/*\n * InheritableThreadLocal，自父线程集成而来的ThreadLocalMap，\n * 主要用于父子线程间ThreadLocal变量的传递\n * 本文主要讨论的就是这个ThreadLocalMap\n */\nThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们可以把 ThreadLocal.ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap. 我们再来看下 ThreadLocal 类的源码\n\n    //调用Thread.set 实际上是往当前线程的 ThreadLocalMap 里面put一个键值对\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n    //调用Thread.getMap 可以获取到当前线程的 ThreadLocalMap\n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n\n    //ThreadLocalMap可以存储以ThreadLocal为key ，Object 对象为 value的键值对。\n    ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n        ......\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ThreadLocal有什么应用场景？\n\n\n * 非线程安全的工具类，需要每个线程持有一个副本，比如 SimpleDateFormat\n * 异步传递traceId\n\n\n# 为什么要使用弱引用？\n\n\nThreadLocalMap的内部类Entry被设计为实现了WeakReference，Entry用来存放数据。\n\n\n弱引用简单理解就是当垃圾回收时，该对象只被WeakReference对象的弱引用字段所引用，而未被任何强类型的对象引用，那么，该弱引用的对象就会被回收。\n注意：WeakReference引用本身是强引用，它内部的（T reference）才是真正的弱引用字段，WeakReference就是一个装弱引用的容器而已。\n那 为什么要使用弱引用呢？\n这是因为：ThreadLocalMap本身并没有为外界提供取出和存放数据的API，我们所能获得数据的方式只有通过ThreadLocal类提供的API来间接的从ThreadLocalMap取出数据，所以，当我们用不了key（ThreadLocal对象）的API也就无法从ThreadLocalMap里取出指定的数据。\n\n一般我们new 一个ThreadLocal对象的时候，它一定会有强引用，在ThreadLocalMap中也一定会有它的弱引用\n当强引用不在的时候一定是我们的程序不再需要这个ThreadLocal对象了 为什么这么说？\n比如我定义了一个 ThreadLocal 变量 formatter，formatter 对 ThreadLocal 变量的强引用关系不存在的一个case 是getDate()方法执行完了，那么当然ThreadLocal 变量是可以回收的。\n\n\npublic void getDate(){\n\n    ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));\n    ......\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 子线程可以从父线程继承 ThreadLocal 吗？\n\n\nThreadLocal 不可以。InheritableThreadLocals 是可以的，它重写了ThreadLocal的三个方法。childValue，createMap，getMap。\n\n\nInheritableThreadLocal 不能和线程池搭配使用\n因为线程池中的线程是复用的，并没有重新初始化线程，InheritableThreadLocal之所以起作用是因为在Thread类中最终会调用init()方法去把InheritableThreadLocal的map复制到子线程中。\n由于线程池复用了已有线程，所以没有调用init()方法这个过程，也就不能将父线程中的InheritableThreadLocal值传给子线程。\n\n\n# ThreadLocal使用不当会有内存泄漏是怎么回事？\n\n\nThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。\n所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\n这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。\n\n\n\n# 使用 ThreadLocal 如何防止内存泄漏 ？\n\n\n使用完 ThreadLocal 手动调用remove方法。 看下 ThreadLocal 的 remove() 会清理 ThreadLocalMap 中 key 为 null的键值对。\n\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n\n\n1\n2\n3\n4\n5\n\n\nThreadLocal 的 get() 有清除操作，那我们是不是不用手动调用 remove() 了？\n不是的。因为 get() 中清除操作 只会检测本次get的 ThreadLocal 变量是否需要清理 。而 remove() 会检测 ThreadLocalMap 中的所有键值对。\n\n\n所以，手动调用remove() 才是最保险的。\n\n\n\n# Netty 的FastThreadLocal fast在哪里？\n\n\n既然jdk已经有ThreadLocal，为何netty还要自己造个FastThreadLocal？FastThreadLocal快在哪里？\n这需要从jdk ThreadLocal的本身说起。如下图：\n在java线程中，每个线程都有一个ThreadLocalMap实例变量（如果不使用ThreadLocal，不会创建这个Map，一个线程第一次访问某个ThreadLocal变量时，才会创建）。该Map是使用线性探测的方式解决hash冲突的问题，如果没有找到空闲的slot，就不断往后尝试，直到找到一个空闲的位置，插入entry，这种方式在经常遇到hash冲突时，影响效率。\n\nFastThreadLocal(下文简称ftl)直接使用数组避免了hash冲突的发生，具体做法是：每一个FastThreadLocal实例创建时，分配一个下标index；分配index使用AtomicInteger实现，每个FastThreadLocal都能获取到一个不重复的下标。当调用ftl.get()方法获取值时，直接从数组获取返回，如return array[index]，如下图：\n\nFastThreadLocal 底层结构代码\n\nstatic final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();\nstatic final AtomicInteger nextIndex = new AtomicInteger();\nObject[] indexedVariables;\n\n\n1\n2\n3\n\n\n\n# FastThreadLocal 性能 比 ThreadLocal 高多少？\n\n\n远高于。\nFastThreadLocal 对 ThreadLocal 的优化点在于，将元素放入 ThreadLocalMap 采用数组结构随机访问代替 原来的 线性探测。 所以我们测试场景为：单线程访问多 FastThreadLocal/ThreadLocal 变量:\n\n/**\n * 单线程访问多个ThreadLocal\n */\npublic static void testThreadLocalWithMultipleThreadLocal() {\n    ThreadLocal<String> threadLocal[] = new ThreadLocal[count];\n    for (int i = 0; i < count; i++) {\n        threadLocal[i] = new ThreadLocal<String>();\n    }\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            long start = System.currentTimeMillis();\n            for (int i = 0; i < count; i++) {\n                threadLocal[i].set("value" + i);\n            }\n            long middle = System.currentTimeMillis();\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < count; j++) {\n                    threadLocal[i].get();\n                }\n            }\n            long end = System.currentTimeMillis();\n            System.out.println("testThreadLocalWithMultipleThreadLocal set:" + (middle - start) + ",get:" + (end - middle));\n        }\n    }).start();\n}\n\n/**\n * 单线程访问多个FastThreadLocal\n */\npublic static void testFastThreadLocalWithMultipleFastThreadLocal() {\n    FastThreadLocal<String> threadLocal[] = new FastThreadLocal[count];\n    for (int i = 0; i < count; i++) {\n        threadLocal[i] = new FastThreadLocal<String>();\n    }\n    new FastThreadLocalThread(new Runnable() {\n        @Override\n        public void run() {\n            long start = System.currentTimeMillis();\n            for (int i = 0; i < count; i++) {\n                threadLocal[i].set("value" + i);\n            }\n            long middle = System.currentTimeMillis();\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < count; j++) {\n                    threadLocal[i].get();\n                }\n            }\n            long end = System.currentTimeMillis();\n            System.out.println("testFastThreadLocalWithMultipleFastThreadLocal set:" + (middle - start) + ",get:" + (end - middle));\n        }\n    }).start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n输出:\n\ntestThreadLocalWithMultipleThreadLocal set:68,get:21492\ntestFastThreadLocalWithMultipleFastThreadLocal set:61,get:8\n\n\n\n\n1\n2\n3\n4\n\n\n有结果可知，FastThreadLocal 性能远高于 ThreadLocal。',normalizedContent:'# threadlocal 实现原理是什么？为什么要使用弱引用？\n\nthreadlocal可以问的点有很多，比如：threadlocal解决什么问题？底层结构是什么？实现原理是什么？有什么应用场景？为什么要使用弱引用？子线程可以从父线程继承 threadlocal 吗？threadlocal使用不当会有内存泄漏是怎么回事？正确的使用姿势是？netty 的fastthreadlocal fast在哪里？\n下面我们一个个来看下这些问题。\n\n\n\n# threadlocal解决什么问题？\n\n\n通常情况下，我们创建的变量任何线程来读取读到的都是同一个值，如果想实现每一个线程都有自己的专属值该如何解决呢\n？jdk中提供的threadlocal类正是为了解决这样的问题。\n比如simpledateformat 不是线程安全的，所以每个线程都要有自己独立的副本\n\n\n\n# threadlocal底层是什么数据结构？\n\n\n实际上是map，key为threadlocal变量、value为值。\n\n\n\n\n我们先看下thread类的源码\n\npublic class thread implements runnable {\n ......\n//与此线程有关的threadlocal值。由threadlocal类维护\nthreadlocal.threadlocalmap threadlocals = null;\n\n/*\n * inheritablethreadlocal，自父线程集成而来的threadlocalmap，\n * 主要用于父子线程间threadlocal变量的传递\n * 本文主要讨论的就是这个threadlocalmap\n */\nthreadlocal.threadlocalmap inheritablethreadlocals = null;\n ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们可以把 threadlocal.threadlocalmap 理解为threadlocal 类实现的定制化的 hashmap. 我们再来看下 threadlocal 类的源码\n\n    //调用thread.set 实际上是往当前线程的 threadlocalmap 里面put一个键值对\n    public void set(t value) {\n        thread t = thread.currentthread();\n        threadlocalmap map = getmap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createmap(t, value);\n    }\n\n    //调用thread.getmap 可以获取到当前线程的 threadlocalmap\n    threadlocalmap getmap(thread t) {\n        return t.threadlocals;\n    }\n\n    //threadlocalmap可以存储以threadlocal为key ，object 对象为 value的键值对。\n    threadlocalmap(threadlocal<?> firstkey, object firstvalue) {\n        ......\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# threadlocal有什么应用场景？\n\n\n * 非线程安全的工具类，需要每个线程持有一个副本，比如 simpledateformat\n * 异步传递traceid\n\n\n# 为什么要使用弱引用？\n\n\nthreadlocalmap的内部类entry被设计为实现了weakreference，entry用来存放数据。\n\n\n弱引用简单理解就是当垃圾回收时，该对象只被weakreference对象的弱引用字段所引用，而未被任何强类型的对象引用，那么，该弱引用的对象就会被回收。\n注意：weakreference引用本身是强引用，它内部的（t reference）才是真正的弱引用字段，weakreference就是一个装弱引用的容器而已。\n那 为什么要使用弱引用呢？\n这是因为：threadlocalmap本身并没有为外界提供取出和存放数据的api，我们所能获得数据的方式只有通过threadlocal类提供的api来间接的从threadlocalmap取出数据，所以，当我们用不了key（threadlocal对象）的api也就无法从threadlocalmap里取出指定的数据。\n\n一般我们new 一个threadlocal对象的时候，它一定会有强引用，在threadlocalmap中也一定会有它的弱引用\n当强引用不在的时候一定是我们的程序不再需要这个threadlocal对象了 为什么这么说？\n比如我定义了一个 threadlocal 变量 formatter，formatter 对 threadlocal 变量的强引用关系不存在的一个case 是getdate()方法执行完了，那么当然threadlocal 变量是可以回收的。\n\n\npublic void getdate(){\n\n    threadlocal<simpledateformat> formatter = threadlocal.withinitial(() -> new simpledateformat("yyyymmdd hhmm"));\n    ......\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 子线程可以从父线程继承 threadlocal 吗？\n\n\nthreadlocal 不可以。inheritablethreadlocals 是可以的，它重写了threadlocal的三个方法。childvalue，createmap，getmap。\n\n\ninheritablethreadlocal 不能和线程池搭配使用\n因为线程池中的线程是复用的，并没有重新初始化线程，inheritablethreadlocal之所以起作用是因为在thread类中最终会调用init()方法去把inheritablethreadlocal的map复制到子线程中。\n由于线程池复用了已有线程，所以没有调用init()方法这个过程，也就不能将父线程中的inheritablethreadlocal值传给子线程。\n\n\n# threadlocal使用不当会有内存泄漏是怎么回事？\n\n\nthreadlocalmap 中使用的 key 为 threadlocal 的弱引用,而 value 是强引用。\n所以，如果 threadlocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\n这样一来，threadlocalmap 中就会出现key为null的entry。假如我们不做任何措施的话，value 永远无法被gc 回收，这个时候就可能会产生内存泄露。\n\n\n\n# 使用 threadlocal 如何防止内存泄漏 ？\n\n\n使用完 threadlocal 手动调用remove方法。 看下 threadlocal 的 remove() 会清理 threadlocalmap 中 key 为 null的键值对。\n\npublic void remove() {\n    threadlocalmap m = getmap(thread.currentthread());\n    if (m != null)\n        m.remove(this);\n}\n\n\n1\n2\n3\n4\n5\n\n\nthreadlocal 的 get() 有清除操作，那我们是不是不用手动调用 remove() 了？\n不是的。因为 get() 中清除操作 只会检测本次get的 threadlocal 变量是否需要清理 。而 remove() 会检测 threadlocalmap 中的所有键值对。\n\n\n所以，手动调用remove() 才是最保险的。\n\n\n\n# netty 的fastthreadlocal fast在哪里？\n\n\n既然jdk已经有threadlocal，为何netty还要自己造个fastthreadlocal？fastthreadlocal快在哪里？\n这需要从jdk threadlocal的本身说起。如下图：\n在java线程中，每个线程都有一个threadlocalmap实例变量（如果不使用threadlocal，不会创建这个map，一个线程第一次访问某个threadlocal变量时，才会创建）。该map是使用线性探测的方式解决hash冲突的问题，如果没有找到空闲的slot，就不断往后尝试，直到找到一个空闲的位置，插入entry，这种方式在经常遇到hash冲突时，影响效率。\n\nfastthreadlocal(下文简称ftl)直接使用数组避免了hash冲突的发生，具体做法是：每一个fastthreadlocal实例创建时，分配一个下标index；分配index使用atomicinteger实现，每个fastthreadlocal都能获取到一个不重复的下标。当调用ftl.get()方法获取值时，直接从数组获取返回，如return array[index]，如下图：\n\nfastthreadlocal 底层结构代码\n\nstatic final threadlocal<internalthreadlocalmap> slowthreadlocalmap = new threadlocal<internalthreadlocalmap>();\nstatic final atomicinteger nextindex = new atomicinteger();\nobject[] indexedvariables;\n\n\n1\n2\n3\n\n\n\n# fastthreadlocal 性能 比 threadlocal 高多少？\n\n\n远高于。\nfastthreadlocal 对 threadlocal 的优化点在于，将元素放入 threadlocalmap 采用数组结构随机访问代替 原来的 线性探测。 所以我们测试场景为：单线程访问多 fastthreadlocal/threadlocal 变量:\n\n/**\n * 单线程访问多个threadlocal\n */\npublic static void testthreadlocalwithmultiplethreadlocal() {\n    threadlocal<string> threadlocal[] = new threadlocal[count];\n    for (int i = 0; i < count; i++) {\n        threadlocal[i] = new threadlocal<string>();\n    }\n    new thread(new runnable() {\n        @override\n        public void run() {\n            long start = system.currenttimemillis();\n            for (int i = 0; i < count; i++) {\n                threadlocal[i].set("value" + i);\n            }\n            long middle = system.currenttimemillis();\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < count; j++) {\n                    threadlocal[i].get();\n                }\n            }\n            long end = system.currenttimemillis();\n            system.out.println("testthreadlocalwithmultiplethreadlocal set:" + (middle - start) + ",get:" + (end - middle));\n        }\n    }).start();\n}\n\n/**\n * 单线程访问多个fastthreadlocal\n */\npublic static void testfastthreadlocalwithmultiplefastthreadlocal() {\n    fastthreadlocal<string> threadlocal[] = new fastthreadlocal[count];\n    for (int i = 0; i < count; i++) {\n        threadlocal[i] = new fastthreadlocal<string>();\n    }\n    new fastthreadlocalthread(new runnable() {\n        @override\n        public void run() {\n            long start = system.currenttimemillis();\n            for (int i = 0; i < count; i++) {\n                threadlocal[i].set("value" + i);\n            }\n            long middle = system.currenttimemillis();\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < count; j++) {\n                    threadlocal[i].get();\n                }\n            }\n            long end = system.currenttimemillis();\n            system.out.println("testfastthreadlocalwithmultiplefastthreadlocal set:" + (middle - start) + ",get:" + (end - middle));\n        }\n    }).start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n输出:\n\ntestthreadlocalwithmultiplethreadlocal set:68,get:21492\ntestfastthreadlocalwithmultiplefastthreadlocal set:61,get:8\n\n\n\n\n1\n2\n3\n4\n\n\n有结果可知，fastthreadlocal 性能远高于 threadlocal。',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"常见的 GC 回收算法有哪些？",frontmatter:{title:"常见的 GC 回收算法有哪些？",date:"2022-09-18T19:01:29.000Z",permalink:"/pages/9b26e8/",categories:["Java相关","JVM"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/30.JVM/010.%E5%B8%B8%E8%A7%81%E7%9A%84%20GC%20%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.html",relativePath:"01.Java相关/30.JVM/010.常见的 GC 回收算法有哪些？.md",key:"v-af821fc8",path:"/pages/9b26e8/",headers:[{level:2,title:"标记-清除算法",slug:"标记-清除算法",normalizedTitle:"标记-清除算法",charIndex:2},{level:2,title:"标记-复制算法",slug:"标记-复制算法",normalizedTitle:"标记-复制算法",charIndex:148},{level:2,title:"标记-整理算法",slug:"标记-整理算法",normalizedTitle:"标记-整理算法",charIndex:281},{level:2,title:"分代收集算法",slug:"分代收集算法",normalizedTitle:"分代收集算法",charIndex:382},{level:2,title:"垃圾收集器",slug:"垃圾收集器",normalizedTitle:"垃圾收集器",charIndex:682},{level:2,title:"Serial 收集器",slug:"serial-收集器",normalizedTitle:"serial 收集器",charIndex:893},{level:2,title:"ParNew 收集器",slug:"parnew-收集器",normalizedTitle:"parnew 收集器",charIndex:1324},{level:2,title:"Parallel Scavenge 收集器",slug:"parallel-scavenge-收集器",normalizedTitle:"parallel scavenge 收集器",charIndex:1678},{level:2,title:"Serial Old 收集器",slug:"serial-old-收集器",normalizedTitle:"serial old 收集器",charIndex:2694},{level:2,title:"Parallel Old 收集器",slug:"parallel-old-收集器",normalizedTitle:"parallel old 收集器",charIndex:2826},{level:2,title:"CMS 收集器",slug:"cms-收集器",normalizedTitle:"cms 收集器",charIndex:1503},{level:2,title:"G1 收集器",slug:"g1-收集器",normalizedTitle:"g1 收集器",charIndex:3638},{level:2,title:"ZGC 收集器",slug:"zgc-收集器",normalizedTitle:"zgc 收集器",charIndex:4351}],headersStr:"标记-清除算法 标记-复制算法 标记-整理算法 分代收集算法 垃圾收集器 Serial 收集器 ParNew 收集器 Parallel Scavenge 收集器 Serial Old 收集器 Parallel Old 收集器 CMS 收集器 G1 收集器 ZGC 收集器",content:'# 标记-清除算法\n\n该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\n\n效率问题 空间问题（标记清除后会产生大量不连续的碎片）\n\n\n# 标记-复制算法\n\n为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n\n\n# 标记-整理算法\n\n根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n\n# 分代收集算法\n\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n延伸面试问题： HotSpot 为什么要分为新生代和老年代？\n\n根据上面的对分代收集算法的介绍回答。\n\n\n# 垃圾收集器\n\n如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。\n\n虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。\n\n\n# Serial 收集器\n\nSerial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。\n\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\n\n但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。\n\n\n# ParNew 收集器\n\nParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。\n\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\n\n并行和并发概念补充：\n\n并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n\n并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。\n\n\n# Parallel Scavenge 收集器\n\nParallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 那么它有什么特别之处呢？\n\n-XX:+UseParallelGC\n\n    使用 Parallel 收集器+ 老年代串行\n\n-XX:+UseParallelOldGC\n\n    使用 Parallel 收集器+ 老年代并行\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nParallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。\n\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n这是 JDK1.8 默认收集器\n\n使用 java -XX:+PrintCommandLineFlags -version 命令查看\n\n-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC\njava version "1.8.0_211"\nJava(TM) SE Runtime Environment (build 1.8.0_211-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)\nJDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能\n\n\n1\n2\n3\n4\n5\n\n\n\n# Serial Old 收集器\n\nSerial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\n\n\n# Parallel Old 收集器\n\nParallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。\n\n\n# CMS 收集器\n\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。\n\nCMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\n\n从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n\n初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\n\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\n\n对 CPU 资源敏感； 无法处理浮动垃圾； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\n\n# G1 收集器\n\nG1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.\n\n被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：\n\n并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。 空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。 G1 收集器的运作大致分为以下几个步骤：\n\n初始标记 并发标记 最终标记 筛选回收 G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\n\n# ZGC 收集器\n\n与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。\n\n在 ZGC 中出现 Stop The World 的情况会更少！ 详情可以看 ： 《新一代垃圾回收器 ZGC 的探索与实践》',normalizedContent:'# 标记-清除算法\n\n该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\n\n效率问题 空间问题（标记清除后会产生大量不连续的碎片）\n\n\n# 标记-复制算法\n\n为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n\n\n# 标记-整理算法\n\n根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n\n# 分代收集算法\n\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n延伸面试问题： hotspot 为什么要分为新生代和老年代？\n\n根据上面的对分代收集算法的介绍回答。\n\n\n# 垃圾收集器\n\n如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。\n\n虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 hotspot 虚拟机就不会实现那么多不同的垃圾收集器了。\n\n\n# serial 收集器\n\nserial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "stop the world" ），直到它收集结束。\n\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n虚拟机的设计者们当然知道 stop the world 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\n\n但是 serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。serial 收集器对于运行在 client 模式下的虚拟机来说是个不错的选择。\n\n\n# parnew 收集器\n\nparnew 收集器其实就是 serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 serial 收集器完全一样。\n\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n它是许多运行在 server 模式下的虚拟机的首要选择，除了 serial 收集器外，只有它能与 cms 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\n\n并行和并发概念补充：\n\n并行（parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n\n并发（concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 cpu 上。\n\n\n# parallel scavenge 收集器\n\nparallel scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 parnew 都一样。 那么它有什么特别之处呢？\n\n-xx:+useparallelgc\n\n    使用 parallel 收集器+ 老年代串行\n\n-xx:+useparalleloldgc\n\n    使用 parallel 收集器+ 老年代并行\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nparallel scavenge 收集器关注点是吞吐量（高效率的利用 cpu）。cms 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 cpu 中用于运行用户代码的时间与 cpu 总消耗时间的比值。 parallel scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 parallel scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。\n\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n这是 jdk1.8 默认收集器\n\n使用 java -xx:+printcommandlineflags -version 命令查看\n\n-xx:initialheapsize=262921408 -xx:maxheapsize=4206742528 -xx:+printcommandlineflags -xx:+usecompressedclasspointers -xx:+usecompressedoops -xx:+useparallelgc\njava version "1.8.0_211"\njava(tm) se runtime environment (build 1.8.0_211-b12)\njava hotspot(tm) 64-bit server vm (build 25.211-b12, mixed mode)\njdk1.8 默认使用的是 parallel scavenge + parallel old，如果指定了-xx:+useparallelgc 参数，则默认指定了-xx:+useparalleloldgc，可以使用-xx:-useparalleloldgc 来禁用该功能\n\n\n1\n2\n3\n4\n5\n\n\n\n# serial old 收集器\n\nserial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 jdk1.5 以及以前的版本中与 parallel scavenge 收集器搭配使用，另一种用途是作为 cms 收集器的后备方案。\n\n\n# parallel old 收集器\n\nparallel scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 cpu 资源的场合，都可以优先考虑 parallel scavenge 收集器和 parallel old 收集器。\n\n\n# cms 收集器\n\ncms（concurrent mark sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。\n\ncms（concurrent mark sweep）收集器是 hotspot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\n\n从名字中的mark sweep这两个词可以看出，cms 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n\n初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记： 同时开启 gc 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 gc 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 gc 线程开始对未标记的区域做清扫。\n\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\n\n对 cpu 资源敏感； 无法处理浮动垃圾； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\n\n\n# g1 收集器\n\ng1 (garbage-first) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 gc 停顿时间要求的同时,还具备高吞吐量性能特征.\n\n被视为 jdk1.7 中 hotspot 虚拟机的一个重要进化特征。它具备以下特点：\n\n并行与并发：g1 能充分利用 cpu、多核环境下的硬件优势，使用多个 cpu（cpu 或者 cpu 核心）来缩短 stop-the-world 停顿时间。部分其他收集器原本需要停顿 java 线程执行的 gc 动作，g1 收集器仍然可以通过并发的方式让 java 程序继续执行。 分代收集：虽然 g1 可以不需要其他收集器配合就能独立管理整个 gc 堆，但是还是保留了分代的概念。 空间整合：与 cms 的“标记-清理”算法不同，g1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。 可预测的停顿：这是 g1 相对于 cms 的另一个大优势，降低停顿时间是 g1 和 cms 共同的关注点，但 g1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 m 毫秒的时间片段内。 g1 收集器的运作大致分为以下几个步骤：\n\n初始标记 并发标记 最终标记 筛选回收 g1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 region(这也就是它的名字 garbage-first 的由来) 。这种使用 region 划分内存空间以及有优先级的区域回收方式，保证了 g1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\n\n# zgc 收集器\n\n与 cms 中的 parnew 和 g1 类似，zgc 也采用标记-复制算法，不过 zgc 对该算法做了重大改进。\n\n在 zgc 中出现 stop the world 的情况会更少！ 详情可以看 ： 《新一代垃圾回收器 zgc 的探索与实践》',charsets:{cjk:!0},lastUpdated:"2022/09/18, 21:28:02",lastUpdatedTimestamp:1663507682e3},{title:"Java 中垃圾回收机制中如何判断对象需要回收？",frontmatter:{title:"Java 中垃圾回收机制中如何判断对象需要回收？",date:"2022-05-21T17:31:41.000Z",permalink:"/pages/948850/",categories:["Java相关","JVM"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/30.JVM/001.Java%20%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6%EF%BC%9F.html",relativePath:"01.Java相关/30.JVM/001.Java 中垃圾回收机制中如何判断对象需要回收？.md",key:"v-7cd97c82",path:"/pages/948850/",headers:[{level:2,title:"引用计数法",slug:"引用计数法",normalizedTitle:"引用计数法",charIndex:95},{level:2,title:"可达性分析算法",slug:"可达性分析算法",normalizedTitle:"可达性分析算法",charIndex:738},{level:2,title:"引用类型总结",slug:"引用类型总结",normalizedTitle:"引用类型总结",charIndex:1442},{level:2,title:"如何判断一个常量是废弃常量？",slug:"如何判断一个常量是废弃常量",normalizedTitle:"如何判断一个常量是废弃常量？",charIndex:2760},{level:2,title:"如何判断一个类是无用的类",slug:"如何判断一个类是无用的类",normalizedTitle:"如何判断一个类是无用的类",charIndex:2930}],headersStr:"引用计数法 可达性分析算法 引用类型总结 如何判断一个常量是废弃常量？ 如何判断一个类是无用的类",content:'Java 中垃圾回收机制中如何判断对象需要回收？ 即死亡对象判断方法 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。\n\n\n# 引用计数法\n\n给对象中添加一个引用计数器：\n\n每当有一个地方引用它，计数器就加 1； 当引用失效，计数器就减 1； 任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\n\n所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\n\npublic class ReferenceCountingGc {\n    Object instance = null;\n    public static void main(String[] args) {\n        ReferenceCountingGc objA = new ReferenceCountingGc();\n        ReferenceCountingGc objB = new ReferenceCountingGc();\n        objA.instance = objB;\n        objB.instance = objA;\n        objA = null;\n        objB = null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 可达性分析算法\n\n这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\n\n下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。\n\n哪些对象可以作为 GC Roots 呢？\n\n虚拟机栈(栈帧中的本地变量表)中引用的对象 本地方法栈(Native 方法)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 所有被同步锁持有的对象 对象可以被回收，就代表一定会被回收吗？\n\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 \'finalize\' 方法。当对象没有覆盖 \'finalize\' 方法，或 \'finalize\' 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n> Object 类中的 finalize 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 finalize 方法会被逐渐弃用移除。忘掉它的存在吧！\n\n\n# 引用类型总结\n\n无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。\n\nJDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\n\nJDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\n\n1．强引用（StrongReference）\n\n以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n2．软引用（SoftReference）\n\n如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n3．弱引用（WeakReference）\n\n如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n4．虚引用（PhantomReference）\n\n"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n虚引用主要用来跟踪对象被垃圾回收的活动。\n\n虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。\n\n\n# 如何判断一个常量是废弃常量？\n\n运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？\n\n假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。\n\n\n# 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n\n * 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n * 加载该类的 ClassLoader 已经被回收。\n * 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。',normalizedContent:'java 中垃圾回收机制中如何判断对象需要回收？ 即死亡对象判断方法 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。\n\n\n# 引用计数法\n\n给对象中添加一个引用计数器：\n\n每当有一个地方引用它，计数器就加 1； 当引用失效，计数器就减 1； 任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。\n\n所谓对象之间的相互引用问题，如下面代码所示：除了对象 obja 和 objb 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 gc 回收器回收他们。\n\npublic class referencecountinggc {\n    object instance = null;\n    public static void main(string[] args) {\n        referencecountinggc obja = new referencecountinggc();\n        referencecountinggc objb = new referencecountinggc();\n        obja.instance = objb;\n        objb.instance = obja;\n        obja = null;\n        objb = null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 可达性分析算法\n\n这个算法的基本思想就是通过一系列的称为 “gc roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 gc roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\n\n下图中的 object 6 ~ object 10 之间虽有引用关系，但它们到 gc roots 不可达，因此为需要被回收的对象。\n\n哪些对象可以作为 gc roots 呢？\n\n虚拟机栈(栈帧中的本地变量表)中引用的对象 本地方法栈(native 方法)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 所有被同步锁持有的对象 对象可以被回收，就代表一定会被回收吗？\n\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 \'finalize\' 方法。当对象没有覆盖 \'finalize\' 方法，或 \'finalize\' 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n> object 类中的 finalize 方法一直被认为是一个糟糕的设计，成为了 java 语言的负担，影响了 java 语言的安全和 gc 的性能。jdk9 版本及后续版本中各个类中的 finalize 方法会被逐渐弃用移除。忘掉它的存在吧！\n\n\n# 引用类型总结\n\n无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。\n\njdk1.2 之前，java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\n\njdk1.2 以后，java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\n\n1．强引用（strongreference）\n\n以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，java 虚拟机宁愿抛出 outofmemoryerror 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n2．软引用（softreference）\n\n如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n\n软引用可以和一个引用队列（referencequeue）联合使用，如果软引用所引用的对象被垃圾回收，java 虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n3．弱引用（weakreference）\n\n如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n\n弱引用可以和一个引用队列（referencequeue）联合使用，如果弱引用所引用的对象被垃圾回收，java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n4．虚引用（phantomreference）\n\n"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n虚引用主要用来跟踪对象被垃圾回收的活动。\n\n虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（referencequeue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 jvm 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（outofmemory）等问题的产生。\n\n\n# 如何判断一个常量是废弃常量？\n\n运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？\n\n假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 string 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。\n\n\n# 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：\n\n * 该类所有的实例都已经被回收，也就是 java 堆中不存在该类的任何实例。\n * 加载该类的 classloader 已经被回收。\n * 该类对应的 java.lang.class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。',charsets:{cjk:!0},lastUpdated:"2022/09/18, 21:28:02",lastUpdatedTimestamp:1663507682e3},{title:"Java 中如何进行 GC 调优？",frontmatter:{title:"Java 中如何进行 GC 调优？",date:"2022-05-21T17:31:53.000Z",permalink:"/pages/07a030/",categories:["Java相关","JVM"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/30.JVM/020.Java%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%20GC%20%E8%B0%83%E4%BC%98%EF%BC%9F.html",relativePath:"01.Java相关/30.JVM/020.Java 中如何进行 GC 调优？.md",key:"v-5474bec0",path:"/pages/07a030/",headers:[{level:2,title:"GC优化需知",slug:"gc优化需知",normalizedTitle:"gc优化需知",charIndex:305},{level:2,title:"JVM内存结构",slug:"jvm内存结构",normalizedTitle:"jvm内存结构",charIndex:506},{level:2,title:"常见垃圾回收器",slug:"常见垃圾回收器",normalizedTitle:"常见垃圾回收器",charIndex:1401},{level:2,title:"参数基本策略",slug:"参数基本策略",normalizedTitle:"参数基本策略",charIndex:1751},{level:2,title:"确定目标",slug:"确定目标",normalizedTitle:"确定目标",charIndex:2165},{level:2,title:"优化",slug:"优化",normalizedTitle:"优化",charIndex:20},{level:2,title:"验收优化结果",slug:"验收优化结果",normalizedTitle:"验收优化结果",charIndex:2841}],headersStr:"GC优化需知 JVM内存结构 常见垃圾回收器 参数基本策略 确定目标 优化 验收优化结果",content:"当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化。 但GC算法复杂，影响GC性能的参数众多，且参数调整又依赖于应用各自的特点，这些因素很大程度上增加了GC优化的难度。\n\n即便如此，GC调优也不是无章可循，仍然有一些通用的思考方法。\n\n本篇会介绍这些通用的GC优化策略和相关实践案例，主要包括如下内容：\n\n> 优化前准备: 简单回顾JVM相关知识、介绍GC优化的一些通用策略。\n> 优化方法: 介绍调优的一般流程：明确优化目标→优化→跟踪优化结果。\n> 优化案例: 简述笔者所在团队遇到的GC问题以及优化方案。\n\n\n# 一、优化前的准备\n\n\n# GC优化需知\n\n为了更好地理解本篇所介绍的内容，你需要了解如下内容。 1. GC相关基础知识，包括但不限于： a) GC工作原理。 b) 理解新生代、老年代、晋升等术语含义。 c) 可以看懂GC日志。\n\nGC优化不能解决一切性能问题，它是最后的调优手段。 如果对第一点中提及的知识点不是很熟悉，可以先阅读小结-JVM基础回顾；如果已经很熟悉，可以跳过该节直接往下阅读。\n\n\n# JVM基础回顾\n\n\n# JVM内存结构\n\n简单介绍一下JVM内存结构和常见的垃圾回收器。\n\n当代主流虚拟机（Hotspot VM）的垃圾回收都采用“分代回收”的算法。“分代回收”是基于这样一个事实：对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率。\n\nHotspot VM将内存划分为不同的物理区，就是“分代”思想的体现。如图所示，JVM内存主要由新生代、老年代、永久代构成。\n\n\n\n① 新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。\n\n新生代内又分三个区：一个Eden区，两个Survivor区（一般而言），大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。\n\n② 老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。\n\n③ 永久代（Perm Generation）：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。\n\n\n# 常见垃圾回收器\n\n不同的垃圾回收器，适用于不同的场景。常用的垃圾回收器：\n\n串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。 并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。 吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。 并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。 GC日志 每一种回收器的日志格式都是由其自身的实现决定的，换而言之，每种回收器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个回收器的日志都维持一定的共性。JavaGC日志 中简单介绍了这些共性。\n\n\n# 参数基本策略\n\n各分区的大小对GC的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。\n\n活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中Full GC之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取GC数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下（见参考文献1）：\n\n例如，根据GC日志获得老年代的活跃数据大小为300M，那么各分区大小可以设为：\n\n总堆：1200MB = 300MB × 4* 新生代：450MB = 300MB × 1.5* 老年代： 750MB = 1200MB - 450MB*\n\n这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。\n\n\n# 二、优化步骤\n\nGC优化一般步骤可以概括为：确定目标、优化参数、验收结果。\n\n\n# 确定目标\n\n明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如： - 高可用，可用性达到几个9。 - 低延迟，请求必须多少毫秒内完成响应。 - 高吞吐，每秒完成多少次事务。\n\n明确系统需求之所以重要，是因为上述性能指标间可能冲突。比如通常情况下，缩小延迟的代价是降低吞吐量或者消耗更多的内存或者两者同时发生。\n\n由于笔者所在团队主要关注高可用和低延迟两项指标，所以接下来分析，如何量化GC时间和频率对于响应时间和可用性的影响。通过这个量化指标，可以计算出当前GC情况对服务的影响，也能评估出GC优化后对响应时间的收益，这两点对于低延迟服务很重要。\n\n举例：假设单位时间T内发生一次持续25ms的GC，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：\n\n\n\n那么有(50ms+25ms)/T比例的请求会受GC影响，其中GC前的50ms内到达的请求都会增加25ms，GC期间的25ms内到达的请求，会增加0-25ms不等，如果时间T内发生N次GC，受GC影响请求占比=(接口响应时间+GC时间)×N/T 。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。\n\n\n# 优化\n\n通过收集GC信息，结合系统需求，确定优化方案，例如选用合适的GC回收器、重新设置内存比例、调整JVM参数等。\n\n进行调整后，将不同的优化方案分别应用到多台机器上，然后比较这些机器上GC的性能差异，有针对性的做出选择，再通过不断的试验和观察，找到最合适的参数。\n\n\n# 验收优化结果\n\n将修改应用到所有服务器，判断优化结果是否符合预期，总结相关经验。\n\n参考：美团技术团队-从实际案例聊聊Java应用的GC优化",normalizedContent:"当java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为gc优化。 但gc算法复杂，影响gc性能的参数众多，且参数调整又依赖于应用各自的特点，这些因素很大程度上增加了gc优化的难度。\n\n即便如此，gc调优也不是无章可循，仍然有一些通用的思考方法。\n\n本篇会介绍这些通用的gc优化策略和相关实践案例，主要包括如下内容：\n\n> 优化前准备: 简单回顾jvm相关知识、介绍gc优化的一些通用策略。\n> 优化方法: 介绍调优的一般流程：明确优化目标→优化→跟踪优化结果。\n> 优化案例: 简述笔者所在团队遇到的gc问题以及优化方案。\n\n\n# 一、优化前的准备\n\n\n# gc优化需知\n\n为了更好地理解本篇所介绍的内容，你需要了解如下内容。 1. gc相关基础知识，包括但不限于： a) gc工作原理。 b) 理解新生代、老年代、晋升等术语含义。 c) 可以看懂gc日志。\n\ngc优化不能解决一切性能问题，它是最后的调优手段。 如果对第一点中提及的知识点不是很熟悉，可以先阅读小结-jvm基础回顾；如果已经很熟悉，可以跳过该节直接往下阅读。\n\n\n# jvm基础回顾\n\n\n# jvm内存结构\n\n简单介绍一下jvm内存结构和常见的垃圾回收器。\n\n当代主流虚拟机（hotspot vm）的垃圾回收都采用“分代回收”的算法。“分代回收”是基于这样一个事实：对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率。\n\nhotspot vm将内存划分为不同的物理区，就是“分代”思想的体现。如图所示，jvm内存主要由新生代、老年代、永久代构成。\n\n\n\n① 新生代（young generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称minor gc）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。\n\n新生代内又分三个区：一个eden区，两个survivor区（一般而言），大部分对象在eden区中生成。当eden区满时，还存活的对象将被复制到两个survivor区（中的一个）。当这个survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个survivor区。对象每经历一次minor gc，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在serial和parnew gc两种回收器中，“晋升年龄阈值”通过参数maxtenuringthreshold设定，默认值为15。\n\n② 老年代（old generation）：在新生代中经历了n次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称major gc）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为full gc（hotspot vm里，除了cms之外，其它能收集老年代的gc都会同时收集整个gc堆，包括新生代）。\n\n③ 永久代（perm generation）：主要存放元数据，例如class、method的元信息，与垃圾回收要回收的java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。\n\n\n# 常见垃圾回收器\n\n不同的垃圾回收器，适用于不同的场景。常用的垃圾回收器：\n\n串行（serial）回收器是单线程的一个回收器，简单、易实现、效率高。 并行（parnew）回收器是serial的多线程版，可以充分的利用cpu资源，减少回收的时间。 吞吐量优先（parallel scavenge）回收器，侧重于吞吐量的控制。 并发标记清除（cms，concurrent mark sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。 gc日志 每一种回收器的日志格式都是由其自身的实现决定的，换而言之，每种回收器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个回收器的日志都维持一定的共性。javagc日志 中简单介绍了这些共性。\n\n\n# 参数基本策略\n\n各分区的大小对gc的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。\n\n活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是full gc后堆中老年代占用空间的大小。可以通过gc日志中full gc之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取gc数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下（见参考文献1）：\n\n例如，根据gc日志获得老年代的活跃数据大小为300m，那么各分区大小可以设为：\n\n总堆：1200mb = 300mb × 4* 新生代：450mb = 300mb × 1.5* 老年代： 750mb = 1200mb - 450mb*\n\n这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。\n\n\n# 二、优化步骤\n\ngc优化一般步骤可以概括为：确定目标、优化参数、验收结果。\n\n\n# 确定目标\n\n明确应用程序的系统需求是性能优化的基础，系统的需求是指应用程序运行时某方面的要求，譬如： - 高可用，可用性达到几个9。 - 低延迟，请求必须多少毫秒内完成响应。 - 高吞吐，每秒完成多少次事务。\n\n明确系统需求之所以重要，是因为上述性能指标间可能冲突。比如通常情况下，缩小延迟的代价是降低吞吐量或者消耗更多的内存或者两者同时发生。\n\n由于笔者所在团队主要关注高可用和低延迟两项指标，所以接下来分析，如何量化gc时间和频率对于响应时间和可用性的影响。通过这个量化指标，可以计算出当前gc情况对服务的影响，也能评估出gc优化后对响应时间的收益，这两点对于低延迟服务很重要。\n\n举例：假设单位时间t内发生一次持续25ms的gc，接口平均响应时间为50ms，且请求均匀到达，根据下图所示：\n\n\n\n那么有(50ms+25ms)/t比例的请求会受gc影响，其中gc前的50ms内到达的请求都会增加25ms，gc期间的25ms内到达的请求，会增加0-25ms不等，如果时间t内发生n次gc，受gc影响请求占比=(接口响应时间+gc时间)×n/t 。可见无论降低单次gc时间还是降低gc次数n都可以有效减少gc对响应时间的影响。\n\n\n# 优化\n\n通过收集gc信息，结合系统需求，确定优化方案，例如选用合适的gc回收器、重新设置内存比例、调整jvm参数等。\n\n进行调整后，将不同的优化方案分别应用到多台机器上，然后比较这些机器上gc的性能差异，有针对性的做出选择，再通过不断的试验和观察，找到最合适的参数。\n\n\n# 验收优化结果\n\n将修改应用到所有服务器，判断优化结果是否符合预期，总结相关经验。\n\n参考：美团技术团队-从实际案例聊聊java应用的gc优化",charsets:{cjk:!0},lastUpdated:"2022/09/18, 21:28:02",lastUpdatedTimestamp:1663507682e3},{title:"JMM 中内存模型是怎样的？什么是指令序列重排序？",frontmatter:{title:"JMM 中内存模型是怎样的？什么是指令序列重排序？",date:"2022-05-21T17:32:49.000Z",permalink:"/pages/c8e6cb/",categories:["Java相关","JVM"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/30.JVM/030.JMM%20%E4%B8%AD%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F.html",relativePath:"01.Java相关/30.JVM/030.JMM 中内存模型是怎样的？什么是指令序列重排序？.md",key:"v-0970cd54",path:"/pages/c8e6cb/",headers:[{level:2,title:"为什么要有内存模型？",slug:"为什么要有内存模型",normalizedTitle:"为什么要有内存模型？",charIndex:40},{level:2,title:"硬件内存架构",slug:"硬件内存架构",normalizedTitle:"硬件内存架构",charIndex:73},{level:2,title:"缓存一致性问题",slug:"缓存一致性问题",normalizedTitle:"缓存一致性问题",charIndex:557},{level:2,title:"处理器优化和指令重排序",slug:"处理器优化和指令重排序",normalizedTitle:"处理器优化和指令重排序",charIndex:943},{level:2,title:"并发编程的问题",slug:"并发编程的问题",normalizedTitle:"并发编程的问题",charIndex:1368}],headersStr:"为什么要有内存模型？ 硬件内存架构 缓存一致性问题 处理器优化和指令重排序 并发编程的问题",content:"Java内存模型(JMM)和 Java 运行时内存区域是不一样的概念。\n\n\n# 为什么要有内存模型？\n\n要想回答这个问题，我们需要先弄懂传统计算机硬件内存架构。好了，我要开始画图了。\n\n\n# 硬件内存架构\n\n\n\n（1）CPU\n\n去过机房的同学都知道，一般在大型服务器上会配置多个CPU，每个CPU还会有多个\n\n核\n\n，这就意味着多个CPU或者多个核可以同时（并发）工作。如果使用Java 起了一个多线程的任务，很有可能每个 CPU 都会跑一个线程，那么你的任务在某一刻就是真正并发执行了。\n\n（2）CPU Register\n\nCPU Register也就是 CPU 寄存器。CPU 寄存器是 CPU 内部集成的，在寄存器上执行操作的效率要比在主存上高出几个数量级。\n\n（3）CPU Cache Memory\n\nCPU Cache Memory也就是 CPU 高速缓存，相对于寄存器来说，通常也可以成为 L2 二级缓存。相对于硬盘读取速度来说内存读取的效率非常高，但是与 CPU 还是相差数量级，所以在 CPU 和主存间引入了多级缓存，目的是为了做一下缓冲。\n\n（4）Main Memory\n\nMain Memory 就是主存，主存比 L1、L2 缓存要大很多。\n\n注意：部分高端机器还有 L3 三级缓存。\n\n\n# 缓存一致性问题\n\n由于主存与 CPU 处理器的运算能力之间有数量级的差距，所以在传统计算机内存架构中会引入高速缓存来作为主存和处理器之间的缓冲，CPU 将常用的数据放在高速缓存中，运算结束后 CPU 再讲运算结果同步到主存中。\n\n使用高速缓存解决了 CPU 和主存速率不匹配的问题，但同时又引入另外一个新问题：缓存一致性问题。\n\n在多CPU的系统中(或者单CPU多核的系统)，每个CPU内核都有自己的高速缓存，它们共享同一主内存(Main Memory)。当多个CPU的运算任务都涉及同一块主内存区域时，CPU 会将数据读取到缓存中进行运算，这可能会导致各自的缓存数据不一致。\n\n因此需要每个 CPU 访问缓存时遵循一定的协议，在读写数据时根据协议进行操作，共同来维护缓存的一致性。这类协议有 MSI、MESI、MOSI、和 Dragon Protocol 等。\n\n\n# 处理器优化和指令重排序\n\n为了提升性能在 CPU 和主内存之间增加了高速缓存，但在多线程并发场景可能会遇到\n\n。那还有没有办法进一步提升 CPU 的执行效率呢？答案是：处理器优化。\n\n为了使处理器内部的运算单元能够最大化被充分利用，处理器会对输入代码进行乱序执行处理，这就是处理器优化。\n\n除了处理器会对代码进行优化处理，很多现代编程语言的编译器也会做类似的优化，比如像 Java 的即时编译器（JIT）会做指令重排序。\n\n处理器优化其实也是重排序的一种类型，这里总结一下，重排序可以分为三种类型： ** 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。 ** 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 ** 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n\n# 并发编程的问题\n\n上面讲了一堆硬件相关的东西，有些同学可能会有点懵，绕了这么大圈，这些东西跟 Java 内存模型有啥关系吗？不要急咱们慢慢往下看。\n\n熟悉 Java 并发的同学肯定对这三个问题很熟悉：『可见性问题』、『原子性问题』、『有序性问题』。如果从更深层次看这三个问题，其实就是上面讲的『缓存一致性』、『处理器优化』、『指令重排序』造成的。\n\n缓存一致性问题其实就是可见性问题，处理器优化可能会造成原子性问题，指令重排序会造成有序性问题，你看是不是都联系上了。\n\n出了问题总是要解决的，那有什么办法呢？首先想到简单粗暴的办法，干掉缓存让 CPU 直接与主内存交互就解决了可见性问题，禁止处理器优化和指令重排序就解决了原子性和有序性问题，但这样一夜回到解放前了，显然不可取。\n\n所以技术前辈们想到了在物理机器上定义出一套内存模型， 规范内存的读写操作。内存模型解决并发问题主要采用两种方式：\n\n限制处理器优化和使用内存屏障。\n\n参考： 全面学习掌握Java内存模型",normalizedContent:"java内存模型(jmm)和 java 运行时内存区域是不一样的概念。\n\n\n# 为什么要有内存模型？\n\n要想回答这个问题，我们需要先弄懂传统计算机硬件内存架构。好了，我要开始画图了。\n\n\n# 硬件内存架构\n\n\n\n（1）cpu\n\n去过机房的同学都知道，一般在大型服务器上会配置多个cpu，每个cpu还会有多个\n\n核\n\n，这就意味着多个cpu或者多个核可以同时（并发）工作。如果使用java 起了一个多线程的任务，很有可能每个 cpu 都会跑一个线程，那么你的任务在某一刻就是真正并发执行了。\n\n（2）cpu register\n\ncpu register也就是 cpu 寄存器。cpu 寄存器是 cpu 内部集成的，在寄存器上执行操作的效率要比在主存上高出几个数量级。\n\n（3）cpu cache memory\n\ncpu cache memory也就是 cpu 高速缓存，相对于寄存器来说，通常也可以成为 l2 二级缓存。相对于硬盘读取速度来说内存读取的效率非常高，但是与 cpu 还是相差数量级，所以在 cpu 和主存间引入了多级缓存，目的是为了做一下缓冲。\n\n（4）main memory\n\nmain memory 就是主存，主存比 l1、l2 缓存要大很多。\n\n注意：部分高端机器还有 l3 三级缓存。\n\n\n# 缓存一致性问题\n\n由于主存与 cpu 处理器的运算能力之间有数量级的差距，所以在传统计算机内存架构中会引入高速缓存来作为主存和处理器之间的缓冲，cpu 将常用的数据放在高速缓存中，运算结束后 cpu 再讲运算结果同步到主存中。\n\n使用高速缓存解决了 cpu 和主存速率不匹配的问题，但同时又引入另外一个新问题：缓存一致性问题。\n\n在多cpu的系统中(或者单cpu多核的系统)，每个cpu内核都有自己的高速缓存，它们共享同一主内存(main memory)。当多个cpu的运算任务都涉及同一块主内存区域时，cpu 会将数据读取到缓存中进行运算，这可能会导致各自的缓存数据不一致。\n\n因此需要每个 cpu 访问缓存时遵循一定的协议，在读写数据时根据协议进行操作，共同来维护缓存的一致性。这类协议有 msi、mesi、mosi、和 dragon protocol 等。\n\n\n# 处理器优化和指令重排序\n\n为了提升性能在 cpu 和主内存之间增加了高速缓存，但在多线程并发场景可能会遇到\n\n。那还有没有办法进一步提升 cpu 的执行效率呢？答案是：处理器优化。\n\n为了使处理器内部的运算单元能够最大化被充分利用，处理器会对输入代码进行乱序执行处理，这就是处理器优化。\n\n除了处理器会对代码进行优化处理，很多现代编程语言的编译器也会做类似的优化，比如像 java 的即时编译器（jit）会做指令重排序。\n\n处理器优化其实也是重排序的一种类型，这里总结一下，重排序可以分为三种类型： ** 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。 ** 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 ** 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n\n# 并发编程的问题\n\n上面讲了一堆硬件相关的东西，有些同学可能会有点懵，绕了这么大圈，这些东西跟 java 内存模型有啥关系吗？不要急咱们慢慢往下看。\n\n熟悉 java 并发的同学肯定对这三个问题很熟悉：『可见性问题』、『原子性问题』、『有序性问题』。如果从更深层次看这三个问题，其实就是上面讲的『缓存一致性』、『处理器优化』、『指令重排序』造成的。\n\n缓存一致性问题其实就是可见性问题，处理器优化可能会造成原子性问题，指令重排序会造成有序性问题，你看是不是都联系上了。\n\n出了问题总是要解决的，那有什么办法呢？首先想到简单粗暴的办法，干掉缓存让 cpu 直接与主内存交互就解决了可见性问题，禁止处理器优化和指令重排序就解决了原子性和有序性问题，但这样一夜回到解放前了，显然不可取。\n\n所以技术前辈们想到了在物理机器上定义出一套内存模型， 规范内存的读写操作。内存模型解决并发问题主要采用两种方式：\n\n限制处理器优化和使用内存屏障。\n\n参考： 全面学习掌握java内存模型",charsets:{cjk:!0},lastUpdated:"2022/09/18, 21:28:02",lastUpdatedTimestamp:1663507682e3},{title:"JVM 内存是如何对应到操作系统内存的？",frontmatter:{title:"JVM 内存是如何对应到操作系统内存的？",date:"2022-05-21T17:33:05.000Z",permalink:"/pages/da65e7/",categories:["Java相关","JVM"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/30.JVM/040.JVM%20%E5%86%85%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BA%94%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F.html",relativePath:"01.Java相关/30.JVM/040.JVM 内存是如何对应到操作系统内存的？.md",key:"v-2de19204",path:"/pages/da65e7/",headers:[{level:2,title:"Java 内存模型",slug:"java-内存模型",normalizedTitle:"java 内存模型",charIndex:2},{level:2,title:"Java 线程与主内存的关系",slug:"java-线程与主内存的关系",normalizedTitle:"java 线程与主内存的关系",charIndex:216},{level:2,title:"线程间通信",slug:"线程间通信",normalizedTitle:"线程间通信",charIndex:421},{level:2,title:"有态度的总结",slug:"有态度的总结",normalizedTitle:"有态度的总结",charIndex:1043}],headersStr:"Java 内存模型 Java 线程与主内存的关系 线程间通信 有态度的总结",content:"# Java 内存模型\n\n同一套内存模型规范，不同语言在实现上可能会有些差别。接下来着重讲一下 Java 内存模型实现原理。\n\nJava 运行时内存区域与硬件内存的关系\n\n了解过 JVM 的同学都知道，JVM 运行时内存区域是分片的，分为栈、堆等，其实这些都是 JVM 定义的逻辑概念。在传统的硬件内存架构中是没有栈和堆这种概念。\n\n\n\n从图中可以看出栈和堆既存在于高速缓存中又存在于主内存中，所以两者并没有很直接的关系。\n\n\n# Java 线程与主内存的关系\n\nJava 内存模型是一种规范，定义了很多东西：\n\n所有的变量都存储在主内存（Main Memory）中。 每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的拷贝副本。 线程对变量的所有操作都必须在本地内存中进行，而不能直接读写主内存。 不同的线程之间无法直接访问对方本地内存中的变量。 看文字太枯燥了，我又画了一张图：\n\n\n# 线程间通信\n\n如果两个线程都对一个共享变量进行操作，共享变量初始值为 1，每个线程都变量进行加 1，预期共享变量的值为 3。在 JMM 规范下会有一系列的操作。\n\n\n\n为了更好的控制主内存和本地内存的交互，Java 内存模型定义了八种操作来实现：\n\n * lock：锁定。作用于主内存的变量，把一个变量标识为一条线程独占状态。\n * unlock：解锁。作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n * read：读取。作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用\n * load：载入。作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。\n * use：使用。作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\n * assign：赋值。作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n * store：存储。作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。\n * write：写入。作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 注意：工作内存也就是本地内存的意思。\n\n\n# 有态度的总结\n\n由于CPU 和主内存间存在数量级的速率差，想到了引入了多级高速缓存的传统硬件内存架构来解决，多级高速缓存作为 CPU 和主内间的缓冲提升了整体性能。解决了速率差的问题，却又带来了缓存一致性问题。\n\n数据同时存在于高速缓存和主内存中，如果不加以规范势必造成灾难，因此在传统机器上又抽象出了内存模型。\n\nJava 语言在遵循内存模型的基础上推出了 JMM 规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。\n\n为了更精准控制工作内存和主内存间的交互，JMM 还定义了八种操作：lock, unlock, read, load,use,assign, store, write。\n\n好了，今天就给大家介绍到这里，简单总结下Java内存模型的定义：Java内存模型并不是一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发操作不会产生歧义；但是，也必须得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存等）来获取更好的执行速度。经过长时间的验证和修补，在JDK1.5发布后，Java内存模型就已经成熟和完善起来了。\n\n参考： 全面学习掌握Java内存模型",normalizedContent:"# java 内存模型\n\n同一套内存模型规范，不同语言在实现上可能会有些差别。接下来着重讲一下 java 内存模型实现原理。\n\njava 运行时内存区域与硬件内存的关系\n\n了解过 jvm 的同学都知道，jvm 运行时内存区域是分片的，分为栈、堆等，其实这些都是 jvm 定义的逻辑概念。在传统的硬件内存架构中是没有栈和堆这种概念。\n\n\n\n从图中可以看出栈和堆既存在于高速缓存中又存在于主内存中，所以两者并没有很直接的关系。\n\n\n# java 线程与主内存的关系\n\njava 内存模型是一种规范，定义了很多东西：\n\n所有的变量都存储在主内存（main memory）中。 每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的拷贝副本。 线程对变量的所有操作都必须在本地内存中进行，而不能直接读写主内存。 不同的线程之间无法直接访问对方本地内存中的变量。 看文字太枯燥了，我又画了一张图：\n\n\n# 线程间通信\n\n如果两个线程都对一个共享变量进行操作，共享变量初始值为 1，每个线程都变量进行加 1，预期共享变量的值为 3。在 jmm 规范下会有一系列的操作。\n\n\n\n为了更好的控制主内存和本地内存的交互，java 内存模型定义了八种操作来实现：\n\n * lock：锁定。作用于主内存的变量，把一个变量标识为一条线程独占状态。\n * unlock：解锁。作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n * read：读取。作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用\n * load：载入。作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。\n * use：使用。作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\n * assign：赋值。作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n * store：存储。作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。\n * write：写入。作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 注意：工作内存也就是本地内存的意思。\n\n\n# 有态度的总结\n\n由于cpu 和主内存间存在数量级的速率差，想到了引入了多级高速缓存的传统硬件内存架构来解决，多级高速缓存作为 cpu 和主内间的缓冲提升了整体性能。解决了速率差的问题，却又带来了缓存一致性问题。\n\n数据同时存在于高速缓存和主内存中，如果不加以规范势必造成灾难，因此在传统机器上又抽象出了内存模型。\n\njava 语言在遵循内存模型的基础上推出了 jmm 规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。\n\n为了更精准控制工作内存和主内存间的交互，jmm 还定义了八种操作：lock, unlock, read, load,use,assign, store, write。\n\n好了，今天就给大家介绍到这里，简单总结下java内存模型的定义：java内存模型并不是一件容易的事情，这个模型必须定义得足够严谨，才能让java的并发操作不会产生歧义；但是，也必须得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存等）来获取更好的执行速度。经过长时间的验证和修补，在jdk1.5发布后，java内存模型就已经成熟和完善起来了。\n\n参考： 全面学习掌握java内存模型",charsets:{cjk:!0},lastUpdated:"2022/09/18, 21:28:02",lastUpdatedTimestamp:1663507682e3},{title:"JVM 是怎么去调优的？了解哪些参数和指令？",frontmatter:{title:"JVM 是怎么去调优的？了解哪些参数和指令？",date:"2022-05-21T17:33:16.000Z",permalink:"/pages/d730dd/",categories:["Java相关","JVM"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/30.JVM/050.JVM%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%8E%BB%E8%B0%83%E4%BC%98%E7%9A%84%EF%BC%9F%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%87%E4%BB%A4%EF%BC%9F.html",relativePath:"01.Java相关/30.JVM/050.JVM 是怎么去调优的？了解哪些参数和指令？.md",key:"v-37fcb440",path:"/pages/d730dd/",headers:[{level:2,title:"查看进程",slug:"查看进程",normalizedTitle:"查看进程",charIndex:2},{level:2,title:"查看JVM参数 jinfo",slug:"查看jvm参数-jinfo",normalizedTitle:"查看jvm参数 jinfo",charIndex:162},{level:2,title:"查看各项指标数据 jstat",slug:"查看各项指标数据-jstat",normalizedTitle:"查看各项指标数据 jstat",charIndex:251},{level:2,title:"jmap",slug:"jmap",normalizedTitle:"jmap",charIndex:588}],headersStr:"查看进程 查看JVM参数 jinfo 查看各项指标数据 jstat jmap",content:"# 查看进程\n\n由于JVM大多数命令都是需要用到进程id的，所以我们需要先查看一下我们系统的进程id，通过使用jps -l，输出所有java相关进程。\n\n这里我们可以根据类名，大致确认出我们的系统进程是什么\n\n注：-l代表的是输出应用程序main class的完整package名或者应用程序的jar文件完整路径名\n\n\n# 查看JVM参数 jinfo\n\n通过运行jinfo -flags <端口号>查看jvm的参数。\n\n通过运行jinfo -sysprops <端口号>查看java系统参数。\n\n\n# 查看各项指标数据 jstat\n\n通过运行 -class <端口号>完成类加载统计 通过运行jstat -gc <端口号>完成垃圾回收统计 通过运行jstat -gccapacity <端口号>完成堆内存统计 通过运行jstat -gcnew <端口号>完成新生代垃圾回收统计 通过运行jstat -gcnewcapacity <端口号>完成新生代内存统计 通过运行jstat -gcold <端口号>完成老年代垃圾回收统计 通过运行jstat -gcoldcapacity <端口号>完成老年代内存统计 通过运行jstat -gcmetacapacity <端口号>完成老年代内存统计 通过运行jstat -gcutil <端口号>数据总览 查看对象及内存使用情况 通过运行jmap -histo <端口号> > ./log.txt类及其对象所占内存数据。\n\n\n# jmap\n\n通过运行jmap -heap <端口号>堆信息。\n\n参考： 深度好文：JVM调优 Java核心篇-故事里的JVM性能调优",normalizedContent:"# 查看进程\n\n由于jvm大多数命令都是需要用到进程id的，所以我们需要先查看一下我们系统的进程id，通过使用jps -l，输出所有java相关进程。\n\n这里我们可以根据类名，大致确认出我们的系统进程是什么\n\n注：-l代表的是输出应用程序main class的完整package名或者应用程序的jar文件完整路径名\n\n\n# 查看jvm参数 jinfo\n\n通过运行jinfo -flags <端口号>查看jvm的参数。\n\n通过运行jinfo -sysprops <端口号>查看java系统参数。\n\n\n# 查看各项指标数据 jstat\n\n通过运行 -class <端口号>完成类加载统计 通过运行jstat -gc <端口号>完成垃圾回收统计 通过运行jstat -gccapacity <端口号>完成堆内存统计 通过运行jstat -gcnew <端口号>完成新生代垃圾回收统计 通过运行jstat -gcnewcapacity <端口号>完成新生代内存统计 通过运行jstat -gcold <端口号>完成老年代垃圾回收统计 通过运行jstat -gcoldcapacity <端口号>完成老年代内存统计 通过运行jstat -gcmetacapacity <端口号>完成老年代内存统计 通过运行jstat -gcutil <端口号>数据总览 查看对象及内存使用情况 通过运行jmap -histo <端口号> > ./log.txt类及其对象所占内存数据。\n\n\n# jmap\n\n通过运行jmap -heap <端口号>堆信息。\n\n参考： 深度好文：jvm调优 java核心篇-故事里的jvm性能调优",charsets:{cjk:!0},lastUpdated:"2022/09/18, 21:28:02",lastUpdatedTimestamp:1663507682e3},{title:"什么是内存泄漏，怎么确定内存泄漏？",frontmatter:{title:"什么是内存泄漏，怎么确定内存泄漏？",date:"2022-05-21T17:33:27.000Z",permalink:"/pages/3ab5f5/",categories:["Java相关","JVM"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/30.JVM/060.%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F.html",relativePath:"01.Java相关/30.JVM/060.什么是内存泄漏，怎么确定内存泄漏？.md",key:"v-15fba8f1",path:"/pages/3ab5f5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"一、介绍",slug:"一、介绍",normalizedTitle:"一、介绍",charIndex:178},{level:3,title:"1、什么是内存泄漏",slug:"_1、什么是内存泄漏",normalizedTitle:"1、什么是内存泄漏",charIndex:187},{level:3,title:"2、内存泄漏的危害",slug:"_2、内存泄漏的危害",normalizedTitle:"2、内存泄漏的危害",charIndex:404},{level:2,title:"二、内存泄漏原因",slug:"二、内存泄漏原因",normalizedTitle:"二、内存泄漏原因",charIndex:491},{level:3,title:"1、大量使用静态变量",slug:"_1、大量使用静态变量",normalizedTitle:"1、大量使用静态变量",charIndex:583},{level:3,title:"2、连接资源未关闭",slug:"_2、连接资源未关闭",normalizedTitle:"2、连接资源未关闭",charIndex:1310},{level:3,title:"4、内部类持有外部类",slug:"_4、内部类持有外部类",normalizedTitle:"4、内部类持有外部类",charIndex:2418},{level:3,title:"5、finalize方法",slug:"_5、finalize方法",normalizedTitle:"5、finalize方法",charIndex:2445},{level:3,title:"6、ThreadLocal的错误使用",slug:"_6、threadlocal的错误使用",normalizedTitle:"6、threadlocal的错误使用",charIndex:2595},{level:2,title:"三、检测内存泄漏",slug:"三、检测内存泄漏",normalizedTitle:"三、检测内存泄漏",charIndex:3062},{level:3,title:"1、工具分析",slug:"_1、工具分析",normalizedTitle:"1、工具分析",charIndex:3106},{level:3,title:"2、垃圾回收分析",slug:"_2、垃圾回收分析",normalizedTitle:"2、垃圾回收分析",charIndex:3232},{level:3,title:"3、基准测试",slug:"_3、基准测试",normalizedTitle:"3、基准测试",charIndex:3374},{level:2,title:"四、结论",slug:"四、结论",normalizedTitle:"四、结论",charIndex:3418}],headersStr:"前言 一、介绍 1、什么是内存泄漏 2、内存泄漏的危害 二、内存泄漏原因 1、大量使用静态变量 2、连接资源未关闭 4、内部类持有外部类 5、finalize方法 6、ThreadLocal的错误使用 三、检测内存泄漏 1、工具分析 2、垃圾回收分析 3、基准测试 四、结论",content:'# 前言\n\n这个问题是我之前翻看面经的时候见到的。那位小姐姐把内存泄漏当成了内存溢出问题去解答的，结果当场挂掉了。为此总结一下，之前和一位老哥也讨论过这个问题。可见不管是面试还是工作这都是一个极为重要的点。\n\n我也曾在面阿里的时候也遇到过原题，题目是写出俩内存泄漏案例，然后问如何排查？如何解决？\n\n本篇文章大体结构来自外国大佬baeldung；\n\n\n# 一、介绍\n\n\n# 1、什么是内存泄漏\n\njava的优势之一就是内置了垃圾回收器GC，它帮助我们实现了自动化内存管理。但是GC再好，也有老马失前蹄的时候，它不能保证提供一个解决内存泄漏的万无一失的解决方案。什么是内存泄漏？可以看看下面这张图，\n\n也就是一部分内存空间我明明已经使用了，却没有引用指向这部分空间。造成这片已经使用的空间无法处理的情况。\n\n正规点的理解：动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。\n\n\n# 2、内存泄漏的危害\n\n长时间运行，程序变卡，性能严重下降 程序莫名其妙挂掉 OutOfMemoryError错误 乱七八糟的错误，还不易排查 反正内存泄漏不是好事。\n\n\n# 二、内存泄漏原因\n\n内存泄漏原因太多了。说不定就是某一行代码不对就会出现这种情况，因此这里给出最常见的几种。关键的还是如何找出哪个地方出现了内存泄漏，代码好修改，错误不易查。\n\n\n# 1、大量使用静态变量\n\n静态变量的生命周期与程序一致。因此常驻内存。\n\npublic class Static Test{\n    public static List<Integer> list = new ArrayList<>();\n    public void populateList(){\n        for (int i = 0; i < 10000000; i++) {\n            list.add((int)Math.random()); \n        } \n        System.out.println("running......"); \n    }\n    public static void main(String[] args){ \n        System.out.println("before......");\n        new StaticTest().populateList(); \n        System.out.println("after......");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n现在可以使用jvisualvm运行一边，看看内存效果。\n\n * 带static关键字（使用静态变量）\n\n从上图可以看到，堆内存从一开始的135M左右飙升了到了200M。直接占据了65M的内存。\n\n * 不使用static关键字（不使用静态变量）\n\n由于全局变量与程序周期不一致，因此不使用时，就会进行回收。此时内存最高150M。\n\n总结：由于静态变量与程序生命周期一致，因此对象常驻内存，造成内存泄漏\n\n\n# 2、连接资源未关闭\n\n每当建立一个连接，jvm就会为这么资源分配内存。比如数据库连接、文件输入输出流、网络连接等等。\n\npublic class File Test{\n    public static void main(String[] args)throws IOException {\n        File f=new File("G:\\\\nginx配套资料\\\\笔记资料.zip"); \n        System.out.println(f.exists());\n        System.out.println(f.isDirectory());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n依然使用jvisualvm运行一边，看看内存效果。\n\n可以看出，在连接文件资源时，jvm会为本资源分配内存。\n\n3、equals()和hashCode()方法使用不当\n\n定义新类时，如果没有重新equals()和hashCode()方法，也有可能会造成内存泄漏。主要原因是没有这两个方法时，很容易造成重复的数据添加。看例子：\n\npublic class User{\n    public String name;\n    publicint age;\n    public User(String name, int age){\n    this.name = name;\n    this.age = age;}\n    }\n    public class EqualTest{\n        public static void main(String[] args){ \n            Map<User, Integer> map = new HashMap<>();\n            for(int i=0; i<100; i++) { \n            map.put(new User("", 1), 1);\n        } \n        System.out.println(map.size() == 1);//输出为false \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n然后运行一下，看看内存情况：\n\n内存从150M一下子飙升到225M，可见飙升的厉害。输出为false，说明user对象被重复添加了。我们知道像HashMap在添加新的对象时，会对其hashcode进行比较，如果一样，那就不插入。如果一样那就插入。此时说明这100个User其hashcode不同。\n\n\n# 4、内部类持有外部类\n\n这个场景和上面类似。\n\n\n# 5、finalize方法\n\n这个方法之前曾经专门花过文章写过，这个问题很简单。看一张图\n\n这就是整个过程。不过在这里我们主要看的是finalize方法对垃圾回收的影响，其实就是在第三步，也就是这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。造成内存泄漏。\n\n\n# 6、ThreadLocal的错误使用\n\nThreadLocal主要用于创建本地线程变量，不合理的使用也有可能会造成内存泄漏。\n\n上面这张图详细的揭示了ThreadLocal和Thread以及ThreadLocalMap三者的关系。\n\n1、Thread中有一个map，就是ThreadLocalMap\n\n2、ThreadLocalMap的key是ThreadLocal，值是我们自己设定的。\n\n3、ThreadLocal是一个弱引用，当为null时，会被当成垃圾回收\n\n4、重点来了，突然我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。\n\n解决办法：使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。\n\n现在介绍了几种常见的内存泄漏情况，上面的知识点比较常见，最主要的是如何检测出来。\n\n\n# 三、检测内存泄漏\n\n检测的目的是定位内存泄漏出现的位置，常见的有以下几种方法：\n\n\n# 1、工具分析\n\n这个工具比较多，比如说JProfiler、YourKit、Java VisualVM和Netbeans Profiler。他可以帮助我们分析是哪一个对象或者是类内存的飙升。也可以看到内存CPU的等等各种情况。上面多次演示到了。\n\n\n# 2、垃圾回收分析\n\n这个其实也可以用工具进行分析。上面的VisualVM中，可以打印堆。也可以从外部导入dump文件进行分析。\n\n如果不用工具的话，我们可以通过IDE看到。JVM配置添加-verbose:gc。然后就会打印出相关信息。下面这张图非原创，来自Baeldung。\n\n\n# 3、基准测试\n\n也就是使用科学的方式进行分析java代码的性能。进而判断分析。\n\n\n# 四、结论\n\n内存泄漏是个很严重的问题，也比较常见。\n\n最主要的原因是动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。因此良好的代码规范，可以有效地避免这些错误。\n\n参考： 什么是内存泄漏？该如何检测？又该如何解决？',normalizedContent:'# 前言\n\n这个问题是我之前翻看面经的时候见到的。那位小姐姐把内存泄漏当成了内存溢出问题去解答的，结果当场挂掉了。为此总结一下，之前和一位老哥也讨论过这个问题。可见不管是面试还是工作这都是一个极为重要的点。\n\n我也曾在面阿里的时候也遇到过原题，题目是写出俩内存泄漏案例，然后问如何排查？如何解决？\n\n本篇文章大体结构来自外国大佬baeldung；\n\n\n# 一、介绍\n\n\n# 1、什么是内存泄漏\n\njava的优势之一就是内置了垃圾回收器gc，它帮助我们实现了自动化内存管理。但是gc再好，也有老马失前蹄的时候，它不能保证提供一个解决内存泄漏的万无一失的解决方案。什么是内存泄漏？可以看看下面这张图，\n\n也就是一部分内存空间我明明已经使用了，却没有引用指向这部分空间。造成这片已经使用的空间无法处理的情况。\n\n正规点的理解：动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。\n\n\n# 2、内存泄漏的危害\n\n长时间运行，程序变卡，性能严重下降 程序莫名其妙挂掉 outofmemoryerror错误 乱七八糟的错误，还不易排查 反正内存泄漏不是好事。\n\n\n# 二、内存泄漏原因\n\n内存泄漏原因太多了。说不定就是某一行代码不对就会出现这种情况，因此这里给出最常见的几种。关键的还是如何找出哪个地方出现了内存泄漏，代码好修改，错误不易查。\n\n\n# 1、大量使用静态变量\n\n静态变量的生命周期与程序一致。因此常驻内存。\n\npublic class static test{\n    public static list<integer> list = new arraylist<>();\n    public void populatelist(){\n        for (int i = 0; i < 10000000; i++) {\n            list.add((int)math.random()); \n        } \n        system.out.println("running......"); \n    }\n    public static void main(string[] args){ \n        system.out.println("before......");\n        new statictest().populatelist(); \n        system.out.println("after......");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n现在可以使用jvisualvm运行一边，看看内存效果。\n\n * 带static关键字（使用静态变量）\n\n从上图可以看到，堆内存从一开始的135m左右飙升了到了200m。直接占据了65m的内存。\n\n * 不使用static关键字（不使用静态变量）\n\n由于全局变量与程序周期不一致，因此不使用时，就会进行回收。此时内存最高150m。\n\n总结：由于静态变量与程序生命周期一致，因此对象常驻内存，造成内存泄漏\n\n\n# 2、连接资源未关闭\n\n每当建立一个连接，jvm就会为这么资源分配内存。比如数据库连接、文件输入输出流、网络连接等等。\n\npublic class file test{\n    public static void main(string[] args)throws ioexception {\n        file f=new file("g:\\\\nginx配套资料\\\\笔记资料.zip"); \n        system.out.println(f.exists());\n        system.out.println(f.isdirectory());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n依然使用jvisualvm运行一边，看看内存效果。\n\n可以看出，在连接文件资源时，jvm会为本资源分配内存。\n\n3、equals()和hashcode()方法使用不当\n\n定义新类时，如果没有重新equals()和hashcode()方法，也有可能会造成内存泄漏。主要原因是没有这两个方法时，很容易造成重复的数据添加。看例子：\n\npublic class user{\n    public string name;\n    publicint age;\n    public user(string name, int age){\n    this.name = name;\n    this.age = age;}\n    }\n    public class equaltest{\n        public static void main(string[] args){ \n            map<user, integer> map = new hashmap<>();\n            for(int i=0; i<100; i++) { \n            map.put(new user("", 1), 1);\n        } \n        system.out.println(map.size() == 1);//输出为false \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n然后运行一下，看看内存情况：\n\n内存从150m一下子飙升到225m，可见飙升的厉害。输出为false，说明user对象被重复添加了。我们知道像hashmap在添加新的对象时，会对其hashcode进行比较，如果一样，那就不插入。如果一样那就插入。此时说明这100个user其hashcode不同。\n\n\n# 4、内部类持有外部类\n\n这个场景和上面类似。\n\n\n# 5、finalize方法\n\n这个方法之前曾经专门花过文章写过，这个问题很简单。看一张图\n\n这就是整个过程。不过在这里我们主要看的是finalize方法对垃圾回收的影响，其实就是在第三步，也就是这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。造成内存泄漏。\n\n\n# 6、threadlocal的错误使用\n\nthreadlocal主要用于创建本地线程变量，不合理的使用也有可能会造成内存泄漏。\n\n上面这张图详细的揭示了threadlocal和thread以及threadlocalmap三者的关系。\n\n1、thread中有一个map，就是threadlocalmap\n\n2、threadlocalmap的key是threadlocal，值是我们自己设定的。\n\n3、threadlocal是一个弱引用，当为null时，会被当成垃圾回收\n\n4、重点来了，突然我们threadlocal是null了，也就是要被垃圾回收器回收了，但是此时我们的threadlocalmap生命周期和thread的一样，它不会回收，这时候就出现了一个现象。那就是threadlocalmap的key没了，但是value还在，这就造成了内存泄漏。\n\n解决办法：使用完threadlocal后，执行remove操作，避免出现内存溢出情况。\n\n现在介绍了几种常见的内存泄漏情况，上面的知识点比较常见，最主要的是如何检测出来。\n\n\n# 三、检测内存泄漏\n\n检测的目的是定位内存泄漏出现的位置，常见的有以下几种方法：\n\n\n# 1、工具分析\n\n这个工具比较多，比如说jprofiler、yourkit、java visualvm和netbeans profiler。他可以帮助我们分析是哪一个对象或者是类内存的飙升。也可以看到内存cpu的等等各种情况。上面多次演示到了。\n\n\n# 2、垃圾回收分析\n\n这个其实也可以用工具进行分析。上面的visualvm中，可以打印堆。也可以从外部导入dump文件进行分析。\n\n如果不用工具的话，我们可以通过ide看到。jvm配置添加-verbose:gc。然后就会打印出相关信息。下面这张图非原创，来自baeldung。\n\n\n# 3、基准测试\n\n也就是使用科学的方式进行分析java代码的性能。进而判断分析。\n\n\n# 四、结论\n\n内存泄漏是个很严重的问题，也比较常见。\n\n最主要的原因是动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。因此良好的代码规范，可以有效地避免这些错误。\n\n参考： 什么是内存泄漏？该如何检测？又该如何解决？',charsets:{cjk:!0},lastUpdated:"2022/09/18, 21:28:02",lastUpdatedTimestamp:1663507682e3},{title:"简述 CMS 与 G1 机制的区别",frontmatter:{title:"简述 CMS 与 G1 机制的区别",date:"2022-05-21T17:33:40.000Z",permalink:"/pages/be69af/",categories:["Java相关","JVM"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/30.JVM/070.%E7%AE%80%E8%BF%B0%20CMS%20%E4%B8%8E%20G1%20%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"01.Java相关/30.JVM/070.简述 CMS 与 G1 机制的区别.md",key:"v-28c1d6d9",path:"/pages/be69af/",headers:[{level:2,title:"G1特有数据结构和算法",slug:"g1特有数据结构和算法",normalizedTitle:"g1特有数据结构和算法",charIndex:2},{level:3,title:"Region",slug:"region",normalizedTitle:"region",charIndex:18},{level:3,title:"SATB算法",slug:"satb算法",normalizedTitle:"satb算法",charIndex:179},{level:3,title:"三色标记法",slug:"三色标记法",normalizedTitle:"三色标记法",charIndex:248},{level:3,title:"RSet",slug:"rset",normalizedTitle:"rset",charIndex:670},{level:3,title:"垃圾回收过程",slug:"垃圾回收过程",normalizedTitle:"垃圾回收过程",charIndex:1013},{level:3,title:"与CMS相比的优势",slug:"与cms相比的优势",normalizedTitle:"与cms相比的优势",charIndex:1517},{level:2,title:"CMS",slug:"cms",normalizedTitle:"cms",charIndex:255},{level:3,title:"什么是CMS？",slug:"什么是cms",normalizedTitle:"什么是cms？",charIndex:1699},{level:3,title:"CMS有什么用？",slug:"cms有什么用",normalizedTitle:"cms有什么用？",charIndex:1785},{level:3,title:"CMS如何执行？",slug:"cms如何执行",normalizedTitle:"cms如何执行？",charIndex:1865}],headersStr:"G1特有数据结构和算法 Region SATB算法 三色标记法 RSet 垃圾回收过程 与CMS相比的优势 CMS 什么是CMS？ CMS有什么用？ CMS如何执行？",content:"# G1特有数据结构和算法\n\n\n# Region\n\n堆仍然有新生代(eden、survivor)、老年代的划分，但是不再要求它们是内存连续的。每个区都由多个Region组成。 部分老年代Region存储Humongous对象(即下图的H)，这种对象大小大于等于Region的一半。\n\n(图片来源-Java Hotspot G1 GC的一些关键技术)\n\n\n# SATB算法\n\n全称Snapshot-At-The-Beginning，起始时活对象的快照。在理解SATB前需要先了解以下知识。\n\n\n# 三色标记法\n\nCMS和G1的算法都是通过对gc root 进行遍历，并进行三色标记。标记规则为\n\n黑色(black): 节点被遍历完成，而且子节点都遍历完成。 灰色(gray): 当前正在遍历的节点，而且子节点（即对象的域）还没有遍历。遍历完所有子节点后，将成为黑色 白色(white): 还没有遍历到的节点，即灰色节点的子节点。扫描结束仍是白色时会被回收。 并发扫描时，对于白色有两种情况同时发生时，可能会漏标导致被误回收：\n\n增加了被黑色引用的关系。 被灰色下应用，删除了到它的引用 具体执行过程：https://www.cnblogs.com/javaadu/p/10713956.html\n\n按照R大的说法：CMS的incremental update设计使得它在remark阶段必须重新扫描所有线程栈和整个young gen作为root；G1的SATB设计在remark阶段则只需要扫描剩下的satb_mark_queue。\n\n\n# RSet\n\n全称Remember Set，记录一个Region里的对象被哪些其他Region引用。 相对应地，有另一种辅助数据结构Collection Set（CSet），它记录了GC要收集的Region集合。GC时只需扫描CSet中各个Rset即可。\n\n(Tips for Tuning the Garbage First Garbage Collector)\n\n更详细的访问机制和回收过程这里不再展开，有兴趣可以参考后文引用文献。\n\nPause Prediction Model 暂停预测模型，G1根据它计算出的历史数据来预测本次收集需要选择的Region数量，从而尽量满足用户设定的目标停顿时间。 具体算法和公式略，可见Java Hotspot G1 GC的一些关键技术\n\n\n# 垃圾回收过程\n\n分为以下几步：\n\n初始标记（Initial Mark）—— 标记GC root能直接关联的对象（短暂STW） 并发标记（Concurrent mark）—— GCRootsTracing，从并发标记中的root遍历，对不可达的对象进行标记，耗时长但可并行 最终标记（Final Remark）—— 收集并发标记期间产生的新垃圾（短暂STW）,采用了SATB算法比CMS更快 筛选回收（Live Data Counting and Evacuation）—— 对各个Region的回收性价比排序，在保证时间可控的情况下清除失活对象，清除Remember Sets 作为对比，CMS的回收过程\n\n初始标记（CMS Initial Mark）—— 标记GC root能直接关联的对象（短暂STW） 并发标记（CMS Concurrent Mark）—— GCRootsTracing，从并发标记中的root遍历，对不可达的对象进行标记 重新标记（CMS Remark）—— 修正并发标记期间因为用户操作导致标记发生变更的对象，有STW 并发清除（CMS Concurrent Sweep）\n\n\n# 与CMS相比的优势\n\n并发度更高，充分利用CPU多线程 —— CMS对CPU资源敏感，需要占用25%的线程，如果核数小于4更会占用一半的资源。 整体上是标记-整理(分代)，局部是复制(分Region)，运行期不产生碎片 —— CMS是标记-清除，会产生空间碎片和本次回收期间产生导致本次无法回收的浮动垃圾 可预测的停顿(基于Region)\n\n\n# CMS\n\n\n# 什么是CMS？\n\nConcurrent Mark Sweep。\n\n看名字就知道，CMS是一款并发、使用标记-清除算法的gc。\n\nCMS是针对老年代进行回收的GC。\n\n\n# CMS有什么用？\n\nCMS以获取最小停顿时间为目的。\n\n在一些对响应时间有很高要求的应用或网站中，用户程序不能有长时间的停顿，CMS 可以用于此场景。\n\n\n# CMS如何执行？\n\n总体来说CMS的执行过程可以分为以下几个阶段：\n\n      3.1 初始标记(STW)\n\n      3.2 并发标记\n\n      3.3 并发预清理\n\n      3.4 重标记(STW)\n\n      3.5 并发清理\n\n      3.6 重置\n\n\n参考： 关于GC(下)：CMS和G1GC的比较 详解CMS垃圾回收机制",normalizedContent:"# g1特有数据结构和算法\n\n\n# region\n\n堆仍然有新生代(eden、survivor)、老年代的划分，但是不再要求它们是内存连续的。每个区都由多个region组成。 部分老年代region存储humongous对象(即下图的h)，这种对象大小大于等于region的一半。\n\n(图片来源-java hotspot g1 gc的一些关键技术)\n\n\n# satb算法\n\n全称snapshot-at-the-beginning，起始时活对象的快照。在理解satb前需要先了解以下知识。\n\n\n# 三色标记法\n\ncms和g1的算法都是通过对gc root 进行遍历，并进行三色标记。标记规则为\n\n黑色(black): 节点被遍历完成，而且子节点都遍历完成。 灰色(gray): 当前正在遍历的节点，而且子节点（即对象的域）还没有遍历。遍历完所有子节点后，将成为黑色 白色(white): 还没有遍历到的节点，即灰色节点的子节点。扫描结束仍是白色时会被回收。 并发扫描时，对于白色有两种情况同时发生时，可能会漏标导致被误回收：\n\n增加了被黑色引用的关系。 被灰色下应用，删除了到它的引用 具体执行过程：https://www.cnblogs.com/javaadu/p/10713956.html\n\n按照r大的说法：cms的incremental update设计使得它在remark阶段必须重新扫描所有线程栈和整个young gen作为root；g1的satb设计在remark阶段则只需要扫描剩下的satb_mark_queue。\n\n\n# rset\n\n全称remember set，记录一个region里的对象被哪些其他region引用。 相对应地，有另一种辅助数据结构collection set（cset），它记录了gc要收集的region集合。gc时只需扫描cset中各个rset即可。\n\n(tips for tuning the garbage first garbage collector)\n\n更详细的访问机制和回收过程这里不再展开，有兴趣可以参考后文引用文献。\n\npause prediction model 暂停预测模型，g1根据它计算出的历史数据来预测本次收集需要选择的region数量，从而尽量满足用户设定的目标停顿时间。 具体算法和公式略，可见java hotspot g1 gc的一些关键技术\n\n\n# 垃圾回收过程\n\n分为以下几步：\n\n初始标记（initial mark）—— 标记gc root能直接关联的对象（短暂stw） 并发标记（concurrent mark）—— gcrootstracing，从并发标记中的root遍历，对不可达的对象进行标记，耗时长但可并行 最终标记（final remark）—— 收集并发标记期间产生的新垃圾（短暂stw）,采用了satb算法比cms更快 筛选回收（live data counting and evacuation）—— 对各个region的回收性价比排序，在保证时间可控的情况下清除失活对象，清除remember sets 作为对比，cms的回收过程\n\n初始标记（cms initial mark）—— 标记gc root能直接关联的对象（短暂stw） 并发标记（cms concurrent mark）—— gcrootstracing，从并发标记中的root遍历，对不可达的对象进行标记 重新标记（cms remark）—— 修正并发标记期间因为用户操作导致标记发生变更的对象，有stw 并发清除（cms concurrent sweep）\n\n\n# 与cms相比的优势\n\n并发度更高，充分利用cpu多线程 —— cms对cpu资源敏感，需要占用25%的线程，如果核数小于4更会占用一半的资源。 整体上是标记-整理(分代)，局部是复制(分region)，运行期不产生碎片 —— cms是标记-清除，会产生空间碎片和本次回收期间产生导致本次无法回收的浮动垃圾 可预测的停顿(基于region)\n\n\n# cms\n\n\n# 什么是cms？\n\nconcurrent mark sweep。\n\n看名字就知道，cms是一款并发、使用标记-清除算法的gc。\n\ncms是针对老年代进行回收的gc。\n\n\n# cms有什么用？\n\ncms以获取最小停顿时间为目的。\n\n在一些对响应时间有很高要求的应用或网站中，用户程序不能有长时间的停顿，cms 可以用于此场景。\n\n\n# cms如何执行？\n\n总体来说cms的执行过程可以分为以下几个阶段：\n\n      3.1 初始标记(stw)\n\n      3.2 并发标记\n\n      3.3 并发预清理\n\n      3.4 重标记(stw)\n\n      3.5 并发清理\n\n      3.6 重置\n\n\n参考： 关于gc(下)：cms和g1gc的比较 详解cms垃圾回收机制",charsets:{cjk:!0},lastUpdated:"2022/09/18, 21:28:02",lastUpdatedTimestamp:1663507682e3},{title:"实现单例设计模式（懒汉，饿汉）",frontmatter:{title:"实现单例设计模式（懒汉，饿汉）",date:"2022-05-21T17:26:00.000Z",permalink:"/pages/b37ad7/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/002.%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%87%92%E6%B1%89%EF%BC%8C%E9%A5%BF%E6%B1%89%EF%BC%89.html",relativePath:"01.Java相关/40.设计模式/002.实现单例设计模式（懒汉，饿汉）.md",key:"v-ba94c306",path:"/pages/b37ad7/",headers:[{level:2,title:"单例模式的定义",slug:"单例模式的定义",normalizedTitle:"单例模式的定义",charIndex:252},{level:2,title:"单例模式的类图",slug:"单例模式的类图",normalizedTitle:"单例模式的类图",charIndex:294},{level:2,title:"单例模式的实现",slug:"单例模式的实现",normalizedTitle:"单例模式的实现",charIndex:15},{level:3,title:"饿汉式",slug:"饿汉式",normalizedTitle:"饿汉式",charIndex:320},{level:3,title:"懒汉式",slug:"懒汉式",normalizedTitle:"懒汉式",charIndex:856},{level:3,title:"静态内部类",slug:"静态内部类",normalizedTitle:"静态内部类",charIndex:2627},{level:3,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:3151},{level:2,title:"单例模式在JDK 中的源码分析",slug:"单例模式在jdk-中的源码分析",normalizedTitle:"单例模式在jdk 中的源码分析",charIndex:3399},{level:2,title:"单例模式注意事项和细节",slug:"单例模式注意事项和细节",normalizedTitle:"单例模式注意事项和细节",charIndex:3459}],headersStr:"单例模式的定义 单例模式的类图 单例模式的实现 饿汉式 懒汉式 静态内部类 枚举 单例模式在JDK 中的源码分析 单例模式注意事项和细节",content:"> 面试官：带笔了吧，那写两种单例模式的实现方法吧 沙沙沙刷刷刷~~~ 写好了 面试官：怎样防止new 对象出来？\n\n有一些对象我们确实只需要一个，比如，线程池、数据库连接、缓存、日志对象等，如果有多个的话，会造成程序的行为异常，资源使用过量或者不一致的问题。你也许会说，这种我用全局变量不也能实现吗，还整个单例模式，好像你很流弊的样子，如果将对象赋值给一个全局变量，那程序启动就会创建好对象，万一这个对象很耗资源，我们还可能在某些时候用不到，这就造成了资源的浪费，不合理，所以就有了单例模式。\n\n\n# 单例模式的定义\n\n单例模式确保一个类只有一个实例，并提供一个全局唯一访问点\n\n\n# 单例模式的类图\n\n\n\n\n# 单例模式的实现\n\n\n# 饿汉式\n\nstatic 变量在类装载的时候进行初始化 多个实例的 static 变量会共享同一块内存区域 用这两个知识点写出的单例类就是饿汉式了，初始化类的时候就创建，饥不择食，饿汉\n\npublic class Singleton {\n\n    //构造私有化，防止直接new\n    private Singleton(){}\n\n    //静态初始化器（static initializer）中创建实例，保证线程安全\n    private static Singleton instance = new Singleton();\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n饿汉式是线程安全的，JVM在加载类时马上创建唯一的实例对象，且只会装载一次。\n\nJava 实现的单例是一个虚拟机的范围，因为装载类的功能是虚拟机的，所以一个虚拟机通过自己的ClassLoader 装载饿汉式实现单例类的时候就会创建一个类实例。（如果一个虚拟机里有多个ClassLoader的话，就会有多个实例）\n\n\n# 懒汉式\n\n懒汉式，就是实例在用到的时候才去创建，比较“懒”\n\n单例模式的懒汉式实现方式体现了延迟加载的思想（延迟加载也称懒加载Lazy Load，就是一开始不要加载资源或数据，等到要使用的时候才加载）\n\n同步方法\n\npublic class Singleton {\n    private static Singleton singleton;\n\n    private Singleton(){}\n\n  \t//解决了线程不安全问题，但是效率太低了，每个线程想获得类的实例的时候，都需要同步方法，不推荐\n    public static synchronized Singleton getInstance(){\n        if(singleton == null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n双重检查加锁\n\npublic class Singleton {\n\n  \t//volatitle关键词确保，多线程正确处理singleton\n    private static volatile Singleton singleton;\n  \n    private Singleton(){}\n  \n    public static Singleton getInstance(){\n        if(singleton ==null){\n            synchronized (Singleton.class){\n                if(singleton == null){\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nDouble-Check 概念（进行两次检查）是多线程开发中经常使用的，为什么需要双重检查锁呢？因为第一次检查是确保之前是一个空对象，而非空对象就不需要同步了，空对象的线程然后进入同步代码块，如果不加第二次空对象检查，两个线程同时获取同步代码块，一个线程进入同步代码块，另一个线程就会等待，而这两个线程就会创建两个实例化对象，所以需要在线程进入同步代码块后再次进行空对象检查，才能确保只创建一个实例化对象。\n\n双重检查加锁（double checked locking）线程安全、延迟加载、效率比较高\n\nvolatile：volatile一般用于多线程的可见性，这里用来防止指令重排（防止new Singleton时指令重排序导致其他线程获取到未初始化完的对象）。被volatile 修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。\n\n指令重排\n\n指令重排是指在程序执行过程中, 为了性能考虑, 编译器和CPU可能会对指令重新排序。\n\nJava中创建一个对象，往往包含三个过程。对于singleton = new Singleton()，这不是一个原子操作，在 JVM 中包含如下三个过程。\n\n给 singleton 分配内存\n\n调用 Singleton 的构造函数来初始化成员变量，形成实例\n\n将 singleton 对象指向分配的内存空间（执行完这步 singleton才是非 null 了）\n\n但是，由于JVM会进行指令重排序，所以上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3，也可能是 1-3-2。\n\n如果是 1-3-2，则在 3 执行完毕，2 未执行之前，被另一个线程抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以这个线程会直接返回 instance，然后使用，那肯定就会报错了，所以要加入 volatile关键字。\n\n\n# 静态内部类\n\npublic class Singleton {\n\n    private Singleton(){}\n\n    private static class SingletonInstance{\n        private static final Singleton INSTANCE = new Singleton();\n    }\n  \n    public static Singleton getInstance(){\n        return SingletonInstance.INSTANCE;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n采用类加载的机制来保证初始化实例时只有一个线程；\n\n静态内部类方式在Singleton 类被装载的时候并不会立即实例化，而是在调用getInstance的时候，才去装载内部类SingletonInstance ,从而完成Singleton的实例化\n\n类的静态属性只会在第一次加载类的时候初始化，所以，JVM帮我们保证了线程的安全性，在类初始化时，其他线程无法进入\n\n优点：线程安全，利用静态内部类实现延迟加载，效率较高，推荐使用\n\n\n# 枚举\n\nenum Singleton{\n  INSTANCE;\n  public void method(){}\n}\n\n\n1\n2\n3\n4\n\n\n借助JDK5 添加的枚举实现单例，不仅可以避免多线程同步问题，还能防止反序列化重新创建新的对象，但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。不过，由于Java1.5中才加入enum特性，所以使用的人并不多。\n\n这种方式是《Effective Java》 作者Josh Bloch 提倡的方式。\n\n\n# 单例模式在JDK 中的源码分析\n\nJDK 中，java.lang.Runtime 就是经典的单例模式（饿汉式）\n\n\n# 单例模式注意事项和细节\n\n单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使 用new 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等)",normalizedContent:"> 面试官：带笔了吧，那写两种单例模式的实现方法吧 沙沙沙刷刷刷~~~ 写好了 面试官：怎样防止new 对象出来？\n\n有一些对象我们确实只需要一个，比如，线程池、数据库连接、缓存、日志对象等，如果有多个的话，会造成程序的行为异常，资源使用过量或者不一致的问题。你也许会说，这种我用全局变量不也能实现吗，还整个单例模式，好像你很流弊的样子，如果将对象赋值给一个全局变量，那程序启动就会创建好对象，万一这个对象很耗资源，我们还可能在某些时候用不到，这就造成了资源的浪费，不合理，所以就有了单例模式。\n\n\n# 单例模式的定义\n\n单例模式确保一个类只有一个实例，并提供一个全局唯一访问点\n\n\n# 单例模式的类图\n\n\n\n\n# 单例模式的实现\n\n\n# 饿汉式\n\nstatic 变量在类装载的时候进行初始化 多个实例的 static 变量会共享同一块内存区域 用这两个知识点写出的单例类就是饿汉式了，初始化类的时候就创建，饥不择食，饿汉\n\npublic class singleton {\n\n    //构造私有化，防止直接new\n    private singleton(){}\n\n    //静态初始化器（static initializer）中创建实例，保证线程安全\n    private static singleton instance = new singleton();\n\n    public static singleton getinstance(){\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n饿汉式是线程安全的，jvm在加载类时马上创建唯一的实例对象，且只会装载一次。\n\njava 实现的单例是一个虚拟机的范围，因为装载类的功能是虚拟机的，所以一个虚拟机通过自己的classloader 装载饿汉式实现单例类的时候就会创建一个类实例。（如果一个虚拟机里有多个classloader的话，就会有多个实例）\n\n\n# 懒汉式\n\n懒汉式，就是实例在用到的时候才去创建，比较“懒”\n\n单例模式的懒汉式实现方式体现了延迟加载的思想（延迟加载也称懒加载lazy load，就是一开始不要加载资源或数据，等到要使用的时候才加载）\n\n同步方法\n\npublic class singleton {\n    private static singleton singleton;\n\n    private singleton(){}\n\n  \t//解决了线程不安全问题，但是效率太低了，每个线程想获得类的实例的时候，都需要同步方法，不推荐\n    public static synchronized singleton getinstance(){\n        if(singleton == null){\n            singleton = new singleton();\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n双重检查加锁\n\npublic class singleton {\n\n  \t//volatitle关键词确保，多线程正确处理singleton\n    private static volatile singleton singleton;\n  \n    private singleton(){}\n  \n    public static singleton getinstance(){\n        if(singleton ==null){\n            synchronized (singleton.class){\n                if(singleton == null){\n                    singleton = new singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ndouble-check 概念（进行两次检查）是多线程开发中经常使用的，为什么需要双重检查锁呢？因为第一次检查是确保之前是一个空对象，而非空对象就不需要同步了，空对象的线程然后进入同步代码块，如果不加第二次空对象检查，两个线程同时获取同步代码块，一个线程进入同步代码块，另一个线程就会等待，而这两个线程就会创建两个实例化对象，所以需要在线程进入同步代码块后再次进行空对象检查，才能确保只创建一个实例化对象。\n\n双重检查加锁（double checked locking）线程安全、延迟加载、效率比较高\n\nvolatile：volatile一般用于多线程的可见性，这里用来防止指令重排（防止new singleton时指令重排序导致其他线程获取到未初始化完的对象）。被volatile 修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。\n\n指令重排\n\n指令重排是指在程序执行过程中, 为了性能考虑, 编译器和cpu可能会对指令重新排序。\n\njava中创建一个对象，往往包含三个过程。对于singleton = new singleton()，这不是一个原子操作，在 jvm 中包含如下三个过程。\n\n给 singleton 分配内存\n\n调用 singleton 的构造函数来初始化成员变量，形成实例\n\n将 singleton 对象指向分配的内存空间（执行完这步 singleton才是非 null 了）\n\n但是，由于jvm会进行指令重排序，所以上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3，也可能是 1-3-2。\n\n如果是 1-3-2，则在 3 执行完毕，2 未执行之前，被另一个线程抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以这个线程会直接返回 instance，然后使用，那肯定就会报错了，所以要加入 volatile关键字。\n\n\n# 静态内部类\n\npublic class singleton {\n\n    private singleton(){}\n\n    private static class singletoninstance{\n        private static final singleton instance = new singleton();\n    }\n  \n    public static singleton getinstance(){\n        return singletoninstance.instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n采用类加载的机制来保证初始化实例时只有一个线程；\n\n静态内部类方式在singleton 类被装载的时候并不会立即实例化，而是在调用getinstance的时候，才去装载内部类singletoninstance ,从而完成singleton的实例化\n\n类的静态属性只会在第一次加载类的时候初始化，所以，jvm帮我们保证了线程的安全性，在类初始化时，其他线程无法进入\n\n优点：线程安全，利用静态内部类实现延迟加载，效率较高，推荐使用\n\n\n# 枚举\n\nenum singleton{\n  instance;\n  public void method(){}\n}\n\n\n1\n2\n3\n4\n\n\n借助jdk5 添加的枚举实现单例，不仅可以避免多线程同步问题，还能防止反序列化重新创建新的对象，但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。不过，由于java1.5中才加入enum特性，所以使用的人并不多。\n\n这种方式是《effective java》 作者josh bloch 提倡的方式。\n\n\n# 单例模式在jdk 中的源码分析\n\njdk 中，java.lang.runtime 就是经典的单例模式（饿汉式）\n\n\n# 单例模式注意事项和细节\n\n单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使 用new 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等)",charsets:{cjk:!0},lastUpdated:"2022/09/20, 22:28:30",lastUpdatedTimestamp:166368411e4},{title:"什么是设计模式",frontmatter:{title:"什么是设计模式",date:"2022-05-21T17:26:19.000Z",permalink:"/pages/3d768c/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/003.%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20.html",relativePath:"01.Java相关/40.设计模式/003.什么是设计模式 .md",key:"v-88b087a6",path:"/pages/3d768c/",headers:[{level:2,title:"什么是设计模式？",slug:"什么是设计模式",normalizedTitle:"什么是设计模式？",charIndex:2},{level:2,title:"设计模式之六大原则",slug:"设计模式之六大原则",normalizedTitle:"设计模式之六大原则",charIndex:286},{level:3,title:"开闭原则（Open Close Principle）",slug:"开闭原则-open-close-principle",normalizedTitle:"开闭原则（open close principle）",charIndex:300},{level:3,title:"里氏代换原则（Liskov Substitution Principle）",slug:"里氏代换原则-liskov-substitution-principle",normalizedTitle:"里氏代换原则（liskov substitution principle）",charIndex:628},{level:3,title:"依赖倒转原则（Dependence Inversion Principle）",slug:"依赖倒转原则-dependence-inversion-principle",normalizedTitle:"依赖倒转原则（dependence inversion principle）",charIndex:861},{level:3,title:"接口隔离原则（Interface Segregation Principle）",slug:"接口隔离原则-interface-segregation-principle",normalizedTitle:"接口隔离原则（interface segregation principle）",charIndex:1024},{level:3,title:"迪米特法则（最少知道原则）（Demeter Principle）",slug:"迪米特法则-最少知道原则-demeter-principle",normalizedTitle:"迪米特法则（最少知道原则）（demeter principle）",charIndex:1138},{level:3,title:"单一职责原则（ Single responsibility principle ）",slug:"单一职责原则-single-responsibility-principle",normalizedTitle:"单一职责原则（ single responsibility principle ）",charIndex:1403},{level:2,title:"高内聚,低耦合？",slug:"高内聚-低耦合",normalizedTitle:"高内聚,低耦合？",charIndex:1768}],headersStr:"什么是设计模式？ 设计模式之六大原则 开闭原则（Open Close Principle） 里氏代换原则（Liskov Substitution Principle） 依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle） 迪米特法则（最少知道原则）（Demeter Principle） 单一职责原则（ Single responsibility principle ） 高内聚,低耦合？",content:"# 什么是设计模式？\n\n设计模式是一套代码设计「经验的总结」。项目中「合理的」运用设计模式可以「巧妙的解决很多问题」。\n\n * 经验的总结：抱着「代码虐我千百遍，我待代码如初恋」的心态，最终得出来的「套路」。\n\n * 合理的：要对设计模式的使用场景有一定的认识后才使用，「不要滥用」。如：输出一句“hello world”，非要强行给加上各种模式。 问：“为什么”，答：“总感觉少了模式！”。\n\n * 巧妙的解决了很多问题：被广泛应用的原因。\n\n> 为什么要提倡“Design Pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？\n\n\n# 设计模式之六大原则\n\n\n# 开闭原则（Open Close Principle）\n\n1988年，勃兰特·梅耶（Bertrand Meyer）在他的著作《面向对象软件构造（Object Oriented Software Construction）》中提出了开闭原则，它的原文是这样：“Software entities should be open for extension,but closed for modification”。 意思：软件模块应该对扩展开放，对修改关闭。 举例：在程序需要进行新增功能的时候，不能去修改原有的代码，而是新增代码，实现一个热插拔的效果（热插拔：灵活的去除或添加功能，不影响到原有的功能）。 目的：为了使程序的扩展性好，易于维护和升级。\n\n\n# 里氏代换原则（Liskov Substitution Principle）\n\n意思：里氏代换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 举例：球类，原本是一种体育用品，它的衍生类有篮球、足球、排球、羽毛球等等，如果衍生类替换了基类的原本方法，如把体育用品改成了食用品（那么软件单位的功能受到影响），就不符合里氏代换原则。 目的：对实现抽象化的具体步骤的规范。\n\n\n# 依赖倒转原则（Dependence Inversion Principle）\n\n意思：针对接口编程，而不是针对实现编程。 举例：以计算机系统为例,无论主板、CPU、内存、硬件都是在针对接口设计的，如果针对实现来设计，内存就要对应到针对某个品牌的主板，那么会出现换内存需要把主板也换掉的尴尬。 目的：降低模块间的耦合。\n\n\n# 接口隔离原则（Interface Segregation Principle）\n\n使用多个隔离的接口，比使用单个接口要好。 举例：比如：登录，注册时属于用户模块的两个接口，比写成一个接口好。 目的：提高程序设计灵活性。\n\n\n# 迪米特法则（最少知道原则）（Demeter Principle）\n\n1987年秋天由美国Northeastern University的Ian Holland提出，被UML的创始者之一[Booch]等普及。后来，因为在经典著作《 The Pragmatic Programmer》而广为人知。 意思：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 举例：一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。 目的：降低类之间的耦合，减少对其他类的依赖。\n\n\n# 单一职责原则（ Single responsibility principle ）\n\n该原则由罗伯特·C·马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中给出的。马丁表示此原则是基于汤姆·狄马克(Tom DeMarco)和Meilir Page-Jones的著作中的内聚性原则发展出的。 意思：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 举例：该原则意思简单到不需要举例！ 目的：类的复杂性降低，可读性提高，可维护性提高。\n\n刚入行的时候，在想什么样的代码是好代码？看到很多前辈的文字都说好的代码要符合「高内聚，低耦合」，但是我听到这样的解释，是这样的\n\n而现在对设计模式有了一定程度上的学习，感觉懂了一些，小伙伴们你们学会了吗？\n\n\n# 高内聚,低耦合？\n\n内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系； 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。\n\n参考： 图解九种常见的设计模式 什么是「设计模式」？",normalizedContent:"# 什么是设计模式？\n\n设计模式是一套代码设计「经验的总结」。项目中「合理的」运用设计模式可以「巧妙的解决很多问题」。\n\n * 经验的总结：抱着「代码虐我千百遍，我待代码如初恋」的心态，最终得出来的「套路」。\n\n * 合理的：要对设计模式的使用场景有一定的认识后才使用，「不要滥用」。如：输出一句“hello world”，非要强行给加上各种模式。 问：“为什么”，答：“总感觉少了模式！”。\n\n * 巧妙的解决了很多问题：被广泛应用的原因。\n\n> 为什么要提倡“design pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？\n\n\n# 设计模式之六大原则\n\n\n# 开闭原则（open close principle）\n\n1988年，勃兰特·梅耶（bertrand meyer）在他的著作《面向对象软件构造（object oriented software construction）》中提出了开闭原则，它的原文是这样：“software entities should be open for extension,but closed for modification”。 意思：软件模块应该对扩展开放，对修改关闭。 举例：在程序需要进行新增功能的时候，不能去修改原有的代码，而是新增代码，实现一个热插拔的效果（热插拔：灵活的去除或添加功能，不影响到原有的功能）。 目的：为了使程序的扩展性好，易于维护和升级。\n\n\n# 里氏代换原则（liskov substitution principle）\n\n意思：里氏代换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 举例：球类，原本是一种体育用品，它的衍生类有篮球、足球、排球、羽毛球等等，如果衍生类替换了基类的原本方法，如把体育用品改成了食用品（那么软件单位的功能受到影响），就不符合里氏代换原则。 目的：对实现抽象化的具体步骤的规范。\n\n\n# 依赖倒转原则（dependence inversion principle）\n\n意思：针对接口编程，而不是针对实现编程。 举例：以计算机系统为例,无论主板、cpu、内存、硬件都是在针对接口设计的，如果针对实现来设计，内存就要对应到针对某个品牌的主板，那么会出现换内存需要把主板也换掉的尴尬。 目的：降低模块间的耦合。\n\n\n# 接口隔离原则（interface segregation principle）\n\n使用多个隔离的接口，比使用单个接口要好。 举例：比如：登录，注册时属于用户模块的两个接口，比写成一个接口好。 目的：提高程序设计灵活性。\n\n\n# 迪米特法则（最少知道原则）（demeter principle）\n\n1987年秋天由美国northeastern university的ian holland提出，被uml的创始者之一[booch]等普及。后来，因为在经典著作《 the pragmatic programmer》而广为人知。 意思：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 举例：一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。 目的：降低类之间的耦合，减少对其他类的依赖。\n\n\n# 单一职责原则（ single responsibility principle ）\n\n该原则由罗伯特·c·马丁（robert c. martin）于《敏捷软件开发：原则、模式和实践》一书中给出的。马丁表示此原则是基于汤姆·狄马克(tom demarco)和meilir page-jones的著作中的内聚性原则发展出的。 意思：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 举例：该原则意思简单到不需要举例！ 目的：类的复杂性降低，可读性提高，可维护性提高。\n\n刚入行的时候，在想什么样的代码是好代码？看到很多前辈的文字都说好的代码要符合「高内聚，低耦合」，但是我听到这样的解释，是这样的\n\n而现在对设计模式有了一定程度上的学习，感觉懂了一些，小伙伴们你们学会了吗？\n\n\n# 高内聚,低耦合？\n\n内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系； 耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。\n\n参考： 图解九种常见的设计模式 什么是「设计模式」？",charsets:{cjk:!0},lastUpdated:"2022/09/20, 22:28:30",lastUpdatedTimestamp:166368411e4},{title:"工厂模式使用场景 能举个例子吗",frontmatter:{title:"工厂模式使用场景 能举个例子吗",date:"2022-05-21T17:26:32.000Z",permalink:"/pages/f15489/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/004.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%20%E8%83%BD%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%90%97.html",relativePath:"01.Java相关/40.设计模式/004.工厂模式使用场景 能举个例子吗.md",key:"v-2d6ed001",path:"/pages/f15489/",headers:[{level:2,title:"工厂模式",slug:"工厂模式",normalizedTitle:"工厂模式",charIndex:15},{level:3,title:"模式动机",slug:"模式动机",normalizedTitle:"模式动机",charIndex:195},{level:3,title:"模式定义",slug:"模式定义",normalizedTitle:"模式定义",charIndex:406},{level:3,title:"模式结构",slug:"模式结构",normalizedTitle:"模式结构",charIndex:562},{level:3,title:"模式分析",slug:"模式分析",normalizedTitle:"模式分析",charIndex:740},{level:2,title:"工厂模式可以分为三类：",slug:"工厂模式可以分为三类",normalizedTitle:"工厂模式可以分为三类：",charIndex:1026},{level:2,title:"一、简单工厂模式",slug:"一、简单工厂模式",normalizedTitle:"一、简单工厂模式",charIndex:2247},{level:3,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:408},{level:3,title:"简单工厂模式实现方式",slug:"简单工厂模式实现方式",normalizedTitle:"简单工厂模式实现方式",charIndex:4042},{level:2,title:"UML类图",slug:"uml类图",normalizedTitle:"uml类图",charIndex:4353},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:512},{level:3,title:"简单工厂模式存在的问题",slug:"简单工厂模式存在的问题",normalizedTitle:"简单工厂模式存在的问题",charIndex:5475},{level:3,title:"简单工厂模式总结",slug:"简单工厂模式总结",normalizedTitle:"简单工厂模式总结",charIndex:5681},{level:2,title:"二、工厂方法模式",slug:"二、工厂方法模式",normalizedTitle:"二、工厂方法模式",charIndex:6056},{level:3,title:"2.1 定义",slug:"_2-1-定义",normalizedTitle:"2.1 定义",charIndex:6114},{level:3,title:"2.2 工厂方法模式实现方式",slug:"_2-2-工厂方法模式实现方式",normalizedTitle:"2.2 工厂方法模式实现方式",charIndex:6178},{level:2,title:"UML类图",slug:"uml类图-2",normalizedTitle:"uml类图",charIndex:4353},{level:2,title:"实例",slug:"实例-2",normalizedTitle:"实例",charIndex:512},{level:3,title:"2.3 工厂方法模式适用场景",slug:"_2-3-工厂方法模式适用场景",normalizedTitle:"2.3 工厂方法模式适用场景",charIndex:7923},{level:3,title:"2.4 工厂方法模式总结",slug:"_2-4-工厂方法模式总结",normalizedTitle:"2.4 工厂方法模式总结",charIndex:8499},{level:2,title:"三、抽象工厂模式",slug:"三、抽象工厂模式",normalizedTitle:"三、抽象工厂模式",charIndex:8875},{level:3,title:"3.1 定义",slug:"_3-1-定义",normalizedTitle:"3.1 定义",charIndex:9033},{level:3,title:"3.2 抽象工厂模式实现方式",slug:"_3-2-抽象工厂模式实现方式",normalizedTitle:"3.2 抽象工厂模式实现方式",charIndex:9130},{level:2,title:"UML类图",slug:"uml类图-3",normalizedTitle:"uml类图",charIndex:4353},{level:2,title:"实例",slug:"实例-3",normalizedTitle:"实例",charIndex:512},{level:2,title:"3.3 抽象工厂模式适用场景",slug:"_3-3-抽象工厂模式适用场景",normalizedTitle:"3.3 抽象工厂模式适用场景",charIndex:11705},{level:2,title:"3.4 抽象工厂模式总结",slug:"_3-4-抽象工厂模式总结",normalizedTitle:"3.4 抽象工厂模式总结",charIndex:12519},{level:2,title:"工厂模式的退化",slug:"工厂模式的退化",normalizedTitle:"工厂模式的退化",charIndex:12987},{level:2,title:"四、我们身边的工厂模式",slug:"四、我们身边的工厂模式",normalizedTitle:"四、我们身边的工厂模式",charIndex:13132}],headersStr:"工厂模式 模式动机 模式定义 模式结构 模式分析 工厂模式可以分为三类： 一、简单工厂模式 定义 简单工厂模式实现方式 UML类图 实例 简单工厂模式存在的问题 简单工厂模式总结 二、工厂方法模式 2.1 定义 2.2 工厂方法模式实现方式 UML类图 实例 2.3 工厂方法模式适用场景 2.4 工厂方法模式总结 三、抽象工厂模式 3.1 定义 3.2 抽象工厂模式实现方式 UML类图 实例 3.3 抽象工厂模式适用场景 3.4 抽象工厂模式总结 工厂模式的退化 四、我们身边的工厂模式",content:'> 3年工作经验是吧？ 你知道工厂模式分为几类吗？能举例子吗？ 那你说说你们项目中是怎么使用工厂模式的？\n\n\n# 工厂模式\n\n工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n\n\n# 模式动机\n\n考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。\n\n\n# 模式定义\n\n简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n\n\n# 模式结构\n\n简单工厂模式包含如下角色：\n\nFactory：工厂角色\n工厂角色负责实现创建所有实例的内部逻辑 Product：抽象产品角色\n抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色\n具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 1.4. 时序图\n\n\n# 模式分析\n\n将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。\n\n在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可.\n\n在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。\n\n简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\n\n# 工厂模式可以分为三类：\n\n简单工厂模式（Simple Factory） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 简单工厂其实不是一个标准的的设计模式。GOF 23种设计模式中只有「工厂方法模式」与「抽象工厂模式」。简单工厂模式可以看为工厂方法模式的一种特例，为了统一整理学习，就都归为工厂模式。\n\n这三种工厂模式在设计模式的分类中都属于创建型模式，三种模式从上到下逐步抽象。\n\n创建型模式 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。\n\n创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。\n\n创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。\n\n工厂模式是创建型模式中比较重要的。工厂模式的主要功能就是帮助我们实例化对象。之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。\n\n工厂模式优点 可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。 对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。 降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。 适用场景 不管是简单工厂模式，工厂方法模式还是抽象工厂模式，他们具有类似的特性，所以他们的适用场景也是类似的。\n\n首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。\n\n再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n\n# 一、简单工厂模式\n\n在介绍简单工厂模式之前，我们尝试解决以下问题：\n\n现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。我们一般会这么写：\n\n// 计算类的基类\n@Setter\n@Getter\npublic abstract class Operation {\n    private double value1 = 0;\n    private double value2 = 0;\n    protected abstract double getResule();\n}\n\n//加法\npublic class OperationAdd extends Operation {\n    @Override\n    protected double getResule() {\n        return getValue1() + getValue2();\n    }\n}\n//减法\npublic class OperationSub extends Operation {\n    @Override\n    protected double getResule() {\n        return getValue1() - getValue2();\n    }\n}\n//乘法\npublic class OperationMul extends Operation {\n    @Override\n    protected double getResule() {\n        return getValue1() * getValue2();\n    }\n}\n//除法\npublic class OperationDiv extends Operation {\n    @Override\n    protected double getResule() {\n        if (getValue2() != 0) {\n            return getValue1() / getValue2();\n        }\n        throw new IllegalArgumentException("除数不能为零");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n当我们要使用这个计算器的时候，又会这么写：\n\npublic static void main(String[] args) {\n  //计算两数之和\n  OperationAdd operationAdd = new OperationAdd();\n  operationAdd.setValue1(1);\n  operationAdd.setValue2(2);\n  System.out.println("sum:"+operationAdd.getResule());\n  //计算两数乘积\n  OperationMul operationMul = new OperationMul();\n  operationMul.setValue1(3);\n  operationMul.setValue2(5);\n  System.out.println("multiply:"+operationMul.getResule());\n  //计算两数之差。。。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。那么这种重复的创建类的工作其实可以放到一个统一的类中去管理。这样的方法我们就叫做「简单工厂模式」，在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为「静态工厂方法」模式。。简单工厂模式有以下优点：\n\n一个调用者想创建一个对象，只要知道其名称就可以了。 屏蔽产品的具体实现，调用者只关心产品的接口。\n\n\n# 定义\n\n提供一个创建对象实例的功能，而无需关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。\n\n\n# 简单工厂模式实现方式\n\n没骗你，简单工厂模式，真是因为简单才被叫做简单工厂模式的。\n\n简单工厂模式包含 3 个角色（要素）：\n\nFactory：即工厂类， 简单工厂模式的核心部分，负责实现创建所有产品的内部逻辑；工厂类可以被外界直接调用，创建所需对象 Product：抽象类产品， 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象 ConcreteProduct：具体产品， 它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。它要实现抽象产品中声明的抽象方法\n\n\n# UML类图\n\n\n\n\n# 实例\n\n现在我们定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n\n//工厂类\npublic class OperationFactory {\n\n    public static Operation createOperation(String operation) {\n        Operation oper = null;\n        switch (operation) {\n            case "add":\n                oper = new OperationAdd();\n                break;\n            case "sub":\n                oper = new OperationSub();\n                break;\n            case "mul":\n                oper = new OperationMul();\n                break;\n\n            case "div":\n                oper = new OperationDiv();\n                break;\n            default:\n                throw new UnsupportedOperationException("不支持该操作");\n        }\n        return oper;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n有了工厂类之后，可以使用工厂创建对象：\n\npublic static void main(String[] args) {\n  Operation operationAdd = OperationFactory.createOperation("add");\n  operationAdd.setValue1(1);\n  operationAdd.setValue2(2)\n  System.out.println(operationAdd.getResule());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，只要知道该类对应的参数"add"就可以了。这就体现了之前提到的工厂模式的优点。\n\n\n# 简单工厂模式存在的问题\n\n当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承Operation类，其中实现平方的代码。除此之外我们还要修改 OperationFactory 类的代码，增加一个 case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。\n\n我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。\n\n\n# 简单工厂模式总结\n\n工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。\n\n但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。\n\n当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；\n\n为了解决这些缺点，就有了工厂方法模式。\n\n\n# 二、工厂方法模式\n\n我们常说的工厂模式，就是指「工厂方法模式」，也叫「虚拟构造器模式」或「多态工厂模式」。\n\n\n# 2.1 定义\n\n定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。\n\n\n# 2.2 工厂方法模式实现方式\n\n工厂方法模式包含 4 个角色（要素）：\n\nProduct：抽象产品，定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口 ConcreteProduct：具体产品，具体的Product接口的实现对象 Factory：工厂接口，也可以叫 Creator(创建器)，申明工厂方法，通常返回一个 Product 类型的实例对象 ConcreteFactory：工厂实现，或者叫 ConcreteCreator(创建器对象)，覆盖 Factory 定义的工厂方法，返回具体的 Product 实例\n\n\n# UML类图\n\n\n\n\n# 实例\n\n从 UML 类图可以看出，每种产品实现，我们都要增加一个继承于工厂接口 IFactory 的工厂类 Factory ，修改简单工厂模式代码中的工厂类如下：\n\n//工厂接口\npublic interface IFactory {\n    Operation CreateOption();\n}\n\n//加法类工厂\npublic class AddFactory implements IFactory {\n    public Operation CreateOption() {\n        return new OperationAdd();\n    }\n}\n\n//减法类工厂\npublic class SubFactory implements IFactory {\n    public Operation CreateOption() {\n        return new OperationSub();\n    }\n}\n\n//乘法类工厂\npublic class MulFactory implements IFactory {\n    public Operation CreateOption() {\n        return new OperationMul();\n    }\n}\n\n//除法类工厂\npublic class DivFactory implements IFactory {\n    public Operation CreateOption() {\n        return new OperationDiv();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这时，我们使用计算器的时候，要为每种运算方法增加一个工厂对象\n\npublic class Client {\n    public static void main(String[] args) {\n      //减法\n      IFactory subFactory = new SubFactory();\n      Operation operationSub =  subFactory.CreateOption();\n      operationSub.setValue1(22);\n      operationSub.setValue2(20);\n      System.out.println("sub:"+operationSub.getResult());\n      //除法\n      IFactory Divfactory = new DivFactory();\n      Operation operationDiv =  Divfactory.CreateOption();\n      operationDiv.setValue1(99);\n      operationDiv.setValue2(33);\n      System.out.println("div:"+operationSub.getResult());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n纳尼，这不是更复杂了吗，每个产品对应一个工厂，我又不是按代码量赚钱的。。。\n\n\n# 2.3 工厂方法模式适用场景\n\n工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合“开闭原则”。\n\n在以下情况下可以使用工厂方法模式：\n\n一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 使用场景 日志记录器：日志可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。 比如 Hibernate 换数据库只需换方言和驱动就可以\n\n\n# 2.4 工厂方法模式总结\n\n工厂方法模式是简单工厂模式的进一步抽象和推广。\n\n由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\n\n在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。\n\n优点：\n\n一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：\n\n每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n\n\n# 三、抽象工厂模式\n\n工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。\n\n\n# 3.1 定义\n\n为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。\n\n抽象工厂(Abstract Factory)模式，又称工具箱(Kit 或Toolkit)模式。\n\n\n# 3.2 抽象工厂模式实现方式\n\n抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。\n\n在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。\n\n也没骗你，抽象工厂模式确实是抽象。\n\n抽象工厂模式包含的角色（要素）：\n\nAbstractFactory：抽象工厂，用于声明生成抽象产品的方法 ConcreteFactory：具体工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建 AbstractProduct：抽象产品，定义一类产品对象的接口 ConcreteProduct：具体产品，通常在具体工厂里，会选择具体的产品实现，来创建符合抽象工厂定义的方法返回的产品类型的对象。 Client：客户端，使用抽象工厂来获取一系列所需要的产品对象\n\n\n# UML类图\n\n\n# 实例\n\n我把维基百科的例子改下用于理解，假设我们要生产两种产品，键盘（Keyboard）和鼠标（Mouse） ，每一种产品都支持多种系列，比如 Mac 系列和 Windows 系列。这样每个系列的产品分别是 MacKeyboard WinKeyboard, MacMouse, WinMouse 。为了可以在运行时刻创建一个系列的产品族，我们可以为每个系列的产品族创建一个工厂 MacFactory 和 WinFactory 。每个工厂都有两个方法 CreateMouse 和 CreateKeyboard 并返回对应的产品，可以将这两个方法抽象成一个接口 HardWare 。这样在运行时刻我们可以选择创建需要的产品系列。\n\n抽象产品\n\npublic interface Keyboard {\n  void input();\n}\npublic interface Mouse {\n  void click();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n具体产品\n\n//具体产品\n\npublic class MacKeyboard implements Keyboard {\n    @Override\n    public void input() {\n        System.out.println("Mac 专用键盘");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\npublic class MacMouse implements Mouse {\n    @Override\n    public void click() {\n        System.out.println("Mac 专用鼠标");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\npublic class WinKeyboard implements Keyboard {\n    @Override\n    public void input() {\n        System.out.println("Win 专用键盘");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\npublic class WinMouse implements Mouse {\n    @Override\n    public void click() {\n        System.out.println("win 专用鼠标");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n抽象工厂\n\npublic interface Hardware {\n     Keyboard createKyeBoard();\n     Mouse createMouse();\n}\n\n\n1\n2\n3\n4\n\n\n具体的工厂类\n\npublic class MacFactory implements Hardware{\n    @Override\n    public Keyboard createKyeBoard() {\n        return new MacKeyboard();\n    }\n\n    @Override\n    public Mouse createMouse() {\n        return new MacMouse();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npublic class WinFactory implements Hardware{\n    @Override\n    public Keyboard createKyeBoard() {\n        return new WinKeyboard();\n    }\n\n    @Override\n    public Mouse createMouse() {\n        return new WinMouse();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用\n\npublic class Client {\n  public static void main(String[] args) {\n    Hardware macFactory = new MacFactory();\n    Keyboard keyboard = macFactory.createKyeBoard();\n    keyboard.input();   //Mac 专用键盘\n\n    Hardware winFactory = new WinFactory();\n    Mouse mouse = winFactory.createMouse();\n    mouse.click();  //win 专用鼠标\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.3 抽象工厂模式适用场景\n\n抽象工厂模式和工厂方法模式一样，都符合开闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。\n\n在以下情况下可以使用抽象工厂模式：\n\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 系统结构稳定，不会频繁的增加对象。 “开闭原则”的倾斜性\n\n在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为**“开闭原则”的倾斜性**。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：\n\n增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。 正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。\n\n\n# 3.4 抽象工厂模式总结\n\n抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。\n\n优点：\n\n抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点：\n\n增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。\n\n\n# 工厂模式的退化\n\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n\n\n# 四、我们身边的工厂模式\n\n工厂模式在Java码农身边真是无处不在，不信打开你的项目，搜索 Factory\n\n我们最常用的 Spring 就是一个最大的 Bean 工厂，IOC 通过BeanFactory对Bean 进行管理。\n\n我们使用的日志门面框架slf4j，点进去就可以看到熟悉的味道\n\nprivate final static Logger logger = LoggerFactory.getLogger(HelloWord.class); JDK 的 Calendar 使用了简单工厂模式\n\n Calendar calendar = Calendar.getInstance();\n\n\n1\n\n\n> 参考\n> https://javakeeper.starfish.ink/design-pattern/Factory-Pattern.html',normalizedContent:'> 3年工作经验是吧？ 你知道工厂模式分为几类吗？能举例子吗？ 那你说说你们项目中是怎么使用工厂模式的？\n\n\n# 工厂模式\n\n工厂模式（factory pattern）是 java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n\n\n# 模式动机\n\n考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。\n\n\n# 模式定义\n\n简单工厂模式(simple factory pattern)：又称为静态工厂方法(static factory method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n\n\n# 模式结构\n\n简单工厂模式包含如下角色：\n\nfactory：工厂角色\n工厂角色负责实现创建所有实例的内部逻辑 product：抽象产品角色\n抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 concreteproduct：具体产品角色\n具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 1.4. 时序图\n\n\n# 模式分析\n\n将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。\n\n在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可.\n\n在实际开发中，还可以在调用时将所传入的参数保存在xml等格式的配置文件中，修改参数时无须修改任何源代码。\n\n简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\n\n# 工厂模式可以分为三类：\n\n简单工厂模式（simple factory） 工厂方法模式（factory method） 抽象工厂模式（abstract factory） 简单工厂其实不是一个标准的的设计模式。gof 23种设计模式中只有「工厂方法模式」与「抽象工厂模式」。简单工厂模式可以看为工厂方法模式的一种特例，为了统一整理学习，就都归为工厂模式。\n\n这三种工厂模式在设计模式的分类中都属于创建型模式，三种模式从上到下逐步抽象。\n\n创建型模式 创建型模式(creational pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。\n\n创建型模式在创建什么(what)，由谁创建(who)，何时创建(when)等方面都为软件设计者提供了尽可能大的灵活性。\n\n创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。\n\n工厂模式是创建型模式中比较重要的。工厂模式的主要功能就是帮助我们实例化对象。之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。\n\n工厂模式优点 可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。 对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。 降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。 适用场景 不管是简单工厂模式，工厂方法模式还是抽象工厂模式，他们具有类似的特性，所以他们的适用场景也是类似的。\n\n首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。\n\n再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n\n# 一、简单工厂模式\n\n在介绍简单工厂模式之前，我们尝试解决以下问题：\n\n现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。我们一般会这么写：\n\n// 计算类的基类\n@setter\n@getter\npublic abstract class operation {\n    private double value1 = 0;\n    private double value2 = 0;\n    protected abstract double getresule();\n}\n\n//加法\npublic class operationadd extends operation {\n    @override\n    protected double getresule() {\n        return getvalue1() + getvalue2();\n    }\n}\n//减法\npublic class operationsub extends operation {\n    @override\n    protected double getresule() {\n        return getvalue1() - getvalue2();\n    }\n}\n//乘法\npublic class operationmul extends operation {\n    @override\n    protected double getresule() {\n        return getvalue1() * getvalue2();\n    }\n}\n//除法\npublic class operationdiv extends operation {\n    @override\n    protected double getresule() {\n        if (getvalue2() != 0) {\n            return getvalue1() / getvalue2();\n        }\n        throw new illegalargumentexception("除数不能为零");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n当我们要使用这个计算器的时候，又会这么写：\n\npublic static void main(string[] args) {\n  //计算两数之和\n  operationadd operationadd = new operationadd();\n  operationadd.setvalue1(1);\n  operationadd.setvalue2(2);\n  system.out.println("sum:"+operationadd.getresule());\n  //计算两数乘积\n  operationmul operationmul = new operationmul();\n  operationmul.setvalue1(3);\n  operationmul.setvalue2(5);\n  system.out.println("multiply:"+operationmul.getresule());\n  //计算两数之差。。。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。那么这种重复的创建类的工作其实可以放到一个统一的类中去管理。这样的方法我们就叫做「简单工厂模式」，在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为「静态工厂方法」模式。。简单工厂模式有以下优点：\n\n一个调用者想创建一个对象，只要知道其名称就可以了。 屏蔽产品的具体实现，调用者只关心产品的接口。\n\n\n# 定义\n\n提供一个创建对象实例的功能，而无需关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。\n\n\n# 简单工厂模式实现方式\n\n没骗你，简单工厂模式，真是因为简单才被叫做简单工厂模式的。\n\n简单工厂模式包含 3 个角色（要素）：\n\nfactory：即工厂类， 简单工厂模式的核心部分，负责实现创建所有产品的内部逻辑；工厂类可以被外界直接调用，创建所需对象 product：抽象类产品， 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象 concreteproduct：具体产品， 它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。它要实现抽象产品中声明的抽象方法\n\n\n# uml类图\n\n\n\n\n# 实例\n\n现在我们定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n\n//工厂类\npublic class operationfactory {\n\n    public static operation createoperation(string operation) {\n        operation oper = null;\n        switch (operation) {\n            case "add":\n                oper = new operationadd();\n                break;\n            case "sub":\n                oper = new operationsub();\n                break;\n            case "mul":\n                oper = new operationmul();\n                break;\n\n            case "div":\n                oper = new operationdiv();\n                break;\n            default:\n                throw new unsupportedoperationexception("不支持该操作");\n        }\n        return oper;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n有了工厂类之后，可以使用工厂创建对象：\n\npublic static void main(string[] args) {\n  operation operationadd = operationfactory.createoperation("add");\n  operationadd.setvalue1(1);\n  operationadd.setvalue2(2)\n  system.out.println(operationadd.getresule());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，只要知道该类对应的参数"add"就可以了。这就体现了之前提到的工厂模式的优点。\n\n\n# 简单工厂模式存在的问题\n\n当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承operation类，其中实现平方的代码。除此之外我们还要修改 operationfactory 类的代码，增加一个 case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。\n\n我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。\n\n\n# 简单工厂模式总结\n\n工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。\n\n但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。\n\n当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；\n\n为了解决这些缺点，就有了工厂方法模式。\n\n\n# 二、工厂方法模式\n\n我们常说的工厂模式，就是指「工厂方法模式」，也叫「虚拟构造器模式」或「多态工厂模式」。\n\n\n# 2.1 定义\n\n定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。\n\n\n# 2.2 工厂方法模式实现方式\n\n工厂方法模式包含 4 个角色（要素）：\n\nproduct：抽象产品，定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口 concreteproduct：具体产品，具体的product接口的实现对象 factory：工厂接口，也可以叫 creator(创建器)，申明工厂方法，通常返回一个 product 类型的实例对象 concretefactory：工厂实现，或者叫 concretecreator(创建器对象)，覆盖 factory 定义的工厂方法，返回具体的 product 实例\n\n\n# uml类图\n\n\n\n\n# 实例\n\n从 uml 类图可以看出，每种产品实现，我们都要增加一个继承于工厂接口 ifactory 的工厂类 factory ，修改简单工厂模式代码中的工厂类如下：\n\n//工厂接口\npublic interface ifactory {\n    operation createoption();\n}\n\n//加法类工厂\npublic class addfactory implements ifactory {\n    public operation createoption() {\n        return new operationadd();\n    }\n}\n\n//减法类工厂\npublic class subfactory implements ifactory {\n    public operation createoption() {\n        return new operationsub();\n    }\n}\n\n//乘法类工厂\npublic class mulfactory implements ifactory {\n    public operation createoption() {\n        return new operationmul();\n    }\n}\n\n//除法类工厂\npublic class divfactory implements ifactory {\n    public operation createoption() {\n        return new operationdiv();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这时，我们使用计算器的时候，要为每种运算方法增加一个工厂对象\n\npublic class client {\n    public static void main(string[] args) {\n      //减法\n      ifactory subfactory = new subfactory();\n      operation operationsub =  subfactory.createoption();\n      operationsub.setvalue1(22);\n      operationsub.setvalue2(20);\n      system.out.println("sub:"+operationsub.getresult());\n      //除法\n      ifactory divfactory = new divfactory();\n      operation operationdiv =  divfactory.createoption();\n      operationdiv.setvalue1(99);\n      operationdiv.setvalue2(33);\n      system.out.println("div:"+operationsub.getresult());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n纳尼，这不是更复杂了吗，每个产品对应一个工厂，我又不是按代码量赚钱的。。。\n\n\n# 2.3 工厂方法模式适用场景\n\n工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合“开闭原则”。\n\n在以下情况下可以使用工厂方法模式：\n\n一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 使用场景 日志记录器：日志可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，"pop3"、"imap"、"http"，可以把这三个作为产品类，共同实现一个接口。 比如 hibernate 换数据库只需换方言和驱动就可以\n\n\n# 2.4 工厂方法模式总结\n\n工厂方法模式是简单工厂模式的进一步抽象和推广。\n\n由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\n\n在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。\n\n优点：\n\n一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：\n\n每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n\n\n# 三、抽象工厂模式\n\n工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。\n\n\n# 3.1 定义\n\n为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。\n\n抽象工厂(abstract factory)模式，又称工具箱(kit 或toolkit)模式。\n\n\n# 3.2 抽象工厂模式实现方式\n\n抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。\n\n在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。\n\n也没骗你，抽象工厂模式确实是抽象。\n\n抽象工厂模式包含的角色（要素）：\n\nabstractfactory：抽象工厂，用于声明生成抽象产品的方法 concretefactory：具体工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建 abstractproduct：抽象产品，定义一类产品对象的接口 concreteproduct：具体产品，通常在具体工厂里，会选择具体的产品实现，来创建符合抽象工厂定义的方法返回的产品类型的对象。 client：客户端，使用抽象工厂来获取一系列所需要的产品对象\n\n\n# uml类图\n\n\n# 实例\n\n我把维基百科的例子改下用于理解，假设我们要生产两种产品，键盘（keyboard）和鼠标（mouse） ，每一种产品都支持多种系列，比如 mac 系列和 windows 系列。这样每个系列的产品分别是 mackeyboard winkeyboard, macmouse, winmouse 。为了可以在运行时刻创建一个系列的产品族，我们可以为每个系列的产品族创建一个工厂 macfactory 和 winfactory 。每个工厂都有两个方法 createmouse 和 createkeyboard 并返回对应的产品，可以将这两个方法抽象成一个接口 hardware 。这样在运行时刻我们可以选择创建需要的产品系列。\n\n抽象产品\n\npublic interface keyboard {\n  void input();\n}\npublic interface mouse {\n  void click();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n具体产品\n\n//具体产品\n\npublic class mackeyboard implements keyboard {\n    @override\n    public void input() {\n        system.out.println("mac 专用键盘");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\npublic class macmouse implements mouse {\n    @override\n    public void click() {\n        system.out.println("mac 专用鼠标");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\npublic class winkeyboard implements keyboard {\n    @override\n    public void input() {\n        system.out.println("win 专用键盘");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\npublic class winmouse implements mouse {\n    @override\n    public void click() {\n        system.out.println("win 专用鼠标");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n抽象工厂\n\npublic interface hardware {\n     keyboard createkyeboard();\n     mouse createmouse();\n}\n\n\n1\n2\n3\n4\n\n\n具体的工厂类\n\npublic class macfactory implements hardware{\n    @override\n    public keyboard createkyeboard() {\n        return new mackeyboard();\n    }\n\n    @override\n    public mouse createmouse() {\n        return new macmouse();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npublic class winfactory implements hardware{\n    @override\n    public keyboard createkyeboard() {\n        return new winkeyboard();\n    }\n\n    @override\n    public mouse createmouse() {\n        return new winmouse();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用\n\npublic class client {\n  public static void main(string[] args) {\n    hardware macfactory = new macfactory();\n    keyboard keyboard = macfactory.createkyeboard();\n    keyboard.input();   //mac 专用键盘\n\n    hardware winfactory = new winfactory();\n    mouse mouse = winfactory.createmouse();\n    mouse.click();  //win 专用鼠标\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.3 抽象工厂模式适用场景\n\n抽象工厂模式和工厂方法模式一样，都符合开闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。\n\n在以下情况下可以使用抽象工厂模式：\n\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 系统结构稳定，不会频繁的增加对象。 “开闭原则”的倾斜性\n\n在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为**“开闭原则”的倾斜性**。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：\n\n增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。 正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。\n\n\n# 3.4 抽象工厂模式总结\n\n抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和api类库的设计中，例如在java语言的awt（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。\n\n优点：\n\n抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点：\n\n增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。\n\n\n# 工厂模式的退化\n\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n\n\n# 四、我们身边的工厂模式\n\n工厂模式在java码农身边真是无处不在，不信打开你的项目，搜索 factory\n\n我们最常用的 spring 就是一个最大的 bean 工厂，ioc 通过beanfactory对bean 进行管理。\n\n我们使用的日志门面框架slf4j，点进去就可以看到熟悉的味道\n\nprivate final static logger logger = loggerfactory.getlogger(helloword.class); jdk 的 calendar 使用了简单工厂模式\n\n calendar calendar = calendar.getinstance();\n\n\n1\n\n\n> 参考\n> https://javakeeper.starfish.ink/design-pattern/factory-pattern.html',charsets:{cjk:!0},lastUpdated:"2022/09/20, 22:28:30",lastUpdatedTimestamp:166368411e4},{title:"简述装饰者模式",frontmatter:{title:"简述装饰者模式",date:"2022-05-21T17:26:42.000Z",permalink:"/pages/47a4e3/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/005.%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java相关/40.设计模式/005.装饰者模式.md",key:"v-22a9eaef",path:"/pages/47a4e3/",headers:[{level:2,title:"模式动机",slug:"模式动机",normalizedTitle:"模式动机",charIndex:186},{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:489},{level:2,title:"角色",slug:"角色",normalizedTitle:"角色",charIndex:632},{level:2,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:1194},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:1203},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:3775},{level:3,title:"Java I/O 中的装饰者模式",slug:"java-i-o-中的装饰者模式",normalizedTitle:"java i/o 中的装饰者模式",charIndex:3782},{level:3,title:"Servlet 中的装饰者模式",slug:"servlet-中的装饰者模式",normalizedTitle:"servlet 中的装饰者模式",charIndex:4933},{level:3,title:"spring 中的装饰者模式",slug:"spring-中的装饰者模式",normalizedTitle:"spring 中的装饰者模式",charIndex:5565},{level:3,title:"Mybatis 缓存中的装饰者模式",slug:"mybatis-缓存中的装饰者模式",normalizedTitle:"mybatis 缓存中的装饰者模式",charIndex:6062},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6192},{level:2,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:6300},{level:2,title:"何时选用",slug:"何时选用",normalizedTitle:"何时选用",charIndex:6776}],headersStr:"模式动机 定义 角色 类图 实例 应用 Java I/O 中的装饰者模式 Servlet 中的装饰者模式 spring 中的装饰者模式 Mybatis 缓存中的装饰者模式 总结 优缺点 何时选用",content:'《Head First 设计模式》中是这么形容装饰者模式的——“给爱用继承的人一个全新的设计眼界”，拒绝继承滥用，从装饰者模式开始。\n\n装饰者模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n\n\n# 模式动机\n\n一般有两种方式可以实现给一个类或对象增加行为：\n\n * 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。\n\n * 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)\n\n装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n\n\n# 定义\n\n装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类（继承）实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。\n\n\n# 角色\n\n * Component： 抽象组件，装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为，可以给这些对象动态添加职责\n\n * ConcreteComponent： 具体的组件对象，实现类 ，即被装饰者，通常就是被装饰器装饰的原始对象，也就是可以给这个对象添加职责\n\n * Decorator： 所有装饰器的抽象父类，一般是抽象类，实现接口；它的属性必然有个指向 Conponent 抽象组件的对象 ，其实就是持有一个被装饰的对象\n\n * ConcreteDecorator： 具体的装饰对象，实现具体要被装饰对象添加的功能。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。\n\n装饰者和被装饰者对象有相同的父类，因为装饰者和被装饰者必须是一样的类型，这里利用继承是为了达到类型匹配，而不是利用继承获得行为。\n\n利用继承设计子类，只能在编译时静态决定，并且所有子类都会继承相同的行为；利用组合的做法扩展对象，就可以在运行时动态的进行扩展。装饰者模式遵循开放-关闭原则：**类应该对扩展开放，对修改关闭。**利用装饰者，我们可以实现新的装饰者增加新的行为而不用修改现有代码，而如果单纯依赖继承，每当需要新行为时，还得修改现有的代码。\n\n\n# 类图\n\n\n\n\n# 实例\n\n看了好多资料的例子，比如\n\n * 公司发放奖金，不同的员工类型对应不同的奖金计算规则，用各种计算规则去装饰统一的奖金计算类\n * 星巴克售卖用咖啡，用摩卡、奶泡去装饰咖啡，实现不同的计费\n * 变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔\n\n我还是比较喜欢卖煎饼的例子\n\n\n\n1、定义抽象组件\n\npublic abstract class Pancake {\n\n    String description = "普通煎饼";\n\n    public String getDescription(){\n        return description;\n    }\n\n    public abstract double cost();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n2、定义具体的被装饰者，这里是煎饼果子，当然还可以有鸡蛋灌饼、手抓饼等其他被装饰者\n\npublic class Battercake extends Pancake {\n    @Override\n    public double cost() {\n        return 8;\n    }\n\n    public Battercake(){\n        description = "煎饼果子";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n3、抽象的装饰器对象，定义一个调料抽象类\n\npublic abstract class CondimentDecorator extends Pancake {\n\n    // 持有组件对象\n    protected Pancake pancake;\n    public CondimentDecorator(Pancake pancake){\n        this.pancake = pancake;\n    }\n\n    public abstract String getDescription();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n4、具体的装饰者，我们定义一个鸡蛋装饰器，一个火腿装饰器\n\npublic class Egg extends CondimentDecorator {\n    public Egg(Pancake pancake){\n        super(pancake);\n    }\n\n    @Override\n    public String getDescription() {\n        return pancake.getDescription() + "加鸡蛋";\n    }\n\n    @Override\n    public double cost() {\n        return pancake.cost() + 1;\n    }\n}\npublic class Sausage extends CondimentDecorator{\n    public Sausage(Pancake pancake){\n        super(pancake);\n    }\n    @Override\n    public String getDescription() {\n        return pancake.getDescription() + "加火腿";\n    }\n\n    @Override\n    public double cost() {\n        return pancake.cost() + 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n5、测试煎饼交易，over\n\npublic class Client {\n\n    public static void main(String[] args) {\n        //买一个普通的煎饼果子\n        Pancake battercake = new Battercake();\n        System.out.println(battercake.getDescription() + "花费："+battercake.cost() + "元");\n\n        //买一个加双蛋的煎饼果子\n        Pancake doubleEgg = new Battercake();\n        doubleEgg = new Egg(doubleEgg);\n        doubleEgg = new Egg(doubleEgg);\n        System.out.println(doubleEgg.getDescription() + "花费" + doubleEgg.cost() + "元");\n\n        //加火腿和鸡蛋\n        Pancake battercakePlus = new Battercake();\n        battercakePlus = new Egg(battercakePlus);\n        battercakePlus = new Sausage(battercakePlus);\n        System.out.println(battercakePlus.getDescription() + "花费" + battercakePlus.cost() + "元");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n输出：\n\n煎饼果子花费：8.0元\n煎饼果子加鸡蛋加鸡蛋花费10.0元\n煎饼果子加鸡蛋加火腿花费11.0元\n\n\n1\n2\n3\n\n\n顺便看下通过 IDEA 生成的 UML 类图（和我们画的类图一样哈）\n\n\n# 应用\n\n\n# Java I/O 中的装饰者模式\n\n我们使用 java.io 包下的各种输入流、输出流、字节流、字符流、缓冲流等各种各样的流，他们中的许多类都是装饰者，下面是一个典型的对象集合，用装饰者将功能结合起来，以读取文件数据\n\n\n\nBufferedInputStream 和 LinerNumberInputStream 都是扩展自 FilterInputStream，而 FilterInputStream 是一个抽象的装饰类。\n\n在 idea 中选中一些常见 InputStream 类，生成 UML 图如下：\n\n我们平时读取一个文件中的内容其实就使用到了装饰模式的思想，简化《Head First 设计模式》的例子，我们自定义一个装饰者，把输入流中的所有大写字符转换为小写\n\npublic class LowerCaseInputStream extends FilterInputStream {\n  \n    protected LowerCaseInputStream(InputStream in) {\n        super(in);\n    }\n\n    public int read() throws IOException {\n        int c = super.read();\n        return (c == -1 ? c:Character.toLowerCase(c));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npublic class InputTest {\n\n    public static void main(String[] args) throws IOException {\n        int c;\n        //装饰器的组装过程\n        InputStream in = new LowerCaseInputStream(new BufferedInputStream(new FileInputStream("JavaKeeper.txt"))); \n\n        while ((c = in.read()) >= 0){\n            System.out.print((char) c);\n        }\n        in.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n采用装饰者模式在实例化组件时，将增加代码的复杂度，一旦使用装饰者模式，不只需要实例化组件，还把把此组件包装进装饰者中，天晓得有几个，所以在某些复杂情况下，我们还会结合工厂模式和生成器模式。比如Spring中的装饰者模式。\n\n\n# Servlet 中的装饰者模式\n\nServlet API 源自于 4 个实现类，它很少被使用，但是十分强大：ServletRequestWrapper、ServletResponseWrapper以及 HttpServletRequestWrapper、HttpServletResponseWrapper。\n\n比如 ServletRequestWrapper 是 ServletRequest 接口的简单实现，开发者可以继承 ServletRequestWrapper 去扩展原来的 request\n\npublic class ServletRequestWrapper implements ServletRequest {\n    private ServletRequest request;\n\n    public ServletRequestWrapper(ServletRequest request) {\n        if (request == null) {\n            throw new IllegalArgumentException("Request cannot be null");\n        } else {\n            this.request = request;\n        }\n    }\n\t//.......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# spring 中的装饰者模式\n\nSpring 的 ApplicationContext 中配置所有的 DataSource。 这些 DataSource 可能是各种不同类型的， 比如不同的数据库： Oracle、 SQL Server、 MySQL 等， 也可能是不同的数据源。 然后 SessionFactory 根据客户的每次请求， 将 DataSource 属性设置成不同的数据源， 以达到切换数据源的目的。\n\n在 Spring 的命名体现：Spring 中用到的包装器模式在类名上有两种表现： 一种是类名中含有 Wrapper， 另一种是类名中含有 Decorator。 基本上都是动态地给一个对象添加一些额外的职责，比如\n\norg.springframework.cache.transaction 包下的 TransactionAwareCacheDecorator 类 org.springframework.session.web.http 包下的 SessionRepositoryFilter 内部类 SessionRepositoryRequestWrapper\n\n\n# Mybatis 缓存中的装饰者模式\n\nMybatis 的缓存模块中，使用了装饰器模式的变体，其中将 Decorator 接口和 Componet 接口合并为一个 Component 接口。org.apache.ibatis.cache 包下的结构\n\n\n\n\n# 总结\n\n装饰模式的本质：动态组合\n\n动态组合是手段，组合才是目的。这里的组合有两个意思，一个是动态功能的组合，也就是动态进行装饰器的组合；另外一个是指对象组合，通过对象组合来实现为被装饰对象透明的增加功能。\n\n\n# 优缺点\n\n装饰模式的优点:\n\n * 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。\n * 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。\n * 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。\n * 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”\n\n装饰模式的缺点:\n\n * 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。\n * 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。\n\n\n# 何时选用\n\n * 如果需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰模式\n * 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如 Java 语言中的 final 类）\n\n参考： 装饰模式——看看 JDK 和 Spring 是如何杜绝继承滥用的',normalizedContent:'《head first 设计模式》中是这么形容装饰者模式的——“给爱用继承的人一个全新的设计眼界”，拒绝继承滥用，从装饰者模式开始。\n\n装饰者模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n\n\n# 模式动机\n\n一般有两种方式可以实现给一个类或对象增加行为：\n\n * 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。\n\n * 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(decorator)\n\n装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n\n\n# 定义\n\n装饰模式(decorator pattern) ：动态地给一个对象增加一些额外的职责(responsibility)，就增加对象功能来说，装饰模式比生成子类（继承）实现更为灵活。其别名也可以称为包装器(wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。\n\n\n# 角色\n\n * component： 抽象组件，装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为，可以给这些对象动态添加职责\n\n * concretecomponent： 具体的组件对象，实现类 ，即被装饰者，通常就是被装饰器装饰的原始对象，也就是可以给这个对象添加职责\n\n * decorator： 所有装饰器的抽象父类，一般是抽象类，实现接口；它的属性必然有个指向 conponent 抽象组件的对象 ，其实就是持有一个被装饰的对象\n\n * concretedecorator： 具体的装饰对象，实现具体要被装饰对象添加的功能。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。\n\n装饰者和被装饰者对象有相同的父类，因为装饰者和被装饰者必须是一样的类型，这里利用继承是为了达到类型匹配，而不是利用继承获得行为。\n\n利用继承设计子类，只能在编译时静态决定，并且所有子类都会继承相同的行为；利用组合的做法扩展对象，就可以在运行时动态的进行扩展。装饰者模式遵循开放-关闭原则：**类应该对扩展开放，对修改关闭。**利用装饰者，我们可以实现新的装饰者增加新的行为而不用修改现有代码，而如果单纯依赖继承，每当需要新行为时，还得修改现有的代码。\n\n\n# 类图\n\n\n\n\n# 实例\n\n看了好多资料的例子，比如\n\n * 公司发放奖金，不同的员工类型对应不同的奖金计算规则，用各种计算规则去装饰统一的奖金计算类\n * 星巴克售卖用咖啡，用摩卡、奶泡去装饰咖啡，实现不同的计费\n * 变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔\n\n我还是比较喜欢卖煎饼的例子\n\n\n\n1、定义抽象组件\n\npublic abstract class pancake {\n\n    string description = "普通煎饼";\n\n    public string getdescription(){\n        return description;\n    }\n\n    public abstract double cost();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n2、定义具体的被装饰者，这里是煎饼果子，当然还可以有鸡蛋灌饼、手抓饼等其他被装饰者\n\npublic class battercake extends pancake {\n    @override\n    public double cost() {\n        return 8;\n    }\n\n    public battercake(){\n        description = "煎饼果子";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n3、抽象的装饰器对象，定义一个调料抽象类\n\npublic abstract class condimentdecorator extends pancake {\n\n    // 持有组件对象\n    protected pancake pancake;\n    public condimentdecorator(pancake pancake){\n        this.pancake = pancake;\n    }\n\n    public abstract string getdescription();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n4、具体的装饰者，我们定义一个鸡蛋装饰器，一个火腿装饰器\n\npublic class egg extends condimentdecorator {\n    public egg(pancake pancake){\n        super(pancake);\n    }\n\n    @override\n    public string getdescription() {\n        return pancake.getdescription() + "加鸡蛋";\n    }\n\n    @override\n    public double cost() {\n        return pancake.cost() + 1;\n    }\n}\npublic class sausage extends condimentdecorator{\n    public sausage(pancake pancake){\n        super(pancake);\n    }\n    @override\n    public string getdescription() {\n        return pancake.getdescription() + "加火腿";\n    }\n\n    @override\n    public double cost() {\n        return pancake.cost() + 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n5、测试煎饼交易，over\n\npublic class client {\n\n    public static void main(string[] args) {\n        //买一个普通的煎饼果子\n        pancake battercake = new battercake();\n        system.out.println(battercake.getdescription() + "花费："+battercake.cost() + "元");\n\n        //买一个加双蛋的煎饼果子\n        pancake doubleegg = new battercake();\n        doubleegg = new egg(doubleegg);\n        doubleegg = new egg(doubleegg);\n        system.out.println(doubleegg.getdescription() + "花费" + doubleegg.cost() + "元");\n\n        //加火腿和鸡蛋\n        pancake battercakeplus = new battercake();\n        battercakeplus = new egg(battercakeplus);\n        battercakeplus = new sausage(battercakeplus);\n        system.out.println(battercakeplus.getdescription() + "花费" + battercakeplus.cost() + "元");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n输出：\n\n煎饼果子花费：8.0元\n煎饼果子加鸡蛋加鸡蛋花费10.0元\n煎饼果子加鸡蛋加火腿花费11.0元\n\n\n1\n2\n3\n\n\n顺便看下通过 idea 生成的 uml 类图（和我们画的类图一样哈）\n\n\n# 应用\n\n\n# java i/o 中的装饰者模式\n\n我们使用 java.io 包下的各种输入流、输出流、字节流、字符流、缓冲流等各种各样的流，他们中的许多类都是装饰者，下面是一个典型的对象集合，用装饰者将功能结合起来，以读取文件数据\n\n\n\nbufferedinputstream 和 linernumberinputstream 都是扩展自 filterinputstream，而 filterinputstream 是一个抽象的装饰类。\n\n在 idea 中选中一些常见 inputstream 类，生成 uml 图如下：\n\n我们平时读取一个文件中的内容其实就使用到了装饰模式的思想，简化《head first 设计模式》的例子，我们自定义一个装饰者，把输入流中的所有大写字符转换为小写\n\npublic class lowercaseinputstream extends filterinputstream {\n  \n    protected lowercaseinputstream(inputstream in) {\n        super(in);\n    }\n\n    public int read() throws ioexception {\n        int c = super.read();\n        return (c == -1 ? c:character.tolowercase(c));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npublic class inputtest {\n\n    public static void main(string[] args) throws ioexception {\n        int c;\n        //装饰器的组装过程\n        inputstream in = new lowercaseinputstream(new bufferedinputstream(new fileinputstream("javakeeper.txt"))); \n\n        while ((c = in.read()) >= 0){\n            system.out.print((char) c);\n        }\n        in.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n采用装饰者模式在实例化组件时，将增加代码的复杂度，一旦使用装饰者模式，不只需要实例化组件，还把把此组件包装进装饰者中，天晓得有几个，所以在某些复杂情况下，我们还会结合工厂模式和生成器模式。比如spring中的装饰者模式。\n\n\n# servlet 中的装饰者模式\n\nservlet api 源自于 4 个实现类，它很少被使用，但是十分强大：servletrequestwrapper、servletresponsewrapper以及 httpservletrequestwrapper、httpservletresponsewrapper。\n\n比如 servletrequestwrapper 是 servletrequest 接口的简单实现，开发者可以继承 servletrequestwrapper 去扩展原来的 request\n\npublic class servletrequestwrapper implements servletrequest {\n    private servletrequest request;\n\n    public servletrequestwrapper(servletrequest request) {\n        if (request == null) {\n            throw new illegalargumentexception("request cannot be null");\n        } else {\n            this.request = request;\n        }\n    }\n\t//.......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# spring 中的装饰者模式\n\nspring 的 applicationcontext 中配置所有的 datasource。 这些 datasource 可能是各种不同类型的， 比如不同的数据库： oracle、 sql server、 mysql 等， 也可能是不同的数据源。 然后 sessionfactory 根据客户的每次请求， 将 datasource 属性设置成不同的数据源， 以达到切换数据源的目的。\n\n在 spring 的命名体现：spring 中用到的包装器模式在类名上有两种表现： 一种是类名中含有 wrapper， 另一种是类名中含有 decorator。 基本上都是动态地给一个对象添加一些额外的职责，比如\n\norg.springframework.cache.transaction 包下的 transactionawarecachedecorator 类 org.springframework.session.web.http 包下的 sessionrepositoryfilter 内部类 sessionrepositoryrequestwrapper\n\n\n# mybatis 缓存中的装饰者模式\n\nmybatis 的缓存模块中，使用了装饰器模式的变体，其中将 decorator 接口和 componet 接口合并为一个 component 接口。org.apache.ibatis.cache 包下的结构\n\n\n\n\n# 总结\n\n装饰模式的本质：动态组合\n\n动态组合是手段，组合才是目的。这里的组合有两个意思，一个是动态功能的组合，也就是动态进行装饰器的组合；另外一个是指对象组合，通过对象组合来实现为被装饰对象透明的增加功能。\n\n\n# 优缺点\n\n装饰模式的优点:\n\n * 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。\n * 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。\n * 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。\n * 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”\n\n装饰模式的缺点:\n\n * 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。\n * 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。\n\n\n# 何时选用\n\n * 如果需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰模式\n * 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如 java 语言中的 final 类）\n\n参考： 装饰模式——看看 jdk 和 spring 是如何杜绝继承滥用的',charsets:{cjk:!0},lastUpdated:"2022/09/20, 22:28:30",lastUpdatedTimestamp:166368411e4},{title:"适配器模式",frontmatter:{title:"适配器模式",date:"2022-05-21T17:28:10.000Z",permalink:"/pages/827fc4/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/010.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java相关/40.设计模式/010.适配器模式.md",key:"v-31509c80",path:"/pages/827fc4/",headers:[{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2},{level:2,title:"真实世界类比",slug:"真实世界类比",normalizedTitle:"真实世界类比",charIndex:233},{level:2,title:"基本介绍",slug:"基本介绍",normalizedTitle:"基本介绍",charIndex:312},{level:2,title:"工作原理",slug:"工作原理",normalizedTitle:"工作原理",charIndex:455},{level:2,title:"适配器模式结构",slug:"适配器模式结构",normalizedTitle:"适配器模式结构",charIndex:591},{level:3,title:"对象适配器",slug:"对象适配器",normalizedTitle:"对象适配器",charIndex:443},{level:3,title:"Coding",slug:"coding",normalizedTitle:"coding",charIndex:1064},{level:2,title:"类适配器",slug:"类适配器",normalizedTitle:"类适配器",charIndex:436},{level:2,title:"Coding",slug:"coding-2",normalizedTitle:"coding",charIndex:1064},{level:2,title:"适配器模式适合应用场景",slug:"适配器模式适合应用场景",normalizedTitle:"适配器模式适合应用场景",charIndex:3145},{level:2,title:"demo",slug:"demo",normalizedTitle:"demo",charIndex:3518},{level:2,title:"适配器模式优缺点",slug:"适配器模式优缺点",normalizedTitle:"适配器模式优缺点",charIndex:5027},{level:2,title:"Spring 中的适配器",slug:"spring-中的适配器",normalizedTitle:"spring 中的适配器",charIndex:5191}],headersStr:"问题 真实世界类比 基本介绍 工作原理 适配器模式结构 对象适配器 Coding 类适配器 Coding 适配器模式适合应用场景 demo 适配器模式优缺点 Spring 中的适配器",content:'# 问题\n\n假设我们在做一套股票看盘系统，数据提供方给我们提供 XML 格式数据，我们获取数据用来显示，随着系统的迭代，我们要整合一些第三方系统的对外数据，但是他们只提供获取 JSON 格式的数据接口。\n\n在不想改变原有代码逻辑的情况下，如何解决呢？\n\n这时候我们就可以创建一个「适配器」。这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。\n\n适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。\n\n\n\n\n# 真实世界类比\n\n适配器是什么，不难理解，生活中也随处可见。比如，笔记本电脑的电源适配器、万能充（曾经的它真有一个这么牛逼的名字）、一拖十数据线等等。\n\n\n# 基本介绍\n\n * 适配器模式将一个类的接口，转换成客户期望的另外一个接口。适配器让原本接口不兼容的类可以合作无间。也可以叫包装器（Wrapper）\n\n * 适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作\n\n * 主要分为两类：类适配器模式、对象适配器模式\n\n\n# 工作原理\n\n * 适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容\n * 从用户的角度看不到被适配者，是解耦的\n * 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法\n * 用户收到反馈结果，感觉只是和目标接口交互\n\n\n# 适配器模式结构\n\n\n# 对象适配器\n\n实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。\n\n适配器设计模式的结构（对象适配器）\n\n * 客户端 （Client） 是包含当前程序业务逻辑的类。\n * 客户端接口 （Target） 描述了其他类与客户端代码合作时必须遵循的协议。\n * 服务 （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能，也可以叫适配者类（Adaptee）。\n * 适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。\n * 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。\n\n\n# Coding\n\n定义客户端使用的接口，与业务相关\n\npublic interface Target {\n\n    /*\n     * 客户端请求处理的方法\n     */\n    void request();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n已经存在的接口，这个接口需要配置\n\npublic class Adaptee {\n\n    /*\n     * 原本存在的方法\n     */\n    public void specificRequest(){\n    //业务代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n适配器类\n\npublic class Adapter implements Target {\n\n    /*\n     * 持有需要被适配的接口对象\n     */\n    private Adaptee adaptee;\n\n    /*\n     * 构造方法，传入需要被适配的对象\n     * @param adaptee 需要被适配的对象\n     */\n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    @Override\n    public void request() {\n        // TODO Auto-generated method stub\n        adaptee.specificRequest();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n使用适配器的客户端\n\npublic class Client {\n\n    public static void main(String[] args) {\n        //创建需要被适配的对象\n        Adaptee adaptee = new Adaptee();\n        //创建客户端需要调用的接口对象\n        Target target = new Adapter(adaptee);\n        //请求处理\n        target.request();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 类适配器\n\n这一实现使用了继承机制： 适配器同时继承两个对象的接口。 请注意， 这种方式仅能在支持多重继承的编程语言中实现，例如 C++， Java 不支持多重继承，也就没有这种适配器了。\n\n适配器设计模式（类适配器）\n\n类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。\n\n\n# Coding\n\nJava 虽然不能实现标准的类适配器，但是有一种变通的方式，也能够使用继承来实现接口的适配，那就是让适配器去实现 Target 的接口，然后继承 Adaptee 的实现，虽然不是十分标准，但意思差不多。\n\n首先有一个已存在的将被适配的类\n\npublic class Adaptee {\n    public void adapteeRequest() {\n        System.out.println("被适配者的方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n定义客户端使用的接口，与业务相关\n\npublic interface Target {\n\n    void request();\n}\n\n\n1\n2\n3\n4\n\n\n怎么才可以在目标接口中的 request() 调用 Adaptee 的 adapteeRequest() 方法呢？直接实现 Target 肯定是不行的，所以我们通过一个适配器类，实现 Target 接口，同时继承了 Adaptee 类，然后在实现的 request() 方法中调用父类的 adapteeRequest() 即可\n\npublic class Adapter extends Adaptee implements Target{\n    @Override\n    public void request() {\n        //...一些操作...\n        super.adapteeRequest();\n        //...一些操作...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用适配器的客户端\n\npublic class Client {\n    public static void main(String[] args) {\n\n        Target adapterTarget = new Adapter();\n        adapterTarget.request();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 适配器模式适合应用场景\n\n当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。\n\n适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。\n\n如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。\n\n你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。\n\n将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。\n\n\n# demo\n\n用一个生活中的充电器的例子来讲解下适配器，我国民用电都是 220V，而我们的手机充电一般需要 5V。\n\n220V 的交流电相当于被适配者 Adaptee，我们的目标 Target 是 5V 直流电，充电器本身相当于一个 Adapter，将220V 的输入电压变换为 5V 输出。\n\n首先是我们的民用电（我国是 220V，当然还可以有其他国家的其他准备，可随时扩展）\n\npublic class Volatage220V {\n\n    public final int output = 220;\n\n    public int output220v() {\n        System.out.println("输出电压 " + output);\n        return output;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n适配接口\n\npublic interface IVoltage5V {\n     int output5V();\n}\n\n\n1\n2\n3\n\n\n我们的手机充电，只支持 5V 电压\n\npublic class Phone {\n\n    public void charging(IVoltage5V v) {\n        if (v.output5V() == 5) {\n            System.out.println("电压 5V ，符合充电标准，开始充电");\n        } else {\n            System.out.println("电压不符合标准，无法充电");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n适配器\n\npublic class VoltageAdapter implements IVoltage5V {\n\n    private Volatage220V volatage220V;  //聚合\n\n    public VoltageAdapter(Volatage220V v) {\n        this.volatage220V = v;\n    }\n\n    @Override\n    public int output5V() {\n        int dst = 0;\n        if (null != volatage220V) {\n            int src = volatage220V.output220v();\n            System.out.println("适配器工作~~~~~");\n            dst = src / 44;\n            System.out.println("适配器工作完成，输出电压" + dst);\n        }\n        return dst;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n工作，如果去国外旅游，有不同的电压，只需要扩展适配器即可。\n\npublic class Client {\n    public static void main(String[] args) {\n        Phone phone = new Phone();\n        phone.charging(new VoltageAdapter(new Volatage220V()));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 适配器模式优缺点\n\n单一职责原则，你可以将接口或数据转换代码从程序主要业务逻辑中分离。\n\n开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。\n\n代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。\n\n\n# Spring 中的适配器\n\nSpring 源码中搜关键字Adapter 会出现很多实现类，SpringMVC 中的 HandlerAdapter ，就是适配器的应用。\n\n我们先回顾下 SpringMVC 处理流程：\n\nSpring MVC 中的适配器模式主要用于执行目标 Controller 中的请求处理方法。\n\n在Spring MVC中，DispatcherServlet 作为用户，HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。\n\n为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样：\n\nif(mappedHandler.getHandler() instanceof MultiActionController){  \n   ((MultiActionController)mappedHandler.getHandler()).xxx  \n}else if(mappedHandler.getHandler() instanceof XXX){  \n    ...  \n}else if(...){  \n   ...  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这样假设如果我们增加一个 Controller，就要在代码中加入一行 if 语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。\n\n我们通过源码看看 SpringMVC 是如何实现的，首先看下核心类 DispatcherServlet：\n\npublic class DispatcherServlet extends FrameworkServlet {\n  \t//......\n\t//维护所有HandlerAdapter类的集合\n    @Nullable\n    private List<HandlerAdapter> handlerAdapters;\n  \n\t//初始化handlerAdapters\n    private void initHandlerAdapters(ApplicationContext context) {\n        this.handlerAdapters = null;\n        if (this.detectAllHandlerAdapters) {\n            Map<String, HandlerAdapter> matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n            if (!matchingBeans.isEmpty()) {\n                this.handlerAdapters = new ArrayList(matchingBeans.values());\n                AnnotationAwareOrderComparator.sort(this.handlerAdapters);\n            }\n        } else {\n            try {\n                HandlerAdapter ha = (HandlerAdapter)context.getBean("handlerAdapter", HandlerAdapter.class);\n                this.handlerAdapters = Collections.singletonList(ha);\n            } catch (NoSuchBeanDefinitionException var3) {\n            }\n        }\n\n        if (this.handlerAdapters == null) {\n            this.handlerAdapters = this.getDefaultStrategies(context, HandlerAdapter.class);\n            if (this.logger.isTraceEnabled()) {\n                this.logger.trace("No HandlerAdapters declared for servlet \'" + this.getServletName() + "\': using default strategies from DispatcherServlet.properties");\n            }\n        }\n    }\n  \n  //dispatch 方法中会获取 HandlerAdapter\n  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        //...\n    \n\t\t//获得controller对应的适配器\n        HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());          \n\t\t\t\t\n\t\t//调用适配器的handler方法处理请求，并返回ModelAndView\n        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());            \n        //...\n    }\n  \t\n\t  //返回对应的controller的处理器\n      protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n        if (this.handlerAdapters != null) {\n            Iterator var2 = this.handlerAdapters.iterator();\n\n            while(var2.hasNext()) {\n                HandlerAdapter adapter = (HandlerAdapter)var2.next();\n                if (adapter.supports(handler)) {\n                    return adapter;\n                }\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n接着看下 HandlerAdapter 的源码，也就是适配器接口:\n\npublic interface HandlerAdapter {\n    boolean supports(Object var1);\n\n    @Nullable\n    ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;\n\n    long getLastModified(HttpServletRequest var1, Object var2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n再来屡一下这个流程：\n\n首先是适配器接口 DispatchServlet 中有一个集合维护所有的 HandlerAdapter，如果配置文件中没有对适配器进行配置，那么 DispatchServlet 会在创建时对该变量进行初始化，注册所有默认的 HandlerAdapter。\n\n当一个请求过来时，DispatchServlet 会根据传过来的 handler 类型从该集合中寻找对应的 HandlerAdapter子类进行处理，并且调用它的 handler() 方法 对应的 HandlerAdapter 中的 handler() 方法又会执行对应 Controller 的 handleRequest() 方法\n\n适配器与 handler 有对应关系，而各个适配器又都是适配器接口的实现类，因此，它们都遵循相同的适配器标准，所以用户可以按照相同的方式，通过不同的 handler 去处理请求。\n\n当然了，Spring 框架中也为我们定义了一些默认的 Handler 对应的适配器。\n\n通过适配器模式我们将所有的 controller 统一交给 HandlerAdapter 处理，免去了写大量的 if-else 语句对 Controller 进行判断，也更利于扩展新的 Controller 类型。\n\n参考： 随遇而安的适配器模式 | Spring 中的适配器',normalizedContent:'# 问题\n\n假设我们在做一套股票看盘系统，数据提供方给我们提供 xml 格式数据，我们获取数据用来显示，随着系统的迭代，我们要整合一些第三方系统的对外数据，但是他们只提供获取 json 格式的数据接口。\n\n在不想改变原有代码逻辑的情况下，如何解决呢？\n\n这时候我们就可以创建一个「适配器」。这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。\n\n适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。\n\n\n\n\n# 真实世界类比\n\n适配器是什么，不难理解，生活中也随处可见。比如，笔记本电脑的电源适配器、万能充（曾经的它真有一个这么牛逼的名字）、一拖十数据线等等。\n\n\n# 基本介绍\n\n * 适配器模式将一个类的接口，转换成客户期望的另外一个接口。适配器让原本接口不兼容的类可以合作无间。也可以叫包装器（wrapper）\n\n * 适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作\n\n * 主要分为两类：类适配器模式、对象适配器模式\n\n\n# 工作原理\n\n * 适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容\n * 从用户的角度看不到被适配者，是解耦的\n * 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法\n * 用户收到反馈结果，感觉只是和目标接口交互\n\n\n# 适配器模式结构\n\n\n# 对象适配器\n\n实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。\n\n适配器设计模式的结构（对象适配器）\n\n * 客户端 （client） 是包含当前程序业务逻辑的类。\n * 客户端接口 （target） 描述了其他类与客户端代码合作时必须遵循的协议。\n * 服务 （service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能，也可以叫适配者类（adaptee）。\n * 适配器 （adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。\n * 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。\n\n\n# coding\n\n定义客户端使用的接口，与业务相关\n\npublic interface target {\n\n    /*\n     * 客户端请求处理的方法\n     */\n    void request();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n已经存在的接口，这个接口需要配置\n\npublic class adaptee {\n\n    /*\n     * 原本存在的方法\n     */\n    public void specificrequest(){\n    //业务代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n适配器类\n\npublic class adapter implements target {\n\n    /*\n     * 持有需要被适配的接口对象\n     */\n    private adaptee adaptee;\n\n    /*\n     * 构造方法，传入需要被适配的对象\n     * @param adaptee 需要被适配的对象\n     */\n    public adapter(adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    @override\n    public void request() {\n        // todo auto-generated method stub\n        adaptee.specificrequest();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n使用适配器的客户端\n\npublic class client {\n\n    public static void main(string[] args) {\n        //创建需要被适配的对象\n        adaptee adaptee = new adaptee();\n        //创建客户端需要调用的接口对象\n        target target = new adapter(adaptee);\n        //请求处理\n        target.request();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 类适配器\n\n这一实现使用了继承机制： 适配器同时继承两个对象的接口。 请注意， 这种方式仅能在支持多重继承的编程语言中实现，例如 c++， java 不支持多重继承，也就没有这种适配器了。\n\n适配器设计模式（类适配器）\n\n类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。\n\n\n# coding\n\njava 虽然不能实现标准的类适配器，但是有一种变通的方式，也能够使用继承来实现接口的适配，那就是让适配器去实现 target 的接口，然后继承 adaptee 的实现，虽然不是十分标准，但意思差不多。\n\n首先有一个已存在的将被适配的类\n\npublic class adaptee {\n    public void adapteerequest() {\n        system.out.println("被适配者的方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n定义客户端使用的接口，与业务相关\n\npublic interface target {\n\n    void request();\n}\n\n\n1\n2\n3\n4\n\n\n怎么才可以在目标接口中的 request() 调用 adaptee 的 adapteerequest() 方法呢？直接实现 target 肯定是不行的，所以我们通过一个适配器类，实现 target 接口，同时继承了 adaptee 类，然后在实现的 request() 方法中调用父类的 adapteerequest() 即可\n\npublic class adapter extends adaptee implements target{\n    @override\n    public void request() {\n        //...一些操作...\n        super.adapteerequest();\n        //...一些操作...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用适配器的客户端\n\npublic class client {\n    public static void main(string[] args) {\n\n        target adaptertarget = new adapter();\n        adaptertarget.request();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 适配器模式适合应用场景\n\n当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。\n\n适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。\n\n如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。\n\n你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。\n\n将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。\n\n\n# demo\n\n用一个生活中的充电器的例子来讲解下适配器，我国民用电都是 220v，而我们的手机充电一般需要 5v。\n\n220v 的交流电相当于被适配者 adaptee，我们的目标 target 是 5v 直流电，充电器本身相当于一个 adapter，将220v 的输入电压变换为 5v 输出。\n\n首先是我们的民用电（我国是 220v，当然还可以有其他国家的其他准备，可随时扩展）\n\npublic class volatage220v {\n\n    public final int output = 220;\n\n    public int output220v() {\n        system.out.println("输出电压 " + output);\n        return output;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n适配接口\n\npublic interface ivoltage5v {\n     int output5v();\n}\n\n\n1\n2\n3\n\n\n我们的手机充电，只支持 5v 电压\n\npublic class phone {\n\n    public void charging(ivoltage5v v) {\n        if (v.output5v() == 5) {\n            system.out.println("电压 5v ，符合充电标准，开始充电");\n        } else {\n            system.out.println("电压不符合标准，无法充电");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n适配器\n\npublic class voltageadapter implements ivoltage5v {\n\n    private volatage220v volatage220v;  //聚合\n\n    public voltageadapter(volatage220v v) {\n        this.volatage220v = v;\n    }\n\n    @override\n    public int output5v() {\n        int dst = 0;\n        if (null != volatage220v) {\n            int src = volatage220v.output220v();\n            system.out.println("适配器工作~~~~~");\n            dst = src / 44;\n            system.out.println("适配器工作完成，输出电压" + dst);\n        }\n        return dst;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n工作，如果去国外旅游，有不同的电压，只需要扩展适配器即可。\n\npublic class client {\n    public static void main(string[] args) {\n        phone phone = new phone();\n        phone.charging(new voltageadapter(new volatage220v()));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 适配器模式优缺点\n\n单一职责原则，你可以将接口或数据转换代码从程序主要业务逻辑中分离。\n\n开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。\n\n代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。\n\n\n# spring 中的适配器\n\nspring 源码中搜关键字adapter 会出现很多实现类，springmvc 中的 handleradapter ，就是适配器的应用。\n\n我们先回顾下 springmvc 处理流程：\n\nspring mvc 中的适配器模式主要用于执行目标 controller 中的请求处理方法。\n\n在spring mvc中，dispatcherservlet 作为用户，handleradapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，controller 作为需要适配的类。\n\n为什么要在 spring mvc 中使用适配器模式？spring mvc 中的 controller 种类众多，不同类型的 controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，dispatcherservlet 直接获取对应类型的 controller，需要的自行来判断，像下面这段代码一样：\n\nif(mappedhandler.gethandler() instanceof multiactioncontroller){  \n   ((multiactioncontroller)mappedhandler.gethandler()).xxx  \n}else if(mappedhandler.gethandler() instanceof xxx){  \n    ...  \n}else if(...){  \n   ...  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这样假设如果我们增加一个 controller，就要在代码中加入一行 if 语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。\n\n我们通过源码看看 springmvc 是如何实现的，首先看下核心类 dispatcherservlet：\n\npublic class dispatcherservlet extends frameworkservlet {\n  \t//......\n\t//维护所有handleradapter类的集合\n    @nullable\n    private list<handleradapter> handleradapters;\n  \n\t//初始化handleradapters\n    private void inithandleradapters(applicationcontext context) {\n        this.handleradapters = null;\n        if (this.detectallhandleradapters) {\n            map<string, handleradapter> matchingbeans = beanfactoryutils.beansoftypeincludingancestors(context, handleradapter.class, true, false);\n            if (!matchingbeans.isempty()) {\n                this.handleradapters = new arraylist(matchingbeans.values());\n                annotationawareordercomparator.sort(this.handleradapters);\n            }\n        } else {\n            try {\n                handleradapter ha = (handleradapter)context.getbean("handleradapter", handleradapter.class);\n                this.handleradapters = collections.singletonlist(ha);\n            } catch (nosuchbeandefinitionexception var3) {\n            }\n        }\n\n        if (this.handleradapters == null) {\n            this.handleradapters = this.getdefaultstrategies(context, handleradapter.class);\n            if (this.logger.istraceenabled()) {\n                this.logger.trace("no handleradapters declared for servlet \'" + this.getservletname() + "\': using default strategies from dispatcherservlet.properties");\n            }\n        }\n    }\n  \n  //dispatch 方法中会获取 handleradapter\n  protected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception {\n        //...\n    \n\t\t//获得controller对应的适配器\n        handleradapter ha = this.gethandleradapter(mappedhandler.gethandler());          \n\t\t\t\t\n\t\t//调用适配器的handler方法处理请求，并返回modelandview\n        mv = ha.handle(processedrequest, response, mappedhandler.gethandler());            \n        //...\n    }\n  \t\n\t  //返回对应的controller的处理器\n      protected handleradapter gethandleradapter(object handler) throws servletexception {\n        if (this.handleradapters != null) {\n            iterator var2 = this.handleradapters.iterator();\n\n            while(var2.hasnext()) {\n                handleradapter adapter = (handleradapter)var2.next();\n                if (adapter.supports(handler)) {\n                    return adapter;\n                }\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n接着看下 handleradapter 的源码，也就是适配器接口:\n\npublic interface handleradapter {\n    boolean supports(object var1);\n\n    @nullable\n    modelandview handle(httpservletrequest var1, httpservletresponse var2, object var3) throws exception;\n\n    long getlastmodified(httpservletrequest var1, object var2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n再来屡一下这个流程：\n\n首先是适配器接口 dispatchservlet 中有一个集合维护所有的 handleradapter，如果配置文件中没有对适配器进行配置，那么 dispatchservlet 会在创建时对该变量进行初始化，注册所有默认的 handleradapter。\n\n当一个请求过来时，dispatchservlet 会根据传过来的 handler 类型从该集合中寻找对应的 handleradapter子类进行处理，并且调用它的 handler() 方法 对应的 handleradapter 中的 handler() 方法又会执行对应 controller 的 handlerequest() 方法\n\n适配器与 handler 有对应关系，而各个适配器又都是适配器接口的实现类，因此，它们都遵循相同的适配器标准，所以用户可以按照相同的方式，通过不同的 handler 去处理请求。\n\n当然了，spring 框架中也为我们定义了一些默认的 handler 对应的适配器。\n\n通过适配器模式我们将所有的 controller 统一交给 handleradapter 处理，免去了写大量的 if-else 语句对 controller 进行判断，也更利于扩展新的 controller 类型。\n\n参考： 随遇而安的适配器模式 | spring 中的适配器',charsets:{cjk:!0},lastUpdated:"2022/09/20, 22:28:30",lastUpdatedTimestamp:166368411e4},{title:"代理模式",frontmatter:{title:"代理模式",date:"2022-05-21T17:28:27.000Z",permalink:"/pages/dd3a6f/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/020.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java相关/40.设计模式/020.代理模式.md",key:"v-0564ba27",path:"/pages/dd3a6f/",headers:[{level:2,title:"基本介绍",slug:"基本介绍",normalizedTitle:"基本介绍",charIndex:2},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:306},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:505},{level:2,title:"静态代理",slug:"静态代理",normalizedTitle:"静态代理",charIndex:137},{level:2,title:"静态代理类优缺点",slug:"静态代理类优缺点",normalizedTitle:"静态代理类优缺点",charIndex:2823},{level:3,title:"优点：",slug:"优点",normalizedTitle:"优点：",charIndex:2836},{level:3,title:"缺点：",slug:"缺点",normalizedTitle:"缺点：",charIndex:2956},{level:2,title:"动态代理",slug:"动态代理",normalizedTitle:"动态代理",charIndex:199},{level:3,title:"JDK 原生动态代理",slug:"jdk-原生动态代理",normalizedTitle:"jdk 原生动态代理",charIndex:3192},{level:3,title:"Coding",slug:"coding",normalizedTitle:"coding",charIndex:3382},{level:2,title:"cglib 代理",slug:"cglib-代理",normalizedTitle:"cglib 代理",charIndex:261},{level:3,title:"Coding",slug:"coding-2",normalizedTitle:"coding",charIndex:3382},{level:2,title:"代理模式适合应用场景",slug:"代理模式适合应用场景",normalizedTitle:"代理模式适合应用场景",charIndex:7232},{level:2,title:"AOP 中的代理模式",slug:"aop-中的代理模式",normalizedTitle:"aop 中的代理模式",charIndex:7961}],headersStr:"基本介绍 问题 解决方案 静态代理 静态代理类优缺点 优点： 缺点： 动态代理 JDK 原生动态代理 Coding cglib 代理 Coding 代理模式适合应用场景 AOP 中的代理模式",content:'# 基本介绍\n\n代理模式是一种结构型设计模式。为对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，并允许在将请求提交给对象前后进行一些处理。\n\n被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。\n\n代理模式主要有三种不同的形式：\n\n * 静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的 .class 文件就已经存在了\n * 动态代理（JDK 代理、接口代理）：在程序运行时运用反射机制动态创建而成，动态就是在程序运行时生成的，而不是编译时。\n * cglib 代理（可以在内存动态的创建对象，而不是实现接口，属于动态代理的范畴）\n\n\n# 问题\n\n为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。\n\n\n\n你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。\n\n在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。\n\n\n# 解决方案\n\n代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。\n\n\n\n代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。\n\n这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。\n\n#代理模式结构\n\n1.服务接口 （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。 2.服务 （Service） 类提供了一些实用的业务逻辑。 3.代理 （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。 4.客户端 （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。 打游戏有代练、买卖房子有中介代理、再比如一般公司投互联网广告也可以找代理公司，这里的代练、中介、广告代理公司扮演的角色都是代理。\n\n这里举个更接近程序员的例子，比如有些变态的公司不允许在公司刷微博，看视频，可以通过一层代理来限制我们访问这些网站。\n\n废话不多说，先来个静态代理。\n\n\n# 静态代理\n\n1、定义网络接口\n\npublic interface Internet {\n    void connectTo(String serverHost) throws Exception;\n}\n\n\n1\n2\n3\n\n\n2、真正的网络连接\n\npublic class RealInternet implements Internet{\n\n    @Override\n    public void connectTo(String serverHost) throws Exception {\n        System.out.println("Connecting to "+ serverHost);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n3、公司的网络代理\n\npublic class ProxyInternet implements Internet {\n\n    //目标对象，通过接口聚合\n    private Internet internet;\n\n    // 通过构造方法传入目标对象\n    public ProxyInternet(Internet internet){\n        this.internet = internet;\n    }\n    //网络黑名单\n    private static List<String> bannedSites;\n\n    static\n    {\n        bannedSites = new ArrayList<String>();\n        bannedSites.add("bilibili.com");\n        bannedSites.add("youtube.com");\n        bannedSites.add("weibo.com");\n        bannedSites.add("qq.com");\n    }\n\n    @Override\n    public void connectTo(String serverhost) throws Exception {\n        // 添加限制功能\n        if(bannedSites.contains(serverhost.toLowerCase()))\n        {\n            throw new Exception("Access Denied:"+serverhost);\n        }\n        internet.connectTo(serverhost);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n4、客户端验证\n\npublic class Client {\n\n    public static void main(String[] args) {\n        Internet internet = new ProxyInternet(new RealInternet());\n        try {\n            internet.connectTo("so.com");\n            internet.connectTo("qq.com");\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n5、输出\n\nConnecting to so.com\nAccess Denied:qq.com\n\n\n1\n2\n\n\n不能访问娱乐性网站，但是可以用 360 搜索，SO 靠谱，哈哈\n\n\n# 静态代理类优缺点\n\n\n# 优点：\n\n在不修改目标对象的前提下，可以通过代理对象对目标对象功能扩展\n\n代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合），对于如上的客户端代码，RealInterner() 可以应用工厂将它隐藏。\n\n\n# 缺点：\n\n代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n\n\n# 动态代理\n\n静态代理会产生很多静态类，所以我们要想办法可以通过一个代理类完成全部的代理功能，这就引出了动态代理。\n\n\n# JDK 原生动态代理\n\n * 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理\n * 代理对象的生成，是通过 JDK 的 API（反射机制），动态的在内存中构建代理对象 在 Java 中要想实现动态代理机制，需要 java.lang.reflect.InvocationHandler 接口和 java.lang.reflect.Proxy 类的支持\n\n\n# Coding\n\n1、网络接口不变\n\npublic interface Internet { void connectTo(String serverHost) throws Exception; } 2、真正的网络连接，也不会改变\n\npublic class RealInternet implements Internet{\n\n@Override\npublic void connectTo(String serverHost) throws Exception {\n    System.out.println("Connecting to "+ serverHost);\n}\n\n\n} 3、动态代理，需要实现 InvocationHandler，我们用 Lambda 表达式简化下\n\npublic class ProxyFactory {\n\n/**\n * 维护一个目标对象\n **/\nprivate Object target;\n\n/**\n * 构造器，初始化目标对象\n **/\npublic ProxyFactory(Object target) {\n    this.target = target;\n}\n\npublic Object getProxyInstance() {\n\n    /**\n     被代理对象target通过参数传递进来，\n     通过target.getClass().getClassLoader()获取ClassLoader对象，\n     然后通过target.getClass().getInterfaces()获取它实现的所有接口，\n     再将target包装到实现了InvocationHandler接口的对象中。\n     通过newProxyInstance函数我们就获得了一个动态代理对象。\n     */\n    return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if(bannedSites.contains(args[0].toString().toLowerCase()))\n            {\n                throw new Exception("Access Denied:"+args[0]);\n            }\n            //反射机制调用目标对象的方法\n            Object obj = method.invoke(target, args);\n            return obj;\n        }\n    });\n}\n\nprivate static List<String> bannedSites;\n\nstatic\n{\n    bannedSites = new ArrayList<String>();\n    bannedSites.add("bilibili.com");\n    bannedSites.add("youtube.com");\n    bannedSites.add("weibo.com");\n    bannedSites.add("qq.com");\n}\n\n\n} 4、客户端\n\npublic class Client {\n\npublic static void main(String[] args) {\n    Internet internet = new ProxyInternet(new RealInternet());\n    try {\n        internet.connectTo("360.cn");\n        internet.connectTo("qq.com");\n    } catch (Exception e) {\n        System.out.println(e.getMessage());\n    }\n}\n\n\n} 动态代理的方式中，所有的函数调用最终都会经过 invoke 函数的转发，因此我们就可以在这里做一些自己想做的操作，比如日志系统、事务、拦截器、权限控制等。\n\n\n# cglib 代理\n\n静态代理和 JDK 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。\n\ncglib (opens new window)(Code Generation Library)是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。cglib 通过继承方式实现代理。它广泛的被许多 AOP 的框架使用，比如我们的 Spring AOP。\n\ncglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。\n\ncglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。\n\n\n# Coding\n\n添加 cglib 依赖\n\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib</artifactId>\n    <version>3.3.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n1、不需要接口\n\npublic class RealInternet{\n\n    public void connectTo(String serverHost) {\n        System.out.println("Connecting to "+ serverHost);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、代理工厂类\n\npublic class ProxyFactory implements MethodInterceptor {\n\n    private Object target;\n\n    public ProxyFactory(Object target){\n        this.target = target;\n    }\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println("cglib 代理开始，可以添加逻辑");\n        Object obj = method.invoke(target,objects);\n        System.out.println("cglib 代理结束");\n        return obj;\n    }\n\n\n    public Object getProxyInstance(){\n        //工具类，类似于JDK动态代理的Proxy类\n        Enhancer enhancer = new Enhancer();\n        //设置父类\n        enhancer.setSuperclass(target.getClass());\n        //设置回调函数\n        enhancer.setCallback(this);\n        //创建子类对象，即代理对象\n        return enhancer.create();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n3、客户端\n\npublic class Client {\n\n    public static void main(String[] args) {\n\n        //目标对象\n        RealInternet target = new RealInternet();\n        //获取代理对象,并且将目标对象传递给代理对象\n        RealInternet internet = (RealInternet) new ProxyFactory(target).getProxyInstance();\n        internet.connectTo("so.cn");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n4、输出\n\ncglib 代理开始，可以添加逻辑\nConnecting to so.cn\ncglib 代理结束\n\n\n1\n2\n3\n\n\n\n# 代理模式适合应用场景\n\n使用代理模式的方式多种多样， 我们来看看最常见的几种。\n\n * 延迟初始化 （虚拟代理）：如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。\n\n你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。\n\n * 访问控制 （保护代理）：如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。\n\n代理可仅在客户端凭据满足要求时将请求传递给服务对象。\n\n * 本地执行远程服务 （远程代理）：适用于服务对象位于远程服务器上的情形。\n\n在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。\n\n * 记录日志请求 （日志记录代理）：适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。\n\n * 缓存请求结果 （缓存代理）：适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。\n\n代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。比如请求图片、文件等资源时，先到代理缓存取，如果没有就去公网取并缓存到代理服务器\n\n * 智能引用：可在没有客户端使用某个重量级对象时立即销毁该对象。\n\n代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。\n\n代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。\n\n\n# AOP 中的代理模式\n\nAOP（面向切面编程）主要的的实现技术主要有 Spring AOP 和 AspectJ\n\nAspectJ 的底层技术就是静态代理，用一种 AspectJ 支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。（AspectJ 的静态代理，不像我们前边介绍的需要为每一个目标类手动编写一个代理类，AspectJ 框架可以在编译时就生成目标类的“代理类”，在这里加了个冒号，是因为实际上它并没有生成一个新的类，而是把代理逻辑直接编译到目标类里面了）\n\nSpring AOP 采用的是动态代理，在运行期间对业务方法进行增强，所以不会生成新类，对于动态代理技术，Spring AOP 提供了对 JDK 动态代理的支持以及 CGLib 的支持。\n\n默认情况下，Spring 对实现了接口的类使用 JDK Proxy 方式，否则的话使用 CGLib。不过可以通过配置指定 Spring AOP 都通过 CGLib 来生成代理类。\n\n具体逻辑在 org.springframework.aop.framework.DefaultAopProxyFactory 类中，使用哪种方式生成由 AopProxy 根据 AdvisedSupport 对象的配置来决定源码如下：\n\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable {\n    public DefaultAopProxyFactory() {\n    }\n\n    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n        if (!config.isOptimize() && !config.isProxyTargetClass() && !this.hasNoUserSuppliedProxyInterfaces(config)) {\n            return new JdkDynamicAopProxy(config);\n        } else {\n            Class<?> targetClass = config.getTargetClass();\n            if (targetClass == null) {\n                throw new AopConfigException("TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.");\n            } else {\n                //如果目标类是接口且是代理类, 使用JDK动态代理类，否则使用Cglib生成代理类\n                return (AopProxy)(!targetClass.isInterface() && !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));\n            }\n        }\n    }\n\n    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n参考： 代理模式',normalizedContent:'# 基本介绍\n\n代理模式是一种结构型设计模式。为对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，并允许在将请求提交给对象前后进行一些处理。\n\n被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。\n\n代理模式主要有三种不同的形式：\n\n * 静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的 .class 文件就已经存在了\n * 动态代理（jdk 代理、接口代理）：在程序运行时运用反射机制动态创建而成，动态就是在程序运行时生成的，而不是编译时。\n * cglib 代理（可以在内存动态的创建对象，而不是实现接口，属于动态代理的范畴）\n\n\n# 问题\n\n为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。\n\n\n\n你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。\n\n在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。\n\n\n# 解决方案\n\n代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。\n\n\n\n代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。\n\n这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。\n\n#代理模式结构\n\n1.服务接口 （service interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。 2.服务 （service） 类提供了一些实用的业务逻辑。 3.代理 （proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。 4.客户端 （client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。 打游戏有代练、买卖房子有中介代理、再比如一般公司投互联网广告也可以找代理公司，这里的代练、中介、广告代理公司扮演的角色都是代理。\n\n这里举个更接近程序员的例子，比如有些变态的公司不允许在公司刷微博，看视频，可以通过一层代理来限制我们访问这些网站。\n\n废话不多说，先来个静态代理。\n\n\n# 静态代理\n\n1、定义网络接口\n\npublic interface internet {\n    void connectto(string serverhost) throws exception;\n}\n\n\n1\n2\n3\n\n\n2、真正的网络连接\n\npublic class realinternet implements internet{\n\n    @override\n    public void connectto(string serverhost) throws exception {\n        system.out.println("connecting to "+ serverhost);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n3、公司的网络代理\n\npublic class proxyinternet implements internet {\n\n    //目标对象，通过接口聚合\n    private internet internet;\n\n    // 通过构造方法传入目标对象\n    public proxyinternet(internet internet){\n        this.internet = internet;\n    }\n    //网络黑名单\n    private static list<string> bannedsites;\n\n    static\n    {\n        bannedsites = new arraylist<string>();\n        bannedsites.add("bilibili.com");\n        bannedsites.add("youtube.com");\n        bannedsites.add("weibo.com");\n        bannedsites.add("qq.com");\n    }\n\n    @override\n    public void connectto(string serverhost) throws exception {\n        // 添加限制功能\n        if(bannedsites.contains(serverhost.tolowercase()))\n        {\n            throw new exception("access denied:"+serverhost);\n        }\n        internet.connectto(serverhost);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n4、客户端验证\n\npublic class client {\n\n    public static void main(string[] args) {\n        internet internet = new proxyinternet(new realinternet());\n        try {\n            internet.connectto("so.com");\n            internet.connectto("qq.com");\n        } catch (exception e) {\n            system.out.println(e.getmessage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n5、输出\n\nconnecting to so.com\naccess denied:qq.com\n\n\n1\n2\n\n\n不能访问娱乐性网站，但是可以用 360 搜索，so 靠谱，哈哈\n\n\n# 静态代理类优缺点\n\n\n# 优点：\n\n在不修改目标对象的前提下，可以通过代理对象对目标对象功能扩展\n\n代理使客户端不需要知道实现类是什么，怎么做的，而客户端只需知道代理即可（解耦合），对于如上的客户端代码，realinterner() 可以应用工厂将它隐藏。\n\n\n# 缺点：\n\n代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n\n\n# 动态代理\n\n静态代理会产生很多静态类，所以我们要想办法可以通过一个代理类完成全部的代理功能，这就引出了动态代理。\n\n\n# jdk 原生动态代理\n\n * 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理\n * 代理对象的生成，是通过 jdk 的 api（反射机制），动态的在内存中构建代理对象 在 java 中要想实现动态代理机制，需要 java.lang.reflect.invocationhandler 接口和 java.lang.reflect.proxy 类的支持\n\n\n# coding\n\n1、网络接口不变\n\npublic interface internet { void connectto(string serverhost) throws exception; } 2、真正的网络连接，也不会改变\n\npublic class realinternet implements internet{\n\n@override\npublic void connectto(string serverhost) throws exception {\n    system.out.println("connecting to "+ serverhost);\n}\n\n\n} 3、动态代理，需要实现 invocationhandler，我们用 lambda 表达式简化下\n\npublic class proxyfactory {\n\n/**\n * 维护一个目标对象\n **/\nprivate object target;\n\n/**\n * 构造器，初始化目标对象\n **/\npublic proxyfactory(object target) {\n    this.target = target;\n}\n\npublic object getproxyinstance() {\n\n    /**\n     被代理对象target通过参数传递进来，\n     通过target.getclass().getclassloader()获取classloader对象，\n     然后通过target.getclass().getinterfaces()获取它实现的所有接口，\n     再将target包装到实现了invocationhandler接口的对象中。\n     通过newproxyinstance函数我们就获得了一个动态代理对象。\n     */\n    return proxy.newproxyinstance(target.getclass().getclassloader(), target.getclass().getinterfaces(), new invocationhandler() {\n        @override\n        public object invoke(object proxy, method method, object[] args) throws throwable {\n            if(bannedsites.contains(args[0].tostring().tolowercase()))\n            {\n                throw new exception("access denied:"+args[0]);\n            }\n            //反射机制调用目标对象的方法\n            object obj = method.invoke(target, args);\n            return obj;\n        }\n    });\n}\n\nprivate static list<string> bannedsites;\n\nstatic\n{\n    bannedsites = new arraylist<string>();\n    bannedsites.add("bilibili.com");\n    bannedsites.add("youtube.com");\n    bannedsites.add("weibo.com");\n    bannedsites.add("qq.com");\n}\n\n\n} 4、客户端\n\npublic class client {\n\npublic static void main(string[] args) {\n    internet internet = new proxyinternet(new realinternet());\n    try {\n        internet.connectto("360.cn");\n        internet.connectto("qq.com");\n    } catch (exception e) {\n        system.out.println(e.getmessage());\n    }\n}\n\n\n} 动态代理的方式中，所有的函数调用最终都会经过 invoke 函数的转发，因此我们就可以在这里做一些自己想做的操作，比如日志系统、事务、拦截器、权限控制等。\n\n\n# cglib 代理\n\n静态代理和 jdk 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。\n\ncglib (opens new window)(code generation library)是一个基于 asm 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。cglib 通过继承方式实现代理。它广泛的被许多 aop 的框架使用，比如我们的 spring aop。\n\ncglib 包的底层是通过使用字节码处理框架 asm 来转换字节码并生成新的类。\n\ncglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。\n\n\n# coding\n\n添加 cglib 依赖\n\n<dependency>\n    <groupid>cglib</groupid>\n    <artifactid>cglib</artifactid>\n    <version>3.3.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n1、不需要接口\n\npublic class realinternet{\n\n    public void connectto(string serverhost) {\n        system.out.println("connecting to "+ serverhost);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、代理工厂类\n\npublic class proxyfactory implements methodinterceptor {\n\n    private object target;\n\n    public proxyfactory(object target){\n        this.target = target;\n    }\n\n    @override\n    public object intercept(object o, method method, object[] objects, methodproxy methodproxy) throws throwable {\n        system.out.println("cglib 代理开始，可以添加逻辑");\n        object obj = method.invoke(target,objects);\n        system.out.println("cglib 代理结束");\n        return obj;\n    }\n\n\n    public object getproxyinstance(){\n        //工具类，类似于jdk动态代理的proxy类\n        enhancer enhancer = new enhancer();\n        //设置父类\n        enhancer.setsuperclass(target.getclass());\n        //设置回调函数\n        enhancer.setcallback(this);\n        //创建子类对象，即代理对象\n        return enhancer.create();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n3、客户端\n\npublic class client {\n\n    public static void main(string[] args) {\n\n        //目标对象\n        realinternet target = new realinternet();\n        //获取代理对象,并且将目标对象传递给代理对象\n        realinternet internet = (realinternet) new proxyfactory(target).getproxyinstance();\n        internet.connectto("so.cn");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n4、输出\n\ncglib 代理开始，可以添加逻辑\nconnecting to so.cn\ncglib 代理结束\n\n\n1\n2\n3\n\n\n\n# 代理模式适合应用场景\n\n使用代理模式的方式多种多样， 我们来看看最常见的几种。\n\n * 延迟初始化 （虚拟代理）：如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。\n\n你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。\n\n * 访问控制 （保护代理）：如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。\n\n代理可仅在客户端凭据满足要求时将请求传递给服务对象。\n\n * 本地执行远程服务 （远程代理）：适用于服务对象位于远程服务器上的情形。\n\n在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。\n\n * 记录日志请求 （日志记录代理）：适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。\n\n * 缓存请求结果 （缓存代理）：适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。\n\n代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。比如请求图片、文件等资源时，先到代理缓存取，如果没有就去公网取并缓存到代理服务器\n\n * 智能引用：可在没有客户端使用某个重量级对象时立即销毁该对象。\n\n代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。\n\n代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。\n\n\n# aop 中的代理模式\n\naop（面向切面编程）主要的的实现技术主要有 spring aop 和 aspectj\n\naspectj 的底层技术就是静态代理，用一种 aspectj 支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。（aspectj 的静态代理，不像我们前边介绍的需要为每一个目标类手动编写一个代理类，aspectj 框架可以在编译时就生成目标类的“代理类”，在这里加了个冒号，是因为实际上它并没有生成一个新的类，而是把代理逻辑直接编译到目标类里面了）\n\nspring aop 采用的是动态代理，在运行期间对业务方法进行增强，所以不会生成新类，对于动态代理技术，spring aop 提供了对 jdk 动态代理的支持以及 cglib 的支持。\n\n默认情况下，spring 对实现了接口的类使用 jdk proxy 方式，否则的话使用 cglib。不过可以通过配置指定 spring aop 都通过 cglib 来生成代理类。\n\n具体逻辑在 org.springframework.aop.framework.defaultaopproxyfactory 类中，使用哪种方式生成由 aopproxy 根据 advisedsupport 对象的配置来决定源码如下：\n\npublic class defaultaopproxyfactory implements aopproxyfactory, serializable {\n    public defaultaopproxyfactory() {\n    }\n\n    public aopproxy createaopproxy(advisedsupport config) throws aopconfigexception {\n        if (!config.isoptimize() && !config.isproxytargetclass() && !this.hasnousersuppliedproxyinterfaces(config)) {\n            return new jdkdynamicaopproxy(config);\n        } else {\n            class<?> targetclass = config.gettargetclass();\n            if (targetclass == null) {\n                throw new aopconfigexception("targetsource cannot determine target class: either an interface or a target is required for proxy creation.");\n            } else {\n                //如果目标类是接口且是代理类, 使用jdk动态代理类，否则使用cglib生成代理类\n                return (aopproxy)(!targetclass.isinterface() && !proxy.isproxyclass(targetclass) ? new objenesiscglibaopproxy(config) : new jdkdynamicaopproxy(config));\n            }\n        }\n    }\n\n    private boolean hasnousersuppliedproxyinterfaces(advisedsupport config) {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n参考： 代理模式',charsets:{cjk:!0},lastUpdated:"2022/09/20, 23:34:59",lastUpdatedTimestamp:1663688099e3},{title:"责任链模式",frontmatter:{title:"责任链模式",date:"2022-05-21T17:28:46.000Z",permalink:"/pages/d3ff35/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/030.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java相关/40.设计模式/030.责任链模式.md",key:"v-34f8aaa2",path:"/pages/d3ff35/",headers:[{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:1127},{level:2,title:"角色",slug:"角色",normalizedTitle:"角色",charIndex:1246},{level:2,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:1521},{level:2,title:"coding",slug:"coding",normalizedTitle:"coding",charIndex:1530},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:3309},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:784},{level:3,title:"Servlet 中的责任链",slug:"servlet-中的责任链",normalizedTitle:"servlet 中的责任链",charIndex:3615},{level:3,title:"Spring MVC 中的责任链",slug:"spring-mvc-中的责任链",normalizedTitle:"spring mvc 中的责任链",charIndex:5641},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:8299}],headersStr:"定义 角色 类图 coding 实例 应用 Servlet 中的责任链 Spring MVC 中的责任链 总结",content:'责任链，顾名思义，就是用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。\n\n这种模式给予请求的类型，对请求的发送者和接收者进行解耦。属于行为型模式。\n\n在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。\n\n\n\n先来看一段代码\n\npublic void test(int i, Request request){\n  if(i==1){\n    Handler1.response(request);\n  }else if(i == 2){\n    Handler2.response(request);\n  }else if(i == 3){\n    Handler3.response(request);\n  }else if(i == 4){\n    Handler4.response(request);\n  }else{\n    Handler5.response(request);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n代码的业务逻辑是这样的，方法有两个参数：整数 i 和一个请求 request，根据 i 的值来决定由谁来处理 request，如果 i==1，由 Handler1来处理，如果 i==2，由 Handler2 来处理，以此类推。在编程中，这种处理业务的方法非常常见，所有处理请求的类由 if…else… 条件判断语句连成一条责任链来对请求进行处理，相信大家都经常用到。这种方法的优点是非常直观，简单明了，并且比较容易维护，但是这种方法也存在着几个比较令人头疼的问题：\n\n代码臃肿：实际应用中的判定条件通常不是这么简单地判断是否为1或者是否为2，也许需要复杂的计算，也许需要查询数据库等等，这就会有很多额外的代码，如果判断条件再比较多，那么这个if…else…语句基本上就没法看了。\n\n耦合度高：如果我们想继续添加处理请求的类，那么就要继续添加if…else…判定条件；另外，这个条件判定的顺序也是写死的，如果想改变顺序，那么也只能修改这个条件语句。 既然缺点我们已经清楚了，就要想办法来解决。这个场景的业务逻辑很简单：如果满足条件1，则由 Handler1 来处理，不满足则向下传递；如果满足条件2，则由 Handler2 来处理，不满足则继续向下传递，以此类推，直到条件结束。其实改进的方法也很简单，就是把判定条件的部分放到处理类中，这就是责任连模式的原理。\n\n\n# 定义\n\n责任链模式(Chain of Responsibility Pattern)：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。\n\n\n# 角色\n\nHandler： 抽象处理类，抽象处理类中主要包含一个指向下一处理类的成员变量 nextHandler 和一个处理请求的方法 handRequest，handRequest 方法的主要主要思想是，如果满足处理的条件，则由本处理类来进行处理，否则由 nextHandler 来处理\n\nConcreteHandler： 具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家\n\nClient：客户端\n\n\n# 类图\n\n\n\n\n# coding\n\npublic abstract class Handler {\n    private Handler nextHandler;\n    private int level;\n\n    public Handler(int level) {\n        this.level = level;\n    }\n\n    public void setNextHandler(Handler handler){\n        this.nextHandler = handler;\n    }\n\n    public final void handlerRequest(Request request){\n        if(level == request.getLevel()){\n            this.response(request);\n        }else{\n            if (this.nextHandler != null){\n                this.nextHandler.handlerRequest(request);\n            }else{\n                System.out.println("===已经没有处理器了===");\n            }\n        }\n\n    }\n    // 抽象方法，子类实现\n    public abstract void response(Request request);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nclass Request {\n    int level = 0;\n    public Request(int level){\n        this.level = level;\n    }\n    public int getLevel() {\n        return level;\n    }\n}\npublic class ConcreteHandler1 extends Handler {\n    public ConcreteHandler1(int level) {\n        super(level);\n    }\n\n    @Override\n    public void response(Request request) {\n        System.out.println("请求由处理器1进行处理");\n    }\n}\n\npublic class ConcreteHandler2 extends Handler {\n\t//...\n}\n\npublic class ConcreteHandler2 extends Handler {\n\t//...\n}\npublic class Client {\n    public static void main(String[] args) {\n        ConcreteHandler1 handler1 = new ConcreteHandler1(1);\n        ConcreteHandler2 handler2 = new ConcreteHandler2(2);\n        ConcreteHandler3 handler3 = new ConcreteHandler3(3);\n\t\t//处理者构成一个环形\n        handler1.setNextHandler(handler2);\n        handler2.setNextHandler(handler3);\n\n        handler1.handlerRequest(new Request(1));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 实例\n\n当你想要让一个以上的对象有机会能够处理某个请求的时候，就是用责任链模式。\n\n通过责任链模式，你可以为某个请求创建一个对象链。每个对象依序检查此请求，并对其进行处理，或者将它传给链中的下一个对象。\n\n比如\n\n * 程序员要请 3 天以上的假期，在 OA 申请，需要直接主管、总监、HR 层层审批后才生效。类似的采购审批、报销审批。。。\n\n * 美团在外卖营销业务中资源位展示的逻辑\n\n\n# 应用\n\nJAVA 中的异常处理机制、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，JSP、Servlet 的 Filter 均是责任链的典型应用。\n\n\n# Servlet 中的责任链\n\npublic final class ApplicationFilterChain implements FilterChain {\n    private static final ThreadLocal<ServletRequest> lastServicedRequest;\n    private static final ThreadLocal<ServletResponse> lastServicedResponse;\n    public static final int INCREMENT = 10;\n    private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];\n    private int pos = 0;  //下一个要执行的filter的位置\n    private int n = 0;    //filter个数\n    private Servlet servlet = null;\n    public ApplicationFilterChain() {\n    }\n\n    public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {\n        if (Globals.IS_SECURITY_ENABLED) {\n            final ServletRequest req = request;\n            final ServletResponse res = response;\n\n            try {\n                AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n                    public Void run() throws ServletException, IOException {\n                        ApplicationFilterChain.this.internalDoFilter(req, res);\n                        return null;\n                    }\n                });\n            } catch (PrivilegedActionException var7) {\n                Exception e = var7.getException();\n                if (e instanceof ServletException) {\n                    throw (ServletException)e;\n                }\n\n                if (e instanceof IOException) {\n                    throw (IOException)e;\n                }\n\n                if (e instanceof RuntimeException) {\n                    throw (RuntimeException)e;\n                }\n\n                throw new ServletException(e.getMessage(), e);\n            }\n        } else {\n            this.internalDoFilter(request, response);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nFilterChain 就是一条过滤链。其中每个过滤器（Filter）都可以决定是否执行下一步。过滤分两个方向，进和出：\n\n进：在把 ServletRequest 和 ServletResponse 交给 Servlet 的 service 方法之前，需要进行过滤\n\n出：在service方法完成后，往客户端发送之前，需要进行过滤\n\n\n# Spring MVC 中的责任链\n\nSpring MVC 的 diapatcherServlet 的 doDispatch 方法中，获取与请求匹配的处理器 HandlerExecutionChain 就是用到了责任链模式。\n\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;    //使用到了责任链模式\n        boolean multipartRequestParsed = false;\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        try {\n            try {\n                ModelAndView mv = null;\n                Object dispatchException = null;\n\n                try {\n                    processedRequest = this.checkMultipart(request);\n                    multipartRequestParsed = processedRequest != request;\n                    mappedHandler = this.getHandler(processedRequest); \n                    if (mappedHandler == null) {\n                        this.noHandlerFound(processedRequest, response);\n                        return;\n                    }\n\n                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());\n                    String method = request.getMethod();\n                    boolean isGet = "GET".equals(method);\n                    if (isGet || "HEAD".equals(method)) {\n                        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                        if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {\n                            return;\n                        }\n                    }\n\t\t\t\t\t\t\t\t\t\t//责任链模式执行预处理方法，其实是将请求交给注册的拦截器执行\n                    if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                        return;\n                    }\n\n                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n                    if (asyncManager.isConcurrentHandlingStarted()) {\n                        return;\n                    }\n\n                    this.applyDefaultViewName(processedRequest, mv);\n                   //责任链执行后处理方法\n                    mappedHandler.applyPostHandle(processedRequest, response, mv);\n                } catch (Exception var22) {\n             //...\n        } finally {\n     }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n * SpringMVC 请求的流程中，执行了拦截器相关方法 interceptor.preHandler 等等\n\n * 在处理 SpringMVC 请求时，使用到职责链模式还使用到适配器模式\n\n * HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理，但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式，减少职责链本身与处理逻辑之间的耦合，规范了处理流程\n\n * HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应的拦截器\n\n\n# 总结\n\n责任链模式其实就是一个灵活版的 if…else…语句，它就是将这些判定条件的语句放到了各个处理类中，这样做的优点是比较灵活了，但同样也带来了风险，比如设置处理类前后关系时，一定要特别仔细，搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。\n\n优点：\n\n降低耦合度：将请求和处理分开，实现解耦，提高了系统的灵活性。\n\n简化了对象：对象不需要知道链的结构\n\n良好的扩展性：增加处理者的实现很简单，只需重写处理请求业务逻辑的方法。\n\n缺点：\n\n从链头发出，直到有处理者响应，在责任链比较长的时候会影响系统性能，一般需要在 Handler 中设置一个最大节点数。\n\n请求递归，调试排错比较麻烦。\n\n使用场景：\n\n有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。\n\n在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。\n\n可动态指定一组对象处理请求。\n\n模式的扩展：\n\n职责链模式存在以下两种情况。\n\n * 纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。\n\n * 不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。',normalizedContent:'责任链，顾名思义，就是用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。\n\n这种模式给予请求的类型，对请求的发送者和接收者进行解耦。属于行为型模式。\n\n在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。\n\n\n\n先来看一段代码\n\npublic void test(int i, request request){\n  if(i==1){\n    handler1.response(request);\n  }else if(i == 2){\n    handler2.response(request);\n  }else if(i == 3){\n    handler3.response(request);\n  }else if(i == 4){\n    handler4.response(request);\n  }else{\n    handler5.response(request);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n代码的业务逻辑是这样的，方法有两个参数：整数 i 和一个请求 request，根据 i 的值来决定由谁来处理 request，如果 i==1，由 handler1来处理，如果 i==2，由 handler2 来处理，以此类推。在编程中，这种处理业务的方法非常常见，所有处理请求的类由 if…else… 条件判断语句连成一条责任链来对请求进行处理，相信大家都经常用到。这种方法的优点是非常直观，简单明了，并且比较容易维护，但是这种方法也存在着几个比较令人头疼的问题：\n\n代码臃肿：实际应用中的判定条件通常不是这么简单地判断是否为1或者是否为2，也许需要复杂的计算，也许需要查询数据库等等，这就会有很多额外的代码，如果判断条件再比较多，那么这个if…else…语句基本上就没法看了。\n\n耦合度高：如果我们想继续添加处理请求的类，那么就要继续添加if…else…判定条件；另外，这个条件判定的顺序也是写死的，如果想改变顺序，那么也只能修改这个条件语句。 既然缺点我们已经清楚了，就要想办法来解决。这个场景的业务逻辑很简单：如果满足条件1，则由 handler1 来处理，不满足则向下传递；如果满足条件2，则由 handler2 来处理，不满足则继续向下传递，以此类推，直到条件结束。其实改进的方法也很简单，就是把判定条件的部分放到处理类中，这就是责任连模式的原理。\n\n\n# 定义\n\n责任链模式(chain of responsibility pattern)：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。\n\n\n# 角色\n\nhandler： 抽象处理类，抽象处理类中主要包含一个指向下一处理类的成员变量 nexthandler 和一个处理请求的方法 handrequest，handrequest 方法的主要主要思想是，如果满足处理的条件，则由本处理类来进行处理，否则由 nexthandler 来处理\n\nconcretehandler： 具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家\n\nclient：客户端\n\n\n# 类图\n\n\n\n\n# coding\n\npublic abstract class handler {\n    private handler nexthandler;\n    private int level;\n\n    public handler(int level) {\n        this.level = level;\n    }\n\n    public void setnexthandler(handler handler){\n        this.nexthandler = handler;\n    }\n\n    public final void handlerrequest(request request){\n        if(level == request.getlevel()){\n            this.response(request);\n        }else{\n            if (this.nexthandler != null){\n                this.nexthandler.handlerrequest(request);\n            }else{\n                system.out.println("===已经没有处理器了===");\n            }\n        }\n\n    }\n    // 抽象方法，子类实现\n    public abstract void response(request request);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nclass request {\n    int level = 0;\n    public request(int level){\n        this.level = level;\n    }\n    public int getlevel() {\n        return level;\n    }\n}\npublic class concretehandler1 extends handler {\n    public concretehandler1(int level) {\n        super(level);\n    }\n\n    @override\n    public void response(request request) {\n        system.out.println("请求由处理器1进行处理");\n    }\n}\n\npublic class concretehandler2 extends handler {\n\t//...\n}\n\npublic class concretehandler2 extends handler {\n\t//...\n}\npublic class client {\n    public static void main(string[] args) {\n        concretehandler1 handler1 = new concretehandler1(1);\n        concretehandler2 handler2 = new concretehandler2(2);\n        concretehandler3 handler3 = new concretehandler3(3);\n\t\t//处理者构成一个环形\n        handler1.setnexthandler(handler2);\n        handler2.setnexthandler(handler3);\n\n        handler1.handlerrequest(new request(1));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 实例\n\n当你想要让一个以上的对象有机会能够处理某个请求的时候，就是用责任链模式。\n\n通过责任链模式，你可以为某个请求创建一个对象链。每个对象依序检查此请求，并对其进行处理，或者将它传给链中的下一个对象。\n\n比如\n\n * 程序员要请 3 天以上的假期，在 oa 申请，需要直接主管、总监、hr 层层审批后才生效。类似的采购审批、报销审批。。。\n\n * 美团在外卖营销业务中资源位展示的逻辑\n\n\n# 应用\n\njava 中的异常处理机制、java web 中 apache tomcat 对 encoding 的处理，struts2 的拦截器，jsp、servlet 的 filter 均是责任链的典型应用。\n\n\n# servlet 中的责任链\n\npublic final class applicationfilterchain implements filterchain {\n    private static final threadlocal<servletrequest> lastservicedrequest;\n    private static final threadlocal<servletresponse> lastservicedresponse;\n    public static final int increment = 10;\n    private applicationfilterconfig[] filters = new applicationfilterconfig[0];\n    private int pos = 0;  //下一个要执行的filter的位置\n    private int n = 0;    //filter个数\n    private servlet servlet = null;\n    public applicationfilterchain() {\n    }\n\n    public void dofilter(servletrequest request, servletresponse response) throws ioexception, servletexception {\n        if (globals.is_security_enabled) {\n            final servletrequest req = request;\n            final servletresponse res = response;\n\n            try {\n                accesscontroller.doprivileged(new privilegedexceptionaction<void>() {\n                    public void run() throws servletexception, ioexception {\n                        applicationfilterchain.this.internaldofilter(req, res);\n                        return null;\n                    }\n                });\n            } catch (privilegedactionexception var7) {\n                exception e = var7.getexception();\n                if (e instanceof servletexception) {\n                    throw (servletexception)e;\n                }\n\n                if (e instanceof ioexception) {\n                    throw (ioexception)e;\n                }\n\n                if (e instanceof runtimeexception) {\n                    throw (runtimeexception)e;\n                }\n\n                throw new servletexception(e.getmessage(), e);\n            }\n        } else {\n            this.internaldofilter(request, response);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nfilterchain 就是一条过滤链。其中每个过滤器（filter）都可以决定是否执行下一步。过滤分两个方向，进和出：\n\n进：在把 servletrequest 和 servletresponse 交给 servlet 的 service 方法之前，需要进行过滤\n\n出：在service方法完成后，往客户端发送之前，需要进行过滤\n\n\n# spring mvc 中的责任链\n\nspring mvc 的 diapatcherservlet 的 dodispatch 方法中，获取与请求匹配的处理器 handlerexecutionchain 就是用到了责任链模式。\n\nprotected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception {\n        httpservletrequest processedrequest = request;\n        handlerexecutionchain mappedhandler = null;    //使用到了责任链模式\n        boolean multipartrequestparsed = false;\n        webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n\n        try {\n            try {\n                modelandview mv = null;\n                object dispatchexception = null;\n\n                try {\n                    processedrequest = this.checkmultipart(request);\n                    multipartrequestparsed = processedrequest != request;\n                    mappedhandler = this.gethandler(processedrequest); \n                    if (mappedhandler == null) {\n                        this.nohandlerfound(processedrequest, response);\n                        return;\n                    }\n\n                    handleradapter ha = this.gethandleradapter(mappedhandler.gethandler());\n                    string method = request.getmethod();\n                    boolean isget = "get".equals(method);\n                    if (isget || "head".equals(method)) {\n                        long lastmodified = ha.getlastmodified(request, mappedhandler.gethandler());\n                        if ((new servletwebrequest(request, response)).checknotmodified(lastmodified) && isget) {\n                            return;\n                        }\n                    }\n\t\t\t\t\t\t\t\t\t\t//责任链模式执行预处理方法，其实是将请求交给注册的拦截器执行\n                    if (!mappedhandler.applyprehandle(processedrequest, response)) {\n                        return;\n                    }\n\n                    mv = ha.handle(processedrequest, response, mappedhandler.gethandler());\n                    if (asyncmanager.isconcurrenthandlingstarted()) {\n                        return;\n                    }\n\n                    this.applydefaultviewname(processedrequest, mv);\n                   //责任链执行后处理方法\n                    mappedhandler.applyposthandle(processedrequest, response, mv);\n                } catch (exception var22) {\n             //...\n        } finally {\n     }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n * springmvc 请求的流程中，执行了拦截器相关方法 interceptor.prehandler 等等\n\n * 在处理 springmvc 请求时，使用到职责链模式还使用到适配器模式\n\n * handlerexecutionchain 主要负责的是请求拦截器的执行和请求处理，但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式，减少职责链本身与处理逻辑之间的耦合，规范了处理流程\n\n * handlerexecutionchain 维护了 handlerinterceptor 的集合， 可以向其中注册相应的拦截器\n\n\n# 总结\n\n责任链模式其实就是一个灵活版的 if…else…语句，它就是将这些判定条件的语句放到了各个处理类中，这样做的优点是比较灵活了，但同样也带来了风险，比如设置处理类前后关系时，一定要特别仔细，搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。\n\n优点：\n\n降低耦合度：将请求和处理分开，实现解耦，提高了系统的灵活性。\n\n简化了对象：对象不需要知道链的结构\n\n良好的扩展性：增加处理者的实现很简单，只需重写处理请求业务逻辑的方法。\n\n缺点：\n\n从链头发出，直到有处理者响应，在责任链比较长的时候会影响系统性能，一般需要在 handler 中设置一个最大节点数。\n\n请求递归，调试排错比较麻烦。\n\n使用场景：\n\n有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。\n\n在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。\n\n可动态指定一组对象处理请求。\n\n模式的扩展：\n\n职责链模式存在以下两种情况。\n\n * 纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。\n\n * 不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。',charsets:{cjk:!0},lastUpdated:"2022/09/20, 23:34:59",lastUpdatedTimestamp:1663688099e3},{title:"模板方法模式",frontmatter:{title:"模板方法模式",date:"2022-05-21T17:29:10.000Z",permalink:"/pages/43b656/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/040.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java相关/40.设计模式/040.模板方法模式.md",key:"v-28deb9da",path:"/pages/43b656/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"场景问题",slug:"场景问题",normalizedTitle:"场景问题",charIndex:94},{level:2,title:"认识模板方法",slug:"认识模板方法",normalizedTitle:"认识模板方法",charIndex:1853},{level:2,title:"JDK 中的模板方法",slug:"jdk-中的模板方法",normalizedTitle:"jdk 中的模板方法",charIndex:4308},{level:2,title:"Spring 中的模板方法",slug:"spring-中的模板方法",normalizedTitle:"spring 中的模板方法",charIndex:5336},{level:2,title:"小总结",slug:"小总结",normalizedTitle:"小总结",charIndex:7326},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:7434}],headersStr:"前言 场景问题 认识模板方法 JDK 中的模板方法 Spring 中的模板方法 小总结 使用场景",content:'# 前言\n\n模板，顾名思义，它是一个固定化、标准化的东西。\n\n模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n\n\n# 场景问题\n\n程序员不愿多扯，上来先干两行代码\n\n网上模板方法的场景示例特别多，个人感觉还是《Head First 设计模式》中的例子比较好。\n\n假设我们是一家饮品店的师傅，起码需要以下两个手艺\n\n真简单哈，这么看，步骤大同小异，我的第一反应就是写个业务接口，不同的饮品实现其中的方法就行，像这样\n\n画完类图，猛地发现，第一步和第三步没什么差别，而且做饮品是个流程式的工作，我希望使用时，直接调用一个方法，就去执行对应的制作步骤。\n\n灵机一动，不用接口了，用一个抽象父类，把步骤方法放在一个大的流程方法 makingDrinks() 中，且第一步和第三步，完全一样，没必要在子类实现，改进如下\n\n再看下我们的设计，感觉还不错，现在用同一个 makingDrinks() 方法来处理咖啡和茶的制作，而且我们不希望子类覆盖这个方法，所以可以申明为 final，不同的制作步骤，我们希望子类来提供，必须在父类申明为抽象方法，而第一步和第三步我们不希望子类重写，所以我们声明为非抽象方法\n\npublic abstract class Drinks {\n\n    void boilWater() {\n        System.out.println("将水煮沸");\n    }\n\n    abstract void brew();\n\n    void pourInCup() {\n        System.out.println("倒入杯子");\n    }\n\n    abstract void addCondiments();\n    \n    public final void makingDrinks() {\n        //热水\n        boilWater();\n        //冲泡\n        brew();\n        //倒进杯子\n        pourInCup();\n        //加料\n        addCondiments();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n接着，我们分别处理咖啡和茶，这两个类只需要继承父类，重写其中的抽象方法即可（实现各自的冲泡和添加调料）\n\npublic class Tea extends Drinks {\n    @Override\n    void brew() {\n        System.out.println("冲茶叶");\n    }\n    @Override\n    void addCondiments() {\n        System.out.println("加柠檬片");\n    }\n}\npublic class Coffee extends Drinks {\n    @Override\n    void brew() {\n        System.out.println("冲咖啡粉");\n    }\n\n    @Override\n    void addCondiments() {\n        System.out.println("加奶加糖");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n现在可以上岗了，试着制作下咖啡和茶吧\n\npublic static void main(String[] args) {\n    Drinks coffee = new Coffee();\n    coffee.makingDrinks();\n    System.out.println();\n    Drinks tea = new Tea();\n    tea.makingDrinks();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n好嘞，又学会一个设计模式，这就是模板方法模式，我们的 makingDrinks() 就是模板方法。我们可以看到相同的步骤 boilWater() 和 pourInCup() 只在父类中进行即可，不同的步骤放在子类实现。\n\n\n# 认识模板方法\n\n在阎宏博士的《JAVA与模式》一书中开头是这样描述模板方法（Template Method）模式的：\n\n> 模板方法模式是类的行为模式。 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现， 然后声明一些抽象方法来迫使子类实现剩余的逻辑。 不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。 这就是模板方法模式的用意。\n\n写代码的一个很重要的思考点就是“变与不变”，程序中哪些功能是可变的，哪些功能是不变的，我们可以把不变的部分抽象出来，进行公共的实现，把变化的部分分离出来，用接口来封装隔离，或用抽象类约束子类行为。模板方法就很好的体现了这一点。\n\n模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。\n\n模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术，我们再看下类图\n\n模板方法模式就是用来创建一个算法的模板，这个模板就是方法，该方法将算法定义成一组步骤，其中的任意步骤都可能是抽象的，由子类负责实现。这样可以确保算法的结构保持不变，同时由子类提供部分实现。\n\n再回顾下我们制作咖啡和茶的例子，有些顾客要不希望咖啡加糖或者不希望茶里加柠檬，我们要改造下模板方法，在加相应的调料之前，问下顾客\n\npublic abstract class Drinks {\n\n    void boilWater() {\n        System.out.println("将水煮沸");\n    }\n\n    abstract void brew();\n\n    void pourInCup() {\n        System.out.println("倒入杯子");\n    }\n\n    abstract void addCondiments();\n\n    public final void makingDrinks() {\n        boilWater();\n        brew();\n        pourInCup();\n\n        //如果顾客需要，才加料\n        if (customerLike()) {\n            addCondiments();\n        }\n    }\n\n    //定义一个空的缺省方法，只返回 true\n    boolean customerLike() {\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n如上，我们加了一个逻辑判断，逻辑判断的方法是一个只返回 true 的方法，这个方法我们叫做 钩子方法。\n\n> 钩子：在模板方法的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。\n\n钩子方法一般是空的或者有默认实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。而要不要挂钩，又由子类去决定。\n\n是不是很有用呢，我们再看下咖啡的制作\n\npublic class Coffee extends Drinks {\n    @Override\n    void brew() {\n        System.out.println("冲咖啡粉");\n    }\n\n    @Override\n    void addCondiments() {\n        System.out.println("加奶加糖");\n    }\n\t//覆盖了钩子，提供了自己的询问功能，让用户输入是否需要加料\n    boolean customerLike() {\n        String answer = getUserInput();\n        if (answer.toLowerCase().startsWith("y")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //处理用户的输入\n    private String getUserInput() {\n        String answer = null;\n        System.out.println("您想要加奶加糖吗？输入 YES 或 NO");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            answer = reader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (answer == null) {\n            return "no";\n        }\n        return answer;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n接着再去测试下代码，看看结果吧。\n\n我想你应该知道钩子的好处了吧，它可以作为条件控制，影响抽象类中的算法流程，当然也可以什么都不做。\n\n模板方法有很多种实现，有时看起来可能不是我们所谓的“中规中矩”的设计。接下来我们看下 JDK 和 Spring 中是怎么使用模板方法的。\n\n\n# JDK 中的模板方法\n\n我们写代码经常会用到 comparable 比较器来对数组对象进行排序，我们都会实现它的 compareTo() 方法，之后就可以通过 Collections.sort() 或者 Arrays.sort() 方法进行排序了。\n\n具体的实现类就不写了(可以去 github：starfish-learning 上看我的代码)，看下使用\n\n@Override\npublic int compareTo(Object o) {\n    Coffee coffee = (Coffee) o;\n    if(this.price < (coffee.price)){\n        return -1;\n    }else if(this.price == coffee.price){\n        return 0;\n    }else{\n        return 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npublic static void main(String[] args) {\n  Coffee[] coffees = {new Coffee("星冰乐",38),\n                      new Coffee("拿铁",32),\n                      new Coffee("摩卡",35)};\n \n  Arrays.sort(coffees);\n\n  for (Coffee coffee1 : coffees) {\n    System.out.println(coffee1);\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n你可能会说，这个看着不像我们常规的模板方法，是的。我们看下比较器实现的步骤\n\n 1. 构建对象数组\n 2. 通过 Arrays.sort 方法对数组排序，传参为 Comparable 接口的实例\n 3. 比较时候会调用我们的实现类的 compareTo() 方法\n 4. 将排好序的数组设置进原数组中，排序完成 一脸懵逼，这个实现竟然也是模板方法。\n\n这个模式的重点在于提供了一个固定算法框架，并让子类实现某些步骤，虽然使用继承是标准的实现方式，但通过回调来实现，也不能说这就不是模板方法。\n\n其实并发编程中最常见，也是面试必问的 AQS 就是一个典型的模板方法。\n\n\n# Spring 中的模板方法\n\nSpring 中的设计模式太多了，而且大部分扩展功能都可以看到模板方法模式的影子。\n\n我们看下 IOC 容器初始化时的模板方法，不管是 XML 还是注解的方式，对于核心容器启动流程都是一致的。\n\nAbstractApplicationContext 的 refresh 方法实现了 IOC 容器启动的主要逻辑。\n\n一个 refresh() 方法包含了好多其他步骤方法，像不像我们说的 模板方法，getBeanFactory() 、refreshBeanFactory() 是子类必须实现的抽象方法，postProcessBeanFactory() 是钩子方法。\n\npublic abstract class AbstractApplicationContext extends DefaultResourceLoader\n      implements ConfigurableApplicationContext {\n\t@Override\n\tpublic void refresh() throws BeansException, IllegalStateException {\n\t\tsynchronized (this.startupShutdownMonitor) {\n\t\t\tprepareRefresh();\n\t\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\t\t\tprepareBeanFactory(beanFactory);\n            postProcessBeanFactory(beanFactory);\n            invokeBeanFactoryPostProcessors(beanFactory);\n            registerBeanPostProcessors(beanFactory);\n            initMessageSource();\n            initApplicationEventMulticaster();\n            onRefresh();\n            registerListeners();\n            finishBeanFactoryInitialization(beanFactory);\n            finishRefresh();\n\t\t}\n\t}\n    // 两个抽象方法\n    @Override\n\tpublic abstract ConfigurableListableBeanFactory getBeanFactory() throws \t\tIllegalStateException;\t\n    \n    protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;\n    \n    //钩子方法\n    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t}\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n打开你的 IDEA，我们会发现常用的 ClassPathXmlApplicationContext 和 AnnotationConfigApplicationContext 启动入口，都是它的实现类（子类的子类的子类的...）。\n\nAbstractApplicationContext 的一个子类 AbstractRefreshableWebApplicationContext 中有钩子方法 onRefresh() 的实现：\n\npublic abstract class AbstractRefreshableWebApplicationContext extends …… {\n    /**\n\t * Initialize the theme capability.\n\t */\n\t@Override\n\tprotected void onRefresh() {\n\t\tthis.themeSource = UiApplicationContextUtils.initThemeSource(this);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n看下大概的类图：\n\n\n# 小总结\n\n * 优点：1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n * 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n\n# 使用场景\n\n 1. 有多个子类共有的方法，且逻辑相同。\n 2. 重要的、复杂的方法，可以考虑作为模板方法。\n\n注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。',normalizedContent:'# 前言\n\n模板，顾名思义，它是一个固定化、标准化的东西。\n\n模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n\n\n# 场景问题\n\n程序员不愿多扯，上来先干两行代码\n\n网上模板方法的场景示例特别多，个人感觉还是《head first 设计模式》中的例子比较好。\n\n假设我们是一家饮品店的师傅，起码需要以下两个手艺\n\n真简单哈，这么看，步骤大同小异，我的第一反应就是写个业务接口，不同的饮品实现其中的方法就行，像这样\n\n画完类图，猛地发现，第一步和第三步没什么差别，而且做饮品是个流程式的工作，我希望使用时，直接调用一个方法，就去执行对应的制作步骤。\n\n灵机一动，不用接口了，用一个抽象父类，把步骤方法放在一个大的流程方法 makingdrinks() 中，且第一步和第三步，完全一样，没必要在子类实现，改进如下\n\n再看下我们的设计，感觉还不错，现在用同一个 makingdrinks() 方法来处理咖啡和茶的制作，而且我们不希望子类覆盖这个方法，所以可以申明为 final，不同的制作步骤，我们希望子类来提供，必须在父类申明为抽象方法，而第一步和第三步我们不希望子类重写，所以我们声明为非抽象方法\n\npublic abstract class drinks {\n\n    void boilwater() {\n        system.out.println("将水煮沸");\n    }\n\n    abstract void brew();\n\n    void pourincup() {\n        system.out.println("倒入杯子");\n    }\n\n    abstract void addcondiments();\n    \n    public final void makingdrinks() {\n        //热水\n        boilwater();\n        //冲泡\n        brew();\n        //倒进杯子\n        pourincup();\n        //加料\n        addcondiments();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n接着，我们分别处理咖啡和茶，这两个类只需要继承父类，重写其中的抽象方法即可（实现各自的冲泡和添加调料）\n\npublic class tea extends drinks {\n    @override\n    void brew() {\n        system.out.println("冲茶叶");\n    }\n    @override\n    void addcondiments() {\n        system.out.println("加柠檬片");\n    }\n}\npublic class coffee extends drinks {\n    @override\n    void brew() {\n        system.out.println("冲咖啡粉");\n    }\n\n    @override\n    void addcondiments() {\n        system.out.println("加奶加糖");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n现在可以上岗了，试着制作下咖啡和茶吧\n\npublic static void main(string[] args) {\n    drinks coffee = new coffee();\n    coffee.makingdrinks();\n    system.out.println();\n    drinks tea = new tea();\n    tea.makingdrinks();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n好嘞，又学会一个设计模式，这就是模板方法模式，我们的 makingdrinks() 就是模板方法。我们可以看到相同的步骤 boilwater() 和 pourincup() 只在父类中进行即可，不同的步骤放在子类实现。\n\n\n# 认识模板方法\n\n在阎宏博士的《java与模式》一书中开头是这样描述模板方法（template method）模式的：\n\n> 模板方法模式是类的行为模式。 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现， 然后声明一些抽象方法来迫使子类实现剩余的逻辑。 不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。 这就是模板方法模式的用意。\n\n写代码的一个很重要的思考点就是“变与不变”，程序中哪些功能是可变的，哪些功能是不变的，我们可以把不变的部分抽象出来，进行公共的实现，把变化的部分分离出来，用接口来封装隔离，或用抽象类约束子类行为。模板方法就很好的体现了这一点。\n\n模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。\n\n模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术，我们再看下类图\n\n模板方法模式就是用来创建一个算法的模板，这个模板就是方法，该方法将算法定义成一组步骤，其中的任意步骤都可能是抽象的，由子类负责实现。这样可以确保算法的结构保持不变，同时由子类提供部分实现。\n\n再回顾下我们制作咖啡和茶的例子，有些顾客要不希望咖啡加糖或者不希望茶里加柠檬，我们要改造下模板方法，在加相应的调料之前，问下顾客\n\npublic abstract class drinks {\n\n    void boilwater() {\n        system.out.println("将水煮沸");\n    }\n\n    abstract void brew();\n\n    void pourincup() {\n        system.out.println("倒入杯子");\n    }\n\n    abstract void addcondiments();\n\n    public final void makingdrinks() {\n        boilwater();\n        brew();\n        pourincup();\n\n        //如果顾客需要，才加料\n        if (customerlike()) {\n            addcondiments();\n        }\n    }\n\n    //定义一个空的缺省方法，只返回 true\n    boolean customerlike() {\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n如上，我们加了一个逻辑判断，逻辑判断的方法是一个只返回 true 的方法，这个方法我们叫做 钩子方法。\n\n> 钩子：在模板方法的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。\n\n钩子方法一般是空的或者有默认实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。而要不要挂钩，又由子类去决定。\n\n是不是很有用呢，我们再看下咖啡的制作\n\npublic class coffee extends drinks {\n    @override\n    void brew() {\n        system.out.println("冲咖啡粉");\n    }\n\n    @override\n    void addcondiments() {\n        system.out.println("加奶加糖");\n    }\n\t//覆盖了钩子，提供了自己的询问功能，让用户输入是否需要加料\n    boolean customerlike() {\n        string answer = getuserinput();\n        if (answer.tolowercase().startswith("y")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //处理用户的输入\n    private string getuserinput() {\n        string answer = null;\n        system.out.println("您想要加奶加糖吗？输入 yes 或 no");\n        bufferedreader reader = new bufferedreader(new inputstreamreader(system.in));\n        try {\n            answer = reader.readline();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        if (answer == null) {\n            return "no";\n        }\n        return answer;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n接着再去测试下代码，看看结果吧。\n\n我想你应该知道钩子的好处了吧，它可以作为条件控制，影响抽象类中的算法流程，当然也可以什么都不做。\n\n模板方法有很多种实现，有时看起来可能不是我们所谓的“中规中矩”的设计。接下来我们看下 jdk 和 spring 中是怎么使用模板方法的。\n\n\n# jdk 中的模板方法\n\n我们写代码经常会用到 comparable 比较器来对数组对象进行排序，我们都会实现它的 compareto() 方法，之后就可以通过 collections.sort() 或者 arrays.sort() 方法进行排序了。\n\n具体的实现类就不写了(可以去 github：starfish-learning 上看我的代码)，看下使用\n\n@override\npublic int compareto(object o) {\n    coffee coffee = (coffee) o;\n    if(this.price < (coffee.price)){\n        return -1;\n    }else if(this.price == coffee.price){\n        return 0;\n    }else{\n        return 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npublic static void main(string[] args) {\n  coffee[] coffees = {new coffee("星冰乐",38),\n                      new coffee("拿铁",32),\n                      new coffee("摩卡",35)};\n \n  arrays.sort(coffees);\n\n  for (coffee coffee1 : coffees) {\n    system.out.println(coffee1);\n  }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n你可能会说，这个看着不像我们常规的模板方法，是的。我们看下比较器实现的步骤\n\n 1. 构建对象数组\n 2. 通过 arrays.sort 方法对数组排序，传参为 comparable 接口的实例\n 3. 比较时候会调用我们的实现类的 compareto() 方法\n 4. 将排好序的数组设置进原数组中，排序完成 一脸懵逼，这个实现竟然也是模板方法。\n\n这个模式的重点在于提供了一个固定算法框架，并让子类实现某些步骤，虽然使用继承是标准的实现方式，但通过回调来实现，也不能说这就不是模板方法。\n\n其实并发编程中最常见，也是面试必问的 aqs 就是一个典型的模板方法。\n\n\n# spring 中的模板方法\n\nspring 中的设计模式太多了，而且大部分扩展功能都可以看到模板方法模式的影子。\n\n我们看下 ioc 容器初始化时的模板方法，不管是 xml 还是注解的方式，对于核心容器启动流程都是一致的。\n\nabstractapplicationcontext 的 refresh 方法实现了 ioc 容器启动的主要逻辑。\n\n一个 refresh() 方法包含了好多其他步骤方法，像不像我们说的 模板方法，getbeanfactory() 、refreshbeanfactory() 是子类必须实现的抽象方法，postprocessbeanfactory() 是钩子方法。\n\npublic abstract class abstractapplicationcontext extends defaultresourceloader\n      implements configurableapplicationcontext {\n\t@override\n\tpublic void refresh() throws beansexception, illegalstateexception {\n\t\tsynchronized (this.startupshutdownmonitor) {\n\t\t\tpreparerefresh();\n\t\t\tconfigurablelistablebeanfactory beanfactory = obtainfreshbeanfactory();\n\t\t\tpreparebeanfactory(beanfactory);\n            postprocessbeanfactory(beanfactory);\n            invokebeanfactorypostprocessors(beanfactory);\n            registerbeanpostprocessors(beanfactory);\n            initmessagesource();\n            initapplicationeventmulticaster();\n            onrefresh();\n            registerlisteners();\n            finishbeanfactoryinitialization(beanfactory);\n            finishrefresh();\n\t\t}\n\t}\n    // 两个抽象方法\n    @override\n\tpublic abstract configurablelistablebeanfactory getbeanfactory() throws \t\tillegalstateexception;\t\n    \n    protected abstract void refreshbeanfactory() throws beansexception, illegalstateexception;\n    \n    //钩子方法\n    protected void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) {\n\t}\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n打开你的 idea，我们会发现常用的 classpathxmlapplicationcontext 和 annotationconfigapplicationcontext 启动入口，都是它的实现类（子类的子类的子类的...）。\n\nabstractapplicationcontext 的一个子类 abstractrefreshablewebapplicationcontext 中有钩子方法 onrefresh() 的实现：\n\npublic abstract class abstractrefreshablewebapplicationcontext extends …… {\n    /**\n\t * initialize the theme capability.\n\t */\n\t@override\n\tprotected void onrefresh() {\n\t\tthis.themesource = uiapplicationcontextutils.initthemesource(this);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n看下大概的类图：\n\n\n# 小总结\n\n * 优点：1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n\n * 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n\n\n# 使用场景\n\n 1. 有多个子类共有的方法，且逻辑相同。\n 2. 重要的、复杂的方法，可以考虑作为模板方法。\n\n注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。',charsets:{cjk:!0},lastUpdated:"2022/09/20, 23:34:59",lastUpdatedTimestamp:1663688099e3},{title:"策略模式",frontmatter:{title:"策略模式",date:"2022-05-21T17:29:26.000Z",permalink:"/pages/78c7aa/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/050.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java相关/40.设计模式/050.策略模式.md",key:"v-5b0157cf",path:"/pages/78c7aa/",headers:[{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:2},{level:2,title:"角色",slug:"角色",normalizedTitle:"角色",charIndex:1075},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:1229},{level:2,title:"解析策略模式",slug:"解析策略模式",normalizedTitle:"解析策略模式",charIndex:2310},{level:2,title:"谁来选择具体的策略算法",slug:"谁来选择具体的策略算法",normalizedTitle:"谁来选择具体的策略算法",charIndex:2795},{level:2,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:2992},{level:3,title:"优点：",slug:"优点",normalizedTitle:"优点：",charIndex:3e3},{level:3,title:"缺点：",slug:"缺点",normalizedTitle:"缺点：",charIndex:3092},{level:2,title:"思考",slug:"思考",normalizedTitle:"思考",charIndex:3233},{level:2,title:"策略模式在 JDK 中的应用",slug:"策略模式在-jdk-中的应用",normalizedTitle:"策略模式在 jdk 中的应用",charIndex:3512}],headersStr:"定义 角色 实例 解析策略模式 谁来选择具体的策略算法 优缺点 优点： 缺点： 思考 策略模式在 JDK 中的应用",content:'# 定义\n\n策略模式（Strategy Design Pattern）：封装可以互换的行为，并使用委托来决定要使用哪一个。\n\n策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n\n> 用人话翻译后就是：运行时我给你这个类的方法传不同的 “key”，你这个方法就去执行不同的业务逻辑。 你品，你细品，这不就是 if else 干的事吗？\n\n先直观的看下传统的多重 if else 代码\n\npublic String getCheckResult(String type) {\n  if ("校验1".equals(type)) {\n    return "执行业务逻辑1";\n  } else if ("校验2".equals(type)) {\n    return "执行业务逻辑2";\n  } else if ("校验3".equals(type)) {\n    return "执行业务逻辑3";\n  } else if ("校验4".equals(type)) {\n    return "执行业务逻辑4";\n  } else if ("校验5".equals(type)) {\n    return "执行业务逻辑5";\n  } else if ("校验6".equals(type)) {\n    return "执行业务逻辑6";\n  } else if ("校验7".equals(type)) {\n    return "执行业务逻辑7";\n  } else if ("校验8".equals(type)) {\n    return "执行业务逻辑8";\n  } else if ("校验9".equals(type)) {\n    return "执行业务逻辑9";\n  }\n  return "不在处理的逻辑中返回业务错误";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n这么看，你要是还觉得挺清晰的话，想象下这些 return 里是各种复杂的业务逻辑方法~~\n\n当然，策略模式的作用可不止是避免冗长的 if-else 或者 switch 分支，它还可以像模板方法模式那样提供框架的扩展点等。\n\n网上的示例很多，比如不同路线的规划、不同支付方式的选择 都是典型的 if-else 问题，也都是典型的策略模式问题，栗子我们待会看，先看下策略模式的类图，然后去改造多重判断~\n\n\n# 角色\n\n策略模式涉及到三个角色：\n\n 1. Strategy：策略接口或者策略抽象类，用来约束一系列的策略算法（Context 使用这个接口来调用具体的策略实现算法）\n 2. ConcreateStrategy：具体的策略类（实现策略接口或继承抽象策略类）\n 3. Context：上下文类，持有具体策略类的实例，并负责调用相关的算法 应用策略模式来解决问题的思路\n\n\n# 实例\n\n先看看最简单的策略模式 demo:\n\n1、策略接口（定义策略）\n\npublic interface Strategy {\n    void operate();\n}\n\n\n1\n2\n3\n\n\n2、具体的算法实现\n\npublic class ConcreteStrategyA implements Strategy {\n    @Override\n    public void operate() {\n        //具体的算法实现\n        System.out.println("执行业务逻辑A");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npublic class ConcreteStrategyB implements Strategy {\n    @Override\n    public void operate() {\n        //具体的算法实现\n        System.out.println("执行业务逻辑B");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n3、上下文的实现\n\npublic class Context {\n\n    //持有一个具体的策略对象\n    private Strategy strategy;\n\n    //构造方法，传入具体的策略对象\n    public Context(Strategy strategy){\n        this.strategy = strategy;\n    }\n\n    public void doSomething(){\n        //调用具体的策略对象进操作\n        strategy.operate();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n4、客户端使用（策略的使用）\n\npublic static void main(String[] args) {\n  Context context = new Context(new ConcreteStrategyA());\n  context.doSomething();\n}\n\n\n1\n2\n3\n4\n\n\n> ps：这种策略的使用方式其实很死板，真正使用的时候如果还这么写， 和写一大推 if-else 没什么区别，所以我们一般会结合工厂类， 在运行时动态确定使用哪种策略。策略模式侧重如何选择策略、工厂模式侧重如何创建策略。\n\n\n# 解析策略模式\n\n策略模式的功能就是把具体的算法实现从具体的业务处理中独立出来，把它们实现成单独的算法类，从而形成一系列算法，并让这些算法可以互相替换。\n\n> 策略模式的重心不是如何来实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。\n\n实际上，每个策略算法具体实现的功能，就是原来在 if-else 结构中的具体实现，每个 if-else 语句都是一个平等的功能结构，可以说是兄弟关系。\n\n策略模式呢，就是把各个平等的具体实现封装到单独的策略实现类了，然后通过上下文与具体的策略类进行交互。\n\n『 策略模式 = 实现策略接口（或抽象类）的每个策略类 + 上下文的逻辑分派 』\n\n> 策略模式的本质：分离算法，选择实现 ——《研磨设计模式》\n\n所以说，策略模式只是在代码结构上的一个调整，即使用了策略模式，该写的逻辑一个也少不了，到逻辑分派的时候，只是变相的 if-else。\n\n而它的优化点是抽象了出了接口，将业务逻辑封装成一个一个的实现类，任意地替换。在复杂场景（业务逻辑较多）时比直接 if-else 更好维护和扩展些。\n\n\n# 谁来选择具体的策略算法\n\n如果你手写了上边的 demo，就会发现，这玩意不及 if-else 来的顺手，尤其是在判断逻辑的时候，每个逻辑都要要构造一个上下文对象，费劲。\n\n其实，策略模式中，我们可以自己定义谁来选择具体的策略算法，有两种：\n\n * 客户端：当使用上下文时，由客户端选择，像我们上边的 demo\n * 上下文：客户端不用选，由上下文来选具体的策略算法，可以在构造器中指定\n\n\n# 优缺点\n\n\n# 优点：\n\n避免多重条件语句：也就是避免大量的 if-else 更好的扩展性（完全符合开闭原则）：策略模式中扩展新的策略实现很容易，无需对上下文修改，只增加新的策略实现类就可以\n\n\n# 缺点：\n\n客户必须了解每种策略的不同（这个可以通过 IOC、依赖注入的方式解决） 增加了对象数：每个具体策略都封装成了类，可能备选的策略会很多 只适合扁平的算法结构：策略模式的一系列算法是平等的，也就是在运行时刻只有一个算法会被使用，这就限制了算法使用的层级，不能嵌套使用\n\n\n# 思考\n\n实际使用中，往往不会只是单一的某个设计模式的套用，一般都会混合使用，而且模式之间的结合也是没有定势的，要具体问题具体分析。\n\n策略模式往往会结合其他模式一起使用，比如工厂、模板等，具体使用需要结合自己的业务。\n\n切记，不要为了使用设计模式而强行模式，不要把简单问题复杂化。\n\n策略模式也不是专为消除 if-else 而生的，不要和 if-else 划等号。它体现了“对修改关闭，对扩展开放“的原则。\n\n并不是说，看到 if-else 就想着用策略模式去优化，业务逻辑简单，可能几个枚举，或者几个卫语句就搞定的场景，就不用非得硬套设计模式了。\n\n\n# 策略模式在 JDK 中的应用\n\n在 JDK 中，Comparator 比较器是一个策略接口，我们常用的 compare() 方法就是一个具体的策略实现，用于定义排序规则。\n\npublic interface Comparator<T> {\n   int compare(T o1, T o2);\n   //......\n}\n\n\n1\n2\n3\n4\n\n\n当我们想自定义排序规则的时候，就可以实现 Comparator 。\n\n这时候我们重写了接口中的 compare() 方法，就是具体的策略类（只不过这里可能是内部类）。当我们在调用 Arrays 的排序方法 sort() 时，可以用默认的排序规则，也可以用自定义的规则。\n\npublic static void main(String[] args) {\n  Integer[] data = {4,2,7,5,1,9};\n  Comparator<Integer> comparator = new Comparator<Integer>() {\n    @Override\n    public int compare(Integer o1, Integer o2) {\n      if(o1 > o2){\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  };\n\n  Arrays.sort(data,comparator);\n  System.out.println(Arrays.toString(data));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nArrays 的 sort() 方法，有自定义规则就按自己的方法排序，反之走源码逻辑。\n\npublic static <T> void sort(T[] a, Comparator<? super T> c) {\n    if (c == null) {\n        sort(a);\n    } else {\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a, c);\n        else\n            TimSort.sort(a, 0, a.length, c, null, 0, 0);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n还有，ThreadPoolExecutor 中的拒绝策略 RejectedExecutionHandler 也是典型的策略模式，感兴趣的也可以再看看源码。',normalizedContent:'# 定义\n\n策略模式（strategy design pattern）：封装可以互换的行为，并使用委托来决定要使用哪一个。\n\n策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n\n> 用人话翻译后就是：运行时我给你这个类的方法传不同的 “key”，你这个方法就去执行不同的业务逻辑。 你品，你细品，这不就是 if else 干的事吗？\n\n先直观的看下传统的多重 if else 代码\n\npublic string getcheckresult(string type) {\n  if ("校验1".equals(type)) {\n    return "执行业务逻辑1";\n  } else if ("校验2".equals(type)) {\n    return "执行业务逻辑2";\n  } else if ("校验3".equals(type)) {\n    return "执行业务逻辑3";\n  } else if ("校验4".equals(type)) {\n    return "执行业务逻辑4";\n  } else if ("校验5".equals(type)) {\n    return "执行业务逻辑5";\n  } else if ("校验6".equals(type)) {\n    return "执行业务逻辑6";\n  } else if ("校验7".equals(type)) {\n    return "执行业务逻辑7";\n  } else if ("校验8".equals(type)) {\n    return "执行业务逻辑8";\n  } else if ("校验9".equals(type)) {\n    return "执行业务逻辑9";\n  }\n  return "不在处理的逻辑中返回业务错误";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n这么看，你要是还觉得挺清晰的话，想象下这些 return 里是各种复杂的业务逻辑方法~~\n\n当然，策略模式的作用可不止是避免冗长的 if-else 或者 switch 分支，它还可以像模板方法模式那样提供框架的扩展点等。\n\n网上的示例很多，比如不同路线的规划、不同支付方式的选择 都是典型的 if-else 问题，也都是典型的策略模式问题，栗子我们待会看，先看下策略模式的类图，然后去改造多重判断~\n\n\n# 角色\n\n策略模式涉及到三个角色：\n\n 1. strategy：策略接口或者策略抽象类，用来约束一系列的策略算法（context 使用这个接口来调用具体的策略实现算法）\n 2. concreatestrategy：具体的策略类（实现策略接口或继承抽象策略类）\n 3. context：上下文类，持有具体策略类的实例，并负责调用相关的算法 应用策略模式来解决问题的思路\n\n\n# 实例\n\n先看看最简单的策略模式 demo:\n\n1、策略接口（定义策略）\n\npublic interface strategy {\n    void operate();\n}\n\n\n1\n2\n3\n\n\n2、具体的算法实现\n\npublic class concretestrategya implements strategy {\n    @override\n    public void operate() {\n        //具体的算法实现\n        system.out.println("执行业务逻辑a");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npublic class concretestrategyb implements strategy {\n    @override\n    public void operate() {\n        //具体的算法实现\n        system.out.println("执行业务逻辑b");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n3、上下文的实现\n\npublic class context {\n\n    //持有一个具体的策略对象\n    private strategy strategy;\n\n    //构造方法，传入具体的策略对象\n    public context(strategy strategy){\n        this.strategy = strategy;\n    }\n\n    public void dosomething(){\n        //调用具体的策略对象进操作\n        strategy.operate();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n4、客户端使用（策略的使用）\n\npublic static void main(string[] args) {\n  context context = new context(new concretestrategya());\n  context.dosomething();\n}\n\n\n1\n2\n3\n4\n\n\n> ps：这种策略的使用方式其实很死板，真正使用的时候如果还这么写， 和写一大推 if-else 没什么区别，所以我们一般会结合工厂类， 在运行时动态确定使用哪种策略。策略模式侧重如何选择策略、工厂模式侧重如何创建策略。\n\n\n# 解析策略模式\n\n策略模式的功能就是把具体的算法实现从具体的业务处理中独立出来，把它们实现成单独的算法类，从而形成一系列算法，并让这些算法可以互相替换。\n\n> 策略模式的重心不是如何来实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。\n\n实际上，每个策略算法具体实现的功能，就是原来在 if-else 结构中的具体实现，每个 if-else 语句都是一个平等的功能结构，可以说是兄弟关系。\n\n策略模式呢，就是把各个平等的具体实现封装到单独的策略实现类了，然后通过上下文与具体的策略类进行交互。\n\n『 策略模式 = 实现策略接口（或抽象类）的每个策略类 + 上下文的逻辑分派 』\n\n> 策略模式的本质：分离算法，选择实现 ——《研磨设计模式》\n\n所以说，策略模式只是在代码结构上的一个调整，即使用了策略模式，该写的逻辑一个也少不了，到逻辑分派的时候，只是变相的 if-else。\n\n而它的优化点是抽象了出了接口，将业务逻辑封装成一个一个的实现类，任意地替换。在复杂场景（业务逻辑较多）时比直接 if-else 更好维护和扩展些。\n\n\n# 谁来选择具体的策略算法\n\n如果你手写了上边的 demo，就会发现，这玩意不及 if-else 来的顺手，尤其是在判断逻辑的时候，每个逻辑都要要构造一个上下文对象，费劲。\n\n其实，策略模式中，我们可以自己定义谁来选择具体的策略算法，有两种：\n\n * 客户端：当使用上下文时，由客户端选择，像我们上边的 demo\n * 上下文：客户端不用选，由上下文来选具体的策略算法，可以在构造器中指定\n\n\n# 优缺点\n\n\n# 优点：\n\n避免多重条件语句：也就是避免大量的 if-else 更好的扩展性（完全符合开闭原则）：策略模式中扩展新的策略实现很容易，无需对上下文修改，只增加新的策略实现类就可以\n\n\n# 缺点：\n\n客户必须了解每种策略的不同（这个可以通过 ioc、依赖注入的方式解决） 增加了对象数：每个具体策略都封装成了类，可能备选的策略会很多 只适合扁平的算法结构：策略模式的一系列算法是平等的，也就是在运行时刻只有一个算法会被使用，这就限制了算法使用的层级，不能嵌套使用\n\n\n# 思考\n\n实际使用中，往往不会只是单一的某个设计模式的套用，一般都会混合使用，而且模式之间的结合也是没有定势的，要具体问题具体分析。\n\n策略模式往往会结合其他模式一起使用，比如工厂、模板等，具体使用需要结合自己的业务。\n\n切记，不要为了使用设计模式而强行模式，不要把简单问题复杂化。\n\n策略模式也不是专为消除 if-else 而生的，不要和 if-else 划等号。它体现了“对修改关闭，对扩展开放“的原则。\n\n并不是说，看到 if-else 就想着用策略模式去优化，业务逻辑简单，可能几个枚举，或者几个卫语句就搞定的场景，就不用非得硬套设计模式了。\n\n\n# 策略模式在 jdk 中的应用\n\n在 jdk 中，comparator 比较器是一个策略接口，我们常用的 compare() 方法就是一个具体的策略实现，用于定义排序规则。\n\npublic interface comparator<t> {\n   int compare(t o1, t o2);\n   //......\n}\n\n\n1\n2\n3\n4\n\n\n当我们想自定义排序规则的时候，就可以实现 comparator 。\n\n这时候我们重写了接口中的 compare() 方法，就是具体的策略类（只不过这里可能是内部类）。当我们在调用 arrays 的排序方法 sort() 时，可以用默认的排序规则，也可以用自定义的规则。\n\npublic static void main(string[] args) {\n  integer[] data = {4,2,7,5,1,9};\n  comparator<integer> comparator = new comparator<integer>() {\n    @override\n    public int compare(integer o1, integer o2) {\n      if(o1 > o2){\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n  };\n\n  arrays.sort(data,comparator);\n  system.out.println(arrays.tostring(data));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\narrays 的 sort() 方法，有自定义规则就按自己的方法排序，反之走源码逻辑。\n\npublic static <t> void sort(t[] a, comparator<? super t> c) {\n    if (c == null) {\n        sort(a);\n    } else {\n        if (legacymergesort.userrequested)\n            legacymergesort(a, c);\n        else\n            timsort.sort(a, 0, a.length, c, null, 0, 0);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n还有，threadpoolexecutor 中的拒绝策略 rejectedexecutionhandler 也是典型的策略模式，感兴趣的也可以再看看源码。',charsets:{cjk:!0},lastUpdated:"2022/09/20, 23:34:59",lastUpdatedTimestamp:1663688099e3},{title:"观察模式",frontmatter:{title:"观察模式",date:"2022-05-21T17:29:45.000Z",permalink:"/pages/cbff3c/",categories:["Java相关","设计模式"],tags:[null]},regularPath:"/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/060.%E8%A7%82%E5%AF%9F%E6%A8%A1%E5%BC%8F.html",relativePath:"01.Java相关/40.设计模式/060.观察模式.md",key:"v-64f1031c",path:"/pages/cbff3c/",headers:[{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:344},{level:2,title:"角色",slug:"角色",normalizedTitle:"角色",charIndex:594},{level:2,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:630},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:1386},{level:2,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:2856},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:2864},{level:3,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:2857},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:3010},{level:3,title:"JDK 中的观察者模式",slug:"jdk-中的观察者模式",normalizedTitle:"jdk 中的观察者模式",charIndex:3017},{level:3,title:"Spring 中的观察者模式",slug:"spring-中的观察者模式",normalizedTitle:"spring 中的观察者模式",charIndex:3164},{level:4,title:"1. Spring 中观察者模式的四个角色",slug:"_1-spring-中观察者模式的四个角色",normalizedTitle:"1. spring 中观察者模式的四个角色",charIndex:3228},{level:4,title:"2. coding~~~~~~",slug:"_2-coding",normalizedTitle:"2. coding~~~~~~",charIndex:3951}],headersStr:"定义 角色 类图 实例 优缺点 优点 缺点 应用 JDK 中的观察者模式 Spring 中的观察者模式 1. Spring 中观察者模式的四个角色 2. coding~~~~~~",content:'在软件系统中经常会有这样的需求：如果一个对象的状态发生改变，某些与它相关的对象也要随之做出相应的变化。 举个例子：\n\n * 微信公众号，如果一个用户订阅了某个公众号，那么便会收到公众号发来的消息，那么，公众号就是『被观察者』，而用户就是『观察者』\n * 气象站可以将每天预测到的温度、湿度、气压等以公告的形式发布给各种第三方网站，如果天气数据有更新，要能够实时的通知给第三方，这里的气象局就是『被观察者』，第三方网站就是『观察者』\n * MVC 模式中的模型与视图的关系也属于观察与被观察关系\n\n观察者模式是使用频率较高的设计模式之一。\n\n观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。\n\n\n# 定义\n\n观察者模式(Observer Pattern)： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。\n\n观察者模式是一种对象行为型模式。\n\n观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。\n\n细究的话，发布订阅和观察者有些不同，可以理解成发布订阅模式属于广义上的观察者模式。\n\n\n\n\n# 角色\n\n * Subject（目标）：被观察者，它是指被观察的对象。 从类图中可以看到，类中有一个用来存放观察者对象的Vector 容器（Vector在是安全的，而List则是不安全的），这个 Vector 容器是被观察者类的核心，另外还有三个方法：attach 方法是向这个容器中添加观察者对象；detach 方法是从容器中移除观察者对象；notify 方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。\n\n * ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。\n\n * Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。\n\n * ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update() 方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。\n\n\n# 类图\n\n\n\n再记录下 UML 类图的注意事项，这里我的 Subject 是抽象方法，所以用***斜体***，抽象方法也要用斜体，具体的各种箭头意义，我之前也总结过《设计模式前传——学设计模式前你要知道这些》（被网上各种帖子毒害过的自己，认真记录~~~）。\n\n\n# 实例\n\n1、定义观察者接口\n\ninterface Observer {\n    public void update();\n}\n\n\n1\n2\n3\n\n\n2、定义被观察者\n\nabstract class Subject {\n    private Vector<Observer> obs = new Vector();\n\n    public void addObserver(Observer obs){\n        this.obs.add(obs);\n    }\n    public void delObserver(Observer obs){\n        this.obs.remove(obs);\n    }\n    protected void notifyObserver(){\n        for(Observer o: obs){\n            o.update();\n        }\n    }\n    public abstract void doSomething();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n3、具体的被观察者\n\nclass ConcreteSubject extends Subject {\n    public void doSomething(){\n        System.out.println("被观察者事件发生改变");\n        this.notifyObserver();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n4、具体的观察者\n\nclass ConcreteObserver1 implements Observer {\n    public void update() {\n        System.out.println("观察者1收到信息，并进行处理");\n    }\n}\nclass ConcreteObserver2 implements Observer {\n    public void update() {\n        System.out.println("观察者2收到信息，并进行处理");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n5、客户端\n\npublic class Client {\n    public static void main(String[] args){\n        Subject sub = new ConcreteSubject();\n        sub.addObserver(new ConcreteObserver1()); //添加观察者1\n        sub.addObserver(new ConcreteObserver2()); //添加观察者2\n        sub.doSomething();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n输出\n\n被观察者事件发生改变\n观察者1收到信息，并进行处理\n观察者2收到信息，并进行处理\n\n\n1\n2\n3\n\n\n通过运行结果可以看到，我们只调用了 Subject 的方法，但同时两个观察者的相关方法都被调用了。仔细看一下代码，其实很简单，就是在 Subject 类中关联一下 Observer 类，并且在 doSomething() 方法中遍历一下 Observer 的 update() 方法就行了。\n\n\n# 优缺点\n\n\n# 优点\n\n降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系 目标与观察者之间建立了一套触发机制 支持广播通信 符合“开闭原则”的要求\n\n\n# 缺点\n\n目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率\n\n\n# 应用\n\n\n# JDK 中的观察者模式\n\n观察者模式在 Java 语言中的地位非常重要。在 JDK 的 java.util 包中，提供了 Observable 类以及 Observer 接口，它们构成了 JDK 对观察者模式的支持（可以去查看下源码，写的比较严谨）。but，在 Java9 被弃用了。\n\n\n# Spring 中的观察者模式\n\nSpring 事件驱动模型也是观察者模式很经典的应用。就是我们项目中最常见的事件监听器。\n\n# 1. Spring 中观察者模式的四个角色\n\n * 事件：ApplicationEvent 是所有事件对象的父类。ApplicationEvent 继承自 jdk 的 EventObject，所有的事件都需要继承 ApplicationEvent，并且通过 source 得到事件源。\n\n * Spring 也为我们提供了很多内置事件，ContextRefreshedEvent、ContextStartedEvent、ContextStoppedEvent、ContextClosedEvent、RequestHandledEvent。\n\n * 事件监听：ApplicationListener，也就是观察者，继承自 jdk 的 EventListener，该类中只有一个方法 onApplicationEvent。当监听的事件发生后该方法会被执行。\n\n * 事件源：ApplicationContext，ApplicationContext 是 Spring 中的核心容器，在事件监听中 ApplicationContext 可以作为事件的发布者，也就是事件源。因为 ApplicationContext 继承自 ApplicationEventPublisher。在 ApplicationEventPublisher 中定义了事件发布的方法：publishEvent(Object event)\n\n * 事件管理：ApplicationEventMulticaster，用于事件监听器的注册和事件的广播。监听器的注册就是通过它来实现的，它的作用是把 Applicationcontext 发布的 Event 广播给它的监听器列表。\n\n# 2. coding~~~~~~\n\n1、定义事件\n\npublic class MyEvent extends ApplicationEvent {\n    public MyEvent(Object source) {\n        super(source);\n        System.out.println("my Event");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、实现事件监听器\n\n@Component\nclass MyListenerA implements ApplicationListener<MyEvent> {\n    public void onApplicationEvent(MyEvent AyEvent) {\n        System.out.println("ListenerA received");\n    }\n}\n\n@Component\nclass MyListenerB implements ApplicationListener<MyEvent> {\n    public void onApplicationEvent(MyEvent AyEvent) {\n        System.out.println("ListenerB received");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n3、事件发布者\n\n@Component\npublic class MyPublisher implements ApplicationContextAware {\n    private ApplicationContext applicationContext;\n    \n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext=applicationContext;\n    }\n    \n    public void publishEvent(ApplicationEvent event){\n        System.out.println("publish event");\n        applicationContext.publishEvent(event);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n4、测试，先用注解方式将 MyPublisher 注入 Spring\n\n@Configuration\n@ComponentScan\npublic class AppConfig {\n\n    @Bean(name = "myPublisher")\n    public MyPublisher myPublisher(){\n        return new MyPublisher();\n    }\n}\npublic class Client {\n\n    @Test\n    public void main() {\n        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n        MyPublisher myPublisher = (MyPublisher) context.getBean("myPublisher");\n        myPublisher.publishEvent(new MyEvent(this));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n5、输出\n\nmy Event\npublish event\nListenerA received\nListenerB received\n\n\n1\n2\n3\n4\n',normalizedContent:'在软件系统中经常会有这样的需求：如果一个对象的状态发生改变，某些与它相关的对象也要随之做出相应的变化。 举个例子：\n\n * 微信公众号，如果一个用户订阅了某个公众号，那么便会收到公众号发来的消息，那么，公众号就是『被观察者』，而用户就是『观察者』\n * 气象站可以将每天预测到的温度、湿度、气压等以公告的形式发布给各种第三方网站，如果天气数据有更新，要能够实时的通知给第三方，这里的气象局就是『被观察者』，第三方网站就是『观察者』\n * mvc 模式中的模型与视图的关系也属于观察与被观察关系\n\n观察者模式是使用频率较高的设计模式之一。\n\n观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。\n\n\n# 定义\n\n观察者模式(observer pattern)： 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。\n\n观察者模式是一种对象行为型模式。\n\n观察者模式的别名包括发布-订阅（publish/subscribe）模式、模型-视图（model/view）模式、源-监听器（source/listener）模式或从属者（dependents）模式。\n\n细究的话，发布订阅和观察者有些不同，可以理解成发布订阅模式属于广义上的观察者模式。\n\n\n\n\n# 角色\n\n * subject（目标）：被观察者，它是指被观察的对象。 从类图中可以看到，类中有一个用来存放观察者对象的vector 容器（vector在是安全的，而list则是不安全的），这个 vector 容器是被观察者类的核心，另外还有三个方法：attach 方法是向这个容器中添加观察者对象；detach 方法是从容器中移除观察者对象；notify 方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。\n\n * concretesubject（具体目标）：具体目标是目标类的子类，通常它包含经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。\n\n * observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。\n\n * concreteobserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 observer 中定义的 update() 方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。\n\n\n# 类图\n\n\n\n再记录下 uml 类图的注意事项，这里我的 subject 是抽象方法，所以用***斜体***，抽象方法也要用斜体，具体的各种箭头意义，我之前也总结过《设计模式前传——学设计模式前你要知道这些》（被网上各种帖子毒害过的自己，认真记录~~~）。\n\n\n# 实例\n\n1、定义观察者接口\n\ninterface observer {\n    public void update();\n}\n\n\n1\n2\n3\n\n\n2、定义被观察者\n\nabstract class subject {\n    private vector<observer> obs = new vector();\n\n    public void addobserver(observer obs){\n        this.obs.add(obs);\n    }\n    public void delobserver(observer obs){\n        this.obs.remove(obs);\n    }\n    protected void notifyobserver(){\n        for(observer o: obs){\n            o.update();\n        }\n    }\n    public abstract void dosomething();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n3、具体的被观察者\n\nclass concretesubject extends subject {\n    public void dosomething(){\n        system.out.println("被观察者事件发生改变");\n        this.notifyobserver();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n4、具体的观察者\n\nclass concreteobserver1 implements observer {\n    public void update() {\n        system.out.println("观察者1收到信息，并进行处理");\n    }\n}\nclass concreteobserver2 implements observer {\n    public void update() {\n        system.out.println("观察者2收到信息，并进行处理");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n5、客户端\n\npublic class client {\n    public static void main(string[] args){\n        subject sub = new concretesubject();\n        sub.addobserver(new concreteobserver1()); //添加观察者1\n        sub.addobserver(new concreteobserver2()); //添加观察者2\n        sub.dosomething();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n输出\n\n被观察者事件发生改变\n观察者1收到信息，并进行处理\n观察者2收到信息，并进行处理\n\n\n1\n2\n3\n\n\n通过运行结果可以看到，我们只调用了 subject 的方法，但同时两个观察者的相关方法都被调用了。仔细看一下代码，其实很简单，就是在 subject 类中关联一下 observer 类，并且在 dosomething() 方法中遍历一下 observer 的 update() 方法就行了。\n\n\n# 优缺点\n\n\n# 优点\n\n降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系 目标与观察者之间建立了一套触发机制 支持广播通信 符合“开闭原则”的要求\n\n\n# 缺点\n\n目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率\n\n\n# 应用\n\n\n# jdk 中的观察者模式\n\n观察者模式在 java 语言中的地位非常重要。在 jdk 的 java.util 包中，提供了 observable 类以及 observer 接口，它们构成了 jdk 对观察者模式的支持（可以去查看下源码，写的比较严谨）。but，在 java9 被弃用了。\n\n\n# spring 中的观察者模式\n\nspring 事件驱动模型也是观察者模式很经典的应用。就是我们项目中最常见的事件监听器。\n\n# 1. spring 中观察者模式的四个角色\n\n * 事件：applicationevent 是所有事件对象的父类。applicationevent 继承自 jdk 的 eventobject，所有的事件都需要继承 applicationevent，并且通过 source 得到事件源。\n\n * spring 也为我们提供了很多内置事件，contextrefreshedevent、contextstartedevent、contextstoppedevent、contextclosedevent、requesthandledevent。\n\n * 事件监听：applicationlistener，也就是观察者，继承自 jdk 的 eventlistener，该类中只有一个方法 onapplicationevent。当监听的事件发生后该方法会被执行。\n\n * 事件源：applicationcontext，applicationcontext 是 spring 中的核心容器，在事件监听中 applicationcontext 可以作为事件的发布者，也就是事件源。因为 applicationcontext 继承自 applicationeventpublisher。在 applicationeventpublisher 中定义了事件发布的方法：publishevent(object event)\n\n * 事件管理：applicationeventmulticaster，用于事件监听器的注册和事件的广播。监听器的注册就是通过它来实现的，它的作用是把 applicationcontext 发布的 event 广播给它的监听器列表。\n\n# 2. coding~~~~~~\n\n1、定义事件\n\npublic class myevent extends applicationevent {\n    public myevent(object source) {\n        super(source);\n        system.out.println("my event");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2、实现事件监听器\n\n@component\nclass mylistenera implements applicationlistener<myevent> {\n    public void onapplicationevent(myevent ayevent) {\n        system.out.println("listenera received");\n    }\n}\n\n@component\nclass mylistenerb implements applicationlistener<myevent> {\n    public void onapplicationevent(myevent ayevent) {\n        system.out.println("listenerb received");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n3、事件发布者\n\n@component\npublic class mypublisher implements applicationcontextaware {\n    private applicationcontext applicationcontext;\n    \n    public void setapplicationcontext(applicationcontext applicationcontext) throws beansexception {\n        this.applicationcontext=applicationcontext;\n    }\n    \n    public void publishevent(applicationevent event){\n        system.out.println("publish event");\n        applicationcontext.publishevent(event);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n4、测试，先用注解方式将 mypublisher 注入 spring\n\n@configuration\n@componentscan\npublic class appconfig {\n\n    @bean(name = "mypublisher")\n    public mypublisher mypublisher(){\n        return new mypublisher();\n    }\n}\npublic class client {\n\n    @test\n    public void main() {\n        applicationcontext context = new annotationconfigapplicationcontext(appconfig.class);\n        mypublisher mypublisher = (mypublisher) context.getbean("mypublisher");\n        mypublisher.publishevent(new myevent(this));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n5、输出\n\nmy event\npublish event\nlistenera received\nlistenerb received\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/09/20, 23:34:59",lastUpdatedTimestamp:1663688099e3},{title:"简述常见的 HTTP 状态码的含义",frontmatter:{title:"简述常见的 HTTP 状态码的含义",date:"2022-06-23T21:09:29.000Z",permalink:"/pages/f33310/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/010.%E7%AE%80%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84%20HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%90%AB%E4%B9%89.html",relativePath:"02.计算机基础/10.计算机网络/010.简述常见的 HTTP 状态码的含义.md",key:"v-0a1d1fb4",path:"/pages/f33310/",headers:[{level:2,title:"2XX 成功",slug:"_2xx-成功",normalizedTitle:"2xx 成功",charIndex:2},{level:2,title:"3XX 重定向",slug:"_3xx-重定向",normalizedTitle:"3xx 重定向",charIndex:109},{level:2,title:"4XX 客户端错误",slug:"_4xx-客户端错误",normalizedTitle:"4xx 客户端错误",charIndex:333},{level:2,title:"5XX 服务器错误",slug:"_5xx-服务器错误",normalizedTitle:"5xx 服务器错误",charIndex:483}],headersStr:"2XX 成功 3XX 重定向 4XX 客户端错误 5XX 服务器错误",content:"# 2XX 成功\n\n200 OK，表示从客户端发来的请求在服务器端被正确处理\n\n204 No content，表示请求成功，但响应报文不含实体的主体部分\n\n206 Partial Content，进行范围请求\n\n\n# 3XX 重定向\n\n301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n\n302 found，临时性重定向，表示资源临时被分配了新的 URL\n\n303 see other，表示资源存在着另一个 URL，应使用 GET 方法定向获取资源\n\n304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n\n307 temporary redirect，临时重定向，和302含义相同\n\n\n# 4XX 客户端错误\n\n400 bad request，请求报文存在语法错误\n\n401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n\n403 forbidden，表示对请求资源的访问被服务器拒绝\n\n404 not found，表示在服务器上没有找到请求的资源\n\n\n# 5XX 服务器错误\n\n500 internal sever error，表示服务器端在执行请求时发生了错误\n\n503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求",normalizedContent:"# 2xx 成功\n\n200 ok，表示从客户端发来的请求在服务器端被正确处理\n\n204 no content，表示请求成功，但响应报文不含实体的主体部分\n\n206 partial content，进行范围请求\n\n\n# 3xx 重定向\n\n301 moved permanently，永久性重定向，表示资源已被分配了新的 url\n\n302 found，临时性重定向，表示资源临时被分配了新的 url\n\n303 see other，表示资源存在着另一个 url，应使用 get 方法定向获取资源\n\n304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n\n307 temporary redirect，临时重定向，和302含义相同\n\n\n# 4xx 客户端错误\n\n400 bad request，请求报文存在语法错误\n\n401 unauthorized，表示发送的请求需要有通过 http 认证的认证信息\n\n403 forbidden，表示对请求资源的访问被服务器拒绝\n\n404 not found，表示在服务器上没有找到请求的资源\n\n\n# 5xx 服务器错误\n\n500 internal sever error，表示服务器端在执行请求时发生了错误\n\n503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？",frontmatter:{title:"简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？",date:"2022-03-11T00:51:01.000Z",permalink:"/pages/e00207/",categories:["计算机基础","HTML"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E7%AE%80%E8%BF%B0%20TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html",relativePath:"02.计算机基础/10.计算机网络/01.简述 TCP 三次握手以及四次挥手.md",key:"v-470b2fce",path:"/pages/e00207/",headers:[{level:2,title:"建立连接-TCP 三次握手",slug:"建立连接-tcp-三次握手",normalizedTitle:"建立连接-tcp 三次握手",charIndex:37},{level:2,title:"为什么要三次握手?",slug:"为什么要三次握手",normalizedTitle:"为什么要三次握手?",charIndex:357},{level:2,title:"第2次握手传回了ACK，为什么还要传回SYN？",slug:"第2次握手传回了ack-为什么还要传回syn",normalizedTitle:"第2次握手传回了ack，为什么还要传回syn？",charIndex:695},{level:2,title:"断开连接-TCP 四次挥手",slug:"断开连接-tcp-四次挥手",normalizedTitle:"断开连接-tcp 四次挥手",charIndex:1036},{level:2,title:"为什么要四次挥手？",slug:"为什么要四次挥手",normalizedTitle:"为什么要四次挥手？",charIndex:1546},{level:2,title:"为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？",slug:"为什么不能把服务器发送的-ack-和-fin-合并起来-变成三次挥手",normalizedTitle:"为什么不能把服务器发送的 ack 和 fin 合并起来，变成三次挥手？",charIndex:1846},{level:2,title:"如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？",slug:"如果第二次挥手时服务器的-ack-没有送达客户端-会怎样",normalizedTitle:"如果第二次挥手时服务器的 ack 没有送达客户端，会怎样？",charIndex:1974},{level:2,title:"为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？",slug:"为什么第四次挥手客户端需要等待-2-msl-报文段最长寿命-时间后才进入-closed-状态",normalizedTitle:"为什么第四次挥手客户端需要等待 2*msl（报文段最长寿命）时间后才进入 closed 状态？",charIndex:2038},{level:2,title:"面试官可能问你这些问题",slug:"面试官可能问你这些问题",normalizedTitle:"面试官可能问你这些问题",charIndex:2373}],headersStr:"建立连接-TCP 三次握手 为什么要三次握手? 第2次握手传回了ACK，为什么还要传回SYN？ 断开连接-TCP 四次挥手 为什么要四次挥手？ 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？ 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？ 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？ 面试官可能问你这些问题",content:"为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。\n\n\n# 建立连接-TCP 三次握手\n\nTCP 三次握手图解\n\n\n\n建立一个 TCP 连接需要“三次握手”，缺一不可 ：\n\n * 一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认；\n * 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 SYN_RECV 状态\n * 三次握手:客户端发送带有带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成TCP三次握手。\n\n当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！\n\n\n# 为什么要三次握手?\n\n三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。\n\n * 第一次握手 ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常\n * 第二次握手 ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常\n * 第三次握手 ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常\n\n三次握手就能确认双发收发功能都正常，缺一不可。\n\n更详细的解答可以看这个：TCP 为什么是三次握手，而不是两次或四次？ 。\n\n\n# 第2次握手传回了ACK，为什么还要传回SYN？\n\n服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。\n\n> SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。\n\n\n# 断开连接-TCP 四次挥手\n\nTCP 四次挥手图解\n\n\n\n断开一个 TCP 连接则需要“四次挥手”，缺一不可 ：\n\n * 第一次挥手 ：客户端发送一个 FIN（SEQ=X） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 FIN-WAIT-1 状态。\n * 第二次挥手 ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包->客户端 。然后，此时服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。\n * 第三次挥手 ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包->客户端请求关闭连接，然后，服务端进入LAST-ACK状态。\n * 第四次挥手 ：客户端发送 ACK (SEQ=y+1)标志的数据包->服务端并且进入TIME-WAIT状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。\n\n只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n\n\n# 为什么要四次挥手？\n\nTCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。\n\n举个例子：A 和 B 打电话，通话即将结束后。\n\n 1. 第一次挥手 ： A 说“我没啥要说的了”\n 2. 第二次挥手 ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话\n 3. 第三次挥手 ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”\n 4. 第四次挥手 ：A 回答“知道了”，这样通话才算结束。\n\n\n# 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？\n\n因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。\n\n\n# 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？\n\n客户端没有收到 ACK 确认，会重新发送 FIN 请求。\n\n\n# 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？\n\n第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。\n\nMSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。\n\n\n# 面试官可能问你这些问题\n\n * 为什么要三次握手?\n * 第 2 次握手传回了ACK，为什么还要传回SYN？\n * 为什么要四次挥手？\n * 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？\n * 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？\n * 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？",normalizedContent:"为了准确无误地把数据送达目标处，tcp 协议采用了三次握手策略。\n\n\n# 建立连接-tcp 三次握手\n\ntcp 三次握手图解\n\n\n\n建立一个 tcp 连接需要“三次握手”，缺一不可 ：\n\n * 一次握手:客户端发送带有 syn（seq=x） 标志的数据包 -> 服务端，然后客户端进入 syn_send 状态，等待服务器的确认；\n * 二次握手:服务端发送带有 syn+ack(seq=y,ack=x+1) 标志的数据包 –> 客户端,然后服务端进入 syn_recv 状态\n * 三次握手:客户端发送带有带有 ack(ack=y+1) 标志的数据包 –> 服务端，然后客户端和服务器端都进入established 状态，完成tcp三次握手。\n\n当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！\n\n\n# 为什么要三次握手?\n\n三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。\n\n * 第一次握手 ：client 什么都不能确认；server 确认了对方发送正常，自己接收正常\n * 第二次握手 ：client 确认了：自己发送、接收正常，对方发送、接收正常；server 确认了：对方发送正常，自己接收正常\n * 第三次握手 ：client 确认了：自己发送、接收正常，对方发送、接收正常；server 确认了：自己发送、接收正常，对方发送、接收正常\n\n三次握手就能确认双发收发功能都正常，缺一不可。\n\n更详细的解答可以看这个：tcp 为什么是三次握手，而不是两次或四次？ 。\n\n\n# 第2次握手传回了ack，为什么还要传回syn？\n\n服务端传回发送端所发送的 ack 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 syn 则是为了建立并确认从服务端到客户端的通信。\n\n> syn 同步序列编号(synchronize sequence numbers) 是 tcp/ip 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 tcp 网络连接时，客户机首先发出一个 syn 消息，服务器使用 syn-ack 应答表示接收到了这个消息，最后客户机再以 ack(acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 tcp 连接，数据才可以在客户机和服务器之间传递。\n\n\n# 断开连接-tcp 四次挥手\n\ntcp 四次挥手图解\n\n\n\n断开一个 tcp 连接则需要“四次挥手”，缺一不可 ：\n\n * 第一次挥手 ：客户端发送一个 fin（seq=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 fin-wait-1 状态。\n * 第二次挥手 ：服务器收到这个 fin（seq=x） 标志的数据包，它发送一个 ack （seq=x+1）标志的数据包->客户端 。然后，此时服务端进入close-wait状态，客户端进入fin-wait-2状态。\n * 第三次挥手 ：服务端关闭与客户端的连接并发送一个 fin (seq=y)标志的数据包->客户端请求关闭连接，然后，服务端进入last-ack状态。\n * 第四次挥手 ：客户端发送 ack (seq=y+1)标志的数据包->服务端并且进入time-wait状态，服务端在收到 ack (seq=y+1)标志的数据包后进入 close 状态。此时，如果客户端等待 2msl 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。\n\n只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n\n\n# 为什么要四次挥手？\n\ntcp是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 tcp 连接。\n\n举个例子：a 和 b 打电话，通话即将结束后。\n\n 1. 第一次挥手 ： a 说“我没啥要说的了”\n 2. 第二次挥手 ：b 回答“我知道了”，但是 b 可能还会有要说的话，a 不能要求 b 跟着自己的节奏结束通话\n 3. 第三次挥手 ：于是 b 可能又巴拉巴拉说了一通，最后 b 说“我说完了”\n 4. 第四次挥手 ：a 回答“知道了”，这样通话才算结束。\n\n\n# 为什么不能把服务器发送的 ack 和 fin 合并起来，变成三次挥手？\n\n因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ack，表示接收到了断开连接的请求。等到数据发完之后再发 fin，断开服务器到客户端的数据传送。\n\n\n# 如果第二次挥手时服务器的 ack 没有送达客户端，会怎样？\n\n客户端没有收到 ack 确认，会重新发送 fin 请求。\n\n\n# 为什么第四次挥手客户端需要等待 2*msl（报文段最长寿命）时间后才进入 closed 状态？\n\n第四次挥手时，客户端发送给服务器的 ack 有可能丢失，如果服务端没有因为某些原因而没有收到 ack 的话，服务端就会重发 fin，如果客户端在 2*msl 的时间内收到了 fin，就会重新发送 ack 并再次等待 2msl，防止 server 没有收到 ack 而不断重发 fin。\n\nmsl(maximum segment lifetime) : 一个片段在网络中最大的存活时间，2msl 就是一个发送和一个回复所需的最大时间。如果直到 2msl，client 都没有再次收到 fin，那么 client 推断 ack 已经被成功接收，则结束 tcp 连接。\n\n\n# 面试官可能问你这些问题\n\n * 为什么要三次握手?\n * 第 2 次握手传回了ack，为什么还要传回syn？\n * 为什么要四次挥手？\n * 为什么不能把服务器发送的 ack 和 fin 合并起来，变成三次挥手？\n * 如果第二次挥手时服务器的 ack 没有送达客户端，会怎样？\n * 为什么第四次挥手客户端需要等待 2*msl（报文段最长寿命）时间后才进入 closed 状态？",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"从输入 URL 到展现页面的全过程",frontmatter:{title:"从输入 URL 到展现页面的全过程",date:"2022-06-23T21:10:44.000Z",permalink:"/pages/ab48ba/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/020.%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E5%B1%95%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B.html",relativePath:"02.计算机基础/10.计算机网络/020.从输入 URL 到展现页面的全过程.md",key:"v-6602e3da",path:"/pages/ab48ba/",headers:[{level:2,title:"总体来说分为以下几个过程：",slug:"总体来说分为以下几个过程",normalizedTitle:"总体来说分为以下几个过程：",charIndex:31},{level:2,title:"输入网址",slug:"输入网址",normalizedTitle:"输入网址",charIndex:49},{level:2,title:"DNS解析",slug:"dns解析",normalizedTitle:"dns解析",charIndex:57},{level:3,title:"什么是IP地址",slug:"什么是ip地址",normalizedTitle:"什么是ip地址",charIndex:459},{level:3,title:"什么是DNS",slug:"什么是dns",normalizedTitle:"什么是dns",charIndex:608},{level:3,title:"DNS解析",slug:"dns解析-2",normalizedTitle:"dns解析",charIndex:57},{level:3,title:"DNS查询的两种方式：递归查询和迭代查询",slug:"dns查询的两种方式-递归查询和迭代查询",normalizedTitle:"dns查询的两种方式：递归查询和迭代查询",charIndex:752},{level:3,title:"DNS域名称空间的组织方式",slug:"dns域名称空间的组织方式",normalizedTitle:"dns域名称空间的组织方式",charIndex:788},{level:3,title:"DNS负载均衡",slug:"dns负载均衡",normalizedTitle:"dns负载均衡",charIndex:808},{level:2,title:"建立TCP/IP链接",slug:"建立tcp-ip链接",normalizedTitle:"建立tcp/ip链接",charIndex:66},{level:3,title:"”三次握手”的详解",slug:"三次握手-的详解",normalizedTitle:"”三次握手”的详解",charIndex:1033},{level:3,title:"为什么要三次握手",slug:"为什么要三次握手",normalizedTitle:"为什么要三次握手",charIndex:1049}],headersStr:"总体来说分为以下几个过程： 输入网址 DNS解析 什么是IP地址 什么是DNS DNS解析 DNS查询的两种方式：递归查询和迭代查询 DNS域名称空间的组织方式 DNS负载均衡 建立TCP/IP链接 ”三次握手”的详解 为什么要三次握手",content:"从我们输入一个网址到页面展现的过程到底发生了什么呢？\n\n\n# 总体来说分为以下几个过程：\n\n * 输入网址\n * DNS解析\n * 建立TCP/IP链接\n * 发送HTTP请求\n * 服务器处理请求\n * 服务器返回HTTP响应\n * 浏览器渲染页面并展现\n * 断开连接\n\n\n# 输入网址\n\n当我们想要打开一个页面时，很简单的会想到去输入一个网址 我们以本网址为例，解释一下它各部分的组成：\n\nhttps://www.baidu.com\n\n\n1\n\n\n * https ：https是协议（Protocol），它表明了浏览器使用何种协议，有http、https、ftp、mailto等，其中https是加密认证版的http（详见《图解HTTP》）\n\n * www.baidu.com ：这是域名（Domain name），它表明正在请求哪个Web服务器，其中www是主机名（host）\n\n\n# DNS解析\n\n输入网址（URL）这一步我们很好理解，但是接下来所谓的域名解析是什么呢？又是为什么要进行域名解析呢？\n\n\n# 什么是IP地址\n\nIP 地址（Internet Protocol Address）是互联网协议特有的一种地址，它是 IP 协议提供的一种统一的地址格式。IP 地址为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 像192.168.59.0就是一个主机IP地址\n\n\n# 什么是DNS\n\nDNS服务器上存储着映射<域名-IP>，DNS解析就是去DNS服务器查询IP地址。\n\n\n# DNS解析\n\nDNS解析按照下面顺序逐个查找。\n\n * 本地（hosts文件）\n * DNS服务器（本地DNS | 根DNS）\n * 域服务器\n * 解析服务器的地址\n\n\n\n\n# DNS查询的两种方式：递归查询和迭代查询\n\n递归解析 迭代解析\n\n\n# DNS域名称空间的组织方式\n\n\n\n\n# DNS负载均衡\n\n当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。\n\n处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址 在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡\n\n\n# 建立TCP/IP链接\n\n\n# ”三次握手”的详解\n\n\n\n\n# 为什么要三次握手\n\n * clien端 防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致连接释放以后的某个时间才到达server。 本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。 于是就向client发出确认报文段，同意建立连接。\n\n * server端 假设不采用“三次握手”。 如果只要server发出确认，新的连接就建立了。并一直等待client发来数据。 事实是client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。 但server端就会有许多这样的等待，server的很多资源就白白浪费掉了。\n\n采用“三次握手”的办法可以防止上述现象发生。主要目的防止server端一直等待，浪费资源。",normalizedContent:"从我们输入一个网址到页面展现的过程到底发生了什么呢？\n\n\n# 总体来说分为以下几个过程：\n\n * 输入网址\n * dns解析\n * 建立tcp/ip链接\n * 发送http请求\n * 服务器处理请求\n * 服务器返回http响应\n * 浏览器渲染页面并展现\n * 断开连接\n\n\n# 输入网址\n\n当我们想要打开一个页面时，很简单的会想到去输入一个网址 我们以本网址为例，解释一下它各部分的组成：\n\nhttps://www.baidu.com\n\n\n1\n\n\n * https ：https是协议（protocol），它表明了浏览器使用何种协议，有http、https、ftp、mailto等，其中https是加密认证版的http（详见《图解http》）\n\n * www.baidu.com ：这是域名（domain name），它表明正在请求哪个web服务器，其中www是主机名（host）\n\n\n# dns解析\n\n输入网址（url）这一步我们很好理解，但是接下来所谓的域名解析是什么呢？又是为什么要进行域名解析呢？\n\n\n# 什么是ip地址\n\nip 地址（internet protocol address）是互联网协议特有的一种地址，它是 ip 协议提供的一种统一的地址格式。ip 地址为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 像192.168.59.0就是一个主机ip地址\n\n\n# 什么是dns\n\ndns服务器上存储着映射<域名-ip>，dns解析就是去dns服务器查询ip地址。\n\n\n# dns解析\n\ndns解析按照下面顺序逐个查找。\n\n * 本地（hosts文件）\n * dns服务器（本地dns | 根dns）\n * 域服务器\n * 解析服务器的地址\n\n\n\n\n# dns查询的两种方式：递归查询和迭代查询\n\n递归解析 迭代解析\n\n\n# dns域名称空间的组织方式\n\n\n\n\n# dns负载均衡\n\n当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。\n\n处理办法就是用dns负载均衡技术，它的原理是在dns服务器中为同一个主机名配置多个ip地址 在应答dns查询时,dns服务器对每个查询将以dns文件中主机记录的ip地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡\n\n\n# 建立tcp/ip链接\n\n\n# ”三次握手”的详解\n\n\n\n\n# 为什么要三次握手\n\n * clien端 防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致连接释放以后的某个时间才到达server。 本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。 于是就向client发出确认报文段，同意建立连接。\n\n * server端 假设不采用“三次握手”。 如果只要server发出确认，新的连接就建立了。并一直等待client发来数据。 事实是client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。 但server端就会有许多这样的等待，server的很多资源就白白浪费掉了。\n\n采用“三次握手”的办法可以防止上述现象发生。主要目的防止server端一直等待，浪费资源。",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"HTTP 中 GET 和 POST 区别",frontmatter:{title:"HTTP 中 GET 和 POST 区别",date:"2022-09-21T22:34:00.000Z",permalink:"/pages/a0e400/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/030.HTTP%20%E4%B8%AD%20GET%20%E5%92%8C%20POST%20%E5%8C%BA%E5%88%AB.html",relativePath:"02.计算机基础/10.计算机网络/030.HTTP 中 GET 和 POST 区别.md",key:"v-12717373",path:"/pages/a0e400/",headers:[{level:2,title:"什么是 HTTP ？",slug:"什么是-http",normalizedTitle:"什么是 http ？",charIndex:2},{level:2,title:"两种 HTTP 请求方法：GET 和 POST",slug:"两种-http-请求方法-get-和-post",normalizedTitle:"两种 http 请求方法：get 和 post",charIndex:186},{level:2,title:"GET 方法",slug:"get-方法",normalizedTitle:"get 方法",charIndex:364},{level:2,title:"POST 方法",slug:"post-方法",normalizedTitle:"post 方法",charIndex:593},{level:2,title:"比较 GET 与 POST",slug:"比较-get-与-post",normalizedTitle:"比较 get 与 post",charIndex:834},{level:2,title:"其他 HTTP 请求方法",slug:"其他-http-请求方法",normalizedTitle:"其他 http 请求方法",charIndex:1967}],headersStr:"什么是 HTTP ？ 两种 HTTP 请求方法：GET 和 POST GET 方法 POST 方法 比较 GET 与 POST 其他 HTTP 请求方法",content:"# 什么是 HTTP ？\n\n超文本传输协议（HTTP）的设计目的是保证客户端与服务器之间的通信。\n\nHTTP 的工作方式是客户端与服务器之间的请求-应答协议。\n\nweb 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。\n\n举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。\n\n\n# 两种 HTTP 请求方法：GET 和 POST\n\n在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。\n\n * GET - 从指定的资源请求数据。\n * POST - 向指定的资源提交要被处理的数据。 GET 提交参数一般显示在 URL 上，POST 通过表单提交不会显示在 URL 上，POST 更具隐蔽性：\n\n\n\n\n# GET 方法\n\n请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：\n\n/test/demo_form.php?name1=value1&name2=value2\n\n\n1\n\n\n有关 GET 请求的其他一些注释：\n\n * GET 请求可被缓存\n * GET 请求保留在浏览器历史记录中\n * GET 请求可被收藏为书签\n * GET 请求不应在处理敏感数据时使用\n * GET 请求有长度限制\n * GET 请求只应当用于取回数据\n\n\n# POST 方法\n\n请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：\n\nPOST /test/demo_form.php HTTP/1.1\nHost: runoob.com\nname1=value1&name2=value2\n\n\n1\n2\n3\n\n\n有关 POST 请求的其他一些注释：\n\n * POST 请求不会被缓存\n * POST 请求不会保留在浏览器历史记录中\n * POST 不能被收藏为书签\n * POST 请求对数据长度没有要求\n\n\n# 比较 GET 与 POST\n\n下面的表格比较了两种 HTTP 方法：GET 和 POST。\n\n           GET                                                       POST\n后退按钮/刷新    无害                                                        数据会被重新提交（浏览器应该告知用户数据会被重新提交）。\n书签         可收藏为书签                                                    不可收藏为书签\n缓存         能被缓存                                                      不能缓存\n编码类型       application/x-www-form-urlencoded                         application/x-www-form-urlencoded or\n                                                                     multipart/form-data。为二进制数据使用多重编码。\n历史         参数保留在浏览器历史中。                                              参数不会保存在浏览器历史中。\n对数据长度的限制   是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048   无限制。\n           个字符）。\n对数据类型的限制   只允许 ASCII 字符。                                             没有限制。也允许二进制数据。\n安全性        与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。                  在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web\n                                                                     服务器日志中。\n可见性        数据在 URL 中对所有人都是可见的。                                       数据不会显示在 URL 中。\n\n\n# 其他 HTTP 请求方法\n\n下面的表格列出了其他一些 HTTP 请求方法：\n\n方法        描述\nHEAD      与 GET 相同，但只返回 HTTP 报头，不返回文档主体。\nPUT       上传指定的 URI 表示。\nDELETE    删除指定资源。\nOPTIONS   返回服务器支持的 HTTP 方法。\nCONNECT   把请求连接转换到透明的 TCP/IP 通道。",normalizedContent:"# 什么是 http ？\n\n超文本传输协议（http）的设计目的是保证客户端与服务器之间的通信。\n\nhttp 的工作方式是客户端与服务器之间的请求-应答协议。\n\nweb 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。\n\n举例：客户端（浏览器）向服务器提交 http 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。\n\n\n# 两种 http 请求方法：get 和 post\n\n在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：get 和 post。\n\n * get - 从指定的资源请求数据。\n * post - 向指定的资源提交要被处理的数据。 get 提交参数一般显示在 url 上，post 通过表单提交不会显示在 url 上，post 更具隐蔽性：\n\n\n\n\n# get 方法\n\n请注意，查询字符串（名称/值对）是在 get 请求的 url 中发送的：\n\n/test/demo_form.php?name1=value1&name2=value2\n\n\n1\n\n\n有关 get 请求的其他一些注释：\n\n * get 请求可被缓存\n * get 请求保留在浏览器历史记录中\n * get 请求可被收藏为书签\n * get 请求不应在处理敏感数据时使用\n * get 请求有长度限制\n * get 请求只应当用于取回数据\n\n\n# post 方法\n\n请注意，查询字符串（名称/值对）是在 post 请求的 http 消息主体中发送的：\n\npost /test/demo_form.php http/1.1\nhost: runoob.com\nname1=value1&name2=value2\n\n\n1\n2\n3\n\n\n有关 post 请求的其他一些注释：\n\n * post 请求不会被缓存\n * post 请求不会保留在浏览器历史记录中\n * post 不能被收藏为书签\n * post 请求对数据长度没有要求\n\n\n# 比较 get 与 post\n\n下面的表格比较了两种 http 方法：get 和 post。\n\n           get                                                       post\n后退按钮/刷新    无害                                                        数据会被重新提交（浏览器应该告知用户数据会被重新提交）。\n书签         可收藏为书签                                                    不可收藏为书签\n缓存         能被缓存                                                      不能缓存\n编码类型       application/x-www-form-urlencoded                         application/x-www-form-urlencoded or\n                                                                     multipart/form-data。为二进制数据使用多重编码。\n历史         参数保留在浏览器历史中。                                              参数不会保存在浏览器历史中。\n对数据长度的限制   是的。当发送数据时，get 方法向 url 添加数据；url 的长度是受限制的（url 的最大长度是 2048   无限制。\n           个字符）。\n对数据类型的限制   只允许 ascii 字符。                                             没有限制。也允许二进制数据。\n安全性        与 post 相比，get 的安全性较差，因为所发送的数据是 url 的一部分。                  在发送密码或其他敏感信息时绝不要使用 get ！ post 比 get 更安全，因为参数不会被保存在浏览器历史或 web\n                                                                     服务器日志中。\n可见性        数据在 url 中对所有人都是可见的。                                       数据不会显示在 url 中。\n\n\n# 其他 http 请求方法\n\n下面的表格列出了其他一些 http 请求方法：\n\n方法        描述\nhead      与 get 相同，但只返回 http 报头，不返回文档主体。\nput       上传指定的 uri 表示。\ndelete    删除指定资源。\noptions   返回服务器支持的 http 方法。\nconnect   把请求连接转换到透明的 tcp/ip 通道。",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"TCP 怎么保证可靠传输",frontmatter:{title:"TCP 怎么保证可靠传输",date:"2022-09-21T22:34:41.000Z",permalink:"/pages/5fcc49/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/040.TCP%20%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.html",relativePath:"02.计算机基础/10.计算机网络/040.TCP 怎么保证可靠传输.md",key:"v-5047727f",path:"/pages/5fcc49/",headersStr:null,content:"TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。\n\n一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：\n\n\n\n其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：\n\n\n\n其中 RTTd 为偏差的加权平均值。\n\n参考： TCP 可靠传输",normalizedContent:"tcp 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。\n\n一个报文段从发送再到接收到确认所经过的时间称为往返时间 rtt，加权平均往返时间 rtts 计算如下：\n\n\n\n其中，0 ≤ a ＜ 1，rtts 随着 a 的增加更容易受到 rtt 的影响。 超时时间 rto 应该略大于 rtts，tcp 使用的超时时间计算如下：\n\n\n\n其中 rttd 为偏差的加权平均值。\n\n参考： tcp 可靠传输",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"什么是 TCP 粘包和拆包？",frontmatter:{title:"什么是 TCP 粘包和拆包？",date:"2022-09-21T22:35:01.000Z",permalink:"/pages/2822ac/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/050.%E4%BB%80%E4%B9%88%E6%98%AF%20TCP%20%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/050.什么是 TCP 粘包和拆包？.md",key:"v-feb79e02",path:"/pages/2822ac/",headers:[{level:2,title:"TCP粘包与拆包",slug:"tcp粘包与拆包",normalizedTitle:"tcp粘包与拆包",charIndex:2},{level:2,title:"粘包和拆包原因",slug:"粘包和拆包原因",normalizedTitle:"粘包和拆包原因",charIndex:510},{level:2,title:"粘包和拆包解决策略",slug:"粘包和拆包解决策略",normalizedTitle:"粘包和拆包解决策略",charIndex:704},{level:2,title:"粘包的概念",slug:"粘包的概念",normalizedTitle:"粘包的概念",charIndex:985},{level:2,title:"出现粘包的原因",slug:"出现粘包的原因",normalizedTitle:"出现粘包的原因",charIndex:1173},{level:2,title:"粘包的处理方式",slug:"粘包的处理方式",normalizedTitle:"粘包的处理方式",charIndex:1711}],headersStr:"TCP粘包与拆包 粘包和拆包原因 粘包和拆包解决策略 粘包的概念 出现粘包的原因 粘包的处理方式",content:"# TCP粘包与拆包\n\nTCP是个“流”协议，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。\n\n\n\n假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。\n\n（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；\n\n（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；\n\n（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；\n\n（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。\n\n如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。\n\n\n# 粘包和拆包原因\n\n（1）要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；\n\n（2）接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；\n\n（3）要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；\n\n（4）待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。\n\n\n# 粘包和拆包解决策略\n\n由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：\n\n消息定长。发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。\n\n设置消息边界。服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如FTP协议。\n\n将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。 更复杂的应用层协议。\n\n\n# 粘包的概念\n\n粘包：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。\n\n比如说：发送方发送了两个数据，接收方一次收了一个半数据（接收方可能不清楚一个包有多大）\n\n\n\n\n# 出现粘包的原因\n\n出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。\n\n发送方引起的粘包是由TCP协议本身造成的：\n\nTCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。\n\n\n\nTCP协议规定有MSS，如果数据包过长就会被分开传输。这样接收方就收到了拆包数据。\n\n\n\n接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。\n\n在代码中常见体现：\n\n要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。\n\n要发送的数据大于MSS，TCP在传输前将进行拆包。\n\n要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。\n\n接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 等等。\n\n\n# 粘包的处理方式\n\n当短连接的情况下，不用考虑粘包的情况\n\n如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包\n\n如果双方建立长连接，需要在连接后一段时间内发送不同结构数据\n\n发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。\n\n发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。\n\n可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。",normalizedContent:"# tcp粘包与拆包\n\ntcp是个“流”协议，没有界限的一串数据。tcp底层并不了解上层业务数据的具体含义，它会根据tcp缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被tcp拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的tcp粘包和拆包问题。\n\n\n\n假设客户端分别发送了两个数据包d1和d2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。\n\n（1）服务端分两次读取到了两个独立的数据包，分别是d1和d2，没有粘包和拆包；\n\n（2）服务端一次接收到了两个数据包，d1和d2粘合在一起，被称为tcp粘包；\n\n（3）服务端分两次读取到了两个数据包，第一次读取到了完整的d1包和d2包的部分内容，第二次读取到了d2包的剩余内容，这被称为tcp拆包；\n\n（4）服务端分两次读取到了两个数据包，第一次读取到了d1包的部分内容d1_1，第二次读取到了d1包的剩余内容d1_2和d2包的整包。\n\n如果此时服务端tcp接收滑窗非常小，而数据包d1和d2比较大，很有可能会发生第五种可能，即服务端分多次才能将d1和d2包接收完全，期间发生多次拆包。\n\n\n# 粘包和拆包原因\n\n（1）要发送的数据小于tcp发送缓冲区的大小，tcp将多次写入缓冲区的数据一次发送出去，将会发生粘包；\n\n（2）接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；\n\n（3）要发送的数据大于tcp发送缓冲区剩余空间大小，将会发生拆包；\n\n（4）待发送数据大于mss（最大报文长度），tcp在传输前将进行拆包。即tcp报文长度-tcp头部长度>mss。\n\n\n# 粘包和拆包解决策略\n\n由于底层的tcp无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：\n\n消息定长。发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。\n\n设置消息边界。服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如ftp协议。\n\n将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。 更复杂的应用层协议。\n\n\n# 粘包的概念\n\n粘包：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。\n\n比如说：发送方发送了两个数据，接收方一次收了一个半数据（接收方可能不清楚一个包有多大）\n\n\n\n\n# 出现粘包的原因\n\n出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。\n\n发送方引起的粘包是由tcp协议本身造成的：\n\ntcp为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常tcp会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。\n\n\n\ntcp协议规定有mss，如果数据包过长就会被分开传输。这样接收方就收到了拆包数据。\n\n\n\n接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。\n\n在代码中常见体现：\n\n要发送的数据大于tcp发送缓冲区剩余空间大小，将会发生拆包。\n\n要发送的数据大于mss，tcp在传输前将进行拆包。\n\n要发送的数据小于tcp发送缓冲区的大小，tcp将多次写入缓冲区的数据一次发送出去，将会发生粘包。\n\n接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 等等。\n\n\n# 粘包的处理方式\n\n当短连接的情况下，不用考虑粘包的情况\n\n如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包\n\n如果双方建立长连接，需要在连接后一段时间内发送不同结构数据\n\n发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。\n\n发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。\n\n可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"简述 HTTPS 的加密与认证过程",frontmatter:{title:"简述 HTTPS 的加密与认证过程",date:"2022-09-21T22:35:16.000Z",permalink:"/pages/12c0cc/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/060.%E7%AE%80%E8%BF%B0%20HTTPS%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.html",relativePath:"02.计算机基础/10.计算机网络/060.简述 HTTPS 的加密与认证过程.md",key:"v-3890e0b4",path:"/pages/12c0cc/",headers:[{level:2,title:"HTTPS 协议优点",slug:"https-协议优点",normalizedTitle:"https 协议优点",charIndex:2},{level:2,title:"HTTPS 的核心—SSL/TLS协议",slug:"https-的核心-ssl-tls协议",normalizedTitle:"https 的核心—ssl/tls协议",charIndex:29},{level:2,title:"SSL 和 TLS 的区别？",slug:"ssl-和-tls-的区别",normalizedTitle:"ssl 和 tls 的区别？",charIndex:150},{level:2,title:"SSL/TLS 的工作原理",slug:"ssl-tls-的工作原理",normalizedTitle:"ssl/tls 的工作原理",charIndex:131},{level:3,title:"非对称加密",slug:"非对称加密",normalizedTitle:"非对称加密",charIndex:474},{level:3,title:"对称加密",slug:"对称加密",normalizedTitle:"对称加密",charIndex:475},{level:3,title:"公钥传输的信赖性",slug:"公钥传输的信赖性",normalizedTitle:"公钥传输的信赖性",charIndex:1626},{level:3,title:"数字签名",slug:"数字签名",normalizedTitle:"数字签名",charIndex:2381}],headersStr:"HTTPS 协议优点 HTTPS 的核心—SSL/TLS协议 SSL 和 TLS 的区别？ SSL/TLS 的工作原理 非对称加密 对称加密 公钥传输的信赖性 数字签名",content:"# HTTPS 协议优点\n\n保密性好、信任度高。\n\n\n# HTTPS 的核心—SSL/TLS协议\n\nHTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。\n\n\n# SSL 和 TLS 的区别？\n\nSSL 和 TLS 没有太大的区别。\n\nSSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，新版本被命名为 TLS 1.0。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL/TLS。\n\n\n# SSL/TLS 的工作原理\n\n\n# 非对称加密\n\nSSL/TLS 的核心要素是非对称加密。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，\n\n> 在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。 但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。 这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。\n\n\n\n非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。\n\n> 单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。 单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。\n\n\n\n上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。\n\n在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。\n\n\n# 对称加密\n\n使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。\n\n> 对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。\n\n\n\n对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？ 因为对称加密的保密性完全依赖于密钥的保密性。 在双方通信之前，需要商量一个用于对称加密的密钥。 我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。 因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。 这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中， 使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。\n\n\n# 公钥传输的信赖性\n\nSSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：\n\n> 客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：\n\n> 1.任何人都可以捕获通信包\n> \n> 2.通信包的保密性由发送者设计\n> \n> 3.保密算法设计方案默认为公开，而（解密）密钥默认是安全的\n> \n> 因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。\n\n同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！\n\n\n\n为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的电子签名。\n\n当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。\n\n\n# 数字签名\n\n好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 靠数字签名技术 。\n\n数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：\n\n> CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。\n\n> 现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。\n\n> 客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。\n\n\n\n总结来说，带有证书的公钥传输机制如下：\n\n 1. 设有服务器 S，客户端 C，和第三方信赖机构 CA。\n 2. S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。\n 3. S 获得 CA 颁发的证书，将该证书传递给 C。\n 4. C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。\n 5. 如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。\n\n\n\n对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看数字签名及数字证书原理 这个视频，这是我看过最清晰的讲解。\n\n",normalizedContent:"# https 协议优点\n\n保密性好、信任度高。\n\n\n# https 的核心—ssl/tls协议\n\nhttps 之所以能达到较高的安全性要求，就是结合了 ssl/tls 和 tcp 协议，对通信数据进行加密，解决了 http 数据透明的问题。接下来重点介绍一下 ssl/tls 的工作原理。\n\n\n# ssl 和 tls 的区别？\n\nssl 和 tls 没有太大的区别。\n\nssl 指安全套接字协议（secure sockets layer），首次发布与 1996 年。ssl 的首次发布其实已经是他的 3.0 版本，ssl 1.0 从未面世，ssl 2.0 则具有较大的缺陷（drown 缺陷——decrypting rsa with obsolete and weakened encryption）。很快，在 1999 年，ssl 3.0 进一步升级，新版本被命名为 tls 1.0。因此，tls 是基于 ssl 之上的，但由于习惯叫法，通常把 https 中的核心加密协议混成为 ssl/tls。\n\n\n# ssl/tls 的工作原理\n\n\n# 非对称加密\n\nssl/tls 的核心要素是非对称加密。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，\n\n> 在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。 但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。 这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。\n\n\n\n非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。\n\n> 单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。 单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。\n\n\n\n上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。\n\n在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。\n\n\n# 对称加密\n\n使用 ssl/tls 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，ssl/tls 实际对消息的加密使用的是对称加密。\n\n> 对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。\n\n\n\n对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 ssl/tls 还需要使用非对称加密呢？ 因为对称加密的保密性完全依赖于密钥的保密性。 在双方通信之前，需要商量一个用于对称加密的密钥。 我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。 因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。 这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中， 使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。\n\n\n# 公钥传输的信赖性\n\nssl/tls 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：\n\n> 客户端 c 和服务器 s 想要使用 ssl/tls 通信，由上述 ssl/tls 通信原理，c 需要先知道 s 的公钥，而 s 公钥的唯一获取途径，就是把 s 公钥在网络信道中传输。要注意网络信道通信中有几个前提：\n\n> 1.任何人都可以捕获通信包\n> \n> 2.通信包的保密性由发送者设计\n> \n> 3.保密算法设计方案默认为公开，而（解密）密钥默认是安全的\n> \n> 因此，假设 s 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 a，发送给 c 一个诈包，假装是 s 公钥，其实是诱饵服务器 as 的公钥。当 c 收获了 as 的公钥（却以为是 s 的公钥），c 后续就会使用 as 公钥对数据进行加密，并在公开信道传输，那么 a 将捕获这些加密包，用 as 的私钥解密，就截获了 c 本要给 s 发送的内容，而 c 和 s 二人全然不知。\n\n同样的，s 公钥即使做加密，也难以避免这种信任性问题，c 被 as 拐跑了！\n\n\n\n为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（ca，certificate authority）。ca 默认是受信任的第三方。ca 会给各个服务器颁发证书，证书存储在服务器上，并附有 ca 的电子签名。\n\n当客户端（浏览器）向服务器发送 https 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。\n\n\n# 数字签名\n\n好，到这一小节，已经是 ssl/tls 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 ca 之所以能被信赖，就是 靠数字签名技术 。\n\n数字签名，是 ca 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：\n\n> ca 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。ca 使用 ca 私钥对该摘要进行加密，并附在证书下方，发送给服务器。\n\n> 现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 ca，获知 ca 的公钥，并用 ca 公钥对证书的签名进行解密，获得了 ca 生成的摘要。\n\n> 客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。\n\n\n\n总结来说，带有证书的公钥传输机制如下：\n\n 1. 设有服务器 s，客户端 c，和第三方信赖机构 ca。\n 2. s 信任 ca，ca 是知道 s 公钥的，ca 向 s 颁发证书。并附上 ca 私钥对消息摘要的加密签名。\n 3. s 获得 ca 颁发的证书，将该证书传递给 c。\n 4. c 获得 s 的证书，信任 ca 并知晓 ca 公钥，使用 ca 公钥对 s 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 s 证书的真实性。\n 5. 如果 c 验证 s 证书是真实的，则信任 s 的公钥（在 s 证书中）。\n\n\n\n对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看数字签名及数字证书原理 这个视频，这是我看过最清晰的讲解。\n\n",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？",frontmatter:{title:"TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？",date:"2022-09-21T22:35:48.000Z",permalink:"/pages/cc4b24/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/080.TCP%20%E4%B8%8E%20UDP%20%E5%9C%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/080.TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？.md",key:"v-c0c0e5c8",path:"/pages/cc4b24/",headers:[{level:2,title:"TCP 与 UDP 的区别（重要）",slug:"tcp-与-udp-的区别-重要",normalizedTitle:"tcp 与 udp 的区别（重要）",charIndex:2},{level:2,title:"什么时候选择 TCP,什么时候选 UDP?",slug:"什么时候选择-tcp-什么时候选-udp",normalizedTitle:"什么时候选择 tcp,什么时候选 udp?",charIndex:907},{level:2,title:"HTTP 基于 TCP 还是 UDP？",slug:"http-基于-tcp-还是-udp",normalizedTitle:"http 基于 tcp 还是 udp？",charIndex:1063},{level:2,title:"使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?",slug:"使用-tcp-的协议有哪些-使用-udp-的协议有哪些",normalizedTitle:"使用 tcp 的协议有哪些?使用 udp 的协议有哪些?",charIndex:1147}],headersStr:"TCP 与 UDP 的区别（重要） 什么时候选择 TCP,什么时候选 UDP? HTTP 基于 TCP 还是 UDP？ 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?",content:"# TCP 与 UDP 的区别（重要）\n\n 1. 是否面向连接 ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。\n 2. 是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。\n 3. 是否有状态 ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。\n 4. 传输效率 ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。\n 5. 传输形式 ： TCP 是面向字节流的，UDP 是面向报文的。\n 6. 首部开销 ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。\n 7. 是否提供广播或多播服务 ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多； ...... 我把上面总结的内容通过表格形式展示出来了！\n\n              TCP             UDP\n是否面向连接        是               否\n是否可靠          是               否\n是否有状态         是               否\n传输效率          较慢              较快\n传输形式          字节流             数据报文段\n首部开销          20 ～ 60 bytes   8 bytes\n是否提供广播或多播服务   否               是\n\n\n# 什么时候选择 TCP,什么时候选 UDP?\n\n * UDP 一般用于即时通信，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。\n * TCP 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等。\n\n\n# HTTP 基于 TCP 还是 UDP？\n\nHTTP 协议是基于 TCP 协议的，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。\n\n\n# 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?\n\n运行于 TCP 协议之上的协议 ：\n\n 1. HTTP 协议 ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。\n\n 2. HTTPS 协议 ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议\n\n 3. FTP 协议：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。\n\n 4. SMTP 协议：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。\n\n 5. POP3/IMAP 协议： POP3 和 IMAP 两者都是负责邮件接收的协议。\n\n 6. Telent 协议：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。\n\n 7. SSH 协议 : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。 ...... 运行于 UDP 协议之上的协议 ：\n\n 8. DHCP 协议：动态主机配置协议，动态配置 IP 地址\n\n 9. DNS ： 域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。",normalizedContent:"# tcp 与 udp 的区别（重要）\n\n 1. 是否面向连接 ：udp 在传送数据之前不需要先建立连接。而 tcp 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。\n 2. 是否是可靠传输：远地主机在收到 udp 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。tcp 提供可靠的传输服务，tcp 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 tcp 连接传输的数据，无差错、不丢失、不重复、并且按序到达。\n 3. 是否有状态 ：这个和上面的“是否可靠传输”相对应。tcp 传输是有状态的，这个有状态说的是 tcp 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，tcp 需要维持复杂的连接状态表。而 udp 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。\n 4. 传输效率 ：由于使用 tcp 进行传输的时候多了连接、确认、重传等机制，所以 tcp 的传输效率要比 udp 低很多。\n 5. 传输形式 ： tcp 是面向字节流的，udp 是面向报文的。\n 6. 首部开销 ：tcp 首部开销（20 ～ 60 字节）比 udp 首部开销（8 字节）要大。\n 7. 是否提供广播或多播服务 ：tcp 只支持点对点通信，udp 支持一对一、一对多、多对一、多对多； ...... 我把上面总结的内容通过表格形式展示出来了！\n\n              tcp             udp\n是否面向连接        是               否\n是否可靠          是               否\n是否有状态         是               否\n传输效率          较慢              较快\n传输形式          字节流             数据报文段\n首部开销          20 ～ 60 bytes   8 bytes\n是否提供广播或多播服务   否               是\n\n\n# 什么时候选择 tcp,什么时候选 udp?\n\n * udp 一般用于即时通信，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。\n * tcp 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等。\n\n\n# http 基于 tcp 还是 udp？\n\nhttp 协议是基于 tcp 协议的，所以发送 http 请求之前首先要建立 tcp 连接也就是要经历 3 次握手。\n\n\n# 使用 tcp 的协议有哪些?使用 udp 的协议有哪些?\n\n运行于 tcp 协议之上的协议 ：\n\n 1. http 协议 ：超文本传输协议（http，hypertext transfer protocol)主要是为 web 浏览器与 web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 http 请求进行加载的。\n\n 2. https 协议 ：更安全的超文本传输协议(https,hypertext transfer protocol secure)，身披 ssl 外衣的 http 协议\n\n 3. ftp 协议：文件传输协议 ftp（file transfer protocol），提供文件传输服务，基于 tcp 实现可靠的传输。使用 ftp 传输文件的好处是可以屏蔽操作系统和文件存储方式。\n\n 4. smtp 协议：简单邮件传输协议（smtp，simple mail transfer protocol）的缩写，基于 tcp 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 smtp 而是 pop3 协议。\n\n 5. pop3/imap 协议： pop3 和 imap 两者都是负责邮件接收的协议。\n\n 6. telent 协议：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 ssh 的非常安全的协议所取代。\n\n 7. ssh 协议 : ssh（ secure shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 ssh 协议可以有效防止远程管理过程中的信息泄露问题。ssh 建立在可靠的传输协议 tcp 之上。 ...... 运行于 udp 协议之上的协议 ：\n\n 8. dhcp 协议：动态主机配置协议，动态配置 ip 地址\n\n 9. dns ： 域名系统（dns，domain name system）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 ip 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 dns 同时支持 udp 和 tcp 协议。",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"如何解决 TCP 传输丢包问题？",frontmatter:{title:"如何解决 TCP 传输丢包问题？",date:"2022-09-21T22:36:03.000Z",permalink:"/pages/a656a9/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/090.%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%20TCP%20%E4%BC%A0%E8%BE%93%E4%B8%A2%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/090.如何解决 TCP 传输丢包问题？.md",key:"v-aa8887a4",path:"/pages/a656a9/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"简述对称与非对称加密的概念",frontmatter:{title:"简述对称与非对称加密的概念",date:"2022-09-21T22:35:34.000Z",permalink:"/pages/057092/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/070.%E7%AE%80%E8%BF%B0%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E6%A6%82%E5%BF%B5.html",relativePath:"02.计算机基础/10.计算机网络/070.简述对称与非对称加密的概念.md",key:"v-eb417bbe",path:"/pages/057092/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"TCP 长连接和短连接有那么不同的使用场景？",frontmatter:{title:"TCP 长连接和短连接有那么不同的使用场景？",date:"2022-09-21T22:36:19.000Z",permalink:"/pages/dda19e/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/100.TCP%20%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E6%9C%89%E9%82%A3%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/100.TCP 长连接和短连接有那么不同的使用场景？.md",key:"v-f886ba80",path:"/pages/dda19e/",headers:[{level:2,title:"前提：",slug:"前提",normalizedTitle:"前提：",charIndex:2},{level:2,title:"定义：",slug:"定义",normalizedTitle:"定义：",charIndex:125},{level:3,title:"优缺点：",slug:"优缺点",normalizedTitle:"优缺点：",charIndex:338},{level:3,title:"使用场景：",slug:"使用场景",normalizedTitle:"使用场景：",charIndex:504}],headersStr:"前提： 定义： 优缺点： 使用场景：",content:"# 前提：\n\nHTTP/1.0默认使用短连接，HTTP/1.1开始默认使用长连接；\n\nHTTP协议的长连接和短连接，实质就是TCP协议的长连接和短连接；\n\nTCP协议建立连接需要3次握手，断开连接需要4次握手，这个过程会消耗网络资源和时间；\n\n\n# 定义：\n\n * 长连接：在一个TCP连接上可以发送多个数据包，但是如果没有数据包发送时，也要双方发检测包以维持这个长连接；三次握手后连接，不断开连接，保持客户端和服务端通信，直到服务器超时自动断开连接，或者客户端主动断开连接。\n * 短连接：当双方需要数据交互的时候，就建立一个TCP连接，本次交互完之后就断开这个连接；三次握手后建立连接，发送数据包并得到服务器返回的结果后，通过客户端和服务器的四次握手后断开连接。\n\n\n# 优缺点：\n\n长连接可以省去较多建立连接和断开连接的操作，所以比较节省资源和时间，但是长连接如果一直存在的话，需要很多探测包的发送来维持这个连接，这对服务器将是很大的负担； 相对而言，短连接不需要服务器承担太大负担，只要存在的连接就是有用的连接，但如果客户端请求频繁，就会在TCP的建立连接和断开连接上浪费较大的资源和时间。\n\n\n# 使用场景：\n\n短连接：适用于网页浏览等数据刷新频度较低的场景。一般而言像及京东，淘宝这些大型网站，随时都会有成千上万的用户请求，一般使用短连接，用户量太大，服务器扛不住那么多长连接； 长连接：适用于客户端和服务端通信频繁的场景，例如：聊天室，实时游戏等场景。即时通讯（QQ）般使用的都是长连接，但并不是永久连接（比如20分钟，半个小时），因为即时通讯是频繁的发送请求，使用长连接只需要建立一次连接，同时再根据业务设置保持时间，超过这个时间就会断开连接，一定程度上保证了服务器的压力不会过大。\n\n##Socket心跳包机制： 像心跳一样，每隔固定时间向服务器发送一个包，以此来告诉服务器，这个客户端还活着。为了保持长连接，一般都是很小的包（节约流量）或者只有包头的空包。 1.客户端每隔一段时间间隔就发送一个探测包给服务器； 2.客户端发包时启动一个超时定时器； 3.服务端接收到探测包后会回应一个包； 4.如果客户端收到服务器的应答包，则说明服务器正常，删除超时定时器；如果没有收到则服务器异常。 ———————————————— 版权声明：本文为CSDN博主「测试小明」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/Dave0002/article/details/125973214",normalizedContent:"# 前提：\n\nhttp/1.0默认使用短连接，http/1.1开始默认使用长连接；\n\nhttp协议的长连接和短连接，实质就是tcp协议的长连接和短连接；\n\ntcp协议建立连接需要3次握手，断开连接需要4次握手，这个过程会消耗网络资源和时间；\n\n\n# 定义：\n\n * 长连接：在一个tcp连接上可以发送多个数据包，但是如果没有数据包发送时，也要双方发检测包以维持这个长连接；三次握手后连接，不断开连接，保持客户端和服务端通信，直到服务器超时自动断开连接，或者客户端主动断开连接。\n * 短连接：当双方需要数据交互的时候，就建立一个tcp连接，本次交互完之后就断开这个连接；三次握手后建立连接，发送数据包并得到服务器返回的结果后，通过客户端和服务器的四次握手后断开连接。\n\n\n# 优缺点：\n\n长连接可以省去较多建立连接和断开连接的操作，所以比较节省资源和时间，但是长连接如果一直存在的话，需要很多探测包的发送来维持这个连接，这对服务器将是很大的负担； 相对而言，短连接不需要服务器承担太大负担，只要存在的连接就是有用的连接，但如果客户端请求频繁，就会在tcp的建立连接和断开连接上浪费较大的资源和时间。\n\n\n# 使用场景：\n\n短连接：适用于网页浏览等数据刷新频度较低的场景。一般而言像及京东，淘宝这些大型网站，随时都会有成千上万的用户请求，一般使用短连接，用户量太大，服务器扛不住那么多长连接； 长连接：适用于客户端和服务端通信频繁的场景，例如：聊天室，实时游戏等场景。即时通讯（qq）般使用的都是长连接，但并不是永久连接（比如20分钟，半个小时），因为即时通讯是频繁的发送请求，使用长连接只需要建立一次连接，同时再根据业务设置保持时间，超过这个时间就会断开连接，一定程度上保证了服务器的压力不会过大。\n\n##socket心跳包机制： 像心跳一样，每隔固定时间向服务器发送一个包，以此来告诉服务器，这个客户端还活着。为了保持长连接，一般都是很小的包（节约流量）或者只有包头的空包。 1.客户端每隔一段时间间隔就发送一个探测包给服务器； 2.客户端发包时启动一个超时定时器； 3.服务端接收到探测包后会回应一个包； 4.如果客户端收到服务器的应答包，则说明服务器正常，删除超时定时器；如果没有收到则服务器异常。 ———————————————— 版权声明：本文为csdn博主「测试小明」的原创文章，遵循cc 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/dave0002/article/details/125973214",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"TCP 中常见的拥塞控制算法有哪些？",frontmatter:{title:"TCP 中常见的拥塞控制算法有哪些？",date:"2022-09-21T22:37:12.000Z",permalink:"/pages/9ccc31/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/130.TCP%20%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/130.TCP 中常见的拥塞控制算法有哪些？.md",key:"v-75f6731c",path:"/pages/9ccc31/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"简述 HTTP 1.0，1.1，2.0 的主要区别",frontmatter:{title:"简述 HTTP 1.0，1.1，2.0 的主要区别",date:"2022-09-21T22:37:24.000Z",permalink:"/pages/f50b70/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/140.%E7%AE%80%E8%BF%B0%20HTTP%201.0%EF%BC%8C1.1%EF%BC%8C2.0%20%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%20.html",relativePath:"02.计算机基础/10.计算机网络/140.简述 HTTP 1.0，1.1，2.0 的主要区别 .md",key:"v-f8f98912",path:"/pages/f50b70/",headers:[{level:2,title:"1 HTTP1.0和HTTP1.1的区别",slug:"_1-http1-0和http1-1的区别",normalizedTitle:"1 http1.0和http1.1的区别",charIndex:2},{level:3,title:"1.1 长连接(Persistent Connection)",slug:"_1-1-长连接-persistent-connection",normalizedTitle:"1.1 长连接(persistent connection)",charIndex:27},{level:3,title:"1.2 节约带宽",slug:"_1-2-节约带宽",normalizedTitle:"1.2 节约带宽",charIndex:227},{level:3,title:"1.3 HOST域",slug:"_1-3-host域",normalizedTitle:"1.3 host域",charIndex:427},{level:3,title:"1.4缓存处理",slug:"_1-4缓存处理",normalizedTitle:"1.4缓存处理",charIndex:658},{level:3,title:"1.5错误通知的管理",slug:"_1-5错误通知的管理",normalizedTitle:"1.5错误通知的管理",charIndex:829},{level:2,title:"2 HTTP1.1和HTTP2.0的区别",slug:"_2-http1-1和http2-0的区别",normalizedTitle:"2 http1.1和http2.0的区别",charIndex:935},{level:3,title:"2.1 多路复用",slug:"_2-1-多路复用",normalizedTitle:"2.1 多路复用",charIndex:960},{level:3,title:"2.2 头部数据压缩",slug:"_2-2-头部数据压缩",normalizedTitle:"2.2 头部数据压缩",charIndex:1091},{level:3,title:"2.3 服务器推送",slug:"_2-3-服务器推送",normalizedTitle:"2.3 服务器推送",charIndex:1389}],headersStr:"1 HTTP1.0和HTTP1.1的区别 1.1 长连接(Persistent Connection) 1.2 节约带宽 1.3 HOST域 1.4缓存处理 1.5错误通知的管理 2 HTTP1.1和HTTP2.0的区别 2.1 多路复用 2.2 头部数据压缩 2.3 服务器推送",content:"# 1 HTTP1.0和HTTP1.1的区别\n\n\n# 1.1 长连接(Persistent Connection)\n\n   HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。\n\n\n\n# 1.2 节约带宽\n\n   HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。\n\n\n\n# 1.3 HOST域\n\n   在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。\n\n\n\n# 1.4缓存处理\n\n   在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n\n\n\n# 1.5错误通知的管理\n\n   在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n\n\n\n# 2 HTTP1.1和HTTP2.0的区别\n\n\n# 2.1 多路复用\n\n   HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。\n\n\n\n# 2.2 头部数据压缩\n\n   在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。\n\n   HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。\n\n\n\n# 2.3 服务器推送\n\n   服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。\n\n   为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。\n\n\n参考： HTTP1.0、HTTP1.1 和 HTTP2.0 的区别",normalizedContent:"# 1 http1.0和http1.1的区别\n\n\n# 1.1 长连接(persistent connection)\n\n   http1.1支持长连接和请求的流水线处理，在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟，在http1.1中默认开启长连接keep-alive，一定程度上弥补了http1.0每次请求都要创建连接的缺点。http1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。\n\n\n\n# 1.2 节约带宽\n\n   http1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。http1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。\n\n\n\n# 1.3 host域\n\n   在http1.0中认为每台服务器都绑定一个唯一的ip地址，因此，请求消息中的url并没有传递主机名（hostname），http1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（multi-homed web servers），并且它们共享一个ip地址。http1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 bad request）。\n\n\n\n# 1.4缓存处理\n\n   在http1.0中主要使用header里的if-modified-since,expires来做为缓存判断的标准，http1.1则引入了更多的缓存控制策略例如entity tag，if-unmodified-since, if-match, if-none-match等更多可供选择的缓存头来控制缓存策略。\n\n\n\n# 1.5错误通知的管理\n\n   在http1.1中新增了24个错误状态响应码，如409（conflict）表示请求的资源与资源的当前状态发生冲突；410（gone）表示服务器上的某个资源被永久性的删除。\n\n\n\n# 2 http1.1和http2.0的区别\n\n\n# 2.1 多路复用\n\n   http2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比http1.1大了好几个数量级。http1.1也可以多建立几个tcp连接，来支持处理更多并发的请求，但是创建tcp连接本身也是有开销的。\n\n\n\n# 2.2 头部数据压缩\n\n   在http1.1中，http请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输useragent、cookie这类不会频繁变动的内容，完全是一种浪费。\n\n   http1.1不支持header数据的压缩，http2.0使用hpack算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。\n\n\n\n# 2.3 服务器推送\n\n   服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：html、样式表、脚本、图片等等。在http1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取html开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。\n\n   为了改善延迟，http2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。\n\n\n参考： http1.0、http1.1 和 http2.0 的区别",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"HTTP 与 HTTPS 有哪些区别？",frontmatter:{title:"HTTP 与 HTTPS 有哪些区别？",date:"2022-09-21T22:36:56.000Z",permalink:"/pages/253334/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/120.HTTP%20%E4%B8%8E%20HTTPS%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/120.HTTP 与 HTTPS 有哪些区别？.md",key:"v-9aa2c788",path:"/pages/253334/",headers:[{level:2,title:"HTTP 协议介绍",slug:"http-协议介绍",normalizedTitle:"http 协议介绍",charIndex:2},{level:2,title:"HTTP 协议通信过程",slug:"http-协议通信过程",normalizedTitle:"http 协议通信过程",charIndex:266},{level:2,title:"HTTP 协议优点",slug:"http-协议优点",normalizedTitle:"http 协议优点",charIndex:481},{level:2,title:"HTTPS 协议",slug:"https-协议",normalizedTitle:"https 协议",charIndex:514},{level:3,title:"HTTPS 协议介绍",slug:"https-协议介绍",normalizedTitle:"https 协议介绍",charIndex:527},{level:3,title:"HTTPS 协议优点",slug:"https-协议优点",normalizedTitle:"https 协议优点",charIndex:728},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:755}],headersStr:"HTTP 协议介绍 HTTP 协议通信过程 HTTP 协议优点 HTTPS 协议 HTTPS 协议介绍 HTTPS 协议优点 总结",content:"# HTTP 协议介绍\n\nHTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。\n\n并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。\n\n\n# HTTP 协议通信过程\n\nHTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：\n\n 1. 服务器在 80 端口等待客户的请求。\n 2. 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。\n 3. 服务器接收来自浏览器的 TCP 连接。\n 4. 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。\n 5. 关闭 TCP 连接。\n\n\n# HTTP 协议优点\n\n扩展性强、速度快、跨平台支持性好。\n\n\n# HTTPS 协议\n\n\n# HTTPS 协议介绍\n\nHTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.\n\nHTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。\n\n\n# HTTPS 协议优点\n\n保密性好、信任度高。\n\n\n# 总结\n\n端口号 ：HTTP 默认是 80，HTTPS 默认是 443。 URL 前缀 ：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。 安全性和资源消耗 ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。",normalizedContent:"# http 协议介绍\n\nhttp 协议，全称超文本传输协议（hypertext transfer protocol）。顾名思义，http 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。\n\n并且，http 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。\n\n\n# http 协议通信过程\n\nhttp 是应用层协议，它以 tcp（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：\n\n 1. 服务器在 80 端口等待客户的请求。\n 2. 浏览器发起到服务器的 tcp 连接（创建套接字 socket）。\n 3. 服务器接收来自浏览器的 tcp 连接。\n 4. 浏览器（http 客户端）与 web 服务器（http 服务器）交换 http 消息。\n 5. 关闭 tcp 连接。\n\n\n# http 协议优点\n\n扩展性强、速度快、跨平台支持性好。\n\n\n# https 协议\n\n\n# https 协议介绍\n\nhttps 协议（hyper text transfer protocol secure），是 http 的加强安全版本。https 是基于 http 的，也是用 tcp 作为底层协议，并额外使用 ssl/tls 协议用作加密和安全认证。默认端口号是 443.\n\nhttps 协议中，ssl 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。\n\n\n# https 协议优点\n\n保密性好、信任度高。\n\n\n# 总结\n\n端口号 ：http 默认是 80，https 默认是 443。 url 前缀 ：http 的 url 前缀是 http://，https 的 url 前缀是 https://。 安全性和资源消耗 ： http 协议运行在 tcp 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。https 是运行在 ssl/tls 之上的 http 协议，ssl/tls 运行在 tcp 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，http 安全性没有 https 高，但是 https 比 http 耗费更多服务器资源。",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？",frontmatter:{title:"TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？",date:"2022-09-21T22:36:40.000Z",permalink:"/pages/212438/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/110.TCP%20%E7%9A%84%20keepalive%20%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%AE%83%E5%92%8C%20HTTP%20%E7%9A%84%20keepalive%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/110.TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？.md",key:"v-df71a6e0",path:"/pages/212438/",headersStr:null,content:"HTTP Keep-Alive 也叫 HTTP 长连接，该函数由应用程序实现,允许使用相同的TCP连接发送和接收多个HTTP请求/响应,减少由HTTP短途连接产生的多个TCP连接的创建和释放成本。\n\nTCP的存活者 也叫 TCP 保活机制，这个函数由内核实现,当客户和服务端在一定时间内与数据不交互时,为了确保连接仍然有效,就会发送探测报文，检查对方是否还在网上,然后决定是否关闭连接\n\n参考： 阿里一面：TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗",normalizedContent:"http keep-alive 也叫 http 长连接，该函数由应用程序实现,允许使用相同的tcp连接发送和接收多个http请求/响应,减少由http短途连接产生的多个tcp连接的创建和释放成本。\n\ntcp的存活者 也叫 tcp 保活机制，这个函数由内核实现,当客户和服务端在一定时间内与数据不交互时,为了确保连接仍然有效,就会发送探测报文，检查对方是否还在网上,然后决定是否关闭连接\n\n参考： 阿里一面：tcp 的 keepalive 和 http 的 keep-alive 是一个东西吗",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"从系统层面上，UDP如何保证尽量可靠？",frontmatter:{title:"从系统层面上，UDP如何保证尽量可靠？",date:"2022-09-21T22:37:36.000Z",permalink:"/pages/e57cfe/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/150.%E4%BB%8E%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E4%B8%8A%EF%BC%8CUDP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B0%BD%E9%87%8F%E5%8F%AF%E9%9D%A0%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/150.从系统层面上，UDP如何保证尽量可靠？.md",key:"v-63453344",path:"/pages/e57cfe/",headersStr:null,content:"基本的思想：模拟tcp的可靠机制来实现,保证四个无即可（无丢失、无失序、无错误、无重复） 可以从以下几点着手：\n\n * ①加上序号\n\n * ②确认机制，超时重传\n\n * ③校验机制，出错重传\n\n我们都知道UDP是面向无连接，不可靠的传输方式，而TCP虽然是面向连接，可靠地连接，但是其过程太繁琐，效率太低，传输速度很慢，所以我们可以利用UDP进行底层传输数据，上层进行封装，来弥补UDP的不足。 做到以下4点，就可以保证UDP协议可靠：\n\n * ①不要TCP的三次握手和四次挥手。\n\n * ②发送方每次发出的数据进行编号，同时保持顺序的正确。\n\n * ③每次接收方接收到数据，发出应答信号。同时发送方在规定的时间检测是否接收到应答，如果没有接收到应答，重发，三次后还未收到应答直接判断发送失败。\n\n * ④发送数据时，发送方增加校验位。如果接收方校验出错，请求重发。",normalizedContent:"基本的思想：模拟tcp的可靠机制来实现,保证四个无即可（无丢失、无失序、无错误、无重复） 可以从以下几点着手：\n\n * ①加上序号\n\n * ②确认机制，超时重传\n\n * ③校验机制，出错重传\n\n我们都知道udp是面向无连接，不可靠的传输方式，而tcp虽然是面向连接，可靠地连接，但是其过程太繁琐，效率太低，传输速度很慢，所以我们可以利用udp进行底层传输数据，上层进行封装，来弥补udp的不足。 做到以下4点，就可以保证udp协议可靠：\n\n * ①不要tcp的三次握手和四次挥手。\n\n * ②发送方每次发出的数据进行编号，同时保持顺序的正确。\n\n * ③每次接收方接收到数据，发出应答信号。同时发送方在规定的时间检测是否接收到应答，如果没有接收到应答，重发，三次后还未收到应答直接判断发送失败。\n\n * ④发送数据时，发送方增加校验位。如果接收方校验出错，请求重发。",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"TCP 挥手时出现大量 CLOSEWAIT 或 TIMEWAIT 怎么解决？",frontmatter:{title:"TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？",date:"2022-09-21T22:37:51.000Z",permalink:"/pages/15d37a/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/160.TCP%20%E6%8C%A5%E6%89%8B%E6%97%B6%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F%20CLOSE_WAIT%20%E6%88%96%20TIME_WAIT%20%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/160.TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？.md",key:"v-93120d3a",path:"/pages/15d37a/",headers:[{level:2,title:"由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。",slug:"由于socket是全双工的工作模式-一个socket的关闭-是需要四次握手来完成的。",normalizedTitle:"由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。",charIndex:2},{level:2,title:"time_wait 产生原因（等待2MSL意义）：",slug:"time-wait-产生原因-等待2msl意义",normalizedTitle:"time_wait 产生原因（等待2msl意义）：",charIndex:404},{level:2,title:"time_wait过多产生原因：",slug:"time-wait过多产生原因",normalizedTitle:"time_wait过多产生原因：",charIndex:762},{level:2,title:"time_wait过多解决方法：",slug:"time-wait过多解决方法",normalizedTitle:"time_wait过多解决方法：",charIndex:1178},{level:2,title:"短连接",slug:"短连接",normalizedTitle:"短连接",charIndex:882},{level:2,title:"长连接",slug:"长连接",normalizedTitle:"长连接",charIndex:1202},{level:2,title:"close_wait产生原因：",slug:"close-wait产生原因",normalizedTitle:"close_wait产生原因：",charIndex:2732},{level:2,title:"close_wait太多解决方法：",slug:"close-wait太多解决方法",normalizedTitle:"close_wait太多解决方法：",charIndex:3126}],headersStr:"由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。 time_wait 产生原因（等待2MSL意义）： time_wait过多产生原因： time_wait过多解决方法： 短连接 长连接 close_wait产生原因： close_wait太多解决方法：",content:"# 由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。\n\n主动关闭连接的一方，调用close()；协议层发送FIN包\n\n被动关闭的一方收到FIN包后，协议层回复ACK；然后被动关闭的一方，进入CLOSE_WAIT状态，主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作。\n\n被动关闭的一方在完成所有数据发送后，调用close()操作；此时，协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态；\n\n主动关闭的一方收到FIN包，协议层回复ACK；此时，主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态\n\n等待2MSL时间，如没发现重传的FIN，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态\n\n\n\n\n# time_wait 产生原因（等待2MSL意义）：\n\n假设是客户端向服务端发起断开连接\n\n为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。\n\n防止“已失效的连接请求报文段”出现在本连接中。\n\n客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\n\n# time_wait过多产生原因：\n\n正常的TCP客户端连接在关闭后，会进入一个TIME_WAIT的状态，持续的时间一般在1-4分钟，对于连接数不高的场景，1-4分钟其实并不长，对系统也不会有什么影响， 但如果短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的socket端口和文件描述符被用尽，系统无法再发起新的连接！\n\n举例来说：   假设每秒建立了1000个短连接（Web场景下是很常见的，例如每个请求都去访问memcached），假设TIME_WAIT的时间是1分钟，则1分钟内需要建立6W个短连接，由于TIME_WAIT时间是1分钟，这些短连接1分钟内都处于TIME_WAIT状态，都不会释放，而Linux默认的本地端口范围配置是：net.ipv4.ip_local_port_range = 32768 61000不到3W，因此这种情况下新的请求由于没有本地端口就不能建立了。\n\n\n# time_wait过多解决方法：\n\n1.可以改为长连接，但代价较大，长连接太多会导致服务器性能问题并且安全性也较差； 2.修改ipv4.ip_local_port_range，增大可用端口范围，但只能缓解问题，不能根本解决问题；\n\n3.客户端机器打开tcp_tw_reuse和tcp_timestamps选项；\n\n字面意思，reuse TIME_WAIT状态的连接。时刻记住一条socket连接，就是那个五元组，出现TIME_WAIT状态的连接，一定出现在主动关闭连接的一方。所以，当主动关闭连接的一方，再次向对方发起连接请求的时候（例如，客户端关闭连接，客户端再次连接服务端，此时可以复用了；负载均衡服务器，主动关闭后端的连接，当有新的HTTP请求，负载均衡服务器再次连接后端服务器，此时也可以复用），可以复用TIME_WAIT状态的连接。\n\n通过字面解释，以及例子说明，你看到了，tcp_tw_reuse应用的场景：某一方，需要不断的通过“短连接”连接其他服务器，总是自己先关闭连接(TIME_WAIT在自己这方)，关闭后又不断的重新连接对方。\n\n那么，当连接被复用了之后，延迟或者重发的数据包到达，新的连接怎么判断，到达的数据是属于复用后的连接，还是复用前的连接呢？那就需要依赖前面提到的两个时间字段了。复用连接后，这条连接的时间被更新为当前的时间，当延迟的数据达到，延迟数据的时间是小于新连接的时间，所以，内核可以通过时间判断出，延迟的数据可以安全的丢弃掉了。\n\n这个配置，依赖于连接双方，同时对timestamps的支持。同时，这个配置，仅仅影响outbound连接，即做为客户端的角色，连接服务端[connect(dest_ip, dest_port)]时复用TIME_WAIT的socket。\n\n4.客户端机器打开tcp_tw_recycle和tcp_timestamps选项；\n\n字面意思，销毁掉 TIME_WAIT。\n\n当开启了这个配置后，内核会快速的回收处于TIME_WAIT状态的socket连接。多快？不再是2MSL，而是一个RTO（retransmission timeout，数据包重传的timeout时间）的时间，这个时间根据RTT动态计算出来，但是远小于2MSL。\n\n有了这个配置，还是需要保障 丢失重传或者延迟的数据包，不会被新的连接(注意，这里不再是复用了，而是之前处于TIME_WAIT状态的连接已经被destroy掉了，新的连接，刚好是和某一个被destroy掉的连接使用了相同的五元组而已)所错误的接收。在启用该配置，当一个socket连接进入TIME_WAIT状态后，内核里会记录包括该socket连接对应的五元组中的对方IP等在内的一些统计数据，当然也包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。\n\n\n这个配置，依赖于连接双方对timestamps的支持。同时，这个配置，主要影响到了inbound的连接（对outbound的连接也有影响，但是不是复用），即做为服务端角色，客户端连进来，服务端主动关闭了连接，TIME_WAIT状态的socket处于服务端，服务端快速的回收该状态的连接。\n\n\n# 短连接\n\n连接->传输数据->关闭连接 HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。\n\n\n# 长连接\n\n连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。\n\n\n# close_wait产生原因：\n\n比如是客户端要与服务端断开连接，先发一个FIN表示自己要主动断开连接了，服务端会先回一个ACK，这时表示客户端没数据要发了，但有可能服务端数据还没发完，所以要经历一个close_wait，等待服务端数据发送完，再回一个FIN和ACK。\n\nclose_wait产生太多原因：\n\nclose_wait 按照正常操作的话应该很短暂的一个状态，接收到客户端的fin包并且回复客户端ack之后，会继续发送FIN包告知客户端关闭关闭连接，之后迁移到Last_ACK状态。但是close_wait过多只能说明没有迁移到Last_ACK，也就是服务端是否发送FIN包，只有发送FIN包才会发生迁移，所以问题定位在是否发送FIN包。FIN包的底层实现其实就是调用socket的close方法，这里的问题出在没有执行close方法。说明服务端socket忙于读写。\n\n\n# close_wait太多解决方法：\n\n代码层面做到 第一：使用完socket就调用close方法； 第二：socket读控制，当读取的长度为0时（读到结尾），立即close； 第三：如果read返回-1，出现错误，检查error返回码，有三种情况：INTR（被中断，可以继续读取），WOULDBLOCK（表示当前socket_fd文件描述符是非阻塞的，但是现在被阻塞了），AGAIN（表示现在没有数据稍后重新读取）。如果不是AGAIN，立即close 可以设置TCP的连接时长keep_alive_time还有tcp监控连接的频率以及连接没有活动多长时间被迫断开连接 ————————————————\n\n参考TCP通信过程中time_wait和close_wait产生过多的原因和解决方法",normalizedContent:"# 由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。\n\n主动关闭连接的一方，调用close()；协议层发送fin包\n\n被动关闭的一方收到fin包后，协议层回复ack；然后被动关闭的一方，进入close_wait状态，主动关闭的一方等待对方关闭，则进入fin_wait_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作。\n\n被动关闭的一方在完成所有数据发送后，调用close()操作；此时，协议层发送fin包给主动关闭的一方，等待对方的ack，被动关闭的一方进入last_ack状态；\n\n主动关闭的一方收到fin包，协议层回复ack；此时，主动关闭连接的一方，进入time_wait状态；而被动关闭的一方，进入closed状态\n\n等待2msl时间，如没发现重传的fin，主动关闭的一方，结束time_wait，进入closed状态\n\n\n\n\n# time_wait 产生原因（等待2msl意义）：\n\n假设是客户端向服务端发起断开连接\n\n为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这个ack有可能丢失，从而导致处在last-ack状态的服务器收不到对fin-ack的确认报文。服务器会超时重传这个fin-ack，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2msl，而是在发送完ack之后直接释放关闭，一但这个ack丢失的话，服务器就无法正常的进入关闭连接状态。\n\n防止“已失效的连接请求报文段”出现在本连接中。\n\n客户端在发送完最后一个ack报文段后，再经过2msl，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\n\n# time_wait过多产生原因：\n\n正常的tcp客户端连接在关闭后，会进入一个time_wait的状态，持续的时间一般在1-4分钟，对于连接数不高的场景，1-4分钟其实并不长，对系统也不会有什么影响， 但如果短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的socket端口和文件描述符被用尽，系统无法再发起新的连接！\n\n举例来说：   假设每秒建立了1000个短连接（web场景下是很常见的，例如每个请求都去访问memcached），假设time_wait的时间是1分钟，则1分钟内需要建立6w个短连接，由于time_wait时间是1分钟，这些短连接1分钟内都处于time_wait状态，都不会释放，而linux默认的本地端口范围配置是：net.ipv4.ip_local_port_range = 32768 61000不到3w，因此这种情况下新的请求由于没有本地端口就不能建立了。\n\n\n# time_wait过多解决方法：\n\n1.可以改为长连接，但代价较大，长连接太多会导致服务器性能问题并且安全性也较差； 2.修改ipv4.ip_local_port_range，增大可用端口范围，但只能缓解问题，不能根本解决问题；\n\n3.客户端机器打开tcp_tw_reuse和tcp_timestamps选项；\n\n字面意思，reuse time_wait状态的连接。时刻记住一条socket连接，就是那个五元组，出现time_wait状态的连接，一定出现在主动关闭连接的一方。所以，当主动关闭连接的一方，再次向对方发起连接请求的时候（例如，客户端关闭连接，客户端再次连接服务端，此时可以复用了；负载均衡服务器，主动关闭后端的连接，当有新的http请求，负载均衡服务器再次连接后端服务器，此时也可以复用），可以复用time_wait状态的连接。\n\n通过字面解释，以及例子说明，你看到了，tcp_tw_reuse应用的场景：某一方，需要不断的通过“短连接”连接其他服务器，总是自己先关闭连接(time_wait在自己这方)，关闭后又不断的重新连接对方。\n\n那么，当连接被复用了之后，延迟或者重发的数据包到达，新的连接怎么判断，到达的数据是属于复用后的连接，还是复用前的连接呢？那就需要依赖前面提到的两个时间字段了。复用连接后，这条连接的时间被更新为当前的时间，当延迟的数据达到，延迟数据的时间是小于新连接的时间，所以，内核可以通过时间判断出，延迟的数据可以安全的丢弃掉了。\n\n这个配置，依赖于连接双方，同时对timestamps的支持。同时，这个配置，仅仅影响outbound连接，即做为客户端的角色，连接服务端[connect(dest_ip, dest_port)]时复用time_wait的socket。\n\n4.客户端机器打开tcp_tw_recycle和tcp_timestamps选项；\n\n字面意思，销毁掉 time_wait。\n\n当开启了这个配置后，内核会快速的回收处于time_wait状态的socket连接。多快？不再是2msl，而是一个rto（retransmission timeout，数据包重传的timeout时间）的时间，这个时间根据rtt动态计算出来，但是远小于2msl。\n\n有了这个配置，还是需要保障 丢失重传或者延迟的数据包，不会被新的连接(注意，这里不再是复用了，而是之前处于time_wait状态的连接已经被destroy掉了，新的连接，刚好是和某一个被destroy掉的连接使用了相同的五元组而已)所错误的接收。在启用该配置，当一个socket连接进入time_wait状态后，内核里会记录包括该socket连接对应的五元组中的对方ip等在内的一些统计数据，当然也包括从该对方ip所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。\n\n\n这个配置，依赖于连接双方对timestamps的支持。同时，这个配置，主要影响到了inbound的连接（对outbound的连接也有影响，但是不是复用），即做为服务端角色，客户端连进来，服务端主动关闭了连接，time_wait状态的socket处于服务端，服务端快速的回收该状态的连接。\n\n\n# 短连接\n\n连接->传输数据->关闭连接 http是无状态的，浏览器和服务器每进行一次http操作，就建立一次连接，但任务结束就中断连接。 也可以这样说：短连接是指socket连接后发送后接收完数据后马上断开连接。\n\n\n# 长连接\n\n连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 长连接指建立socket连接后不管是否使用都保持连接，但安全性较差。\n\n\n# close_wait产生原因：\n\n比如是客户端要与服务端断开连接，先发一个fin表示自己要主动断开连接了，服务端会先回一个ack，这时表示客户端没数据要发了，但有可能服务端数据还没发完，所以要经历一个close_wait，等待服务端数据发送完，再回一个fin和ack。\n\nclose_wait产生太多原因：\n\nclose_wait 按照正常操作的话应该很短暂的一个状态，接收到客户端的fin包并且回复客户端ack之后，会继续发送fin包告知客户端关闭关闭连接，之后迁移到last_ack状态。但是close_wait过多只能说明没有迁移到last_ack，也就是服务端是否发送fin包，只有发送fin包才会发生迁移，所以问题定位在是否发送fin包。fin包的底层实现其实就是调用socket的close方法，这里的问题出在没有执行close方法。说明服务端socket忙于读写。\n\n\n# close_wait太多解决方法：\n\n代码层面做到 第一：使用完socket就调用close方法； 第二：socket读控制，当读取的长度为0时（读到结尾），立即close； 第三：如果read返回-1，出现错误，检查error返回码，有三种情况：intr（被中断，可以继续读取），wouldblock（表示当前socket_fd文件描述符是非阻塞的，但是现在被阻塞了），again（表示现在没有数据稍后重新读取）。如果不是again，立即close 可以设置tcp的连接时长keep_alive_time还有tcp监控连接的频率以及连接没有活动多长时间被迫断开连接 ————————————————\n\n参考tcp通信过程中time_wait和close_wait产生过多的原因和解决方法",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"简述 TCP 滑动窗口",frontmatter:{title:"简述 TCP 滑动窗口",date:"2022-09-21T22:38:09.000Z",permalink:"/pages/dae451/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/170.%E7%AE%80%E8%BF%B0%20TCP%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html",relativePath:"02.计算机基础/10.计算机网络/170.简述 TCP 滑动窗口.md",key:"v-3e902cd4",path:"/pages/dae451/",headers:[{level:2,title:"滑动窗口解决什么问题？",slug:"滑动窗口解决什么问题",normalizedTitle:"滑动窗口解决什么问题？",charIndex:2},{level:2,title:"滑动窗口是什么？",slug:"滑动窗口是什么",normalizedTitle:"滑动窗口是什么？",charIndex:221},{level:2,title:"窗口大小由哪一方决定？",slug:"窗口大小由哪一方决定",normalizedTitle:"窗口大小由哪一方决定？",charIndex:609},{level:2,title:"程序是如何表示发送方的四个部分的呢？",slug:"程序是如何表示发送方的四个部分的呢",normalizedTitle:"程序是如何表示发送方的四个部分的呢？",charIndex:1217},{level:2,title:"接收方的滑动窗口",slug:"接收方的滑动窗口",normalizedTitle:"接收方的滑动窗口",charIndex:1598},{level:2,title:"接收窗口和发送窗口的大小是相等的吗？",slug:"接收窗口和发送窗口的大小是相等的吗",normalizedTitle:"接收窗口和发送窗口的大小是相等的吗？",charIndex:1917},{level:2,title:"参考：",slug:"参考",normalizedTitle:"参考：",charIndex:2106}],headersStr:"滑动窗口解决什么问题？ 滑动窗口是什么？ 窗口大小由哪一方决定？ 程序是如何表示发送方的四个部分的呢？ 接收方的滑动窗口 接收窗口和发送窗口的大小是相等的吗？ 参考：",content:"# 滑动窗口解决什么问题？\n\n我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。\n\n这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。\n\n如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。\n\n\n\n所以，这样的传输方式有一个缺点：数据包的往返时间越长，通信的效率就越低。\n\n\n# 滑动窗口是什么？\n\n为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。\n\n那么有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。\n\n窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。\n\n假设窗口大小为 3个 TCP 段，那么发送方就可以「连续发送」3个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：\n\n\n\n图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。\n\n\n# 窗口大小由哪一方决定？\n\nTCP 头里有一个字段叫 Window，也就是窗口大小。\n\n这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。\n\n所以，通常窗口的大小是由接收方的窗口大小来决定的。\n\n发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。\n\n我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：\n\n\n\n 1. 井1是已发送并收到 ACK确认的数据：1~31 字节\n 2. 井2是已发送但未收到 ACK确认的数据：32~45 字节\n 3. 井3是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节\n 4. 井4是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后 在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。\n\n\n\n在下图，当收到之前发送的数据 32~36字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。\n\n\n\n\n# 程序是如何表示发送方的四个部分的呢？\n\nTCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。\n\n\n\n * SND.WND：表示发送窗口的大小（大小是由接收方指定的）；\n\n * SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。\n\n * SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。\n\n指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND大小的偏移量，就可以指向 #4 的第一个字节了。\n\n那么可用窗口大小的计算就可以是：\n\n可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）\n\n\n# 接收方的滑动窗口\n\n接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：\n\n * 井1 + 井2 是已成功接收并确认的数据（等待应用进程读取）\n * 井3 是未收到数据但可以接收的数据\n * 井4 未收到数据并不可以接收的数据\n\n\n\n接收窗口 其中三个接收部分，使用两个指针进行划分:\n\n * RCV.WND：表示接收窗口的大小，它会通告给发送方。\n * RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。\n * 指向 #4 的第一个字节是个相对指针，它需要RCV.NXT指针加上 RCV.WND大小的偏移量，就可以指向 #4 的第一个字节了。\n\n\n# 接收窗口和发送窗口的大小是相等的吗？\n\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n\n因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。\n\n\n# 参考：\n\nTCP滑动窗口和重传机制",normalizedContent:"# 滑动窗口解决什么问题？\n\n我们都知道 tcp 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。\n\n这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。\n\n如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。\n\n\n\n所以，这样的传输方式有一个缺点：数据包的往返时间越长，通信的效率就越低。\n\n\n# 滑动窗口是什么？\n\n为解决这个问题，tcp 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。\n\n那么有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。\n\n窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。\n\n假设窗口大小为 3个 tcp 段，那么发送方就可以「连续发送」3个 tcp 段，并且中途若有 ack 丢失，可以通过「下一个确认应答进行确认」。如下图：\n\n\n\n图中的 ack 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ack 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。\n\n\n# 窗口大小由哪一方决定？\n\ntcp 头里有一个字段叫 window，也就是窗口大小。\n\n这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。\n\n所以，通常窗口的大小是由接收方的窗口大小来决定的。\n\n发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。\n\n我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：\n\n\n\n 1. 井1是已发送并收到 ack确认的数据：1~31 字节\n 2. 井2是已发送但未收到 ack确认的数据：32~45 字节\n 3. 井3是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节\n 4. 井4是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后 在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ack 确认之前是无法继续发送数据了。\n\n\n\n在下图，当收到之前发送的数据 32~36字节的 ack 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。\n\n\n\n\n# 程序是如何表示发送方的四个部分的呢？\n\ntcp 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。\n\n\n\n * snd.wnd：表示发送窗口的大小（大小是由接收方指定的）；\n\n * snd.una：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。\n\n * snd.nxt：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。\n\n指向 #4 的第一个字节是个相对指针，它需要 snd.una 指针加上 snd.wnd大小的偏移量，就可以指向 #4 的第一个字节了。\n\n那么可用窗口大小的计算就可以是：\n\n可用窗口大小 = snd.wnd -（snd.nxt - snd.una）\n\n\n# 接收方的滑动窗口\n\n接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：\n\n * 井1 + 井2 是已成功接收并确认的数据（等待应用进程读取）\n * 井3 是未收到数据但可以接收的数据\n * 井4 未收到数据并不可以接收的数据\n\n\n\n接收窗口 其中三个接收部分，使用两个指针进行划分:\n\n * rcv.wnd：表示接收窗口的大小，它会通告给发送方。\n * rcv.nxt：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。\n * 指向 #4 的第一个字节是个相对指针，它需要rcv.nxt指针加上 rcv.wnd大小的偏移量，就可以指向 #4 的第一个字节了。\n\n\n# 接收窗口和发送窗口的大小是相等的吗？\n\n并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。\n\n因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 tcp 报文中的 windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。\n\n\n# 参考：\n\ntcp滑动窗口和重传机制",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"简述 JWT 的原理和校验机制",frontmatter:{title:"简述 JWT 的原理和校验机制",date:"2022-09-21T22:38:22.000Z",permalink:"/pages/34d064/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/180.%E7%AE%80%E8%BF%B0%20JWT%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6.html",relativePath:"02.计算机基础/10.计算机网络/180.简述 JWT 的原理和校验机制.md",key:"v-74475c54",path:"/pages/34d064/",headers:[{level:2,title:"什么是 Token（令牌）",slug:"什么是-token-令牌",normalizedTitle:"什么是 token（令牌）",charIndex:2},{level:3,title:"Acesss Token",slug:"acesss-token",normalizedTitle:"acesss token",charIndex:20},{level:3,title:"Refresh Token",slug:"refresh-token",normalizedTitle:"refresh token",charIndex:648},{level:2,title:"Token 和 Session 的区别",slug:"token-和-session-的区别",normalizedTitle:"token 和 session 的区别",charIndex:1110},{level:2,title:"什么是 JWT",slug:"什么是-jwt",normalizedTitle:"什么是 jwt",charIndex:1773},{level:2,title:"生成 JWT",slug:"生成-jwt",normalizedTitle:"生成 jwt",charIndex:2064},{level:2,title:"JWT 的原理",slug:"jwt-的原理",normalizedTitle:"jwt 的原理",charIndex:2127},{level:3,title:"JWT 认证流程：",slug:"jwt-认证流程",normalizedTitle:"jwt 认证流程：",charIndex:2141},{level:2,title:"JWT 的使用方式",slug:"jwt-的使用方式",normalizedTitle:"jwt 的使用方式",charIndex:2570},{level:3,title:"方式一",slug:"方式一",normalizedTitle:"方式一",charIndex:2638},{level:3,title:"方式二",slug:"方式二",normalizedTitle:"方式二",charIndex:3096},{level:3,title:"方式三",slug:"方式三",normalizedTitle:"方式三",charIndex:3139},{level:2,title:"Token 和 JWT 的区别",slug:"token-和-jwt-的区别",normalizedTitle:"token 和 jwt 的区别",charIndex:3202},{level:3,title:"相同：",slug:"相同",normalizedTitle:"相同：",charIndex:3222},{level:3,title:"区别：",slug:"区别",normalizedTitle:"区别：",charIndex:3303},{level:2,title:"常见的前后端鉴权方式",slug:"常见的前后端鉴权方式",normalizedTitle:"常见的前后端鉴权方式",charIndex:3483}],headersStr:"什么是 Token（令牌） Acesss Token Refresh Token Token 和 Session 的区别 什么是 JWT 生成 JWT JWT 的原理 JWT 认证流程： JWT 的使用方式 方式一 方式二 方式三 Token 和 JWT 的区别 相同： 区别： 常见的前后端鉴权方式",content:"# 什么是 Token（令牌）\n\n\n# Acesss Token\n\n * 访问资源接口（API）时所需要的资源凭证\n * 简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）\n * 特点：\n   * 服务端无状态化、可扩展性好\n   * 支持移动端设备\n   * 安全\n   * 支持跨程序调用\n * token 的身份验证流程：\n\n\n\n 1. 客户端使用用户名跟密码请求登录\n 2. 服务端收到请求，去验证用户名与密码\n 3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端\n 4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里\n 5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token\n 6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据\n\n * 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里\n * 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库\n * token 完全由应用管理，所以它可以避开同源策略\n\n\n# Refresh Token\n\n * 另外一种 token——refresh token\n * refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。\n\n\n\n * Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。\n * Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。\n\n\n# Token 和 Session 的区别\n\n * Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。\n\n * Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。\n\n * 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。\n\n\n# 什么是 JWT\n\n * JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。\n * 是一种认证授权机制。\n * JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。 阮一峰老师的 JSON Web Token 入门教程 讲的非常通俗易懂，这里就不再班门弄斧了\n\n\n# 生成 JWT\n\n * https://jwt.io/\n * https://www.jsonwebtoken.io/\n\n\n# JWT 的原理\n\n\n\n\n# JWT 认证流程：\n\n * 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT\n * 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）\n * 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样\n\nAuthorization: Bearer <token>\n\n\n1\n\n * 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为\n * 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要\n * 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）\n * 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制\n\n\n# JWT 的使用方式\n\n客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。\n\n\n# 方式一\n\n * 当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。\n\nGET /calendar/v1/events\nHost: api.example.com\nAuthorization: Bearer <token>\n\n\n1\n2\n3\n\n * 用户的状态不会存储在服务端的内存中，这是一种 无状态的认证机制\n * 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。\n * 由于 JWT 是自包含的，因此减少了需要查询数据库的需要\n * JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。\n * 因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）\n\n\n# 方式二\n\n * 跨域的时候，可以把 JWT 放在 POST 请求的数据体里。\n\n\n# 方式三\n\n通过 URL 传输\n\nhttp://www.example.com/user?token=xxx\n\n\n1\n\n\n\n# Token 和 JWT 的区别\n\n\n# 相同：\n\n * 都是访问资源的令牌\n * 都可以记录用户的信息\n * 都是使服务端无状态化\n * 都是只有验证成功后，客户端才能访问服务端上受保护的资源\n\n\n# 区别：\n\n * Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。\n * JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。\n\n\n# 常见的前后端鉴权方式\n\nSession-Cookie Token 验证（包括 JWT，SSO） OAuth2.0（开放授权）\n\n参考： 还分不清 Cookie、Session、Token、JWT？",normalizedContent:"# 什么是 token（令牌）\n\n\n# acesss token\n\n * 访问资源接口（api）时所需要的资源凭证\n * 简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）\n * 特点：\n   * 服务端无状态化、可扩展性好\n   * 支持移动端设备\n   * 安全\n   * 支持跨程序调用\n * token 的身份验证流程：\n\n\n\n 1. 客户端使用用户名跟密码请求登录\n 2. 服务端收到请求，去验证用户名与密码\n 3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端\n 4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localstorage 里\n 5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token\n 6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据\n\n * 每一次请求都需要携带 token，需要把 token 放到 http 的 header 里\n * 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库\n * token 完全由应用管理，所以它可以避开同源策略\n\n\n# refresh token\n\n * 另外一种 token——refresh token\n * refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。\n\n\n\n * access token 的有效期比较短，当 acesss token 由于过期而失效时，使用 refresh token 就可以获取到新的 token，如果 refresh token 也失效了，用户就只能重新登录了。\n * refresh token 及过期时间是存储在服务器的数据库中，只有在申请新的 acesss token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 session 一样一直保持在内存中以应对大量的请求。\n\n\n# token 和 session 的区别\n\n * session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 token 是令牌，访问资源接口（api）时所需要的资源凭证。token 使服务端无状态化，不会存储会话信息。\n\n * session 和 token 并不矛盾，作为身份认证 token 安全性比 session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 session 来在服务器端保存一些状态。\n\n * 所谓 session 认证只是简单的把 user 信息存储到 session 里，因为 sessionid 的不可预测性，暂且认为是安全的。而 token ，如果指的是 oauth token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 app 。其目的是让某 app 有权利访问某用户的信息。这里的 token 是唯一的。不可以转移到其它 app上，也不可以转到其它用户上。session 只提供一种简单的认证，即只要有此 sessionid ，即认为有此 user 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 app。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 api 接口，用 token 。如果永远只是自己的网站，自己的 app，用什么就无所谓了。\n\n\n# 什么是 jwt\n\n * json web token（简称 jwt）是目前最流行的跨域认证解决方案。\n * 是一种认证授权机制。\n * jwt 是为了在网络应用环境间传递声明而执行的一种基于 json 的开放标准（rfc 7519）。jwt 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 可以使用 hmac 算法或者是 rsa 的公/私秘钥对 jwt 进行签名。因为数字签名的存在，这些传递的信息是可信的。 阮一峰老师的 json web token 入门教程 讲的非常通俗易懂，这里就不再班门弄斧了\n\n\n# 生成 jwt\n\n * https://jwt.io/\n * https://www.jsonwebtoken.io/\n\n\n# jwt 的原理\n\n\n\n\n# jwt 认证流程：\n\n * 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 jwt\n * 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）\n * 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 authorization 字段中使用bearer 模式添加 jwt，其内容看起来是下面这样\n\nauthorization: bearer <token>\n\n\n1\n\n * 服务端的保护路由将会检查请求头 authorization 中的 jwt 信息，如果合法，则允许用户的行为\n * 因为 jwt 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要\n * 因为 jwt 并不使用 cookie 的，所以你可以使用任何域名提供你的 api 服务而不需要担心跨域资源共享问题（cors）\n * 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制\n\n\n# jwt 的使用方式\n\n客户端收到服务器返回的 jwt，可以储存在 cookie 里面，也可以储存在 localstorage。\n\n\n# 方式一\n\n * 当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 http 请求头信息的 authorization 字段里，使用 bearer 模式添加 jwt。\n\nget /calendar/v1/events\nhost: api.example.com\nauthorization: bearer <token>\n\n\n1\n2\n3\n\n * 用户的状态不会存储在服务端的内存中，这是一种 无状态的认证机制\n * 服务端的保护路由将会检查请求头 authorization 中的 jwt 信息，如果合法，则允许用户的行为。\n * 由于 jwt 是自包含的，因此减少了需要查询数据库的需要\n * jwt 的这些特性使得我们可以完全依赖其无状态的特性提供数据 api 服务，甚至是创建一个下载流服务。\n * 因为 jwt 并不使用 cookie ，所以你可以使用任何域名提供你的 api 服务而不需要担心跨域资源共享问题（cors）\n\n\n# 方式二\n\n * 跨域的时候，可以把 jwt 放在 post 请求的数据体里。\n\n\n# 方式三\n\n通过 url 传输\n\nhttp://www.example.com/user?token=xxx\n\n\n1\n\n\n\n# token 和 jwt 的区别\n\n\n# 相同：\n\n * 都是访问资源的令牌\n * 都可以记录用户的信息\n * 都是使服务端无状态化\n * 都是只有验证成功后，客户端才能访问服务端上受保护的资源\n\n\n# 区别：\n\n * token：服务端验证客户端发送过来的 token 时，还需要查询数据库获取用户信息，然后验证 token 是否有效。\n * jwt：将 token 和 payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 jwt 自己实现的）即可，不需要查询或者减少查询数据库，因为 jwt 自包含了用户信息和加密的数据。\n\n\n# 常见的前后端鉴权方式\n\nsession-cookie token 验证（包括 jwt，sso） oauth2.0（开放授权）\n\n参考： 还分不清 cookie、session、token、jwt？",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"简述 iPv4 和 iPv6 的区别",frontmatter:{title:"简述 iPv4 和 iPv6 的区别",date:"2022-09-21T22:38:54.000Z",permalink:"/pages/6a2e50/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/200.%E7%AE%80%E8%BF%B0%20iPv4%20%E5%92%8C%20iPv6%20%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"02.计算机基础/10.计算机网络/200.简述 iPv4 和 iPv6 的区别.md",key:"v-730f9a6a",path:"/pages/6a2e50/",headers:[{level:2,title:"什么是IPv4和IPv6？",slug:"什么是ipv4和ipv6",normalizedTitle:"什么是ipv4和ipv6？",charIndex:249},{level:2,title:"IPv4地址",slug:"ipv4地址",normalizedTitle:"ipv4地址",charIndex:414},{level:2,title:"IPv6地址",slug:"ipv6地址",normalizedTitle:"ipv6地址",charIndex:844},{level:2,title:"IPv4和IPv6之间的区别",slug:"ipv4和ipv6之间的区别",normalizedTitle:"ipv4和ipv6之间的区别",charIndex:264},{level:2,title:"IPv4或IPv6：使用哪个？",slug:"ipv4或ipv6-使用哪个",normalizedTitle:"ipv4或ipv6：使用哪个？",charIndex:280},{level:2,title:"那么为什么我们仍在使用IPv4？",slug:"那么为什么我们仍在使用ipv4",normalizedTitle:"那么为什么我们仍在使用ipv4？",charIndex:2104},{level:2,title:"您需要什么才能使用IPv6？",slug:"您需要什么才能使用ipv6",normalizedTitle:"您需要什么才能使用ipv6？",charIndex:2328},{level:2,title:"IPv4与IPv6的安全性",slug:"ipv4与ipv6的安全性",normalizedTitle:"ipv4与ipv6的安全性",charIndex:2528},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2794},{level:2,title:"参考：",slug:"参考",normalizedTitle:"参考：",charIndex:2924}],headersStr:"什么是IPv4和IPv6？ IPv4地址 IPv6地址 IPv4和IPv6之间的区别 IPv4或IPv6：使用哪个？ 那么为什么我们仍在使用IPv4？ 您需要什么才能使用IPv6？ IPv4与IPv6的安全性 总结 参考：",content:"前言\n\n\n\nInternet协议（IP）是为连接到Internet网络的每个设备分配的数字地址。\n\n它类似于电话号码，是一种独特的数字组合，允许用户与他人通信。\n\nIP地址主要有两个主要功能。\n\n首先，有了IP，用户能够在Internet上被识别。\n\n第二，IP地址允许计算机通过Internet发送和接收数据，也就是我们经常说的通信。\n\n在本文中，我们将深入研究两种类型的IP地址：IPv4与IPv6。\n\n我们将从以下几个方面来给大家介绍这两种类型的IP地址，让大家了解到两类IP的必备知识：\n\n什么是IPv4和IPv6？\n\nIPv4和IPv6之间的区别\n\nIPv4或IPv6：使用哪个？\n\nIPv4与IPv6安全性如何\n\n\n# 什么是IPv4和IPv6？\n\nIPv4和IPv6是不同类型的IP地址。\n\n它们的主要用途相同，标记不同的用户，并且让用户能通过IP进行通信。\n\n主要区别在于IPv6是最新一代的IP地址。\n\n\n# IPv4地址\n\nIPv4地址的概念是在1980年代初期提出的。\n\n即使有新版本的IP地址，IPv4地址仍然是Internet用户使用最广泛的地址。\n\n通常，IPv4地址以点分十进制表示。每个部分代表一组构成8位地址方案的8位地址。\n\n\n\nIPv4地址组合的数量是有限的。总体而言，可以算出40亿（256 4）个唯一地址。\n\n在IPv4地址才开始时，这个数字似乎永远不会过期。但是，现在情况有所不同了。\n\n2011年，全球互联网编号分配机构（IANA）分发了IPv4地址空间的最后一块。\n\n2015年，IANA正式宣布美国已用完IPv4地址。\n\n直到今天，IPv4地址仍然承载着最多（超过90％）的互联网流量。\n\n到目前为止，即使目前存在IPv4地址耗尽的问题，也有一些方法可以继续使用IPv4地址。\n\n例如，当仅需要一个唯一的IP地址来代表一组设备时，网络地址转换（NAT）是一种方法。\n\n除此之外，IP地址可以重复使用。当然，我们已经有了彻底耗尽的解决方案-IPv6地址。\n\n\n# IPv6地址\n\n仔细观察，您会发现IPv6地址并不是一种全新的技术。\n\n它是Internet协议的最新版本，但它是在1998年开发的，旨在替换IPv4地址。\n\nIPv6地址使用以冒号分隔的十六进制数字。\n\n它分为八个16位块，构成一个128位地址方案。\n\n\n\nIPv6也存在数量限制。不过可用的IP数量远大于IPv4。\n\n从理论上讲，可以创建大约3.4×10 38个地址。\n\n这一数据听起来很高，远超于IPv4的总数40亿个，但是有一天也可能出现不够的情况。\n\n但就目前而言，这些地址将可以供我们使用很长一段时间。\n\n\n# IPv4和IPv6之间的区别\n\nIPv4和IPv6用于用户标识和Internet上不同设备之间的通信。\n\nIPv4是32位IP地址，而IPv6是128位IP地址。\n\nIPv4是数字地址，用点分隔。IPv6是一个字母数字地址，用冒号分隔。\n\n我们分别详细介绍了IPv4和IPv6类型。\n\n现在，我们可以比较这些类型，并找出这两种协议之间的主要区别。\n\n我们列举了IPv4和IPv6之间的八个主要区别。\n\n\n\n 1. 地址类型。IPv4具有三种不同类型的地址：多播，广播和单播。IPv6还具有三种不同类型的地址：任意广播，单播和多播。\n\n 2. 数据包大小。对于IPv4，最小数据包大小为576字节。对于IPv6，最小数据包大小为1208字节。\n\n 3. header区域字段数。IPv4具有12个标头字段，而IPv6支持8个标头字段。\n\n 4. 可选字段。IPv4具有可选字段，而IPv6没有。但是，IPv6具有扩展header，可以在将来扩展协议而不会影响主包结构。\n\n 5. 配置。在IPv4中，新装的系统必须配置好才能与其他系统通信。在IPv6中，配置是可选的，它允许根据所需功能进行选择。\n\n 6. 安全性。在IPv4中，安全性主要取决于网站和应用程序。它不是针对安全性而开发的IP协议。而IPv6集成了Internet协议安全标准（IPSec）。IPv6的网络安全不像IPv4是可选项，IPv6里的网络安全项是强制性的。\n\n 7. 与移动设备的兼容性。IPv4不适合移动网络，因为正如我们前面提到的，它使用点分十进制表示法，而IPv6使用冒号，是移动设备的更好选择。\n\n 8. 主要功能。IPv6允许直接寻址，因为存在大量可能的地址。但是，IPv4已经广泛传播并得到许多设备的支持，这使其更易于使用。\n\n\n# IPv4或IPv6：使用哪个？\n\n对于使用IPv6还是IPv4这个问题，没有标准答案。\n\n在考虑未来的网络体验时，IPv6地址就显得至关重要。\n\n即使在我们已经没有网络地址的情况下仍然可以有其他办法使用IPv4地址，\n\n但是这些选项也可能会轻微影响到网络速度或引起其他问题。\n\n不过，使用IPv6需要开发支持IPv6的新技术和产品。\n\nIPv6的速度显然不比IPv4快，但是从IPv4完全更改为IPv6将为Internet提供更大的唯一IP池。\n\n\n# 那么为什么我们仍在使用IPv4？\n\n问题就在于IPv4和IPv6无法相互通信。\n\n这就是为什么IPv6的集成和适配很复杂。\n\n大多数网站或应用程序仅支持IPv4类型的IP地址。想象一下突然更改每个设备的IP地址。\n\n用户将无法访问大多数网站或应用程序，而我们在互联网上将陷入一片混乱。\n\n从旧的IP类型转换为新的IP类型的过程应分步完成。\n\n例如，这两个协议能够并行运行。\n\n此功能称为双重堆栈。它允许用户同时访问IPv4和IPv6内容。\n\n\n# 您需要什么才能使用IPv6？\n\n 1. 操作系统必须与IPv6兼容。Windows Vista和Windows的较新版本，Mac OS X的现代版本以及Linux。\n\n 2. 大多数路由器不支持IPv6。如果您想尝试使用IPv6，请检查路由器的详细信息。\n\n 3. Internet服务提供商（ISP）也必须支持IPv6。即使您具有合适的操作系统和路由器，您的ISP也必须提供IPv6连接。\n\n\n# IPv4与IPv6的安全性\n\nIPv6的开发考虑了安全性。这就是将IPSec集成在IPv6中的原因，而对于IPv4，IPSec是可选的。\n\n什么是IPSec？\n\nIPSec（Internet协议安全性）是一种安全的网络协议，它对数据包进行身份验证和加密，以在设备之间提供安全的通信。\n\n加密是只有经过确认的各方才能理解的一种秘密代码。它有助于确保通过公共网络发送的信息的安全。\n\n由于IPv4还可以选择集成IPSec，因此我们可以假设在安全性方面IPv4与IPv6几乎相同。\n\n但是，如果已经集成了安全措施，则要简单得多。\n\n\n# 总结\n\nIPv6是IP地址的未来。 但是，从IPv4过渡到IPv6的过程却是漫长而复杂的。\n\n如果您对使用IPv6地址感到好奇，建议将其用法与IPv4结合使用，因为大多数网站和应用程序仍仅支持IPv4地址。\n\nIPv4和IPv6使用的结合称为双重堆栈\n\n\n# 参考：\n\nIPv4 vs. IPv6: What is the Difference?",normalizedContent:"前言\n\n\n\ninternet协议（ip）是为连接到internet网络的每个设备分配的数字地址。\n\n它类似于电话号码，是一种独特的数字组合，允许用户与他人通信。\n\nip地址主要有两个主要功能。\n\n首先，有了ip，用户能够在internet上被识别。\n\n第二，ip地址允许计算机通过internet发送和接收数据，也就是我们经常说的通信。\n\n在本文中，我们将深入研究两种类型的ip地址：ipv4与ipv6。\n\n我们将从以下几个方面来给大家介绍这两种类型的ip地址，让大家了解到两类ip的必备知识：\n\n什么是ipv4和ipv6？\n\nipv4和ipv6之间的区别\n\nipv4或ipv6：使用哪个？\n\nipv4与ipv6安全性如何\n\n\n# 什么是ipv4和ipv6？\n\nipv4和ipv6是不同类型的ip地址。\n\n它们的主要用途相同，标记不同的用户，并且让用户能通过ip进行通信。\n\n主要区别在于ipv6是最新一代的ip地址。\n\n\n# ipv4地址\n\nipv4地址的概念是在1980年代初期提出的。\n\n即使有新版本的ip地址，ipv4地址仍然是internet用户使用最广泛的地址。\n\n通常，ipv4地址以点分十进制表示。每个部分代表一组构成8位地址方案的8位地址。\n\n\n\nipv4地址组合的数量是有限的。总体而言，可以算出40亿（256 4）个唯一地址。\n\n在ipv4地址才开始时，这个数字似乎永远不会过期。但是，现在情况有所不同了。\n\n2011年，全球互联网编号分配机构（iana）分发了ipv4地址空间的最后一块。\n\n2015年，iana正式宣布美国已用完ipv4地址。\n\n直到今天，ipv4地址仍然承载着最多（超过90％）的互联网流量。\n\n到目前为止，即使目前存在ipv4地址耗尽的问题，也有一些方法可以继续使用ipv4地址。\n\n例如，当仅需要一个唯一的ip地址来代表一组设备时，网络地址转换（nat）是一种方法。\n\n除此之外，ip地址可以重复使用。当然，我们已经有了彻底耗尽的解决方案-ipv6地址。\n\n\n# ipv6地址\n\n仔细观察，您会发现ipv6地址并不是一种全新的技术。\n\n它是internet协议的最新版本，但它是在1998年开发的，旨在替换ipv4地址。\n\nipv6地址使用以冒号分隔的十六进制数字。\n\n它分为八个16位块，构成一个128位地址方案。\n\n\n\nipv6也存在数量限制。不过可用的ip数量远大于ipv4。\n\n从理论上讲，可以创建大约3.4×10 38个地址。\n\n这一数据听起来很高，远超于ipv4的总数40亿个，但是有一天也可能出现不够的情况。\n\n但就目前而言，这些地址将可以供我们使用很长一段时间。\n\n\n# ipv4和ipv6之间的区别\n\nipv4和ipv6用于用户标识和internet上不同设备之间的通信。\n\nipv4是32位ip地址，而ipv6是128位ip地址。\n\nipv4是数字地址，用点分隔。ipv6是一个字母数字地址，用冒号分隔。\n\n我们分别详细介绍了ipv4和ipv6类型。\n\n现在，我们可以比较这些类型，并找出这两种协议之间的主要区别。\n\n我们列举了ipv4和ipv6之间的八个主要区别。\n\n\n\n 1. 地址类型。ipv4具有三种不同类型的地址：多播，广播和单播。ipv6还具有三种不同类型的地址：任意广播，单播和多播。\n\n 2. 数据包大小。对于ipv4，最小数据包大小为576字节。对于ipv6，最小数据包大小为1208字节。\n\n 3. header区域字段数。ipv4具有12个标头字段，而ipv6支持8个标头字段。\n\n 4. 可选字段。ipv4具有可选字段，而ipv6没有。但是，ipv6具有扩展header，可以在将来扩展协议而不会影响主包结构。\n\n 5. 配置。在ipv4中，新装的系统必须配置好才能与其他系统通信。在ipv6中，配置是可选的，它允许根据所需功能进行选择。\n\n 6. 安全性。在ipv4中，安全性主要取决于网站和应用程序。它不是针对安全性而开发的ip协议。而ipv6集成了internet协议安全标准（ipsec）。ipv6的网络安全不像ipv4是可选项，ipv6里的网络安全项是强制性的。\n\n 7. 与移动设备的兼容性。ipv4不适合移动网络，因为正如我们前面提到的，它使用点分十进制表示法，而ipv6使用冒号，是移动设备的更好选择。\n\n 8. 主要功能。ipv6允许直接寻址，因为存在大量可能的地址。但是，ipv4已经广泛传播并得到许多设备的支持，这使其更易于使用。\n\n\n# ipv4或ipv6：使用哪个？\n\n对于使用ipv6还是ipv4这个问题，没有标准答案。\n\n在考虑未来的网络体验时，ipv6地址就显得至关重要。\n\n即使在我们已经没有网络地址的情况下仍然可以有其他办法使用ipv4地址，\n\n但是这些选项也可能会轻微影响到网络速度或引起其他问题。\n\n不过，使用ipv6需要开发支持ipv6的新技术和产品。\n\nipv6的速度显然不比ipv4快，但是从ipv4完全更改为ipv6将为internet提供更大的唯一ip池。\n\n\n# 那么为什么我们仍在使用ipv4？\n\n问题就在于ipv4和ipv6无法相互通信。\n\n这就是为什么ipv6的集成和适配很复杂。\n\n大多数网站或应用程序仅支持ipv4类型的ip地址。想象一下突然更改每个设备的ip地址。\n\n用户将无法访问大多数网站或应用程序，而我们在互联网上将陷入一片混乱。\n\n从旧的ip类型转换为新的ip类型的过程应分步完成。\n\n例如，这两个协议能够并行运行。\n\n此功能称为双重堆栈。它允许用户同时访问ipv4和ipv6内容。\n\n\n# 您需要什么才能使用ipv6？\n\n 1. 操作系统必须与ipv6兼容。windows vista和windows的较新版本，mac os x的现代版本以及linux。\n\n 2. 大多数路由器不支持ipv6。如果您想尝试使用ipv6，请检查路由器的详细信息。\n\n 3. internet服务提供商（isp）也必须支持ipv6。即使您具有合适的操作系统和路由器，您的isp也必须提供ipv6连接。\n\n\n# ipv4与ipv6的安全性\n\nipv6的开发考虑了安全性。这就是将ipsec集成在ipv6中的原因，而对于ipv4，ipsec是可选的。\n\n什么是ipsec？\n\nipsec（internet协议安全性）是一种安全的网络协议，它对数据包进行身份验证和加密，以在设备之间提供安全的通信。\n\n加密是只有经过确认的各方才能理解的一种秘密代码。它有助于确保通过公共网络发送的信息的安全。\n\n由于ipv4还可以选择集成ipsec，因此我们可以假设在安全性方面ipv4与ipv6几乎相同。\n\n但是，如果已经集成了安全措施，则要简单得多。\n\n\n# 总结\n\nipv6是ip地址的未来。 但是，从ipv4过渡到ipv6的过程却是漫长而复杂的。\n\n如果您对使用ipv6地址感到好奇，建议将其用法与ipv4结合使用，因为大多数网站和应用程序仍仅支持ipv4地址。\n\nipv4和ipv6使用的结合称为双重堆栈\n\n\n# 参考：\n\nipv4 vs. ipv6: what is the difference?",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"简述TCP重传机制",frontmatter:{title:"简述TCP重传机制",date:"2022-09-27T22:26:11.000Z",permalink:"/pages/a219df/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/171.%20%E7%AE%80%E8%BF%B0TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6.html",relativePath:"02.计算机基础/10.计算机网络/171. 简述TCP重传机制.md",key:"v-52edac80",path:"/pages/a219df/",headers:[{level:2,title:"重传机制",slug:"重传机制",normalizedTitle:"重传机制",charIndex:2},{level:2,title:"超时重传",slug:"超时重传",normalizedTitle:"超时重传",charIndex:101},{level:2,title:"快速重传",slug:"快速重传",normalizedTitle:"快速重传",charIndex:109},{level:2,title:"SACK 方法",slug:"sack-方法",normalizedTitle:"sack 方法",charIndex:1791},{level:2,title:"Duplicate SACK",slug:"duplicate-sack",normalizedTitle:"duplicate sack",charIndex:2063},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2811}],headersStr:"重传机制 超时重传 快速重传 SACK 方法 Duplicate SACK 参考",content:"# 重传机制\n\nTCP 实现可靠传输的方式之一，是通过序列号与确认应答。\n\n在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。\n\n常见的重传机制：\n\n * 超时重传\n * 快速重传\n * SACK D-SACK\n\n\n# 超时重传\n\n重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。\n\nTCP 会在以下两种情况发生超时重传：\n\n * 数据包丢失\n * 确认应答丢失\n\n超时时间应该设置为多少呢？\n\n\n\nRTT 就是数据从网络一端传送到另一端所需的时间，也就是包的往返时间。\n\n超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。\n\n假设在重传的情况下，超时时间 RTO 「较长或较短」时，会发生什么事情呢？\n\n\n\n上图中有两种超时时间不同的情况：\n\n * 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；\n * 当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。\n\n根据上述的两种情况，我们可以得知，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。\n\n\n\n好像就是在发送端发包时记下t0 ，然后接收端再把这个ack 回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。\n\n实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。\n\n估计往返时间，通常需要采样以下两个：\n\n * 需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。\n * 除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。 RFC6289 建议使用以下的公式计算 RTO：\n\n\n\n其中 SRTT 是计算平滑的RTT ，DevRTR 是计算平滑的RTT 与 最新 RTT 的差距。\n\n在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4。别问怎么来的，问就是大量实验中调出来的。\n\n如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时时间隔加倍。\n\n也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。\n\n超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？\n\n于是就可以用「快速重传」机制来解决超时重发的时间等待。\n\n\n# 快速重传\n\nTCP 还有另外一种快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。\n\n\n\n在上图，发送方发出了 1，2，3，4，5 份数据：\n\n * 第一份 Seq1 先送到了，于是就 Ack 回 2；\n * 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；\n * 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；\n * 发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。\n * 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。\n\n所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。\n\n快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。\n\n比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。\n\n为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。\n\n\n# SACK 方法\n\n还有一种实现重传机制的方式叫：SACK（ Selective Acknowledgment 选择性确认）。\n\n这种方式需要在 TCP 头部「选项」字段里加一个 SACK的东西，它可以将缓存的数据发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。\n\n如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。\n\n\n\n\n# Duplicate SACK\n\nDuplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。\n\n下面举例两个栗子，来说明 D-SACK 的作用。\n\n栗子一号：ACK 丢包:\n\n\n\n「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499） 于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。 这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。 栗子二号：网络延时:\n\n\n\n * 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。\n * 而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；\n * 所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。\n * 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。\n\n可见，D-SACK 有这么几个好处：\n\n 1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;\n 2. 可以知道是不是「发送方」的数据包被网络延迟了;\n 3. 可以知道网络中是不是把「发送方」的数据包给复制了;\n\n\n# 参考\n\nTCP滑动窗口和重传机制",normalizedContent:"# 重传机制\n\ntcp 实现可靠传输的方式之一，是通过序列号与确认应答。\n\n在 tcp 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。\n\n常见的重传机制：\n\n * 超时重传\n * 快速重传\n * sack d-sack\n\n\n# 超时重传\n\n重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ack 确认应答报文，就会重发该数据，也就是我们常说的超时重传。\n\ntcp 会在以下两种情况发生超时重传：\n\n * 数据包丢失\n * 确认应答丢失\n\n超时时间应该设置为多少呢？\n\n\n\nrtt 就是数据从网络一端传送到另一端所需的时间，也就是包的往返时间。\n\n超时重传时间是以 rto （retransmission timeout 超时重传时间）表示。\n\n假设在重传的情况下，超时时间 rto 「较长或较短」时，会发生什么事情呢？\n\n\n\n上图中有两种超时时间不同的情况：\n\n * 当超时时间 rto 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；\n * 当超时时间 rto 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。\n\n根据上述的两种情况，我们可以得知，超时重传时间 rto 的值应该略大于报文往返 rtt 的值。\n\n\n\n好像就是在发送端发包时记下t0 ，然后接收端再把这个ack 回来时再记一个t1，于是rtt = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。\n\n实际上「报文往返 rtt 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 rtt 的值」 是经常波动变化的，所以「超时重传时间 rto 的值」应该是一个动态变化的值。\n\n估计往返时间，通常需要采样以下两个：\n\n * 需要 tcp 通过采样 rtt 的时间，然后进行加权平均，算出一个平滑 rtt 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。\n * 除了采样 rtt，还要采样 rtt 的波动范围，这样就避免如果 rtt 有一个大的波动的话，很难被发现的情况。 rfc6289 建议使用以下的公式计算 rto：\n\n\n\n其中 srtt 是计算平滑的rtt ，devrtr 是计算平滑的rtt 与 最新 rtt 的差距。\n\n在 linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4。别问怎么来的，问就是大量实验中调出来的。\n\n如果超时重发的数据，再次超时的时候，又需要重传的时候，tcp 的策略是超时时间隔加倍。\n\n也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。\n\n超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？\n\n于是就可以用「快速重传」机制来解决超时重发的时间等待。\n\n\n# 快速重传\n\ntcp 还有另外一种快速重传（fast retransmit）机制，它不以时间为驱动，而是以数据驱动重传。\n\n\n\n在上图，发送方发出了 1，2，3，4，5 份数据：\n\n * 第一份 seq1 先送到了，于是就 ack 回 2；\n * 结果 seq2 因为某些原因没收到，seq3 到达了，于是还是 ack 回 2；\n * 后面的 seq4 和 seq5 都到了，但还是 ack 回 2，因为 seq2 还是没有收到；\n * 发送端收到了三个 ack = 2 的确认，知道了 seq2 还没有收到，就会在定时器过期之前，重传丢失的 seq2。\n * 最后，收到了 seq2，此时因为 seq3，seq4，seq5 都收到了，于是 ack 回 6 。\n\n所以，快速重传的工作方式是当收到三个相同的 ack 报文时，会在定时器过期之前，重传丢失的报文段。\n\n快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。\n\n比如对于上面的例子，是重传 seq2 呢？还是重传 seq2、seq3、seq4、seq5 呢？因为发送端并不清楚这连续的三个 ack 2 是谁传回来的。\n\n为了解决不知道该重传哪些 tcp 报文，于是就有 sack 方法。\n\n\n# sack 方法\n\n还有一种实现重传机制的方式叫：sack（ selective acknowledgment 选择性确认）。\n\n这种方式需要在 tcp 头部「选项」字段里加一个 sack的东西，它可以将缓存的数据发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。\n\n如下图，发送方收到了三次同样的 ack 确认报文，于是就会触发快速重发机制，通过 sack 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 tcp 段进行重复。\n\n\n\n\n# duplicate sack\n\nduplicate sack 又称 d-sack，其主要使用了 sack 来告诉「发送方」有哪些数据被重复接收了。\n\n下面举例两个栗子，来说明 d-sack 的作用。\n\n栗子一号：ack 丢包:\n\n\n\n「接收方」发给「发送方」的两个 ack 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499） 于是「接收方」发现数据是重复收到的，于是回了一个 sack = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ack 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 sack 就代表着 d-sack。 这样「发送方」就知道了，数据没有丢，是「接收方」的 ack 确认报文丢了。 栗子二号：网络延时:\n\n\n\n * 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 ack 1500 的确认报文。\n * 而后面报文到达的三个相同的 ack 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；\n * 所以「接收方」回了一个 sack=1000~1500，因为 ack 已经到了 3000，所以这个 sack 是 d-sack，表示收到了重复的包。\n * 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ack 包丢了，而是因为网络延迟了。\n\n可见，d-sack 有这么几个好处：\n\n 1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ack 包丢了;\n 2. 可以知道是不是「发送方」的数据包被网络延迟了;\n 3. 可以知道网络中是不是把「发送方」的数据包给复制了;\n\n\n# 参考\n\ntcp滑动窗口和重传机制",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"为什么需要序列化？有什么序列化的方式？",frontmatter:{title:"为什么需要序列化？有什么序列化的方式？",date:"2022-09-21T22:38:38.000Z",permalink:"/pages/68d6c8/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/190.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/190.为什么需要序列化？有什么序列化的方式？.md",key:"v-0e7ed85a",path:"/pages/68d6c8/",headers:[{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:2},{level:2,title:"2.为什么要序列化？实现序列化的作用是什么？",slug:"_2-为什么要序列化-实现序列化的作用是什么",normalizedTitle:"2.为什么要序列化？实现序列化的作用是什么？",charIndex:68},{level:2,title:"3.什么情况下需要序列化？",slug:"_3-什么情况下需要序列化",normalizedTitle:"3.什么情况下需要序列化？",charIndex:467},{level:2,title:"4.序列化的方式",slug:"_4-序列化的方式",normalizedTitle:"4.序列化的方式",charIndex:599},{level:2,title:"5.序列化技术选型的几个关键点",slug:"_5-序列化技术选型的几个关键点",normalizedTitle:"5.序列化技术选型的几个关键点",charIndex:735}],headersStr:"定义 2.为什么要序列化？实现序列化的作用是什么？ 3.什么情况下需要序列化？ 4.序列化的方式 5.序列化技术选型的几个关键点",content:"# 定义\n\n1）序列化：把对象转化为可传输的字节序列过程称为序列化。\n\n2）反序列化：把字节序列还原为对象的过程称为反序列化。\n\n\n# 2.为什么要序列化？实现序列化的作用是什么？\n\n如果光看定义我想你很难一下子理解序列化的意义，那么我们可以从另一个角度来推导出什么是序列化, 那么究竟序列化的目的是什么？\n\n其实序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。\n\n因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。\n\n如果我们要把一栋房子从一个地方运输到另一个地方去，序列化就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，反序列化就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程\n\n\n# 3.什么情况下需要序列化？\n\n通过上面我想你已经知道了凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。\n\n本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。\n\n\n# 4.序列化的方式\n\n序列化只是一种拆装组装对象的规则，那么这种规则肯定也可能有多种多样，比如现在常见的序列化方式有：\n\nJDK（不支持跨语言）、JSON、XML、Hessian、Kryo（不支持跨语言）、Thrift、Protostuff、FST（不支持跨语言）\n\n\n# 5.序列化技术选型的几个关键点\n\n序列化协议各有千秋，不能简单的说一种序列化协议是最好的，只能从你的当时环境下去选择最适合你们的序列化协议，如果你要为你的公司项目进行序列化技术的选型，那么主要从以下几个因素。\n\n协议是否支持跨平台\n\n如果你们公司有好多种语言进行混合开发，那么就肯定不适合用有语言局限性的序列化协议，要不然你JDK序列化出来的格式，其他语言并没法支持。\n\n序列化的速度\n\n如果序列化的频率非常高，那么选择序列化速度快的协议会为你的系统性能提升不少。\n\n序列化出来的大小\n\n如果频繁的在网络中传输的数据那就需要数据越小越好，小的数据传输快，也不占带宽，也能整体提升系统的性能。",normalizedContent:"# 定义\n\n1）序列化：把对象转化为可传输的字节序列过程称为序列化。\n\n2）反序列化：把字节序列还原为对象的过程称为反序列化。\n\n\n# 2.为什么要序列化？实现序列化的作用是什么？\n\n如果光看定义我想你很难一下子理解序列化的意义，那么我们可以从另一个角度来推导出什么是序列化, 那么究竟序列化的目的是什么？\n\n其实序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是io，而我们的io支持的数据格式就是字节数组。\n\n因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从io流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。\n\n如果我们要把一栋房子从一个地方运输到另一个地方去，序列化就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，反序列化就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程\n\n\n# 3.什么情况下需要序列化？\n\n通过上面我想你已经知道了凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。\n\n本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。\n\n\n# 4.序列化的方式\n\n序列化只是一种拆装组装对象的规则，那么这种规则肯定也可能有多种多样，比如现在常见的序列化方式有：\n\njdk（不支持跨语言）、json、xml、hessian、kryo（不支持跨语言）、thrift、protostuff、fst（不支持跨语言）\n\n\n# 5.序列化技术选型的几个关键点\n\n序列化协议各有千秋，不能简单的说一种序列化协议是最好的，只能从你的当时环境下去选择最适合你们的序列化协议，如果你要为你的公司项目进行序列化技术的选型，那么主要从以下几个因素。\n\n协议是否支持跨平台\n\n如果你们公司有好多种语言进行混合开发，那么就肯定不适合用有语言局限性的序列化协议，要不然你jdk序列化出来的格式，其他语言并没法支持。\n\n序列化的速度\n\n如果序列化的频率非常高，那么选择序列化速度快的协议会为你的系统性能提升不少。\n\n序列化出来的大小\n\n如果频繁的在网络中传输的数据那就需要数据越小越好，小的数据传输快，也不占带宽，也能整体提升系统的性能。",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"TCP 中 SYN 攻击是什么？如何防止？",frontmatter:{title:"TCP 中 SYN 攻击是什么？如何防止？",date:"2022-09-21T22:39:09.000Z",permalink:"/pages/d0c6d3/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/210.TCP%20%E4%B8%AD%20SYN%20%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/210.TCP 中 SYN 攻击是什么？如何防止？.md",key:"v-15fe5424",path:"/pages/d0c6d3/",headers:[{level:2,title:"SYN Flooding简介",slug:"syn-flooding简介",normalizedTitle:"syn flooding简介",charIndex:2},{level:2,title:"TCP SYN Flood攻击原理",slug:"tcp-syn-flood攻击原理",normalizedTitle:"tcp syn flood攻击原理",charIndex:361},{level:2,title:"如何检测SYN攻击",slug:"如何检测syn攻击",normalizedTitle:"如何检测syn攻击",charIndex:1553},{level:2,title:"常见的防御SYN攻击方法",slug:"常见的防御syn攻击方法",normalizedTitle:"常见的防御syn攻击方法",charIndex:1651},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1756}],headersStr:"SYN Flooding简介 TCP SYN Flood攻击原理 如何检测SYN攻击 常见的防御SYN攻击方法 参考",content:"# SYN Flooding简介\n\n拒绝服务攻击（DDoS）从1970 年出现直到今天都依然在作祟\n\n并给全球范围内的各大组织带来了不可估量的损失。\n\nSYN Flood是互联网上最经典的DDoS攻击方式之一，\n\n最早出现于 1999 年左右，雅虎是当时最著名的受害者。\n\nSYN Flood攻击利用了 TCP 三次握手的缺陷，能够以较小代价使目标服务器无法响应，且难以追查。\n\nSYN flood 是一种常见的 DOS（denial of service拒绝服务）和 DDos(distributed denial of serivce 分布式拒绝服务）攻击方式。\n\n这是一种使用TCP协议缺陷，发送大量的伪造的 TCP 连接请求，\n\n使得被攻击方 CPU 或内存资源耗尽，最终导致被攻击方无法提供正常的服务。\n\n\n# TCP SYN Flood攻击原理\n\nTCP SYN Flood 攻击利用的是 TCP 的三次握手（SYN -> SYN/ACK -> ACK），\n\n假设连接发起方是A，连接接受方是 B，即 B 在某个端口（Port）上监听A发出的连接请求，\n\n过程如下图所示，左边是A，右边是B。\n\n\n\nA 首先发送 SYN（Synchronization）消息给 B，要求 B 做好接收数据的准备；\n\nB 收到后反馈 SYN-ACK（Synchronization-Acknowledgement） 消息给A，这个消息的目的有两个：\n\n * 向 A 确认已做好接收数据的准备\n\n * 同时要求 A 也做好接收数据的准备，此时 B 已向 A 确认好接收状态，并等待 A 的确认，连接处于半开状态（Half-Open），顾名思义只开了一半；A 收到后再次发送ACK (Acknowledgement) 消息给B，向 B 确认也做好了接收数据的准备，至此三次握手完成，「连接」就建立了，\n\n大家注意到没有，最关键的一点在于双方是否都按对方的要求进入了可以接收消息的状态。而这个状态的确认主要是双方将要使用的消息序号(SquenceNum)，TCP 为保证消息按发送顺序抵达接收方的上层应用，需要用消息序号来标记消息的发送先后顺序的。\n\nTCP是「双工」(Duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 SYN 和 SYN-ACK 消息开启了A→B的单向通信通道（B 获知了 A 的消息序号）；SYN-ACK 和 ACK 消息开启了B→A单向通信通道（A获知了B的消息序号）。\n\n上面讨论的是双方在诚实守信，正常情况下的通信。\n\n但实际情况是，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。\n\n假设 B 通过某 TCP 端口提供服务，B 在收到 A 的 SYN 消息时，积极的反馈了SYN-ACK 消息，\n\n使连接进入半开状态，因为 B 不确定自己发给 A 的 SYN-ACK 消息或 A 反馈的 ACK 消息是否会丢在半路，\n\n所以会给每个待完成的半开连接都设一个Timer，如果超过时间还没有收到 A 的 ACK 消息，\n\n则重新发送一次 SYN-ACK 消息给A，直到重试超过一定次数时才会放弃。\n\n\n\nB 为帮助 A 能顺利连接，需要分配内核资源维护半开连接，那么当 B 面临海量的连接 A 时，如上图所示，SYN Flood 攻击就形成了。攻击方 A 可以控制肉鸡向 B 发送大量 SYN 消息但不响应 ACK 消息，或者干脆伪造 SYN 消息中的 Source IP，使 B 反馈的 SYN-ACK 消息石沉大海，导致 B 被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。\n\n\n# 如何检测SYN攻击\n\n查看服务器上是否能看到大量的半连接状态时，特别时源IP地址时随机的，基本可以断定这是一次SYN攻击\n\nnetstat -ntp|grep SYB_RECV\n\n\n1\n\n\n\n# 常见的防御SYN攻击方法\n\n * 缩短超时（SYN Timeout) 时间\n * 增加最大半连接数（SYN队列）\n * 过滤网关防护\n * SYN cookies技术\n * 减少syn+ack重传次数\n\n\n# 参考\n\nTCP/IP常见攻击手段",normalizedContent:"# syn flooding简介\n\n拒绝服务攻击（ddos）从1970 年出现直到今天都依然在作祟\n\n并给全球范围内的各大组织带来了不可估量的损失。\n\nsyn flood是互联网上最经典的ddos攻击方式之一，\n\n最早出现于 1999 年左右，雅虎是当时最著名的受害者。\n\nsyn flood攻击利用了 tcp 三次握手的缺陷，能够以较小代价使目标服务器无法响应，且难以追查。\n\nsyn flood 是一种常见的 dos（denial of service拒绝服务）和 ddos(distributed denial of serivce 分布式拒绝服务）攻击方式。\n\n这是一种使用tcp协议缺陷，发送大量的伪造的 tcp 连接请求，\n\n使得被攻击方 cpu 或内存资源耗尽，最终导致被攻击方无法提供正常的服务。\n\n\n# tcp syn flood攻击原理\n\ntcp syn flood 攻击利用的是 tcp 的三次握手（syn -> syn/ack -> ack），\n\n假设连接发起方是a，连接接受方是 b，即 b 在某个端口（port）上监听a发出的连接请求，\n\n过程如下图所示，左边是a，右边是b。\n\n\n\na 首先发送 syn（synchronization）消息给 b，要求 b 做好接收数据的准备；\n\nb 收到后反馈 syn-ack（synchronization-acknowledgement） 消息给a，这个消息的目的有两个：\n\n * 向 a 确认已做好接收数据的准备\n\n * 同时要求 a 也做好接收数据的准备，此时 b 已向 a 确认好接收状态，并等待 a 的确认，连接处于半开状态（half-open），顾名思义只开了一半；a 收到后再次发送ack (acknowledgement) 消息给b，向 b 确认也做好了接收数据的准备，至此三次握手完成，「连接」就建立了，\n\n大家注意到没有，最关键的一点在于双方是否都按对方的要求进入了可以接收消息的状态。而这个状态的确认主要是双方将要使用的消息序号(squencenum)，tcp 为保证消息按发送顺序抵达接收方的上层应用，需要用消息序号来标记消息的发送先后顺序的。\n\ntcp是「双工」(duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 syn 和 syn-ack 消息开启了a→b的单向通信通道（b 获知了 a 的消息序号）；syn-ack 和 ack 消息开启了b→a单向通信通道（a获知了b的消息序号）。\n\n上面讨论的是双方在诚实守信，正常情况下的通信。\n\n但实际情况是，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。\n\n假设 b 通过某 tcp 端口提供服务，b 在收到 a 的 syn 消息时，积极的反馈了syn-ack 消息，\n\n使连接进入半开状态，因为 b 不确定自己发给 a 的 syn-ack 消息或 a 反馈的 ack 消息是否会丢在半路，\n\n所以会给每个待完成的半开连接都设一个timer，如果超过时间还没有收到 a 的 ack 消息，\n\n则重新发送一次 syn-ack 消息给a，直到重试超过一定次数时才会放弃。\n\n\n\nb 为帮助 a 能顺利连接，需要分配内核资源维护半开连接，那么当 b 面临海量的连接 a 时，如上图所示，syn flood 攻击就形成了。攻击方 a 可以控制肉鸡向 b 发送大量 syn 消息但不响应 ack 消息，或者干脆伪造 syn 消息中的 source ip，使 b 反馈的 syn-ack 消息石沉大海，导致 b 被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。\n\n\n# 如何检测syn攻击\n\n查看服务器上是否能看到大量的半连接状态时，特别时源ip地址时随机的，基本可以断定这是一次syn攻击\n\nnetstat -ntp|grep syb_recv\n\n\n1\n\n\n\n# 常见的防御syn攻击方法\n\n * 缩短超时（syn timeout) 时间\n * 增加最大半连接数（syn队列）\n * 过滤网关防护\n * syn cookies技术\n * 减少syn+ack重传次数\n\n\n# 参考\n\ntcp/ip常见攻击手段",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"什么是 ARP 协议？简述其使用场景",frontmatter:{title:"什么是 ARP 协议？简述其使用场景",date:"2022-09-21T22:53:54.000Z",permalink:"/pages/665162/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/230.%E4%BB%80%E4%B9%88%E6%98%AF%20ARP%20%E5%8D%8F%E8%AE%AE%EF%BC%9F%E7%AE%80%E8%BF%B0%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"02.计算机基础/10.计算机网络/230.什么是 ARP 协议？简述其使用场景.md",key:"v-01df2b5d",path:"/pages/665162/",headers:[{level:2,title:"什么是 Mac 地址？",slug:"什么是-mac-地址",normalizedTitle:"什么是 mac 地址？",charIndex:2},{level:2,title:"ARP 协议解决了什么问题地位如何？",slug:"arp-协议解决了什么问题地位如何",normalizedTitle:"arp 协议解决了什么问题地位如何？",charIndex:832},{level:2,title:"ARP 协议工作原理",slug:"arp-协议工作原理",normalizedTitle:"arp 协议工作原理",charIndex:1036},{level:3,title:"同一局域网内的 MAC 寻址",slug:"同一局域网内的-mac-寻址",normalizedTitle:"同一局域网内的 mac 寻址",charIndex:1237},{level:3,title:"不同局域网内的 MAC 寻址",slug:"不同局域网内的-mac-寻址",normalizedTitle:"不同局域网内的 mac 寻址",charIndex:2663}],headersStr:"什么是 Mac 地址？ ARP 协议解决了什么问题地位如何？ ARP 协议工作原理 同一局域网内的 MAC 寻址 不同局域网内的 MAC 寻址",content:"# 什么是 Mac 地址？\n\nMAC 地址的全称是 媒体访问控制地址（Media Access Control Address）。\n\n如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。\n\n\n\n路由器的背面就会注明 MAC 位址.\n\n可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。\n\n还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。 MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。\n\nMAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。\n\n最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。\n\n\n# ARP 协议解决了什么问题地位如何？\n\nARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。\n\n因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址.\n\nARP 协议解决了 IP 地址转 MAC 地址的问题。\n\n\n# ARP 协议工作原理\n\nARP 协议工作时有一个大前提，那就是 ARP 表。\n\n在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <IP, MAC, TTL> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。\n\nARP 的工作原理将分两种场景讨论：\n\n同一局域网内的 MAC 寻址； 从一个局域网到另一个局域网中的网络设备的寻址。\n\n\n# 同一局域网内的 MAC 寻址\n\n假设当前有如下场景：IP 地址为137.196.7.23的主机 A，想要给同一局域网内的 IP 地址为137.196.7.14主机 B，发送 IP 数据报文。\n\n再次强调，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，而 ARP 协议就是解决这一问题的。 为了达成这一目标，主机 A 将不得不通过 ARP 协议来获取主机 B 的 MAC 地址，并将 IP 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：\n\n 1. 主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。\n\n 2. 主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。\n\nARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——FF-FF-FF-FF-FF-FF，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。\n\n 3. 主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。\n\n 4. 主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。\n\nARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。\n\n 5. 主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。\n\n\n\n在整个过程中，有几点需要补充说明的是：\n\n 1. 主机 A 想要给主机 B 发送 IP 数据报，如果主机 B 的 IP-MAC 映射信息已经存在于主机 A 的 ARP 表中，那么主机 A 无需广播，只需提取 MAC 地址并构造链路层帧发送即可。\n\n 2. ARP 表中的映射信息是有生存周期的，典型值为 20 分钟。\n\n 3. 目标主机接收到了问询主机构造的问询报文后，将先把问询主机的 IP-MAC 映射存进自己的 ARP 表中，这样才能获取到响应的目标 MAC 地址，顺利的发送响应分组。\n\n总结来说，ARP 协议是一个广播问询，单播响应协议。\n\n\n# 不同局域网内的 MAC 寻址\n\n更复杂的情况是，发送主机 A 和接收主机 B 不在同一个子网中，\n\n假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，\n\n一般情况下，我们说网络设备都有一个 IP 地址和一个 MAC 地址，这里说的网络设备，\n\n更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。\n\n因此，在讨论 ARP 表时，路由器的多个接口都个各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。\n\n接下来，回顾同一子网内的 MAC 寻址，如果主机 A 发送一个广播问询分组，那么 A 所在子网内的所有设备（接口）都将不会捕获该分组，\n\n因为该分组的目的 IP 地址在另一个子网中，本子网内不会有设备成功接收。\n\n那么，主机 A 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：\n\n 1. 主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。\n\n目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。\n\n 2. 主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。\n\n 3. 主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是本子网内与路由器连接的接口的 MAC 地址。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。\n\n 4. 目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。\n\n到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。\n\n 5. 路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。\n\n 6. 路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。\n\n 7. 路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。\n\n",normalizedContent:"# 什么是 mac 地址？\n\nmac 地址的全称是 媒体访问控制地址（media access control address）。\n\n如果说，互联网中每一个资源都由 ip 地址唯一标识（ip 协议内容），那么一切网络设备都由 mac 地址唯一标识。\n\n\n\n路由器的背面就会注明 mac 位址.\n\n可以理解为，mac 地址是一个网络设备真正的身份证号，ip 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 ip 地址，他的身份证号才是他的 mac 地址），也可以理解为 mac 地址是身份证号，ip 地址是邮政地址。mac 地址也有一些别称，如 lan 地址、物理地址、以太网地址等。\n\n还有一点要知道的是，不仅仅是网络资源才有 ip 地址，网络设备也有 ip 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 ip 地址通常是内网 ip，内网的设备在与内网以外的设备进行通信时，需要用到 nat 协议。 mac 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），mac 地址由 ieee 统一管理与分配，理论上，一个网络设备中的网卡上的 mac 地址是永久的。不同的网卡生产商从 ieee 那里购买自己的 mac 地址空间（mac 的前 24 比特），也就是前 24 比特由 ieee 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 mac 地址不会重复。\n\nmac 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 ip 地址不具有这些性质，当一台设备更换了网络，它的 ip 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。\n\n最后，记住，mac 地址有一个特殊地址：ff-ff-ff-ff-ff-ff（全 1 地址），该地址表示广播地址。\n\n\n# arp 协议解决了什么问题地位如何？\n\narp 协议，全称 地址解析协议（address resolution protocol），它解决的是网络层地址和链路层地址之间的转换问题。\n\n因为一个 ip 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 ip 地址属于逻辑地址，而 mac 地址才是物理地址.\n\narp 协议解决了 ip 地址转 mac 地址的问题。\n\n\n# arp 协议工作原理\n\narp 协议工作时有一个大前提，那就是 arp 表。\n\n在一个局域网内，每个网络设备都自己维护了一个 arp 表，arp 表记录了某些其他网络设备的 ip 地址-mac 地址映射关系，该映射关系以 <ip, mac, ttl> 三元组的形式存储。其中，ttl 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。\n\narp 的工作原理将分两种场景讨论：\n\n同一局域网内的 mac 寻址； 从一个局域网到另一个局域网中的网络设备的寻址。\n\n\n# 同一局域网内的 mac 寻址\n\n假设当前有如下场景：ip 地址为137.196.7.23的主机 a，想要给同一局域网内的 ip 地址为137.196.7.14主机 b，发送 ip 数据报文。\n\n再次强调，当主机发送 ip 数据报文时（网络层），仅知道目的地的 ip 地址，并不清楚目的地的 mac 地址，而 arp 协议就是解决这一问题的。 为了达成这一目标，主机 a 将不得不通过 arp 协议来获取主机 b 的 mac 地址，并将 ip 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：\n\n 1. 主机 a 检索自己的 arp 表，发现 arp 表中并无主机 b 的 ip 地址对应的映射条目，也就无从知道主机 b 的 mac 地址。\n\n 2. 主机 a 将构造一个 arp 查询分组，并将其广播到所在的局域网中。\n\narp 分组是一种特殊报文，arp 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 ip 地址、发送和接收的 mac 地址。当然了，查询分组中，发送的 ip 地址，即为主机 a 的 ip 地址，接收的 ip 地址即为主机 b 的 ip 地址，发送的 mac 地址也是主机 a 的 mac 地址，但接收的 mac 地址绝不会是主机 b 的 mac 地址（因为这正是我们要问询的！），而是一个特殊值——ff-ff-ff-ff-ff-ff，之前说过，该 mac 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。\n\n 3. 主机 a 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 ip 地址是否为自己的 ip 地址，如果是，说明查询分组已经到达了主机 b，否则，该查询分组对当前设备无效，丢弃之。\n\n 4. 主机 b 收到了查询分组之后，验证是对自己的问询，接着构造一个 arp 响应分组，该分组的目的地只有一个——主机 a，发送给主机 a。同时，主机 b 提取查询分组中的 ip 地址和 mac 地址信息，在自己的 arp 表中构造一条主机 a 的 ip-mac 映射记录。\n\narp 响应分组具有和 arp 查询分组相同的构造，不同的是，发送和接受的 ip 地址恰恰相反，发送的 mac 地址为发送者本身，目标 mac 地址为查询分组的发送者，也就是说，arp 响应分组只有一个目的地，而非广播。\n\n 5. 主机 a 终将收到主机 b 的响应分组，提取出该分组中的 ip 地址和 mac 地址后，构造映射信息，加入到自己的 arp 表中。\n\n\n\n在整个过程中，有几点需要补充说明的是：\n\n 1. 主机 a 想要给主机 b 发送 ip 数据报，如果主机 b 的 ip-mac 映射信息已经存在于主机 a 的 arp 表中，那么主机 a 无需广播，只需提取 mac 地址并构造链路层帧发送即可。\n\n 2. arp 表中的映射信息是有生存周期的，典型值为 20 分钟。\n\n 3. 目标主机接收到了问询主机构造的问询报文后，将先把问询主机的 ip-mac 映射存进自己的 arp 表中，这样才能获取到响应的目标 mac 地址，顺利的发送响应分组。\n\n总结来说，arp 协议是一个广播问询，单播响应协议。\n\n\n# 不同局域网内的 mac 寻址\n\n更复杂的情况是，发送主机 a 和接收主机 b 不在同一个子网中，\n\n假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，\n\n一般情况下，我们说网络设备都有一个 ip 地址和一个 mac 地址，这里说的网络设备，\n\n更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 ip 地址和 mac 地址。\n\n因此，在讨论 arp 表时，路由器的多个接口都个各自维护一个 arp 表，而非一个路由器只维护一个 arp 表。\n\n接下来，回顾同一子网内的 mac 寻址，如果主机 a 发送一个广播问询分组，那么 a 所在子网内的所有设备（接口）都将不会捕获该分组，\n\n因为该分组的目的 ip 地址在另一个子网中，本子网内不会有设备成功接收。\n\n那么，主机 a 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：\n\n 1. 主机 a 查询 arp 表，期望寻找到目标路由器的本子网接口的 mac 地址。\n\n目标路由器指的是，根据目的主机 b 的 ip 地址，分析出 b 所在的子网，能够把报文转发到 b 所在子网的那个路由器。\n\n 2. 主机 a 未能找到目标路由器的本子网接口的 mac 地址，将采用 arp 协议，问询到该 mac 地址，由于目标接口与主机 a 在同一个子网内，该过程与同一局域网内的 mac 寻址相同。\n\n 3. 主机 a 获取到目标接口的 mac 地址，先构造 ip 数据报，其中源 ip 是 a 的 ip 地址，目的 ip 地址是 b 的 ip 地址，再构造链路层帧，其中源 mac 地址是 a 的 mac 地址，目的 mac 地址是本子网内与路由器连接的接口的 mac 地址。主机 a 将把这个链路层帧，以单播的方式，发送给目标接口。\n\n 4. 目标接口接收到了主机 a 发过来的链路层帧，解析，根据目的 ip 地址，查询转发表，将该 ip 数据报转发到与主机 b 所在子网相连的接口上。\n\n到此，该帧已经从主机 a 所在的子网，转移到了主机 b 所在的子网了。\n\n 5. 路由器接口查询 arp 表，期望寻找到主机 b 的 mac 地址。\n\n 6. 路由器接口如未能找到主机 b 的 mac 地址，将采用 arp 协议，广播问询，单播响应，获取到主机 b 的 mac 地址。\n\n 7. 路由器接口将对 ip 数据报重新封装成链路层帧，目标 mac 地址为主机 b 的 mac 地址，单播发送，直到目的地。\n\n",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"什么是跨域，什么情况下会发生跨域请求？",frontmatter:{title:"什么是跨域，什么情况下会发生跨域请求？",date:"2022-09-21T22:54:11.000Z",permalink:"/pages/eadd05/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/240.%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/240.什么是跨域，什么情况下会发生跨域请求？.md",key:"v-7370facf",path:"/pages/eadd05/",headersStr:null,content:'说起跨域请求，必须要了解浏览器的同源策略，同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。\n\n解决跨域请求的常用方法是：\n\n * 通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。\n * 通过 Jsonp 跨域\n * 其它跨域解决方案\n\n重点谈一下 Jsonp 跨域原理。浏览器的同源策略把跨域请求都禁止了，但是页面中的',normalizedContent:'说起跨域请求，必须要了解浏览器的同源策略，同源策略/sop（same origin policy）是一种约定，由 netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 xss、csfr 等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。\n\n解决跨域请求的常用方法是：\n\n * 通过代理来避免，比如使用 nginx 在后端转发请求，避免了前端出现跨域的问题。\n * 通过 jsonp 跨域\n * 其它跨域解决方案\n\n重点谈一下 jsonp 跨域原理。浏览器的同源策略把跨域请求都禁止了，但是页面中的',charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"简述 DDOS 攻击原理，如何防范它？",frontmatter:{title:"简述 DDOS 攻击原理，如何防范它？",date:"2022-09-21T22:53:23.000Z",permalink:"/pages/056828/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/220.%E7%AE%80%E8%BF%B0%20DDOS%20%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E5%AE%83%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/220.简述 DDOS 攻击原理，如何防范它？.md",key:"v-7fc8ca51",path:"/pages/056828/",headers:[{level:2,title:"DDoS 攻击究竟是什么？",slug:"ddos-攻击究竟是什么",normalizedTitle:"ddos 攻击究竟是什么？",charIndex:216},{level:2,title:"举个例子",slug:"举个例子",normalizedTitle:"举个例子",charIndex:458},{level:2,title:"SYN Flood进行DDoS攻击的实现原理",slug:"syn-flood进行ddos攻击的实现原理",normalizedTitle:"syn flood进行ddos攻击的实现原理",charIndex:766},{level:2,title:"如何应对 DDoS 攻击？",slug:"如何应对-ddos-攻击",normalizedTitle:"如何应对 ddos 攻击？",charIndex:1157}],headersStr:"DDoS 攻击究竟是什么？ 举个例子 SYN Flood进行DDoS攻击的实现原理 如何应对 DDoS 攻击？",content:"其实，像全球互联网各大公司，均遭受过大量的 DDoS。\n\n2018年，GitHub 在一瞬间遭到高达 1.35Tbps 的带宽攻击。\n\n这次 DDoS 攻击几乎可以堪称是互联网有史以来规模最大、威力最大的 DDoS 攻击了。\n\n在 GitHub 遭到攻击后，仅仅一周后，DDoS 攻击又开始对 Google、亚马逊甚至 Pornhub 等网站进行了 DDoS 攻击。\n\n后续的 DDoS 攻击带宽最高也达到了 1Tbps。\n\n\n# DDoS 攻击究竟是什么？\n\nDDos 全名 Distributed Denial of Service，翻译成中文就是分布式拒绝服务。\n\n指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。\n\n单一的DoS攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，\n\n使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。\n\n\n# 举个例子\n\n我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。\n\n平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。\n\n二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。\n\n上面这个例子讲的就是典型的 DDoS 攻击，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，\n\n大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。\n\n攻击方式很多，比如 ICMP Flood、UDP Flood、NTP Flood、SYN Flood、CC 攻击、DNS Query Flood等等。\n\n\n# SYN Flood进行DDoS攻击的实现原理\n\nSYN Flood 是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。\n\n一次正常的建立 TCP 连接，需要三次握手：客户端发送 SYN 报文，服务端收到请求并返回报文表示接受，客户端也返回确认，完成连接。\n\nSYN Flood 就是用户向服务器发送报文后突然死机或掉线，那么服务器在发出应答报文后就无法收到客户端的确认报文（第三次握手无法完成），这时服务器端一般会重试并等待一段时间后再丢弃这个未完成的连接。\n\n一个用户出现异常导致服务器的一个线程等待一会儿并不是大问题，但恶意攻击者大量模拟这种情况，服务器端为了维护数以万计的半连接而消耗非常多的资源，结果往往是无暇理睬客户的正常请求，甚至崩溃。从正常客户的角度看来，网站失去了响应，无法访问。\n\n\n# 如何应对 DDoS 攻击？\n\n 1. 高防服务器 还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。\n\n高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~\n\n 2. 黑名单 面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。\n\n 3. DDoS 清洗 DDos 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。\n\nDDoS 清洗会对用户请求数据进行实时监控，及时发现 **DOS **攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。\n\n 4. CDN 加速 CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。\n\n在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。",normalizedContent:"其实，像全球互联网各大公司，均遭受过大量的 ddos。\n\n2018年，github 在一瞬间遭到高达 1.35tbps 的带宽攻击。\n\n这次 ddos 攻击几乎可以堪称是互联网有史以来规模最大、威力最大的 ddos 攻击了。\n\n在 github 遭到攻击后，仅仅一周后，ddos 攻击又开始对 google、亚马逊甚至 pornhub 等网站进行了 ddos 攻击。\n\n后续的 ddos 攻击带宽最高也达到了 1tbps。\n\n\n# ddos 攻击究竟是什么？\n\nddos 全名 distributed denial of service，翻译成中文就是分布式拒绝服务。\n\n指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。\n\n单一的dos攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，\n\n使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。\n\n\n# 举个例子\n\n我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。\n\n平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。\n\n二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。\n\n上面这个例子讲的就是典型的 ddos 攻击，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，\n\n大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 ddos 攻击的高发行业。\n\n攻击方式很多，比如 icmp flood、udp flood、ntp flood、syn flood、cc 攻击、dns query flood等等。\n\n\n# syn flood进行ddos攻击的实现原理\n\nsyn flood 是一种利用 tcp 协议缺陷，发送大量伪造的 tcp 连接请求，从而使得被攻击方资源耗尽（cpu满负荷或内存不足）的攻击方式。\n\n一次正常的建立 tcp 连接，需要三次握手：客户端发送 syn 报文，服务端收到请求并返回报文表示接受，客户端也返回确认，完成连接。\n\nsyn flood 就是用户向服务器发送报文后突然死机或掉线，那么服务器在发出应答报文后就无法收到客户端的确认报文（第三次握手无法完成），这时服务器端一般会重试并等待一段时间后再丢弃这个未完成的连接。\n\n一个用户出现异常导致服务器的一个线程等待一会儿并不是大问题，但恶意攻击者大量模拟这种情况，服务器端为了维护数以万计的半连接而消耗非常多的资源，结果往往是无暇理睬客户的正常请求，甚至崩溃。从正常客户的角度看来，网站失去了响应，无法访问。\n\n\n# 如何应对 ddos 攻击？\n\n 1. 高防服务器 还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。\n\n高防服务器主要是指能独立硬防御 50gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~\n\n 2. 黑名单 面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。\n\n 3. ddos 清洗 ddos 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。\n\nddos 清洗会对用户请求数据进行实时监控，及时发现 **dos **攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。\n\n 4. cdn 加速 cdn 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。\n\n在现实中，cdn 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 ip，另一方面即使遭遇 ddos 攻击，也可以将流量分散到各个节点中，防止源站崩溃。",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"Cookie 和 Session 的关系和区别是什么？",frontmatter:{title:"Cookie 和 Session 的关系和区别是什么？",date:"2022-09-21T22:54:25.000Z",permalink:"/pages/980cc7/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/250.Cookie%20%E5%92%8C%20Session%20%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/250.Cookie 和 Session 的关系和区别是什么？.md",key:"v-15ca313a",path:"/pages/980cc7/",headers:[{level:2,title:"什么是认证（Authentication）",slug:"什么是认证-authentication",normalizedTitle:"什么是认证（authentication）",charIndex:2},{level:2,title:"什么是授权（Authorization）",slug:"什么是授权-authorization",normalizedTitle:"什么是授权（authorization）",charIndex:175},{level:2,title:"什么是凭证（Credentials）",slug:"什么是凭证-credentials",normalizedTitle:"什么是凭证（credentials）",charIndex:362},{level:2,title:"什么是 Cookie",slug:"什么是-cookie",normalizedTitle:"什么是 cookie",charIndex:764},{level:2,title:"什么是 Session",slug:"什么是-session",normalizedTitle:"什么是 session",charIndex:1164},{level:2,title:"二：Cookie和Session的区别？",slug:"二-cookie和session的区别",normalizedTitle:"二：cookie和session的区别？",charIndex:1718},{level:2,title:"三：为什么需要Cookie和Session，它们的联系是什么？",slug:"三-为什么需要cookie和session-它们的联系是什么",normalizedTitle:"三：为什么需要cookie和session，它们的联系是什么？",charIndex:2008},{level:2,title:"四：如果浏览器禁止使用cookie，那如何保证判断用户是否登录的机制正常执行？",slug:"四-如果浏览器禁止使用cookie-那如何保证判断用户是否登录的机制正常执行",normalizedTitle:"四：如果浏览器禁止使用cookie，那如何保证判断用户是否登录的机制正常执行？",charIndex:2476},{level:2,title:"五：如何考虑分布式 Session 问题？",slug:"五-如何考虑分布式-session-问题",normalizedTitle:"五：如何考虑分布式 session 问题？",charIndex:2842}],headersStr:"什么是认证（Authentication） 什么是授权（Authorization） 什么是凭证（Credentials） 什么是 Cookie 什么是 Session 二：Cookie和Session的区别？ 三：为什么需要Cookie和Session，它们的联系是什么？ 四：如果浏览器禁止使用cookie，那如何保证判断用户是否登录的机制正常执行？ 五：如何考虑分布式 Session 问题？",content:"# 什么是认证（Authentication）\n\n通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功） 互联网中的认证：\n\n * 用户名密码登录\n * 邮箱发送登录链接\n * 手机号接收验证码\n * 只要你能收到邮箱/验证码，就默认你是账号的主人\n\n\n# 什么是授权（Authorization）\n\n用户授予第三方应用访问该用户某些资源的权限\n\n * 你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）\n * 你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）\n * 实现授权的方式有：cookie、session、token、OAuth\n\n\n# 什么是凭证（Credentials）\n\n实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份\n\n * 在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。\n * 在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。\n * 在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。\n\n\n# 什么是 Cookie\n\n * HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。\n * cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。\n\n\n# 什么是 Session\n\n * session 是另一种记录服务器和客户端会话状态的机制\n * session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中\n\n\n\nsession 认证流程：\n\n * 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session\n * 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器\n * 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名\n * 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。\n\n根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\n\n\n# 二：Cookie和Session的区别？\n\n存储位置不同：cookie保存在客户端浏览器，session保存在服务器端；\n\n存取方式不同：cookie只能保存ASCII（是基于拉丁字母的一套电脑编码系统），session能保存任意数据类型；\n\n有效期不同：cookie中的数据可以长时间存在，session中的数据在会话结束或者浏览器关闭时失效；\n\n数据安全性不同：因为cookie是保存在浏览器中的，数据安全性相对较差；session是存储在服务器端的，安全性相对较高；\n\n存储大小不同：cookie一般保存的数据大小不会超过4K；而session理论上来说没有限制；\n\n\n# 三：为什么需要Cookie和Session，它们的联系是什么？\n\n因为浏览器是无状态的（http协议是无状态），浏览器并不知道是谁在跟服务器联系，这个时候就需要一个机制来告诉服务器，是谁在操作浏览器，操作人是否登录等，要实现这个机制，就需要cookie和session配合完成；\n\n当用户第一次访问服务器时，服务器会根据用户提交的信息生成session，然后给浏览器返回一个sessionId，浏览器接收到这个sessionId后，保存在cookie中，同时cookie记录此sessionId属于哪个域名；\n\n用户再次访问服务器时，请求会自动判断此域名下是否用cookie信息，如果存在cookie，则将cookie发送给服务器，服务器解析cookie拿到sessionId，然后根据sessionId查询session信息，如果能找到session信息，则可以执行后面的操作，如果没有则说明没有登录或者登录已经失效；\n\nsessionId是联系cookie和session的桥梁，大部分系统也是通过这个来判断用户是否登录；\n\n\n# 四：如果浏览器禁止使用cookie，那如何保证判断用户是否登录的机制正常执行？\n\n第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456...。\n\n第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。\n\nToken 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。\n\n当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。\n\n\n# 五：如何考虑分布式 Session 问题？\n\n在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。\n\n分布式 Session 一般会有以下几种解决方案：\n\nNginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。\n\nSession 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。\n\n共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。\n\n建议采用第三种方案。\n\n参考： 还分不清 Cookie、Session、Token、JWT？",normalizedContent:"# 什么是认证（authentication）\n\n通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功） 互联网中的认证：\n\n * 用户名密码登录\n * 邮箱发送登录链接\n * 手机号接收验证码\n * 只要你能收到邮箱/验证码，就默认你是账号的主人\n\n\n# 什么是授权（authorization）\n\n用户授予第三方应用访问该用户某些资源的权限\n\n * 你在安装手机应用的时候，app 会询问是否允许授予权限（访问相册、地理位置等权限）\n * 你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）\n * 实现授权的方式有：cookie、session、token、oauth\n\n\n# 什么是凭证（credentials）\n\n实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份\n\n * 在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。\n * 在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。\n * 在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。\n\n\n# 什么是 cookie\n\n * http 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。\n * cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。\n\n\n# 什么是 session\n\n * session 是另一种记录服务器和客户端会话状态的机制\n * session 是基于 cookie 实现的，session 存储在服务器端，sessionid 会被存储到客户端的cookie 中\n\n\n\nsession 认证流程：\n\n * 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 session\n * 请求返回时将此 session 的唯一标识信息 sessionid 返回给浏览器\n * 浏览器接收到服务器返回的 sessionid 信息后，会将此信息存入到 cookie 中，同时 cookie 记录此 sessionid 属于哪个域名\n * 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 cookie 信息，如果存在自动将 cookie 信息也发送给服务端，服务端会从 cookie 中获取 sessionid，再根据 sessionid 查找对应的 session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 session 证明用户已经登录可执行后面操作。\n\n根据以上流程可知，sessionid 是连接 cookie 和 session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\n\n\n# 二：cookie和session的区别？\n\n存储位置不同：cookie保存在客户端浏览器，session保存在服务器端；\n\n存取方式不同：cookie只能保存ascii（是基于拉丁字母的一套电脑编码系统），session能保存任意数据类型；\n\n有效期不同：cookie中的数据可以长时间存在，session中的数据在会话结束或者浏览器关闭时失效；\n\n数据安全性不同：因为cookie是保存在浏览器中的，数据安全性相对较差；session是存储在服务器端的，安全性相对较高；\n\n存储大小不同：cookie一般保存的数据大小不会超过4k；而session理论上来说没有限制；\n\n\n# 三：为什么需要cookie和session，它们的联系是什么？\n\n因为浏览器是无状态的（http协议是无状态），浏览器并不知道是谁在跟服务器联系，这个时候就需要一个机制来告诉服务器，是谁在操作浏览器，操作人是否登录等，要实现这个机制，就需要cookie和session配合完成；\n\n当用户第一次访问服务器时，服务器会根据用户提交的信息生成session，然后给浏览器返回一个sessionid，浏览器接收到这个sessionid后，保存在cookie中，同时cookie记录此sessionid属于哪个域名；\n\n用户再次访问服务器时，请求会自动判断此域名下是否用cookie信息，如果存在cookie，则将cookie发送给服务器，服务器解析cookie拿到sessionid，然后根据sessionid查询session信息，如果能找到session信息，则可以执行后面的操作，如果没有则说明没有登录或者登录已经失效；\n\nsessionid是联系cookie和session的桥梁，大部分系统也是通过这个来判断用户是否登录；\n\n\n# 四：如果浏览器禁止使用cookie，那如何保证判断用户是否登录的机制正常执行？\n\n第一种方案，每次请求中都携带一个 sessionid 的参数，也可以 post 的方式提交，也可以在请求的地址后面拼接 xxx?sessionid=123456...。\n\n第二种方案，token 机制。token 机制多用于 app 客户端和服务器交互的模式，也可以用于 web 端做用户状态管理。\n\ntoken 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。token 机制和 cookie 和 session 的使用机制比较类似。\n\n当用户第一次登录后，服务器根据提交的用户信息生成一个 token，响应时将 token 返回给客户端，以后客户端只需带上这个 token 前来请求数据即可，无需再次登录验证。\n\n\n# 五：如何考虑分布式 session 问题？\n\n在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 a 服务器登录了，第二次请求跑到服务 b 就会出现登录失效问题。\n\n分布式 session 一般会有以下几种解决方案：\n\nnginx ip_hash 策略，服务端使用 nginx 代理，每个请求按访问 ip 的 hash 分配，这样来自同一 ip 固定访问一个后台服务器，避免了在服务器 a 创建 session，第二次分发到服务器 b 的现象。\n\nsession 复制，任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点。\n\n共享 session，服务端无状态话，将用户的 session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。\n\n建议采用第三种方案。\n\n参考： 还分不清 cookie、session、token、jwt？",charsets:{cjk:!0},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"简述 WebSocket 是如何进行传输的",frontmatter:{title:"简述 WebSocket 是如何进行传输的",date:"2022-09-21T22:54:37.000Z",permalink:"/pages/172129/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/260.%E7%AE%80%E8%BF%B0%20WebSocket%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%A0%E8%BE%93%E7%9A%84.html",relativePath:"02.计算机基础/10.计算机网络/260.简述 WebSocket 是如何进行传输的.md",key:"v-7707a260",path:"/pages/172129/",headers:[{level:2,title:"WebSocket 协议",slug:"websocket-协议",normalizedTitle:"websocket 协议",charIndex:729},{level:2,title:"WebSocket与TCP、Http协议之间的关系",slug:"websocket与tcp、http协议之间的关系",normalizedTitle:"websocket与tcp、http协议之间的关系",charIndex:1550}],headersStr:"WebSocket 协议 WebSocket与TCP、Http协议之间的关系",content:"一、什么是 WebSocket ？ WebSocket ——一种在 2011 年被互联网工程任务组（ IETF ）标准化的协议。\n\nWebSocket 解决了一个长期存在的问题：既然底层的协议（ HTTP ）是一个请求 / 响应模式的交互序列，\n\n那么如何实时地发布信息呢？\n\nAJAX 提供了一定程度上的改善，但是数据流仍然是由客户端所发送的请求驱动的。\n\n还有其他的一些或多或少的取巧方式(Comet) WebSocket 规范以及它的实现代表了对一种更加有效的解决方案的尝试。\n\n简单地说，WebSocket 提供了“在一个单个的 TCP 连接上提供双向的通信……结合 WebSocket API ……\n\n它为网页和远程服务器之间的双向通信提供了一种替代 HTTP 轮询的方案。\n\n但是最终它们仍然属于扩展性受限的变通之法。也就是说，WebSocket 在客户端和\n\n服务器之间提供了真正的双向数据交换。\n\nWebSocket 连接允许客户端和服务器之间进行全双工通信，\n\n以便任一方都可以通过建立的连接将数据推送到另一端。\n\nWebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。\n\nWeb 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。 特点\n\n 1. HTML5 中的协议，实现与客户端与服务器双向，基于消息的文本或二进制数据通信\n\n 2. 适合于对数据的实时性要求比较强的场景，如通信、直播、共享桌面，特别适合于客户与服务频繁交互的情况下，如实时共享、多人协作等平台。\n\n 3. 采用新的协议，后端需要单独实现\n\n 4. 客户端并不是所有浏览器都支持\n\n\n# WebSocket 协议\n\nWebSocket协议是一种双向通信协议，它建立在TCP之上，同http一样通过TCP来传输数据，\n\n但是它和http最大的不同有两点：\n\n 1. WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/UA都能主动的向对方发送或接收数据，就像Socket一样，\n\n不同的是WebSocket是一种建立在Web基础上的一种简单模拟Socket的协议；\n\n 2. WebSocket需要通过握手连接，类似于TCP它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。\n\n下面是一个简单的建立握手的时序图：\n\n\n\n这里简单说明一下WebSocket握手的过程。\n\n当Web应用程序调用new WebSocket(url)接口时，Browser就开始了与地址为url的WebServer建立握手连接的过程。\n\n 1. Browser与WebSocket服务器通过TCP三次握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。\n\n 2. 在TCP建立连接成功后，Browser/UA通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。\n\n例如：\n\n\n\n 3. WebSocket服务器收到Browser/UA发送来的握手请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，\n\n就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。\n\n\n\n 4. Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口想服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。\n\n\n# WebSocket与TCP、Http协议之间的关系\n\nWebSocket与http协议一样都是基于TCP的，所以他们都是可靠的协议，\n\nWeb开发者调用的WebSocket的send函数在browser的实现中最终都是通过TCP的系统接口进行传输的。\n\nWebSocket和Http协议一样都属于应用层的协议，那么他们之间有没有什么关系呢？\n\n答案是肯定的，WebSocket在建立握手连接时，数据是通过http协议传输的，正如我们之前所看到的“GET/chat HTTP/1.1”，\n\n这里面用到的只是http协议一些简单的字段。但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。\n\n具体关系可以参考下图：\n\n",normalizedContent:"一、什么是 websocket ？ websocket ——一种在 2011 年被互联网工程任务组（ ietf ）标准化的协议。\n\nwebsocket 解决了一个长期存在的问题：既然底层的协议（ http ）是一个请求 / 响应模式的交互序列，\n\n那么如何实时地发布信息呢？\n\najax 提供了一定程度上的改善，但是数据流仍然是由客户端所发送的请求驱动的。\n\n还有其他的一些或多或少的取巧方式(comet) websocket 规范以及它的实现代表了对一种更加有效的解决方案的尝试。\n\n简单地说，websocket 提供了“在一个单个的 tcp 连接上提供双向的通信……结合 websocket api ……\n\n它为网页和远程服务器之间的双向通信提供了一种替代 http 轮询的方案。\n\n但是最终它们仍然属于扩展性受限的变通之法。也就是说，websocket 在客户端和\n\n服务器之间提供了真正的双向数据交换。\n\nwebsocket 连接允许客户端和服务器之间进行全双工通信，\n\n以便任一方都可以通过建立的连接将数据推送到另一端。\n\nwebsocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。\n\nweb 浏览器和服务器都必须实现 websockets 协议来建立和维护连接。 特点\n\n 1. html5 中的协议，实现与客户端与服务器双向，基于消息的文本或二进制数据通信\n\n 2. 适合于对数据的实时性要求比较强的场景，如通信、直播、共享桌面，特别适合于客户与服务频繁交互的情况下，如实时共享、多人协作等平台。\n\n 3. 采用新的协议，后端需要单独实现\n\n 4. 客户端并不是所有浏览器都支持\n\n\n# websocket 协议\n\nwebsocket协议是一种双向通信协议，它建立在tcp之上，同http一样通过tcp来传输数据，\n\n但是它和http最大的不同有两点：\n\n 1. websocket是一种双向通信协议，在建立连接后，websocket服务器和browser/ua都能主动的向对方发送或接收数据，就像socket一样，\n\n不同的是websocket是一种建立在web基础上的一种简单模拟socket的协议；\n\n 2. websocket需要通过握手连接，类似于tcp它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。\n\n下面是一个简单的建立握手的时序图：\n\n\n\n这里简单说明一下websocket握手的过程。\n\n当web应用程序调用new websocket(url)接口时，browser就开始了与地址为url的webserver建立握手连接的过程。\n\n 1. browser与websocket服务器通过tcp三次握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，web应用程序将收到错误消息通知。\n\n 2. 在tcp建立连接成功后，browser/ua通过http协议传送websocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。\n\n例如：\n\n\n\n 3. websocket服务器收到browser/ua发送来的握手请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，\n\n就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。\n\n\n\n 4. browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时web开发者就可以在此时通过send接口想服务器发送数据。否则，握手连接失败，web应用程序会收到onerror消息，并且能知道连接失败的原因。\n\n\n# websocket与tcp、http协议之间的关系\n\nwebsocket与http协议一样都是基于tcp的，所以他们都是可靠的协议，\n\nweb开发者调用的websocket的send函数在browser的实现中最终都是通过tcp的系统接口进行传输的。\n\nwebsocket和http协议一样都属于应用层的协议，那么他们之间有没有什么关系呢？\n\n答案是肯定的，websocket在建立握手连接时，数据是通过http协议传输的，正如我们之前所看到的“get/chat http/1.1”，\n\n这里面用到的只是http协议一些简单的字段。但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。\n\n具体关系可以参考下图：\n\n",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"DNS 查询服务器的基本流程是什么？DNS 劫持是什么？",frontmatter:{title:"DNS 查询服务器的基本流程是什么？DNS 劫持是什么？",date:"2022-09-21T22:54:50.000Z",permalink:"/pages/017113/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/270.DNS%20%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FDNS%20%E5%8A%AB%E6%8C%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/270.DNS 查询服务器的基本流程是什么？DNS 劫持是什么？.md",key:"v-a9abf6a0",path:"/pages/017113/",headers:[{level:2,title:"1、DNS是什么？",slug:"_1、dns是什么",normalizedTitle:"1、dns是什么？",charIndex:2},{level:2,title:"2、为什么会出DNS这种东西？",slug:"_2、为什么会出dns这种东西",normalizedTitle:"2、为什么会出dns这种东西？",charIndex:53},{level:2,title:"3、那DNS在我们生活中怎么用的？",slug:"_3、那dns在我们生活中怎么用的",normalizedTitle:"3、那dns在我们生活中怎么用的？",charIndex:172},{level:2,title:"4、DNS劫持是什么？",slug:"_4、dns劫持是什么",normalizedTitle:"4、dns劫持是什么？",charIndex:719},{level:2,title:"如何防止DNS劫持？",slug:"如何防止dns劫持",normalizedTitle:"如何防止dns劫持？",charIndex:779},{level:2,title:"DNS劫持具体有哪些技术手段呢？",slug:"dns劫持具体有哪些技术手段呢",normalizedTitle:"dns劫持具体有哪些技术手段呢？",charIndex:888}],headersStr:"1、DNS是什么？ 2、为什么会出DNS这种东西？ 3、那DNS在我们生活中怎么用的？ 4、DNS劫持是什么？ 如何防止DNS劫持？ DNS劫持具体有哪些技术手段呢？",content:"# 1、DNS是什么？\n\n域名解析系统，可以将域名与IP地址建立映射关系，通过域名得知目标IP。\n\n\n# 2、为什么会出DNS这种东西？\n\n在网络中，想要访问主机资源或者服务器资源需要知道目标的IP地址，但是IP地址又长数字又很容易记错，而且全世界那么多IP地址我也记不住，怎么办？就需要域名来代表一个IP地址，进行相互之间的映射关系\n\n\n# 3、那DNS在我们生活中怎么用的？\n\n比如：在我们平常访问百度在网页地址栏输入： 这样我们就会进入百度的主页。\n\n\n\nDNS实现过程\n\n 1. 第一步：当在浏览器上输入域名时，我们的PC机会自动提出域名解析请求，并将请求发送给我们所配置的域名服务器进行解析\n\n 2. 第二步：域名服务器收到我们PC机的域名解析请求值后，会先查询本地的缓存（DNS缓存），如果有对应的域名与IP地址条目，域名服务器会将结果直接发送给我们的PC机，不会进一步解析操作。\n\n 3. 第三步：但是如果域名服务器的本地缓存中没有该纪录，则本地域名服务器就会把请求发给根域名服务器进行解析，然后根域名服务器收到后再返回给本地域名服务器一个所查询域(根的子域) 的主域名服务器的地址给我们的PC机。\n\n 4. 第四步：本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的域名服务器会继续查询自己的缓存，如果没有该纪录，则返回相关的下级的域名服务器的地址。\n\n 5. 第五步：持续进行第四步的查询解析操作，直至解析到对应的纪录。\n\n 6. 第六步：本地域名服务器把歇息到的纪录返回的结果保存到缓存，以备下一次使用，同时还将结果返回给客户机\n\n 7. 第七步：客户机收到结果后向向目标IP发出访问请求，进行访问\n\n\n# 4、DNS劫持是什么？\n\n当我们访问某个网页时，如输入百度的域名，但是进入页面时其他的网页，这就是DNS劫持。\n\n\n# 如何防止DNS劫持？\n\n通常我们使用的DNS服务器使用的是服务商域名服务器，我们出来可以向运营商反馈这种情况外，还可以将自己的DNS服务器切换为其他第三方DNS服务器，如百度DNS、阿里DNS等等都是可以的。\n\n\n# DNS劫持具体有哪些技术手段呢？\n\n 1. DNS缓存感染\n\n攻击者使用DNS请求将数据放入脆弱的DNS服务器的缓存。然后这些缓存信息在用户进行DNS访问时返回用户，将对通常的域名的访问引导到入侵者设定的钓鱼、挂马等页面，或通过伪造邮件或其他server服务取得用户密码信息会给客人带来进一步的侵害。\n\n 2. DNS信息劫持\n\nTCP/IP系统避免以诸如序列号等各种方式插入钓鱼数据，但是入侵者可以通过截取客户端与DNS服务器的交互来推测服务器响应于客户端的DNS查询ID。每个DNS报告包括相关联的16位ID号，并且DNS服务器从该ID号获取请求源位置。攻击者在DNS服务器前向用户发送虚假应答，欺骗客户访问恶意网站。\n\n 3. DNS重定向\n\n攻击者如果将权威DNS服务器重定向到恶意DNS服务器，那么被劫持域名的解析就完全置于攻击者的控制之下。\n\n 4. 盗用DNS服务器\n\n在该攻击中，攻击者不仅可以破坏DNS服务器还可以改变DNS记录，将DNS请求重定向到恶意网站。\n\n 5. 中间人（MiTM）DNS攻击\n\n在DNS劫持中还有一种类型是，攻击者执行中间人（MiTM）攻击以截断用户与DNS服务器之间的通信，并向恶意网站重定向用户，以提供不同的目标IP地址。\n\n 6. 流氓DNS服务器\n\n在此攻击中，攻击者可以破解DNS服务器，并更改DNS记录以将DNS请求重定向到恶意站点。",normalizedContent:"# 1、dns是什么？\n\n域名解析系统，可以将域名与ip地址建立映射关系，通过域名得知目标ip。\n\n\n# 2、为什么会出dns这种东西？\n\n在网络中，想要访问主机资源或者服务器资源需要知道目标的ip地址，但是ip地址又长数字又很容易记错，而且全世界那么多ip地址我也记不住，怎么办？就需要域名来代表一个ip地址，进行相互之间的映射关系\n\n\n# 3、那dns在我们生活中怎么用的？\n\n比如：在我们平常访问百度在网页地址栏输入： 这样我们就会进入百度的主页。\n\n\n\ndns实现过程\n\n 1. 第一步：当在浏览器上输入域名时，我们的pc机会自动提出域名解析请求，并将请求发送给我们所配置的域名服务器进行解析\n\n 2. 第二步：域名服务器收到我们pc机的域名解析请求值后，会先查询本地的缓存（dns缓存），如果有对应的域名与ip地址条目，域名服务器会将结果直接发送给我们的pc机，不会进一步解析操作。\n\n 3. 第三步：但是如果域名服务器的本地缓存中没有该纪录，则本地域名服务器就会把请求发给根域名服务器进行解析，然后根域名服务器收到后再返回给本地域名服务器一个所查询域(根的子域) 的主域名服务器的地址给我们的pc机。\n\n 4. 第四步：本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的域名服务器会继续查询自己的缓存，如果没有该纪录，则返回相关的下级的域名服务器的地址。\n\n 5. 第五步：持续进行第四步的查询解析操作，直至解析到对应的纪录。\n\n 6. 第六步：本地域名服务器把歇息到的纪录返回的结果保存到缓存，以备下一次使用，同时还将结果返回给客户机\n\n 7. 第七步：客户机收到结果后向向目标ip发出访问请求，进行访问\n\n\n# 4、dns劫持是什么？\n\n当我们访问某个网页时，如输入百度的域名，但是进入页面时其他的网页，这就是dns劫持。\n\n\n# 如何防止dns劫持？\n\n通常我们使用的dns服务器使用的是服务商域名服务器，我们出来可以向运营商反馈这种情况外，还可以将自己的dns服务器切换为其他第三方dns服务器，如百度dns、阿里dns等等都是可以的。\n\n\n# dns劫持具体有哪些技术手段呢？\n\n 1. dns缓存感染\n\n攻击者使用dns请求将数据放入脆弱的dns服务器的缓存。然后这些缓存信息在用户进行dns访问时返回用户，将对通常的域名的访问引导到入侵者设定的钓鱼、挂马等页面，或通过伪造邮件或其他server服务取得用户密码信息会给客人带来进一步的侵害。\n\n 2. dns信息劫持\n\ntcp/ip系统避免以诸如序列号等各种方式插入钓鱼数据，但是入侵者可以通过截取客户端与dns服务器的交互来推测服务器响应于客户端的dns查询id。每个dns报告包括相关联的16位id号，并且dns服务器从该id号获取请求源位置。攻击者在dns服务器前向用户发送虚假应答，欺骗客户访问恶意网站。\n\n 3. dns重定向\n\n攻击者如果将权威dns服务器重定向到恶意dns服务器，那么被劫持域名的解析就完全置于攻击者的控制之下。\n\n 4. 盗用dns服务器\n\n在该攻击中，攻击者不仅可以破坏dns服务器还可以改变dns记录，将dns请求重定向到恶意网站。\n\n 5. 中间人（mitm）dns攻击\n\n在dns劫持中还有一种类型是，攻击者执行中间人（mitm）攻击以截断用户与dns服务器之间的通信，并向恶意网站重定向用户，以提供不同的目标ip地址。\n\n 6. 流氓dns服务器\n\n在此攻击中，攻击者可以破解dns服务器，并更改dns记录以将dns请求重定向到恶意站点。",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"RestFul 是什么？RestFul 请求的 URL 有什么特点？",frontmatter:{title:"RestFul 是什么？RestFul 请求的 URL 有什么特点？",date:"2022-09-21T22:55:07.000Z",permalink:"/pages/c08bb6/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/280.RestFul%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FRestFul%20%E8%AF%B7%E6%B1%82%E7%9A%84%20URL%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F.html",relativePath:"02.计算机基础/10.计算机网络/280.RestFul 是什么？RestFul 请求的 URL 有什么特点？.md",key:"v-693fb010",path:"/pages/c08bb6/",headers:[{level:2,title:"REST 设计风格",slug:"rest-设计风格",normalizedTitle:"rest 设计风格",charIndex:2},{level:2,title:"理解 REST",slug:"理解-rest",normalizedTitle:"理解 rest",charIndex:611},{level:2,title:"RESTful 的系统",slug:"restful-的系统",normalizedTitle:"restful 的系统",charIndex:4659},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:9427}],headersStr:"REST 设计风格 理解 REST RESTful 的系统 参考",content:'# REST 设计风格\n\n很多人会拿 REST 与 RPC 互相比较，其实，REST 无论是在思想上、概念上，还是使用范围上，与 RPC 都不尽相同，充其量只能算是有一些相似，\n\n应用会有一部分重合之处，但本质上并不是同一类型的东西。\n\nREST 与 RPC 在思想上差异的核心是抽象的目标不一样，即面向资源的编程思想与面向过程的编程思想两者之间的区别。\n\n面向过程编程、面向对象编程大家想必听说过，但什么是面向资源编程？\n\n这个问题等介绍完 REST 的特征之后我们再回头细说。\n\n而概念上的不同是指 REST 并不是一种远程服务调用协议，甚至可以把定语也去掉，它就不是一种协议。\n\n协议都带有一定的规范性和强制性，最起码也该有个规约文档，譬如 JSON-RPC，它哪怕再简单，也要有个《JSON-RPC Specification》 来规定协议的格式细节、异常、响应码等信息，\n\n但是 REST 并没有定义这些内容，尽管有一些指导原则，但实际上并不受任何强制的约束。\n\n常有人批评某个系统接口“设计得不够 RESTful”，其实这句话本身就有些争议，REST 只能说是风格而不是规范、协议，\n\n并且能完全达到 REST 所有指导原则的系统也是不多见的，这一点我们同样将在后文中详细讨论。\n\n至于使用范围，REST 与 RPC 作为主流的两种远程调用方式，在使用上是确有重合的，但重合的区域有多大就见仁见智了。\n\n\n# 理解 REST\n\n个人会有好恶偏爱，但计算机科学是务实的，有了 RPC，还会提出 REST，有了面向过程编程之后，还能产生面向资源编程，并引起广泛的关注、使用和讨论，\n\n说明后者一定是有一些前者没有的闪光点，或者解决、避免了一些面向过程中的缺陷。我们不妨先去理解 REST 为什么会出现，然后再来讨论评价它。\n\n简单搜索就能找到 REST 源于 Roy Thomas Fielding 在 2000 年发表的博士论文：《Architectural Styles and the Design of Network-based Software Architectures》 ，此文的确是 REST 的源头，但我们不应该忽略 Fielding 的身份和此前的工作背景，这些信息对理解 REST 的设计思想至关重要。\n\n首先，Fielding 是一名很优秀的软件工程师，他是 Apache 服务器的核心开发者，后来成为了著名的Apache 软件基金会 的联合创始人；\n\n同时，Fielding 也是 HTTP 1.0 协议（1996 年发布）的专家组成员，后来还晋升为 HTTP 1.1 协议（1999 年发布）的负责人。\n\nHTTP 1.1 协议设计得极为成功，以至于发布之后长达十年的时间里，都没有收到多少修订的意见。\n\n用来指导 HTTP 1.1 协议设计的理论和思想，最初是以备忘录的形式用作专家组成员之间交流，除了 IETF、W3C 的专家外，并没有在外界广泛流传。\n\n从时间上看，对 HTTP 1.1 协议的设计工作贯穿了 Fielding 的整个博士研究生涯，当起草 HTTP 1.1 协议的工作完成后，Fielding 回到了加州大学欧文分校继续攻读自己的博士学位。\n\n第二年，他更为系统、严谨地阐述了这套理论框架，并且以这套理论框架导出了一种新的编程思想，他为这种程序设计风格取了一个很多人难以理解，但是今天已经广为人知的名字 REST，即“表征状态转移”的缩写。\n\n哪怕对编程和网络都很熟悉的同学，只从标题中也不太可能直接弄明白什么叫“表征”、啥东西的“状态”、从哪“转移”到哪。\n\n尽管在论文原文中确有论述这些概念，但写得确实相当晦涩（不想读英文的同学从此处获得中文翻译版本），笔者推荐比较容易理解 REST 思想的途径是先理解什么是 HTTP，\n\n再配合一些实际例子来进行类比，你会发现“REST”（Representational State Transfer）实际上是“HTT”（Hypertext Transfer）的进一步抽象，两者就如同接口与实现类的关系一般。\n\nHTTP 中使用的“超文本”（Hypertext）一词是美国社会学家 Theodor Holm Nelson 在 1967 年于《Brief Words on the Hypertext》 一文里提出的，下面引用的是他本人在 1992 年修正后的定义：\n\n> Hypertext\n\n> By now the word "hypertext" has become generally accepted for branching and responding text, but the corresponding word "hypermedia", meaning complexes of branching and responding graphics, movies and sound – as well as text – is much less used.\n\n> 现在，"超文本 "一词已被普遍接受，它指的是能够进行分支判断和差异响应的文本，相应地， "超媒体 "一词指的是能够进行分支判断和差异响应的图形、电影和声音（也包括文本）的复合体。\n\n> —— Theodor Holm Nelson Literary Machines, 1992\n\n以上定义描述的“超文本（或超媒体，Hypermedia）”是一种“能够对操作进行判断和响应的文本（或声音、图像等）”，这个概念在上世纪 60 年代提出时应该还属于科幻的范畴，但是今天大众已经完全接受了它，互联网中一段文字可以点击、可以触发脚本执行、可以调用服务端，这一切已毫不稀奇。下面我们继续尝试从“超文本”或者“超媒体”的含义来理解什么是“表征”以及 REST 中其他关键概念，这里使用一个具体事例将其描述如下。\n\n * 资源（Resource）：譬如你现在正在阅读一篇名为《REST 设计风格》的文章，这篇文章的内容本身（你可以将其理解为其蕴含的信息、数据）我们称之为“资源”。无论你是购买的书籍、是在浏览器看的网页、是打印出来看的文稿、是在电脑屏幕上阅读抑或是手机上浏览，尽管呈现的样子各不相同，但其中的信息是不变的，你所阅读的仍是同一份“资源”。\n\n * 表征（Representation）：当你通过电脑浏览器阅读此文章时，浏览器向服务端发出请求“我需要这个资源的 HTML 格式”，服务端向浏览器返回的这个 HTML 就被称之为“表征”，你可能通过其他方式拿到本文的 PDF、Markdown、RSS 等其他形式的版本，它们也同样是一个资源的多种表征。可见“表征”这个概念是指信息与用户交互时的表示形式，这与我们软件分层架构中常说的“表示层”（Presentation Layer）的语义其实是一致的。\n\n * 状态（State）：当你读完了这篇文章，想看后面是什么内容时，你向服务器发出请求“给我下一篇文章”。但是“下一篇”是个相对概念，必须依赖“当前你正在阅读的文章是哪一篇”才能正确回应，这类在特定语境中才能产生的上下文信息即被称为“状态”。我们所说的有状态（Stateful）抑或是无状态（Stateless），都是只相对于服务端来说的，服务器要完成“取下一篇”的请求，要么自己记住用户的状态：这个用户现在阅读的是哪一篇文章，这称为有状态；要么客户端来记住状态，在请求的时候明确告诉服务器：我正在阅读某某文章，现在要读它的下一篇，这称为无状态。\n\n * 转移（Transfer）：无论状态是由服务端还是客户端来提供的，“取下一篇文章”这个行为逻辑必然只能由服务端来提供，因为只有服务端拥有该资源及其表征形式。服务器通过某种方式，把“用户当前阅读的文章”转变成“下一篇文章”，这就被称为“表征状态转移”。\n\n通过“阅读文章”这个例子，笔者对资源等概念进行通俗的释义，你应该能够理解 REST 所说的“表征状态转移”的含义了。借着这个故事的上下文状态，笔者再继续介绍几个现在不涉及但稍后要用到的概念名词。\n\n * 统一接口（Uniform Interface）：上面说的服务器“通过某种方式”让表征状态发生转移，具体是什么方式？如果你真的是用浏览器阅读本文电子版的话，请把本文滚动到结尾处，右下角有下一篇文章的 URI 超链接地址，这是服务端渲染这篇文章时就预置好的，点击它让页面跳转到下一篇，就是所谓“某种方式”的其中一种方式。任何人都不会对点击超链接网页会出现跳转感到奇怪，但你细想一下，URI 的含义是统一资源标识符，是一个名词，如何能表达出“转移”动作的含义呢？答案是 HTTP 协议中已经提前约定好了一套“统一接口”，它包括：GET、HEAD、POST、PUT、DELETE、TRACE、OPTIONS 七种基本操作，任何一个支持 HTTP 协议的服务器都会遵守这套规定，对特定的 URI 采取这些操作，服务器就会触发相应的表征状态转移。\n\n * 超文本驱动（Hypertext Driven）：尽管表征状态转移是由浏览器主动向服务器发出请求所引发的，该请求导致了“在浏览器屏幕上显示出了下一篇文章的内容”这个结果的出现。但是，你我都清楚这不可能真的是浏览器的主动意图，浏览器是根据用户输入的 URI 地址来找到网站首页，服务器给予的首页超文本内容后，浏览器再通过超文本内部的链接来导航到了这篇文章，阅读结束时，也是通过超文本内部的链接来再导航到下一篇。浏览器作为所有网站的通用的客户端，任何网站的导航（状态转移）行为都不可能是预置于浏览器代码之中，而是由服务器发出的请求响应信息（超文本）来驱动的。这点与其他带有客户端的软件有十分本质的区别，在那些软件中，业务逻辑往往是预置于程序代码之中的，有专门的页面控制器（无论在服务端还是在客户端中）来驱动页面的状态转移。\n\n * 自描述消息（Self-Descriptive Messages）：由于资源的表征可能存在多种不同形态，在消息中应当有明确的信息来告知客户端该消息的类型以及应如何处理这条消息。一种被广泛采用的自描述方法是在名为“Content-Type”的 HTTP Header 中标识出互联网媒体类型（MIME type），譬如“Content-Type : application/json; charset=utf-8”，则说明该资源会以 JSON 的格式来返回，请使用 UTF-8 字符集进行处理。\n\n除了以上列出的这些看名字不容易弄懂的概念外，在理解 REST 的过程中，还有一个常见的误区值得注意，Fielding 提出 REST 时所谈论的范围是“架构风格与网络的软件架构设计”（Architectural Styles and Design of Network-based Software Architectures），而不是现在被人们所狭义理解的一种“远程服务设计风格”，这两者的范围差别就好比本书所谈论的话题“软件架构”与本章谈论话题“访问远程服务”的关系那样，前者是后者的一个很大的超集，尽管基于本节的主题和多数人的关注点考虑，我们确实是会以“远程服务设计风格”作为讨论的重点，但至少应该说明清楚它们范围上的差别。\n\n\n# RESTful 的系统\n\n如果你已经理解了上面这些概念，我们就可以开始讨论面向资源的编程思想与 Fielding 所提出的几个具体的软件架构设计原则了。Fielding 认为，一套理想的、完全满足 REST 风格的系统应该满足以下六大原则。\n\n 1. 服务端与客户端分离（Client-Server） 将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来，有助于提高用户界面的跨平台的可移植性，这一点正越来越受到广大开发者所认可，以前完全基于服务端控制和渲染（如 JSF 这类）框架实际用户已甚少，而在服务端进行界面控制（Controller），通过服务端或者客户端的模版渲染引擎来进行界面渲染的框架（如 Struts、SpringMVC 这类）也受到了颇大的冲击。这一点主要推动力量与 REST 可能关系并不大，前端技术（从 ES 规范，到语言实现，到前端框架等）的近年来的高速发展，使得前端表达能力大幅度加强才是真正的幕后推手。由于前端的日渐强势，现在还流行起由前端代码反过来驱动服务端进行渲染的 SSR（Server-Side Rendering）技术，在 Serverless、SEO 等场景中已经占领了一块领地。\n\n 2. 无状态（Stateless） 无状态是 REST 的一条核心原则，部分开发者在做服务接口规划时，觉得 REST 风格的服务怎么设计都感觉别扭，很有可能的一种原因是在服务端持有着比较重的状态。REST 希望服务器不要去负责维护状态，每一次从客户端发送的请求中，应包括所有的必要的上下文信息，会话信息也由客户端负责保存维护，服务端依据客户端传递的状态来执行业务处理逻辑，驱动整个应用的状态变迁。客户端承担状态维护职责以后，会产生一些新的问题，譬如身份认证、授权等可信问题，它们都应有针对性的解决方案（这部分内容可参见“安全架构”的内容）。 但必须承认的现状是，目前大多数的系统都达不到这个要求，往往越复杂、越大型的系统越是如此。服务端无状态可以在分布式计算中获得非常高价值的好处，但大型系统的上下文状态数量完全可能膨胀到让客户端在每次请求时提供变得不切实际的程度，在服务端的内存、会话、数据库或者缓存等地方持有一定的状态成为一种是事实上存在，并将长期存在、被广泛使用的主流的方案。\n\n 3. 可缓存（Cacheability） 无状态服务虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。“降低网络性”的通俗解释是某个功能如果使用有状态的设计只需要一次（或少量）请求就能完成，使用无状态的设计则可能会需要多次请求，或者在请求中带有额外冗余的信息。为了缓解这个矛盾，REST 希望软件系统能够如同万维网一样，允许客户端和中间的通讯传递者（譬如代理）将部分服务端的应答缓存起来。当然，为了缓存能够正确地运作，服务端的应答中必须明确地或者间接地表明本身是否可以进行缓存、可以缓存多长时间，以避免客户端在将来进行请求的时候得到过时的数据。运作良好的缓存机制可以减少客户端、服务器之间的交互，甚至有些场景中可以完全避免交互，这就进一步提高了性能。\n\n 4. 分层系统（Layered System） 这里所指的并不是表示层、服务层、持久层这种意义上的分层。而是指客户端一般不需要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样也便于缓存、伸缩和安全策略的部署。该原则的典型的应用是内容分发网络（Content Distribution Network，CDN）。如果你是通过网站浏览到这篇文章的话，你所发出的请求一般（假设你在中国国境内的话）并不是直接访问位于 GitHub Pages 的源服务器，而是访问了位于国内的 CDN 服务器，但作为用户，你完全不需要感知到这一点。我们将在“透明多级分流系统”中讨论如何构建自动的、可缓存的分层系统。\n\n 5. 统一接口（Uniform Interface） 这是 REST 的另一条核心原则，REST 希望开发者面向资源编程，希望软件系统设计的重点放在抽象系统该有哪些资源上，而不是抽象系统该有哪些行为（服务）上。这条原则你可以类比计算机中对文件管理的操作来理解，管理文件可能会进行创建、修改、删除、移动等操作，这些操作数量是可数的，而且对所有文件都是固定的、统一的。如果面向资源来设计系统，同样会具有类似的操作特征，由于 REST 并没有设计新的协议，所以这些操作都借用了 HTTP 协议中固有的操作命令来完成。 统一接口也是 REST 最容易陷入争论的地方，基于网络的软件系统，到底是面向资源更好，还是面向服务更合适，这事情哪怕是很长时间里都不会有个定论，也许永远都没有。但是，已经有一个基本清晰的结论是：面向资源编程的抽象程度通常更高。抽象程度高意味着坏处是往往距离人类的思维方式更远，而好处是往往通用程度会更好。用这样的语言去诠释 REST，大概本身就挺抽象的，笔者还是举个例子来说明：譬如，几乎每个系统都有的登录和注销功能，如果你理解成登录对应于 login()服务，注销对应于 logout()服务这样两个独立服务，这是“符合人类思维”的；如果你理解成登录是 PUT Session，注销是 DELETE Session，这样你只需要设计一种“Session 资源”即可满足需求，甚至以后对 Session 的其他需求，如查询登陆用户的信息，就是 GET Session 而已，其他操作如修改用户信息等都可以被这同一套设计囊括在内，这便是“抽象程度更高”带来的好处。 想要在架构设计中合理恰当地利用统一接口，Fielding 建议系统应能做到每次请求中都包含资源的 ID，所有操作均通过资源 ID 来进行；建议每个资源都应该是自描述的消息；建议通过超文本来驱动应用状态的转移。\n\n 6. 按需代码（Code-On-Demand ） 按需代码被 Fielding 列为一条可选原则。它是指任何按照客户端（譬如浏览器）的请求，将可执行的软件程序从服务器发送到客户端的技术，按需代码赋予了客户端无需事先知道所有来自服务端的信息应该如何处理、如何运行的宽容度。举个具体例子，以前的Java Applet 技术，今天的WebAssembly 等都属于典型的按需代码，蕴含着具体执行逻辑的代码是存放在服务端，只有当客户端请求了某个 Java Applet 之后，代码才会被传输并在客户端机器中运行，结束后通常也会随即在客户端中被销毁掉。将按需代码列为可选原则的原因并非是它特别难以达到，而更多是出于必要性和性价比的实际考虑。\n\n至此，REST 中的主要概念与思想原则已经介绍完毕，我们再回过头来讨论本节开篇提出的 REST 与 RPC 在思想上的差异。REST 的基本思想是面向资源来抽象问题，它与此前流行的编程思想——面向过程的编程在抽象主体上有本质的差别。在 REST 提出以前，人们设计分布式系统服务的唯一方案就只有 RPC，RPC 是将本地的方法调用思路迁移到远程方法调用上，开发者是围绕着“远程方法”去设计两个系统间交互的，譬如 CORBA、RMI、DCOM，等等。这样做的坏处不仅是“如何在异构系统间表示一个方法”、“如何获得接口能够提供的方法清单”都成了需要专门协议去解决的问题（RPC 的三大基本问题之一），更在于服务的每个方法都是完全独立的，服务使用者必须逐个学习才能正确地使用它们。Google 在《Google API Design Guide》 中曾经写下这样一段话：\n\n> Traditionally, people design RPC APIs in terms of API interfaces and methods, such as CORBA and Windows COM. As time goes by, more and more interfaces and methods are introduced. The end result can be an overwhelming number of interfaces and methods, each of them different from the others. Developers have to learn each one carefully in order to use it correctly, which can be both time consuming and error prone\n\n以前，人们面向方法去设计 RPC API，譬如 CORBA 和 DCOM，随着时间推移，接口与方法越来越多却又各不相同，开发人员必须了解每一个方法才能正确使用它们，这样既耗时又容易出错。\n\n—— Google API Design Guide, 2017\n\nREST 提出以资源为主体进行服务设计的风格，能为它带来不少好处（自然也有坏处，笔者将在下一节集中谈论 REST 的不足与争议），譬如：\n\n * 降低的服务接口的学习成本。统一接口（Uniform Interface）是 REST 的重要标志，将对资源的标准操作都映射到了标准的 HTTP 方法上去，这些方法对于每个资源的用法都是一致的，语义都是类似的，不需要刻意去学习，更不需要有什么 Interface Description Language 之类的协议存在。\n\n * 资源天然具有集合与层次结构。以方法为中心抽象的接口，由于方法是动词，逻辑上决定了每个接口都是互相独立的；但以资源为中心抽象的接口，由于资源是名词，天然就可以产生集合与层次结构。举个具体例子，你想像一个商城用户中心的接口设计：用户资源会拥有多个不同的下级的资源，譬如若干条短消息资源、一份用户资料资源、一部购物车资源，购物车中又会有自己的下级资源，譬如多本书籍资源。很容易在程序接口中构造出这些资源的集合关系与层次关系，而且是符合人们长期在单机或网络环境中管理数据的直觉的。相信你不需要专门阅读接口说明书，也能轻易推断出获取用户icyfenix的购物车中的第2本书的 REST 接口应该表示为：\n\nGET /users/icyfenix/cart/2\n\n\n1\n\n\n * REST 绑定于 HTTP 协议。面向资源编程不是必须构筑在 HTTP 之上，但 REST 是，这是缺点，也是优点。因为 HTTP 本来就是面向资源而设计的网络协议，纯粹只用 HTTP（而不是 SOAP over HTTP 那样在再构筑协议）带来的好处是 RPC 中的 Wire Protocol 问题就无需再多考虑了，REST 将复用 HTTP 协议中已经定义的概念和相关基础支持来解决问题。HTTP 协议已经有效运作了三十年，其相关的技术基础设施已是千锤百炼，无比成熟。而坏处自然是，当你想去考虑那些 HTTP 不提供的特性时，便会彻底地束手无策。\n\n * ……\n\n以上列举了一些面向资源的优点，笔者并非要证明它比面向过程、面向对象更优秀，是否选用 REST 的 API 设计风格，需要权衡的是你的需求场景、你团队的设计和开发人员是否能够适应面向资源的思想来设计软件，来编写代码。在互联网中，面向资源来进行网络传输是这三十年来 HTTP 协议精心培养出来的用户习惯，如果开发者能够适应 REST 不太符合人类思维习惯的抽象方式，那 REST 通常能够更好地匹配在 HTTP 基础上构建的互联网，在效率与扩展性方面会有可观的收益。\n\n\n# 参考\n\nREST设计风格',normalizedContent:'# rest 设计风格\n\n很多人会拿 rest 与 rpc 互相比较，其实，rest 无论是在思想上、概念上，还是使用范围上，与 rpc 都不尽相同，充其量只能算是有一些相似，\n\n应用会有一部分重合之处，但本质上并不是同一类型的东西。\n\nrest 与 rpc 在思想上差异的核心是抽象的目标不一样，即面向资源的编程思想与面向过程的编程思想两者之间的区别。\n\n面向过程编程、面向对象编程大家想必听说过，但什么是面向资源编程？\n\n这个问题等介绍完 rest 的特征之后我们再回头细说。\n\n而概念上的不同是指 rest 并不是一种远程服务调用协议，甚至可以把定语也去掉，它就不是一种协议。\n\n协议都带有一定的规范性和强制性，最起码也该有个规约文档，譬如 json-rpc，它哪怕再简单，也要有个《json-rpc specification》 来规定协议的格式细节、异常、响应码等信息，\n\n但是 rest 并没有定义这些内容，尽管有一些指导原则，但实际上并不受任何强制的约束。\n\n常有人批评某个系统接口“设计得不够 restful”，其实这句话本身就有些争议，rest 只能说是风格而不是规范、协议，\n\n并且能完全达到 rest 所有指导原则的系统也是不多见的，这一点我们同样将在后文中详细讨论。\n\n至于使用范围，rest 与 rpc 作为主流的两种远程调用方式，在使用上是确有重合的，但重合的区域有多大就见仁见智了。\n\n\n# 理解 rest\n\n个人会有好恶偏爱，但计算机科学是务实的，有了 rpc，还会提出 rest，有了面向过程编程之后，还能产生面向资源编程，并引起广泛的关注、使用和讨论，\n\n说明后者一定是有一些前者没有的闪光点，或者解决、避免了一些面向过程中的缺陷。我们不妨先去理解 rest 为什么会出现，然后再来讨论评价它。\n\n简单搜索就能找到 rest 源于 roy thomas fielding 在 2000 年发表的博士论文：《architectural styles and the design of network-based software architectures》 ，此文的确是 rest 的源头，但我们不应该忽略 fielding 的身份和此前的工作背景，这些信息对理解 rest 的设计思想至关重要。\n\n首先，fielding 是一名很优秀的软件工程师，他是 apache 服务器的核心开发者，后来成为了著名的apache 软件基金会 的联合创始人；\n\n同时，fielding 也是 http 1.0 协议（1996 年发布）的专家组成员，后来还晋升为 http 1.1 协议（1999 年发布）的负责人。\n\nhttp 1.1 协议设计得极为成功，以至于发布之后长达十年的时间里，都没有收到多少修订的意见。\n\n用来指导 http 1.1 协议设计的理论和思想，最初是以备忘录的形式用作专家组成员之间交流，除了 ietf、w3c 的专家外，并没有在外界广泛流传。\n\n从时间上看，对 http 1.1 协议的设计工作贯穿了 fielding 的整个博士研究生涯，当起草 http 1.1 协议的工作完成后，fielding 回到了加州大学欧文分校继续攻读自己的博士学位。\n\n第二年，他更为系统、严谨地阐述了这套理论框架，并且以这套理论框架导出了一种新的编程思想，他为这种程序设计风格取了一个很多人难以理解，但是今天已经广为人知的名字 rest，即“表征状态转移”的缩写。\n\n哪怕对编程和网络都很熟悉的同学，只从标题中也不太可能直接弄明白什么叫“表征”、啥东西的“状态”、从哪“转移”到哪。\n\n尽管在论文原文中确有论述这些概念，但写得确实相当晦涩（不想读英文的同学从此处获得中文翻译版本），笔者推荐比较容易理解 rest 思想的途径是先理解什么是 http，\n\n再配合一些实际例子来进行类比，你会发现“rest”（representational state transfer）实际上是“htt”（hypertext transfer）的进一步抽象，两者就如同接口与实现类的关系一般。\n\nhttp 中使用的“超文本”（hypertext）一词是美国社会学家 theodor holm nelson 在 1967 年于《brief words on the hypertext》 一文里提出的，下面引用的是他本人在 1992 年修正后的定义：\n\n> hypertext\n\n> by now the word "hypertext" has become generally accepted for branching and responding text, but the corresponding word "hypermedia", meaning complexes of branching and responding graphics, movies and sound – as well as text – is much less used.\n\n> 现在，"超文本 "一词已被普遍接受，它指的是能够进行分支判断和差异响应的文本，相应地， "超媒体 "一词指的是能够进行分支判断和差异响应的图形、电影和声音（也包括文本）的复合体。\n\n> —— theodor holm nelson literary machines, 1992\n\n以上定义描述的“超文本（或超媒体，hypermedia）”是一种“能够对操作进行判断和响应的文本（或声音、图像等）”，这个概念在上世纪 60 年代提出时应该还属于科幻的范畴，但是今天大众已经完全接受了它，互联网中一段文字可以点击、可以触发脚本执行、可以调用服务端，这一切已毫不稀奇。下面我们继续尝试从“超文本”或者“超媒体”的含义来理解什么是“表征”以及 rest 中其他关键概念，这里使用一个具体事例将其描述如下。\n\n * 资源（resource）：譬如你现在正在阅读一篇名为《rest 设计风格》的文章，这篇文章的内容本身（你可以将其理解为其蕴含的信息、数据）我们称之为“资源”。无论你是购买的书籍、是在浏览器看的网页、是打印出来看的文稿、是在电脑屏幕上阅读抑或是手机上浏览，尽管呈现的样子各不相同，但其中的信息是不变的，你所阅读的仍是同一份“资源”。\n\n * 表征（representation）：当你通过电脑浏览器阅读此文章时，浏览器向服务端发出请求“我需要这个资源的 html 格式”，服务端向浏览器返回的这个 html 就被称之为“表征”，你可能通过其他方式拿到本文的 pdf、markdown、rss 等其他形式的版本，它们也同样是一个资源的多种表征。可见“表征”这个概念是指信息与用户交互时的表示形式，这与我们软件分层架构中常说的“表示层”（presentation layer）的语义其实是一致的。\n\n * 状态（state）：当你读完了这篇文章，想看后面是什么内容时，你向服务器发出请求“给我下一篇文章”。但是“下一篇”是个相对概念，必须依赖“当前你正在阅读的文章是哪一篇”才能正确回应，这类在特定语境中才能产生的上下文信息即被称为“状态”。我们所说的有状态（stateful）抑或是无状态（stateless），都是只相对于服务端来说的，服务器要完成“取下一篇”的请求，要么自己记住用户的状态：这个用户现在阅读的是哪一篇文章，这称为有状态；要么客户端来记住状态，在请求的时候明确告诉服务器：我正在阅读某某文章，现在要读它的下一篇，这称为无状态。\n\n * 转移（transfer）：无论状态是由服务端还是客户端来提供的，“取下一篇文章”这个行为逻辑必然只能由服务端来提供，因为只有服务端拥有该资源及其表征形式。服务器通过某种方式，把“用户当前阅读的文章”转变成“下一篇文章”，这就被称为“表征状态转移”。\n\n通过“阅读文章”这个例子，笔者对资源等概念进行通俗的释义，你应该能够理解 rest 所说的“表征状态转移”的含义了。借着这个故事的上下文状态，笔者再继续介绍几个现在不涉及但稍后要用到的概念名词。\n\n * 统一接口（uniform interface）：上面说的服务器“通过某种方式”让表征状态发生转移，具体是什么方式？如果你真的是用浏览器阅读本文电子版的话，请把本文滚动到结尾处，右下角有下一篇文章的 uri 超链接地址，这是服务端渲染这篇文章时就预置好的，点击它让页面跳转到下一篇，就是所谓“某种方式”的其中一种方式。任何人都不会对点击超链接网页会出现跳转感到奇怪，但你细想一下，uri 的含义是统一资源标识符，是一个名词，如何能表达出“转移”动作的含义呢？答案是 http 协议中已经提前约定好了一套“统一接口”，它包括：get、head、post、put、delete、trace、options 七种基本操作，任何一个支持 http 协议的服务器都会遵守这套规定，对特定的 uri 采取这些操作，服务器就会触发相应的表征状态转移。\n\n * 超文本驱动（hypertext driven）：尽管表征状态转移是由浏览器主动向服务器发出请求所引发的，该请求导致了“在浏览器屏幕上显示出了下一篇文章的内容”这个结果的出现。但是，你我都清楚这不可能真的是浏览器的主动意图，浏览器是根据用户输入的 uri 地址来找到网站首页，服务器给予的首页超文本内容后，浏览器再通过超文本内部的链接来导航到了这篇文章，阅读结束时，也是通过超文本内部的链接来再导航到下一篇。浏览器作为所有网站的通用的客户端，任何网站的导航（状态转移）行为都不可能是预置于浏览器代码之中，而是由服务器发出的请求响应信息（超文本）来驱动的。这点与其他带有客户端的软件有十分本质的区别，在那些软件中，业务逻辑往往是预置于程序代码之中的，有专门的页面控制器（无论在服务端还是在客户端中）来驱动页面的状态转移。\n\n * 自描述消息（self-descriptive messages）：由于资源的表征可能存在多种不同形态，在消息中应当有明确的信息来告知客户端该消息的类型以及应如何处理这条消息。一种被广泛采用的自描述方法是在名为“content-type”的 http header 中标识出互联网媒体类型（mime type），譬如“content-type : application/json; charset=utf-8”，则说明该资源会以 json 的格式来返回，请使用 utf-8 字符集进行处理。\n\n除了以上列出的这些看名字不容易弄懂的概念外，在理解 rest 的过程中，还有一个常见的误区值得注意，fielding 提出 rest 时所谈论的范围是“架构风格与网络的软件架构设计”（architectural styles and design of network-based software architectures），而不是现在被人们所狭义理解的一种“远程服务设计风格”，这两者的范围差别就好比本书所谈论的话题“软件架构”与本章谈论话题“访问远程服务”的关系那样，前者是后者的一个很大的超集，尽管基于本节的主题和多数人的关注点考虑，我们确实是会以“远程服务设计风格”作为讨论的重点，但至少应该说明清楚它们范围上的差别。\n\n\n# restful 的系统\n\n如果你已经理解了上面这些概念，我们就可以开始讨论面向资源的编程思想与 fielding 所提出的几个具体的软件架构设计原则了。fielding 认为，一套理想的、完全满足 rest 风格的系统应该满足以下六大原则。\n\n 1. 服务端与客户端分离（client-server） 将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来，有助于提高用户界面的跨平台的可移植性，这一点正越来越受到广大开发者所认可，以前完全基于服务端控制和渲染（如 jsf 这类）框架实际用户已甚少，而在服务端进行界面控制（controller），通过服务端或者客户端的模版渲染引擎来进行界面渲染的框架（如 struts、springmvc 这类）也受到了颇大的冲击。这一点主要推动力量与 rest 可能关系并不大，前端技术（从 es 规范，到语言实现，到前端框架等）的近年来的高速发展，使得前端表达能力大幅度加强才是真正的幕后推手。由于前端的日渐强势，现在还流行起由前端代码反过来驱动服务端进行渲染的 ssr（server-side rendering）技术，在 serverless、seo 等场景中已经占领了一块领地。\n\n 2. 无状态（stateless） 无状态是 rest 的一条核心原则，部分开发者在做服务接口规划时，觉得 rest 风格的服务怎么设计都感觉别扭，很有可能的一种原因是在服务端持有着比较重的状态。rest 希望服务器不要去负责维护状态，每一次从客户端发送的请求中，应包括所有的必要的上下文信息，会话信息也由客户端负责保存维护，服务端依据客户端传递的状态来执行业务处理逻辑，驱动整个应用的状态变迁。客户端承担状态维护职责以后，会产生一些新的问题，譬如身份认证、授权等可信问题，它们都应有针对性的解决方案（这部分内容可参见“安全架构”的内容）。 但必须承认的现状是，目前大多数的系统都达不到这个要求，往往越复杂、越大型的系统越是如此。服务端无状态可以在分布式计算中获得非常高价值的好处，但大型系统的上下文状态数量完全可能膨胀到让客户端在每次请求时提供变得不切实际的程度，在服务端的内存、会话、数据库或者缓存等地方持有一定的状态成为一种是事实上存在，并将长期存在、被广泛使用的主流的方案。\n\n 3. 可缓存（cacheability） 无状态服务虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。“降低网络性”的通俗解释是某个功能如果使用有状态的设计只需要一次（或少量）请求就能完成，使用无状态的设计则可能会需要多次请求，或者在请求中带有额外冗余的信息。为了缓解这个矛盾，rest 希望软件系统能够如同万维网一样，允许客户端和中间的通讯传递者（譬如代理）将部分服务端的应答缓存起来。当然，为了缓存能够正确地运作，服务端的应答中必须明确地或者间接地表明本身是否可以进行缓存、可以缓存多长时间，以避免客户端在将来进行请求的时候得到过时的数据。运作良好的缓存机制可以减少客户端、服务器之间的交互，甚至有些场景中可以完全避免交互，这就进一步提高了性能。\n\n 4. 分层系统（layered system） 这里所指的并不是表示层、服务层、持久层这种意义上的分层。而是指客户端一般不需要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样也便于缓存、伸缩和安全策略的部署。该原则的典型的应用是内容分发网络（content distribution network，cdn）。如果你是通过网站浏览到这篇文章的话，你所发出的请求一般（假设你在中国国境内的话）并不是直接访问位于 github pages 的源服务器，而是访问了位于国内的 cdn 服务器，但作为用户，你完全不需要感知到这一点。我们将在“透明多级分流系统”中讨论如何构建自动的、可缓存的分层系统。\n\n 5. 统一接口（uniform interface） 这是 rest 的另一条核心原则，rest 希望开发者面向资源编程，希望软件系统设计的重点放在抽象系统该有哪些资源上，而不是抽象系统该有哪些行为（服务）上。这条原则你可以类比计算机中对文件管理的操作来理解，管理文件可能会进行创建、修改、删除、移动等操作，这些操作数量是可数的，而且对所有文件都是固定的、统一的。如果面向资源来设计系统，同样会具有类似的操作特征，由于 rest 并没有设计新的协议，所以这些操作都借用了 http 协议中固有的操作命令来完成。 统一接口也是 rest 最容易陷入争论的地方，基于网络的软件系统，到底是面向资源更好，还是面向服务更合适，这事情哪怕是很长时间里都不会有个定论，也许永远都没有。但是，已经有一个基本清晰的结论是：面向资源编程的抽象程度通常更高。抽象程度高意味着坏处是往往距离人类的思维方式更远，而好处是往往通用程度会更好。用这样的语言去诠释 rest，大概本身就挺抽象的，笔者还是举个例子来说明：譬如，几乎每个系统都有的登录和注销功能，如果你理解成登录对应于 login()服务，注销对应于 logout()服务这样两个独立服务，这是“符合人类思维”的；如果你理解成登录是 put session，注销是 delete session，这样你只需要设计一种“session 资源”即可满足需求，甚至以后对 session 的其他需求，如查询登陆用户的信息，就是 get session 而已，其他操作如修改用户信息等都可以被这同一套设计囊括在内，这便是“抽象程度更高”带来的好处。 想要在架构设计中合理恰当地利用统一接口，fielding 建议系统应能做到每次请求中都包含资源的 id，所有操作均通过资源 id 来进行；建议每个资源都应该是自描述的消息；建议通过超文本来驱动应用状态的转移。\n\n 6. 按需代码（code-on-demand ） 按需代码被 fielding 列为一条可选原则。它是指任何按照客户端（譬如浏览器）的请求，将可执行的软件程序从服务器发送到客户端的技术，按需代码赋予了客户端无需事先知道所有来自服务端的信息应该如何处理、如何运行的宽容度。举个具体例子，以前的java applet 技术，今天的webassembly 等都属于典型的按需代码，蕴含着具体执行逻辑的代码是存放在服务端，只有当客户端请求了某个 java applet 之后，代码才会被传输并在客户端机器中运行，结束后通常也会随即在客户端中被销毁掉。将按需代码列为可选原则的原因并非是它特别难以达到，而更多是出于必要性和性价比的实际考虑。\n\n至此，rest 中的主要概念与思想原则已经介绍完毕，我们再回过头来讨论本节开篇提出的 rest 与 rpc 在思想上的差异。rest 的基本思想是面向资源来抽象问题，它与此前流行的编程思想——面向过程的编程在抽象主体上有本质的差别。在 rest 提出以前，人们设计分布式系统服务的唯一方案就只有 rpc，rpc 是将本地的方法调用思路迁移到远程方法调用上，开发者是围绕着“远程方法”去设计两个系统间交互的，譬如 corba、rmi、dcom，等等。这样做的坏处不仅是“如何在异构系统间表示一个方法”、“如何获得接口能够提供的方法清单”都成了需要专门协议去解决的问题（rpc 的三大基本问题之一），更在于服务的每个方法都是完全独立的，服务使用者必须逐个学习才能正确地使用它们。google 在《google api design guide》 中曾经写下这样一段话：\n\n> traditionally, people design rpc apis in terms of api interfaces and methods, such as corba and windows com. as time goes by, more and more interfaces and methods are introduced. the end result can be an overwhelming number of interfaces and methods, each of them different from the others. developers have to learn each one carefully in order to use it correctly, which can be both time consuming and error prone\n\n以前，人们面向方法去设计 rpc api，譬如 corba 和 dcom，随着时间推移，接口与方法越来越多却又各不相同，开发人员必须了解每一个方法才能正确使用它们，这样既耗时又容易出错。\n\n—— google api design guide, 2017\n\nrest 提出以资源为主体进行服务设计的风格，能为它带来不少好处（自然也有坏处，笔者将在下一节集中谈论 rest 的不足与争议），譬如：\n\n * 降低的服务接口的学习成本。统一接口（uniform interface）是 rest 的重要标志，将对资源的标准操作都映射到了标准的 http 方法上去，这些方法对于每个资源的用法都是一致的，语义都是类似的，不需要刻意去学习，更不需要有什么 interface description language 之类的协议存在。\n\n * 资源天然具有集合与层次结构。以方法为中心抽象的接口，由于方法是动词，逻辑上决定了每个接口都是互相独立的；但以资源为中心抽象的接口，由于资源是名词，天然就可以产生集合与层次结构。举个具体例子，你想像一个商城用户中心的接口设计：用户资源会拥有多个不同的下级的资源，譬如若干条短消息资源、一份用户资料资源、一部购物车资源，购物车中又会有自己的下级资源，譬如多本书籍资源。很容易在程序接口中构造出这些资源的集合关系与层次关系，而且是符合人们长期在单机或网络环境中管理数据的直觉的。相信你不需要专门阅读接口说明书，也能轻易推断出获取用户icyfenix的购物车中的第2本书的 rest 接口应该表示为：\n\nget /users/icyfenix/cart/2\n\n\n1\n\n\n * rest 绑定于 http 协议。面向资源编程不是必须构筑在 http 之上，但 rest 是，这是缺点，也是优点。因为 http 本来就是面向资源而设计的网络协议，纯粹只用 http（而不是 soap over http 那样在再构筑协议）带来的好处是 rpc 中的 wire protocol 问题就无需再多考虑了，rest 将复用 http 协议中已经定义的概念和相关基础支持来解决问题。http 协议已经有效运作了三十年，其相关的技术基础设施已是千锤百炼，无比成熟。而坏处自然是，当你想去考虑那些 http 不提供的特性时，便会彻底地束手无策。\n\n * ……\n\n以上列举了一些面向资源的优点，笔者并非要证明它比面向过程、面向对象更优秀，是否选用 rest 的 api 设计风格，需要权衡的是你的需求场景、你团队的设计和开发人员是否能够适应面向资源的思想来设计软件，来编写代码。在互联网中，面向资源来进行网络传输是这三十年来 http 协议精心培养出来的用户习惯，如果开发者能够适应 rest 不太符合人类思维习惯的抽象方式，那 rest 通常能够更好地匹配在 http 基础上构建的互联网，在效率与扩展性方面会有可观的收益。\n\n\n# 参考\n\nrest设计风格',charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"简述 HTTP 报文头部的组成结构",frontmatter:{title:"简述 HTTP 报文头部的组成结构",date:"2022-09-21T22:55:20.000Z",permalink:"/pages/dfb780/",categories:["计算机基础","计算机网络"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/290.%E7%AE%80%E8%BF%B0%20HTTP%20%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.html",relativePath:"02.计算机基础/10.计算机网络/290.简述 HTTP 报文头部的组成结构.md",key:"v-51f24219",path:"/pages/dfb780/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2}],headersStr:"参考",content:"# 参考\n\nHTTP 报文结构详解",normalizedContent:"# 参考\n\nhttp 报文结构详解",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"简述自旋锁与互斥锁的使用场景",frontmatter:{title:"简述自旋锁与互斥锁的使用场景",date:"2022-09-21T23:00:00.000Z",permalink:"/pages/9e6232/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/010.%E7%AE%80%E8%BF%B0%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"02.计算机基础/20.操作系统/010.简述自旋锁与互斥锁的使用场景.md",key:"v-fe1405b0",path:"/pages/9e6232/",headers:[{level:2,title:"自旋锁",slug:"自旋锁",normalizedTitle:"自旋锁",charIndex:2},{level:2,title:"自旋锁优缺点",slug:"自旋锁优缺点",normalizedTitle:"自旋锁优缺点",charIndex:571},{level:2,title:"自旋锁的使用场景",slug:"自旋锁的使用场景",normalizedTitle:"自旋锁的使用场景",charIndex:913},{level:2,title:"互斥锁",slug:"互斥锁",normalizedTitle:"互斥锁",charIndex:1214},{level:2,title:"自旋锁和互斥锁的使用场景",slug:"自旋锁和互斥锁的使用场景",normalizedTitle:"自旋锁和互斥锁的使用场景",charIndex:1530}],headersStr:"自旋锁 自旋锁优缺点 自旋锁的使用场景 互斥锁 自旋锁和互斥锁的使用场景",content:"# 自旋锁\n\n自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU\n\n\n\n/**\n * 面试题分享：手写一个自旋锁\n *\n **/\npublic class SpinLockDemo {\n\n    AtomicReference<Thread> lock = new AtomicReference<>();\n\n    public void myLock(){\n        Thread thread = Thread.currentThread();\n        //如果不为空，自旋\n        while (!lock.compareAndSet(null,thread)){\n\n        }\n    }\n\n    public void myUnlock(){\n        Thread thread = Thread.currentThread();\n        //解锁后，将锁置为 null\n        lock.compareAndSet(thread,null);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 自旋锁优缺点\n\n缺点：\n\n 1. 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU 使用率极高。\n 2. 上面 Java 实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。\n\n优点：\n\n 1. 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是 active 的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快\n 2. 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）\n\n\n# 自旋锁的使用场景\n\n如果锁的使用者持有锁的时间非常长，那么其余的等待获得锁的线程就会一直做自旋操作，这是非常浪费 CPU 的使得 CPU 有效利用率大大降低。其次如果并发抢锁的线程非常多，也会加大这种浪费。\n\n那么显然锁的持有时间非常短是使用自旋锁的场景。\n\n因为自旋锁不会阻塞不会陷入内核重新调度其他线程，所以如果自旋带来的 CPU 消耗比阻塞，陷入内核，OS 调度其他线程，再切回用户态这一系列过程来的 CPU 消耗少那么自旋锁就能够节省 CPU，让 CPU 更多的去执行有效代码！ 因为线程切换，陷入内核等等这一系列的操作和傻傻的自旋操作一样都是在做“无意义”事情，白白的消耗 CPU。\n\n\n# 互斥锁\n\n互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞\n\n\n\n对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。\n\n当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。\n\n所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。\n\n性能开销的成本就是上下文切换的成本。\n\n\n# 自旋锁和互斥锁的使用场景\n\na. 如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁 b. 如果临界区需要睡眠，应该选择互斥锁 c. 中断里应该使用自旋锁，因为中断处理中不允许睡眠",normalizedContent:"# 自旋锁\n\n自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 cpu\n\n\n\n/**\n * 面试题分享：手写一个自旋锁\n *\n **/\npublic class spinlockdemo {\n\n    atomicreference<thread> lock = new atomicreference<>();\n\n    public void mylock(){\n        thread thread = thread.currentthread();\n        //如果不为空，自旋\n        while (!lock.compareandset(null,thread)){\n\n        }\n    }\n\n    public void myunlock(){\n        thread thread = thread.currentthread();\n        //解锁后，将锁置为 null\n        lock.compareandset(thread,null);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 自旋锁优缺点\n\n缺点：\n\n 1. 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗cpu。使用不当会造成cpu 使用率极高。\n 2. 上面 java 实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。\n\n优点：\n\n 1. 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是 active 的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快\n 2. 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）\n\n\n# 自旋锁的使用场景\n\n如果锁的使用者持有锁的时间非常长，那么其余的等待获得锁的线程就会一直做自旋操作，这是非常浪费 cpu 的使得 cpu 有效利用率大大降低。其次如果并发抢锁的线程非常多，也会加大这种浪费。\n\n那么显然锁的持有时间非常短是使用自旋锁的场景。\n\n因为自旋锁不会阻塞不会陷入内核重新调度其他线程，所以如果自旋带来的 cpu 消耗比阻塞，陷入内核，os 调度其他线程，再切回用户态这一系列过程来的 cpu 消耗少那么自旋锁就能够节省 cpu，让 cpu 更多的去执行有效代码！ 因为线程切换，陷入内核等等这一系列的操作和傻傻的自旋操作一样都是在做“无意义”事情，白白的消耗 cpu。\n\n\n# 互斥锁\n\n互斥锁是一种「独占锁」，比如当线程 a 加锁成功后，此时互斥锁已经被线程 a 独占了，只要线程 a 没有释放手中的锁，线程 b 加锁就会失败，于是就会释放 cpu 让给其他线程，既然线程 b 释放掉了 cpu，自然线程 b 加锁的代码就会被阻塞\n\n\n\n对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。\n\n当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。\n\n所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。\n\n性能开销的成本就是上下文切换的成本。\n\n\n# 自旋锁和互斥锁的使用场景\n\na. 如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁 b. 如果临界区需要睡眠，应该选择互斥锁 c. 中断里应该使用自旋锁，因为中断处理中不允许睡眠",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"进程间有哪些通信方式？",frontmatter:{title:"进程间有哪些通信方式？",date:"2022-03-11T00:51:48.000Z",permalink:"/pages/e5f2d7/",categories:["计算机基础","CSS"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/01.进程间有哪些通信方式？.md",key:"v-18f7a69e",path:"/pages/e5f2d7/",headers:[{level:2,title:"管道",slug:"管道",normalizedTitle:"管道",charIndex:136},{level:2,title:"2. FIFO",slug:"_2-fifo",normalizedTitle:"2. fifo",charIndex:288},{level:2,title:"3. 消息队列",slug:"_3-消息队列",normalizedTitle:"3. 消息队列",charIndex:510},{level:2,title:"4. 信号量",slug:"_4-信号量",normalizedTitle:"4. 信号量",charIndex:665},{level:2,title:"5. 共享存储",slug:"_5-共享存储",normalizedTitle:"5. 共享存储",charIndex:706},{level:2,title:"6. 套接字",slug:"_6-套接字",normalizedTitle:"6. 套接字",charIndex:850},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:890}],headersStr:"管道 2. FIFO 3. 消息队列 4. 信号量 5. 共享存储 6. 套接字 参考",content:"进程同步与进程通信很容易混淆，它们的区别在于：\n\n * 进程同步：控制多个进程按一定顺序执行；\n * 进程通信：进程间传输信息。\n\n进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。\n\n\n# 管道\n\n管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。\n\n#include <unistd.h>\nint pipe(int fd[2]);\n\n\n1\n2\n\n\n它具有以下限制：\n\n * 只支持半双工通信（单向交替传输）；\n * 只能在父子进程或者兄弟进程中使用。\n\n\n\n\n# 2. FIFO\n\n也称为命名管道，去除了管道只能在父子进程中使用的限制。\n\n#include <sys/stat.h>\nint mkfifo(const char *path, mode_t mode);\nint mkfifoat(int fd, const char *path, mode_t mode);\n\n\n1\n2\n3\n\n\nFIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。\n\n\n\n\n# 3. 消息队列\n\n相比于 FIFO，消息队列具有以下优点：\n\n消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。\n\n\n# 4. 信号量\n\n它是一个计数器，用于为多个进程提供对共享数据对象的访问。\n\n\n# 5. 共享存储\n\n允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。\n\n需要使用信号量用来同步对共享存储的访问。\n\n多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。\n\n\n# 6. 套接字\n\n与其它通信机制不同的是，它可用于不同机器间的进程通信。\n\n\n# 参考\n\n进程通信",normalizedContent:"进程同步与进程通信很容易混淆，它们的区别在于：\n\n * 进程同步：控制多个进程按一定顺序执行；\n * 进程通信：进程间传输信息。\n\n进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。\n\n\n# 管道\n\n管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。\n\n#include <unistd.h>\nint pipe(int fd[2]);\n\n\n1\n2\n\n\n它具有以下限制：\n\n * 只支持半双工通信（单向交替传输）；\n * 只能在父子进程或者兄弟进程中使用。\n\n\n\n\n# 2. fifo\n\n也称为命名管道，去除了管道只能在父子进程中使用的限制。\n\n#include <sys/stat.h>\nint mkfifo(const char *path, mode_t mode);\nint mkfifoat(int fd, const char *path, mode_t mode);\n\n\n1\n2\n3\n\n\nfifo 常用于客户-服务器应用程序中，fifo 用作汇聚点，在客户进程和服务器进程之间传递数据。\n\n\n\n\n# 3. 消息队列\n\n相比于 fifo，消息队列具有以下优点：\n\n消息队列可以独立于读写进程存在，从而避免了 fifo 中同步管道的打开和关闭时可能产生的困难； 避免了 fifo 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 fifo 那样只能默认地接收。\n\n\n# 4. 信号量\n\n它是一个计数器，用于为多个进程提供对共享数据对象的访问。\n\n\n# 5. 共享存储\n\n允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 ipc。\n\n需要使用信号量用来同步对共享存储的访问。\n\n多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 xsi 共享内存不是使用文件，而是使用内存的匿名段。\n\n\n# 6. 套接字\n\n与其它通信机制不同的是，它可用于不同机器间的进程通信。\n\n\n# 参考\n\n进程通信",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"进程和线程之间有什么区别？",frontmatter:{title:"进程和线程之间有什么区别？",date:"2022-09-21T23:00:14.000Z",permalink:"/pages/c2fd8a/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/020.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/020.进程和线程之间有什么区别？.md",key:"v-a0ab5810",path:"/pages/c2fd8a/",headers:[{level:2,title:"1. 进程",slug:"_1-进程",normalizedTitle:"1. 进程",charIndex:2},{level:2,title:"2. 线程",slug:"_2-线程",normalizedTitle:"2. 线程",charIndex:145},{level:2,title:"3. 区别",slug:"_3-区别",normalizedTitle:"3. 区别",charIndex:302},{level:3,title:"Ⅰ 拥有资源",slug:"i-拥有资源",normalizedTitle:"ⅰ 拥有资源",charIndex:312},{level:3,title:"Ⅱ 调度",slug:"ii-调度",normalizedTitle:"ⅱ 调度",charIndex:362},{level:3,title:"Ⅲ 系统开销",slug:"iii-系统开销",normalizedTitle:"ⅲ 系统开销",charIndex:438},{level:3,title:"Ⅳ 通信方面",slug:"iv-通信方面",normalizedTitle:"ⅳ 通信方面",charIndex:585}],headersStr:"1. 进程 2. 线程 3. 区别 Ⅰ 拥有资源 Ⅱ 调度 Ⅲ 系统开销 Ⅳ 通信方面",content:"# 1. 进程\n\n进程是资源分配的基本单位。\n\n进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。\n\n下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。\n\n\n\n\n# 2. 线程\n\n线程是独立调度的基本单位。\n\n一个进程中可以有多个线程，它们共享进程资源。\n\nQQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。\n\n\n\n\n# 3. 区别\n\n\n# Ⅰ 拥有资源\n\n进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。\n\n\n# Ⅱ 调度\n\n线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n\n\n# Ⅲ 系统开销\n\n由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。\n\n\n# Ⅳ 通信方面\n\n线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。",normalizedContent:"# 1. 进程\n\n进程是资源分配的基本单位。\n\n进程控制块 (process control block, pcb) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 pcb 的操作。\n\n下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。\n\n\n\n\n# 2. 线程\n\n线程是独立调度的基本单位。\n\n一个进程中可以有多个线程，它们共享进程资源。\n\nqq 和浏览器是两个进程，浏览器进程里面有很多线程，例如 http 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 http 请求时，浏览器还可以响应用户的其它事件。\n\n\n\n\n# 3. 区别\n\n\n# ⅰ 拥有资源\n\n进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。\n\n\n# ⅱ 调度\n\n线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n\n\n# ⅲ 系统开销\n\n由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、i/o 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 cpu 环境的保存及新调度进程 cpu 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。\n\n\n# ⅳ 通信方面\n\n线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 ipc。",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"简述 select, poll, epoll 的使用场景以及区别",frontmatter:{title:"简述 select, poll, epoll 的使用场景以及区别",date:"2022-09-21T23:01:24.000Z",permalink:"/pages/68ea00/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/070.%E7%AE%80%E8%BF%B0%20select,%20poll,%20epoll%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB.html",relativePath:"02.计算机基础/20.操作系统/070.简述 select, poll, epoll 的使用场景以及区别.md",key:"v-5a37154c",path:"/pages/68ea00/",headers:[{level:2,title:"select",slug:"select",normalizedTitle:"select",charIndex:0},{level:2,title:"poll",slug:"poll",normalizedTitle:"poll",charIndex:7},{level:2,title:"比较",slug:"比较",normalizedTitle:"比较",charIndex:2467},{level:3,title:"1. 功能",slug:"_1-功能",normalizedTitle:"1. 功能",charIndex:2474},{level:3,title:"2. 速度",slug:"_2-速度",normalizedTitle:"2. 速度",charIndex:2775},{level:3,title:"3. 可移植性",slug:"_3-可移植性",normalizedTitle:"3. 可移植性",charIndex:2838},{level:2,title:"epoll",slug:"epoll",normalizedTitle:"epoll",charIndex:12},{level:2,title:"工作模式",slug:"工作模式",normalizedTitle:"工作模式",charIndex:5260},{level:3,title:"1. LT 模式",slug:"_1-lt-模式",normalizedTitle:"1. lt 模式",charIndex:5327},{level:3,title:"2. ET 模式",slug:"_2-et-模式",normalizedTitle:"2. et 模式",charIndex:5456},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:5626},{level:3,title:"1. select 应用场景",slug:"_1-select-应用场景",normalizedTitle:"1. select 应用场景",charIndex:5698},{level:3,title:"2. poll 应用场景",slug:"_2-poll-应用场景",normalizedTitle:"2. poll 应用场景",charIndex:5829},{level:3,title:"3. epoll 应用场景",slug:"_3-epoll-应用场景",normalizedTitle:"3. epoll 应用场景",charIndex:5904}],headersStr:"select poll 比较 1. 功能 2. 速度 3. 可移植性 epoll 工作模式 1. LT 模式 2. ET 模式 应用场景 1. select 应用场景 2. poll 应用场景 3. epoll 应用场景",content:"select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。\n\n\n# select\n\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n\n\n1\n\n\nselect 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。\n\n * fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。\n\n * timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。\n\n * 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。\n\nfd_set fd_in, fd_out;\nstruct timeval tv;\n\n// Reset the sets\nFD_ZERO( &fd_in );\nFD_ZERO( &fd_out );\n\n// Monitor sock1 for input events\nFD_SET( sock1, &fd_in );\n\n// Monitor sock2 for output events\nFD_SET( sock2, &fd_out );\n\n// Find out which socket has the largest numeric value as select requires it\nint largest_sock = sock1 > sock2 ? sock1 : sock2;\n\n// Wait up to 10 seconds\ntv.tv_sec = 10;\ntv.tv_usec = 0;\n\n// Call the select\nint ret = select( largest_sock + 1, &fd_in, &fd_out, NULL, &tv );\n\n// Check if select actually succeed\nif ( ret == -1 )\n    // report error and abort\nelse if ( ret == 0 )\n    // timeout; no event detected\nelse\n{\n    if ( FD_ISSET( sock1, &fd_in ) )\n        // input event on sock1\n\n    if ( FD_ISSET( sock2, &fd_out ) )\n        // output event on sock2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# poll\n\nint poll(struct pollfd *fds, unsigned int nfds, int timeout);\n\n\n1\n\n\npoll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。\n\npoll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：\n\nstruct pollfd {\n               int   fd;         /* file descriptor */\n               short events;     /* requested events */\n               short revents;    /* returned events */\n           };\n\n\n1\n2\n3\n4\n5\n\n\n// The structure for two events\nstruct pollfd fds[2];\n\n// Monitor sock1 for input\nfds[0].fd = sock1;\nfds[0].events = POLLIN;\n\n// Monitor sock2 for output\nfds[1].fd = sock2;\nfds[1].events = POLLOUT;\n\n// Wait 10 seconds\nint ret = poll( &fds, 2, 10000 );\n// Check if poll actually succeed\nif ( ret == -1 )\n    // report error and abort\nelse if ( ret == 0 )\n    // timeout; no event detected\nelse\n{\n    // If we detect the event, zero it out so we can reuse the structure\n    if ( fds[0].revents & POLLIN )\n        fds[0].revents = 0;\n        // input event on sock1\n\n    if ( fds[1].revents & POLLOUT )\n        fds[1].revents = 0;\n        // output event on sock2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 比较\n\n\n# 1. 功能\n\nselect 和 poll 的功能基本相同，不过在一些实现细节上有所不同。\n\n * select 会修改描述符，而 poll 不会；\n * select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；\n * poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。\n * 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。\n\n\n# 2. 速度\n\nselect 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n\n\n# 3. 可移植性\n\n几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。\n\n\n# epoll\n\nint epoll_create(int size);\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n\n\n1\n2\n3\n\n\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。\n\n从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。\n\nepoll 仅适用于 Linux OS。\n\nepoll 比 select 和 poll 更加灵活而且没有描述符数量限制。\n\nepoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。\n\n// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.\n// The function argument is ignored (it was not before, but now it is), so put your favorite number here\nint pollingfd = epoll_create( 0xCAFE );\n\nif ( pollingfd < 0 )\n // report error\n\n// Initialize the epoll structure in case more members are added in future\nstruct epoll_event ev = { 0 };\n\n// Associate the connection class instance with the event. You can associate anything\n// you want, epoll does not use this information. We store a connection class pointer, pConnection1\nev.data.ptr = pConnection1;\n\n// Monitor for input, and do not automatically rearm the descriptor after the event\nev.events = EPOLLIN | EPOLLONESHOT;\n// Add the descriptor into the monitoring list. We can do it even if another thread is\n// waiting in epoll_wait - the descriptor will be properly added\nif ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1->getSocket(), &ev ) != 0 )\n    // report error\n\n// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)\nstruct epoll_event pevents[ 20 ];\n\n// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array\nint ready = epoll_wait( pollingfd, pevents, 20, 10000 );\n// Check if epoll actually succeed\nif ( ret == -1 )\n    // report error and abort\nelse if ( ret == 0 )\n    // timeout; no event detected\nelse\n{\n    // Check if any events detected\n    for ( int i = 0; i < ready; i++ )\n    {\n        if ( pevents[i].events & EPOLLIN )\n        {\n            // Get back our connection pointer\n            Connection * c = (Connection*) pevents[i].data.ptr;\n            c->handleReadEvent();\n         }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 工作模式\n\nepoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。\n\n\n# 1. LT 模式\n\n当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\n\n\n# 2. ET 模式\n\n和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n\n# 应用场景\n\n很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。\n\n\n# 1. select 应用场景\n\nselect 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。\n\nselect 可移植性更好，几乎被所有主流平台所支持。\n\n\n# 2. poll 应用场景\n\npoll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n\n# 3. epoll 应用场景\n\n只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。\n\n需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。\n\n需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。\n\n因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。\n\n并且 epoll 的描述符存储在内核，不容易调试。",normalizedContent:"select/poll/epoll 都是 i/o 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。\n\n\n# select\n\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n\n\n1\n\n\nselect 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 i/o 操作。\n\n * fd_set 使用数组实现，数组大小使用 fd_setsize 定义，所以只能监听少于 fd_setsize 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。\n\n * timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。\n\n * 成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。\n\nfd_set fd_in, fd_out;\nstruct timeval tv;\n\n// reset the sets\nfd_zero( &fd_in );\nfd_zero( &fd_out );\n\n// monitor sock1 for input events\nfd_set( sock1, &fd_in );\n\n// monitor sock2 for output events\nfd_set( sock2, &fd_out );\n\n// find out which socket has the largest numeric value as select requires it\nint largest_sock = sock1 > sock2 ? sock1 : sock2;\n\n// wait up to 10 seconds\ntv.tv_sec = 10;\ntv.tv_usec = 0;\n\n// call the select\nint ret = select( largest_sock + 1, &fd_in, &fd_out, null, &tv );\n\n// check if select actually succeed\nif ( ret == -1 )\n    // report error and abort\nelse if ( ret == 0 )\n    // timeout; no event detected\nelse\n{\n    if ( fd_isset( sock1, &fd_in ) )\n        // input event on sock1\n\n    if ( fd_isset( sock2, &fd_out ) )\n        // output event on sock2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# poll\n\nint poll(struct pollfd *fds, unsigned int nfds, int timeout);\n\n\n1\n\n\npoll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。\n\npoll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：\n\nstruct pollfd {\n               int   fd;         /* file descriptor */\n               short events;     /* requested events */\n               short revents;    /* returned events */\n           };\n\n\n1\n2\n3\n4\n5\n\n\n// the structure for two events\nstruct pollfd fds[2];\n\n// monitor sock1 for input\nfds[0].fd = sock1;\nfds[0].events = pollin;\n\n// monitor sock2 for output\nfds[1].fd = sock2;\nfds[1].events = pollout;\n\n// wait 10 seconds\nint ret = poll( &fds, 2, 10000 );\n// check if poll actually succeed\nif ( ret == -1 )\n    // report error and abort\nelse if ( ret == 0 )\n    // timeout; no event detected\nelse\n{\n    // if we detect the event, zero it out so we can reuse the structure\n    if ( fds[0].revents & pollin )\n        fds[0].revents = 0;\n        // input event on sock1\n\n    if ( fds[1].revents & pollout )\n        fds[1].revents = 0;\n        // output event on sock2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 比较\n\n\n# 1. 功能\n\nselect 和 poll 的功能基本相同，不过在一些实现细节上有所不同。\n\n * select 会修改描述符，而 poll 不会；\n * select 的描述符类型使用数组实现，fd_setsize 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 fd_setsize 之后重新编译；而 poll 没有描述符数量的限制；\n * poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。\n * 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。\n\n\n# 2. 速度\n\nselect 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n\n\n# 3. 可移植性\n\n几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。\n\n\n# epoll\n\nint epoll_create(int size);\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n\n\n1\n2\n3\n\n\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 i/o 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。\n\n从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。\n\nepoll 仅适用于 linux os。\n\nepoll 比 select 和 poll 更加灵活而且没有描述符数量限制。\n\nepoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。\n\n// create the epoll descriptor. only one is needed per app, and is used to monitor all sockets.\n// the function argument is ignored (it was not before, but now it is), so put your favorite number here\nint pollingfd = epoll_create( 0xcafe );\n\nif ( pollingfd < 0 )\n // report error\n\n// initialize the epoll structure in case more members are added in future\nstruct epoll_event ev = { 0 };\n\n// associate the connection class instance with the event. you can associate anything\n// you want, epoll does not use this information. we store a connection class pointer, pconnection1\nev.data.ptr = pconnection1;\n\n// monitor for input, and do not automatically rearm the descriptor after the event\nev.events = epollin | epolloneshot;\n// add the descriptor into the monitoring list. we can do it even if another thread is\n// waiting in epoll_wait - the descriptor will be properly added\nif ( epoll_ctl( epollfd, epoll_ctl_add, pconnection1->getsocket(), &ev ) != 0 )\n    // report error\n\n// wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)\nstruct epoll_event pevents[ 20 ];\n\n// wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array\nint ready = epoll_wait( pollingfd, pevents, 20, 10000 );\n// check if epoll actually succeed\nif ( ret == -1 )\n    // report error and abort\nelse if ( ret == 0 )\n    // timeout; no event detected\nelse\n{\n    // check if any events detected\n    for ( int i = 0; i < ready; i++ )\n    {\n        if ( pevents[i].events & epollin )\n        {\n            // get back our connection pointer\n            connection * c = (connection*) pevents[i].data.ptr;\n            c->handlereadevent();\n         }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 工作模式\n\nepoll 的描述符事件有两种触发模式：lt（level trigger）和 et（edge trigger）。\n\n\n# 1. lt 模式\n\n当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 blocking 和 no-blocking。\n\n\n# 2. et 模式\n\n和 lt 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 lt 模式高。只支持 no-blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n\n# 应用场景\n\n很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。\n\n\n# 1. select 应用场景\n\nselect 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。\n\nselect 可移植性更好，几乎被所有主流平台所支持。\n\n\n# 2. poll 应用场景\n\npoll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n\n# 3. epoll 应用场景\n\n只需要运行在 linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。\n\n需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。\n\n需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。\n\n因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。\n\n并且 epoll 的描述符存储在内核，不容易调试。",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"进程有多少种状态？",frontmatter:{title:"进程有多少种状态？",date:"2022-09-21T23:01:06.000Z",permalink:"/pages/165ea8/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/060.%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/060.进程有多少种状态？.md",key:"v-262f2c87",path:"/pages/165ea8/",headersStr:null,content:" * 就绪状态（ready）：等待被调度\n\n * 运行状态（running）\n\n * 阻塞状态（waiting）：等待资源 应该注意以下内容：\n\n * 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。\n\n * 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。",normalizedContent:" * 就绪状态（ready）：等待被调度\n\n * 运行状态（running）\n\n * 阻塞状态（waiting）：等待资源 应该注意以下内容：\n\n * 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 cpu 时间，转为运行状态；而运行状态的进程，在分配给它的 cpu 时间片用完之后就会转为就绪状态，等待下一次调度。\n\n * 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 cpu 时间，缺少 cpu 时间会从运行态转换为就绪态。",charsets:{cjk:!0},lastUpdated:"2022/10/09, 11:12:48",lastUpdatedTimestamp:1665285168e3},{title:"Linux 下如何排查 CPU 以及 内存占用过多？",frontmatter:{title:"Linux 下如何排查 CPU 以及 内存占用过多？",date:"2022-09-21T23:01:37.000Z",permalink:"/pages/b043a6/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/080.Linux%20%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%20CPU%20%E4%BB%A5%E5%8F%8A%20%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9A%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/080.Linux 下如何排查 CPU 以及 内存占用过多？.md",key:"v-05845816",path:"/pages/b043a6/",headers:[{level:4,title:"一、通过top命令定位占用cpu高的进程",slug:"一、通过top命令定位占用cpu高的进程",normalizedTitle:"一、通过top命令定位占用cpu高的进程",charIndex:73},{level:4,title:"二、通过top命令定位问题进程中每个线程占用cpu情况",slug:"二、通过top命令定位问题进程中每个线程占用cpu情况",normalizedTitle:"二、通过top命令定位问题进程中每个线程占用cpu情况",charIndex:1318},{level:4,title:"三、通过jstack 命令定位问题代码",slug:"三、通过jstack-命令定位问题代码",normalizedTitle:"三、通过jstack 命令定位问题代码",charIndex:1512}],headersStr:"一、通过top命令定位占用cpu高的进程 二、通过top命令定位问题进程中每个线程占用cpu情况 三、通过jstack 命令定位问题代码",content:'一个应用占用CPU很高，除了确实是计算密集型应用之外，通常原因都是出现了死循环。 下面我们将一步步定位问题，详尽的介绍每一步骤的相关知识。\n\n# 一、通过top命令定位占用cpu高的进程\n\n执行top命令得到以下结果：\n\n\n\ntop命令执行结果\n\n通过上图可以明显看出进程PID41843占用cpu过高，明显存在问题，定位到了进程id。当然如果你想只观察进程PID41843的CPU和内存以及负载情况，可以使用以下命令\n\n> top -p 41843。\n\n结果如下：\n\n\n\ntop -p 41843命令执行结果\n\n这里顺便解释下上图各个参数的意义，有利于读者更好的排查问题。\n\n 1. 第一行是任务队列信息 top - 14:06:34 up 537 days, 6 min, 6 users, load average: 0.41, 0.45, 0.43\n\n任务队列信息                           含义\n14:06:34                         当前时间\n537 days                         系统运行时间\n6 min                            用户在线时间\n6 users                          在线用户数\nload average: 0.41, 0.45, 0.43   系统负载，即任务队列的平均长度。1分钟前、5分钟前、15分钟前平均负载\n\n2)第二行为进程的信息\n\n进程信息             含义\nTasks: 1 total   进程总数\n0 running        正在运行的进程数\n1 sleeping       睡眠的进程数\n0 stopped        停止的进程数\n0 zombie         僵尸进程数\n\n 1. 第三行为cpu信息\n\nCPU信息      含义\n6.1% us    用户空间占用CPU百分比\n1.5% sy    内核空间占用CPU百分比\n0.0% ni    用户进程空间内改变过优先级的进程占用CPU百分比\n92.2% id   空闲CPU百分比\n0.0% wa    等待输入输出的CPU时间百分比\n0.0% hi    硬件中断\n0.0% si    软件中断\n0.0%st     实时\n\n 1. 第四、五行为内存信息。 内容如下：\n\n物理内存信息               含义\nMem: 191272k total   物理内存总量\n173656k used         使用的物理内存总量\n17616k free          空闲内存总量\n22052k buffers       用作内核缓存的内存量\n\n交换区信息                 含义\nSwap: 192772k total   交换区总量\n0k used               使用的交换区总量\n192772k free          空闲交换区总量\n123988k cached        缓冲的交换区总量\n\n# 二、通过top命令定位问题进程中每个线程占用cpu情况\n\n通过问题进程中每个线程占用cpu情况使用可以使用如下命令：\n\n> top -p 41843 -H\n\n查看进程PID41843的每一个线程占用CPU情况，如图。\n\n\n\ntop -p 41843 -H的执行结果\n\n由上图明显可以发现，线程PID41892CPU占用率最高，接下来定位该线程的代码是否出现异常导致cpu占用过高。\n\n# 三、通过jstack 命令定位问题代码\n\n上一步发现PID41892占用的CPU过高，就将这个PID转换成16进制，易知，PID41892转化成16进制为a3a4。使用如下命令命令定位问题代码：\n\n> jstack 41892 | grep a3a4\n\n输出如下：\n\n> "Thread" prio=10 tid=0x00007f950043e000 nid=0x54ee in test()；\n\n可以分析得到： 线程Thread下的wait()函数cpu使用率很高，查看源代码中的test()函数代码如下：\n\npublic void test(){\n  while(true){\n     for(int i = 0 ;i<100;i++);\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\nwhile循环无法结束，一直抢占cpu，导致程序cpu使用过高，修改代码即可。 到此为止，因为代码问题导致的cpu使用过高的故障排查方法就介绍完了。\n\n参考',normalizedContent:'一个应用占用cpu很高，除了确实是计算密集型应用之外，通常原因都是出现了死循环。 下面我们将一步步定位问题，详尽的介绍每一步骤的相关知识。\n\n# 一、通过top命令定位占用cpu高的进程\n\n执行top命令得到以下结果：\n\n\n\ntop命令执行结果\n\n通过上图可以明显看出进程pid41843占用cpu过高，明显存在问题，定位到了进程id。当然如果你想只观察进程pid41843的cpu和内存以及负载情况，可以使用以下命令\n\n> top -p 41843。\n\n结果如下：\n\n\n\ntop -p 41843命令执行结果\n\n这里顺便解释下上图各个参数的意义，有利于读者更好的排查问题。\n\n 1. 第一行是任务队列信息 top - 14:06:34 up 537 days, 6 min, 6 users, load average: 0.41, 0.45, 0.43\n\n任务队列信息                           含义\n14:06:34                         当前时间\n537 days                         系统运行时间\n6 min                            用户在线时间\n6 users                          在线用户数\nload average: 0.41, 0.45, 0.43   系统负载，即任务队列的平均长度。1分钟前、5分钟前、15分钟前平均负载\n\n2)第二行为进程的信息\n\n进程信息             含义\ntasks: 1 total   进程总数\n0 running        正在运行的进程数\n1 sleeping       睡眠的进程数\n0 stopped        停止的进程数\n0 zombie         僵尸进程数\n\n 1. 第三行为cpu信息\n\ncpu信息      含义\n6.1% us    用户空间占用cpu百分比\n1.5% sy    内核空间占用cpu百分比\n0.0% ni    用户进程空间内改变过优先级的进程占用cpu百分比\n92.2% id   空闲cpu百分比\n0.0% wa    等待输入输出的cpu时间百分比\n0.0% hi    硬件中断\n0.0% si    软件中断\n0.0%st     实时\n\n 1. 第四、五行为内存信息。 内容如下：\n\n物理内存信息               含义\nmem: 191272k total   物理内存总量\n173656k used         使用的物理内存总量\n17616k free          空闲内存总量\n22052k buffers       用作内核缓存的内存量\n\n交换区信息                 含义\nswap: 192772k total   交换区总量\n0k used               使用的交换区总量\n192772k free          空闲交换区总量\n123988k cached        缓冲的交换区总量\n\n# 二、通过top命令定位问题进程中每个线程占用cpu情况\n\n通过问题进程中每个线程占用cpu情况使用可以使用如下命令：\n\n> top -p 41843 -h\n\n查看进程pid41843的每一个线程占用cpu情况，如图。\n\n\n\ntop -p 41843 -h的执行结果\n\n由上图明显可以发现，线程pid41892cpu占用率最高，接下来定位该线程的代码是否出现异常导致cpu占用过高。\n\n# 三、通过jstack 命令定位问题代码\n\n上一步发现pid41892占用的cpu过高，就将这个pid转换成16进制，易知，pid41892转化成16进制为a3a4。使用如下命令命令定位问题代码：\n\n> jstack 41892 | grep a3a4\n\n输出如下：\n\n> "thread" prio=10 tid=0x00007f950043e000 nid=0x54ee in test()；\n\n可以分析得到： 线程thread下的wait()函数cpu使用率很高，查看源代码中的test()函数代码如下：\n\npublic void test(){\n  while(true){\n     for(int i = 0 ;i<100;i++);\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\nwhile循环无法结束，一直抢占cpu，导致程序cpu使用过高，修改代码即可。 到此为止，因为代码问题导致的cpu使用过高的故障排查方法就介绍完了。\n\n参考',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"简述几个常用的 Linux 命令以及他们的功能",frontmatter:{title:"简述几个常用的 Linux 命令以及他们的功能",date:"2022-09-21T23:00:27.000Z",permalink:"/pages/198887/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/030.%E7%AE%80%E8%BF%B0%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%20Linux%20%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8A%9F%E8%83%BD.html",relativePath:"02.计算机基础/20.操作系统/030.简述几个常用的 Linux 命令以及他们的功能.md",key:"v-32c73af0",path:"/pages/198887/",headers:[{level:2,title:"ls",slug:"ls",normalizedTitle:"ls",charIndex:2},{level:2,title:"长格式显示项",slug:"长格式显示项",normalizedTitle:"长格式显示项",charIndex:259},{level:2,title:"cd",slug:"cd",normalizedTitle:"cd",charIndex:413},{level:2,title:"pwd",slug:"pwd",normalizedTitle:"pwd",charIndex:695},{level:2,title:"Linux 常见目录",slug:"linux-常见目录",normalizedTitle:"linux 常见目录",charIndex:796},{level:2,title:"mkdir",slug:"mkdir",normalizedTitle:"mkdir",charIndex:1187},{level:2,title:"rmdir",slug:"rmdir",normalizedTitle:"rmdir",charIndex:1332},{level:2,title:"文件操作命令",slug:"文件操作命令",normalizedTitle:"文件操作命令",charIndex:1487},{level:2,title:"# touch",slug:"touch",normalizedTitle:"# touch",charIndex:1498},{level:3,title:"rm",slug:"rm",normalizedTitle:"rm",charIndex:1332},{level:3,title:"cat",slug:"cat",normalizedTitle:"cat",charIndex:1750},{level:3,title:"more",slug:"more",normalizedTitle:"more",charIndex:1861},{level:3,title:"head",slug:"head",normalizedTitle:"head",charIndex:1972},{level:3,title:"ln",slug:"ln",normalizedTitle:"ln",charIndex:2148},{level:2,title:"文件和目录都能操作的命令",slug:"文件和目录都能操作的命令",normalizedTitle:"文件和目录都能操作的命令",charIndex:2321},{level:3,title:"rm",slug:"rm-2",normalizedTitle:"rm",charIndex:1332},{level:3,title:"cp",slug:"cp",normalizedTitle:"cp",charIndex:2354},{level:3,title:"mv",slug:"mv",normalizedTitle:"mv",charIndex:2545},{level:3,title:"mv 源文件 目标位置",slug:"mv-源文件-目标位置",normalizedTitle:"mv 源文件 目标位置",charIndex:2601},{level:2,title:"权限管理",slug:"权限管理",normalizedTitle:"权限管理",charIndex:2720},{level:3,title:"➤权限位",slug:"➤权限位",normalizedTitle:"➤权限位",charIndex:2729},{level:3,title:"➤权限位是十位",slug:"➤权限位是十位",normalizedTitle:"➤权限位是十位",charIndex:2793},{level:3,title:"➤权限意义",slug:"➤权限意义",normalizedTitle:"➤权限意义",charIndex:2909},{level:3,title:"chmod",slug:"chmod",normalizedTitle:"chmod",charIndex:3108},{level:3,title:"属主和属组命令chown",slug:"属主和属组命令chown",normalizedTitle:"属主和属组命令chown",charIndex:3432},{level:3,title:"用户操作",slug:"用户操作",normalizedTitle:"用户操作",charIndex:3619},{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:3679},{level:3,title:"man",slug:"man",normalizedTitle:"man",charIndex:3688},{level:3,title:"--help",slug:"help",normalizedTitle:"--help",charIndex:3766},{level:2,title:"查找命令",slug:"查找命令",normalizedTitle:"查找命令",charIndex:3818},{level:3,title:"whereis",slug:"whereis",normalizedTitle:"whereis",charIndex:3827},{level:3,title:"find",slug:"find",normalizedTitle:"find",charIndex:3927},{level:3,title:"grep",slug:"grep",normalizedTitle:"grep",charIndex:4302},{level:2,title:"压缩和解压缩",slug:"压缩和解压缩",normalizedTitle:"压缩和解压缩",charIndex:4534},{level:3,title:"➤linux可以识别的常见压缩格式：.gz .bz2",slug:"➤linux可以识别的常见压缩格式-gz-bz2",normalizedTitle:"➤linux可以识别的常见压缩格式：.gz .bz2",charIndex:4545},{level:3,title:"➤常见的压缩和打包命令：.tar.gz .tar.bz2",slug:"➤常见的压缩和打包命令-tar-gz-tar-bz2",normalizedTitle:"➤常见的压缩和打包命令：.tar.gz .tar.bz2",charIndex:4576},{level:3,title:"➤压缩/解压 同时打包",slug:"➤压缩-解压-同时打包",normalizedTitle:"➤压缩/解压 同时打包",charIndex:4609},{level:2,title:"关机和重启命令",slug:"关机和重启命令",normalizedTitle:"关机和重启命令",charIndex:4934},{level:3,title:"shutdown",slug:"shutdown",normalizedTitle:"shutdown",charIndex:4946},{level:3,title:"reboot",slug:"reboot",normalizedTitle:"reboot",charIndex:5064},{level:3,title:"mount",slug:"mount",normalizedTitle:"mount",charIndex:5140},{level:3,title:"光盘挂载",slug:"光盘挂载",normalizedTitle:"光盘挂载",charIndex:5226},{level:3,title:"光盘卸载",slug:"光盘卸载",normalizedTitle:"光盘卸载",charIndex:5402},{level:2,title:"网络命令",slug:"网络命令",normalizedTitle:"网络命令",charIndex:5518},{level:3,title:"ping",slug:"ping",normalizedTitle:"ping",charIndex:5527},{level:3,title:"ifconfig",slug:"ifconfig",normalizedTitle:"ifconfig",charIndex:5612}],headersStr:"ls 长格式显示项 cd pwd Linux 常见目录 mkdir rmdir 文件操作命令 # touch rm cat more head ln 文件和目录都能操作的命令 rm cp mv mv 源文件 目标位置 权限管理 ➤权限位 ➤权限位是十位 ➤权限意义 chmod 属主和属组命令chown 用户操作 帮助命令 man --help 查找命令 whereis find grep 压缩和解压缩 ➤linux可以识别的常见压缩格式：.gz .bz2 ➤常见的压缩和打包命令：.tar.gz .tar.bz2 ➤压缩/解压 同时打包 关机和重启命令 shutdown reboot mount 光盘挂载 光盘卸载 网络命令 ping ifconfig",content:"# ls\n\n命令名称：ls\n\n命令英文原意：list\n\n命令所在路径：/bin/ls\n\n执行权限：所有用户\n\n功能描述：显示目录文件\n\nls (显示当前目录下文件)\n\nls 目录名 (显示指定目录下文件)\n\nls -l (长格式显示目录文件)\n\nls -l 文件名 (长格式显示指定文件)\n\nls -a (显示所有文件(包含隐藏文件))\n\nls -al (长格式显示当前目录下所有文件)\n\nls -h (文件大小显示为常见大小单位 B KB MB ...)\n\nls -d (显示目录本身，而不是里面的子文件)\n\n\n# 长格式显示项\n\n-rw------- 1 root root 1190 08-10 23:37 anaconda-ks.cfg\n\n① ② ③ ④ ⑤ ⑥ ⑦\n\n第①项：权限位\n\n第②项：引用计数\n\n第③项：属主（所有者）\n\n第④项：属组\n\n第⑤项：大小\n\n第⑥项：最后一次修改时间\n\n第⑦项：文件名\n\n\n# cd\n\n命令名称：cd\n\n命令英文原意：change directory\n\n命令所在路径：shell内置命令\n\n执行权限：所有用户\n\n功能描述：切换所在目录\n\ncd /usr/local/src 切换到指定路径(使用绝对路径方式)\n\ncd ~ 进入当前用户的家目录\n\ncd - 进入上次目录\n\ncd .. 进入上一级目录\n\ncd . 进入当前目录\n\n绝对路径：cd ../usr/local 参照当前所在目录，进行查找。一定要先确定当前所在目录。 相对路径：cd /usr/local 从根目录开始指定，一级一级递归查找。在任何目录下，都能进入指定位置。\n\n\n# pwd\n\n命令名称：pwd\n\n命令英文原意：print working directory\n\n命令所在路径：/bin/pwd\n\n执行权限：所有用户\n\n功能描述：显示当前所在目录(当前工作目录)\n\n\n# Linux 常见目录\n\n/ 根目录\n\n/bin 命令保存目录（普通用户就可以读取的命令）\n\n/boot 启动目录，启动相关文件\n\n/dev 设备文件保存目录\n\n/etc 配置文件保存目录\n\n/home 普通用户的家目录\n\n/lib 系统库保存目录\n\n/mnt 系统挂载目录\n\n/media 挂载目录\n\n/root 超级用户的家目录\n\n/tmp 临时目录\n\n/sbin 命令保存目录（超级用户才能使用的目录）\n\n/proc 直接写入内存的\n\n/sys 将内核的一些信息映射，可供应用程序所用\n\n/usr 系统软件资源目录\n\n/usr/bin/ 系统命令（普通用户）\n\n/usr/sbin/ 系统命令（超级用户）\n\n/var 系统相关文档内容\n\n/var/log/ 系统日志位置\n\n/var/spool/mail/ 系统默认邮箱位置\n\n/var/lib/ 默认安装的库文件目录\n\n\n# mkdir\n\n命令名称：mkdir\n\n命令英文原意：make directories\n\n命令所在路径：/bin/mkdir\n\n执行权限：所有用户\n\n功能描述：建立目录\n\nmkdir test 创建名为test的目录\n\nmkdir -p test1/test2/test3 递归创建\n\n\n# rmdir\n\n命令名称：rmdir\n\n命令英文原意：remove empty directories\n\n命令所在路径：/bin/rmdir\n\n执行权限：所有用户\n\n功能描述：删除目录 (只能删除空目录)\n\n![](/assets/屏幕快照 2017-07-19 上午11.05.47.png)\n\n\n\n\n\n\n# 文件操作命令\n\n\n# # touch\n\n命令名称：touch\n\n命令所在路径：/bin/touch\n\n执行权限：所有用户\n\n功能描述：创建空文件 或 修改文件时间\n\ntouch test.py 创建空文件，如果文件存在，则修改文件创建时间\n\n\n# rm\n\n命令名称：rm\n\n命令英文原意：remove\n\n命令所在路径：/bin/rm\n\n执行权限：所有用户\n\n功能描述：删除\n\nrm 文件名 删除文件\n\nrm -r 目录名 递归删除文件和目录\n\nrm -f 文件名 强制删除\n\nrm -rf 目录名 强制删除目录和文件\n\n\n# cat\n\n命令名称：cat\n\n命令所在路径：/bin/cat\n\n执行权限：所有用户\n\n功能描述：查看文件内容，从头到尾的内容。\n\ncat 文件名 查看文件内容内容\n\ncat -n 文件名 查看文件内容，并列出行号\n\n\n# more\n\n命令名称：more\n\n命令所在路径：/bin/more\n\n执行权限：所有用户\n\n功能描述：分屏显示文件内容\n\nmore 文件名 分屏显示文件内容\n\n向上翻页 空格键\n\n向下翻页 b键\n\n退出查看 q键\n\n\n# head\n\n命令名称：head\n\n命令所在路径：/usr/bin/head\n\n执行权限：所有用户\n\n功能描述：显示文件头\n\nhead 文件名 显示文件头几行(默认显示10行)\n\nhead -n 20 文件名 显示文件前20行\n\nhead -n -20 文件名 显示文件最后20行\n\nctrl + c 强制终止查看模式\n\nctrl + l 清屏\n\n\n# ln\n\n命令名称：ln\n\n命令英文原意：link\n\n命令所在路径：/bin/ln\n\n执行权限：所有用户\n\n功能描述：链接文件\n\n等同于Windows中的快捷方式\n\n新建的链接，占用不同的硬盘位置\n\n修改一个文件，两边都会改变\n\n删除源文件，软连接文件打不开\n\nln -s 源文件 目标文件 创建链接文件(文件名都必须写绝对路径)\n\n\n\n\n\n\n# 文件和目录都能操作的命令\n\n\n# rm\n\n删除文件或目录\n\n\n# cp\n\n命令名称：cp\n\n命令英文原意：copy\n\n命令所在路径：/bin/cp\n\n执行权限：所有用户\n\n功能描述：复制文件或目录\n\ncp 源文件 目标位置 (复制)\n\n或\n\ncp 源文件 目标位置/目标名称 (复制并改名)\n\ncp -r 复制目录\n\ncp -p 连带文件属性一起复制\n\ncp -d 若源文件是链接文件，则复制链接属性\n\ncp -a 相当于 cp -pdr\n\n\n# mv\n\n命令名称：mv\n\n命令英文原意：move\n\n命令所在路径：/bin/mv\n\n执行权限：所有用户\n\n\n# mv 源文件 目标位置\n\nmv /root/test /tmp/ 将/root/下的test文件移动到/tmp/目录下\n\nmv /root/test /root/newtest 将/root/下的test文件改名为newtest\n\n\n# 权限管理\n\n\n# ➤权限位\n\n-rw-r--r--. 1 root root 44736 7月 18 00:38 install.log\n\n\n# ➤权限位是十位\n\n第一位：代表文件类型\n\n- 普通文件\n\nd 目录文件\n\nl 链接文件\n\n其他九位：代表各用户的权限\n\n(前三位=属主权限u 中间三位=属组权限g 其他人权限o)\n\nr 读 4\n\nw 写 2\n\nx 执行 1\n\n\n# ➤权限意义\n\n✦权限对文件的含义：\n\nr：读取文件内容 如：cat、more、head、tail\n\nw：编辑、新增、修改文件内容 如：vi、echo 但是不包含删除文件\n\nx：可执行 /tmp/11/22/abc ---------\n\n✦权限对目录的含义：\n\nr：可以查询目录下文件名 如：ls\n\nw：具有修改目录结构的权限 如：touch、rm、mv、cp\n\nx：可以进入目录 如：cd\n\n\n# chmod\n\n命令名称：chmod\n\n命令英文原意：change the permissions mode of a file\n\n命令所在路径：/bin/chmod\n\n执行权限：所有用户\n\n功能描述：修改权限\n\nchmod u+x aa aa文件的属主加上执行权限\n\nchmod u-x aa aa文件的属主减去执行权限\n\nchmod g+w,o+w aa aa文件的属组和其他人加上写权限\n\nchmod u=rwx aa aa文件的用户权限改为所有权限(读+写+执行)\n\n另一种表现方式：\n\nchmod 755 aa aa文件的属主权限是rwx，属组和其他人是rx\n\nchmod 644 aa aa文件的属主权限是rw，属组和其他人是r\n\n\n# 属主和属组命令chown\n\n命令名称：chown\n\n命令英文原意：change file ownership\n\n命令所在路径：/bin/chown\n\n执行权限：所有用户\n\n功能描述：修改文件的属主或属组\n\nchown 用户名 文件名 改变文件属主\n\nchown user1 aa user1必须存在\n\nchown user1:user1 aa 改变属主同时改变属组\n\n\n# 用户操作\n\nuseradd 用户名 功能描述：添加用户\n\npasswd 用户名 功能描述：设定用户密码\n\n\n\n\n\n\n# 帮助命令\n\n\n# man\n\n命令名：man\n\n命令英文原意：manual\n\n命令所在路径：/usr/bin/man\n\n执行权限：所有用户\n\n功能描述：查看命令的帮助\n\n\n# --help\n\n命令名：--help\n\n执行权限：所有用户\n\n功能描述：查看命令的帮助\n\n\n\n\n\n\n# 查找命令\n\n\n# whereis\n\n命令名：whereis\n\n命令名称：whereis\n\n命令所在路径：/usr/bin/whereis\n\n执行权限：所有用户\n\n功能描述：查找命令的命令，同时看到帮助文档位置\n\n\n# find\n\n命令名称：find\n\n命令所在路径：/usr/bin/find\n\n执行权限：所有用户\n\n功能描述：搜索命令\n\nfind 查找位置 -name 文件名\n\nfind / -name aabbcc 查找/目录下名为 aabbcc的文件\n\n更多选项：\n\n-name 文件名 按照文件名查找\n\n-user 用户名 按照属主用户名查找文件\n\n-group 组名 按照属组组名查找文件\n\n-nouser 找没有属主的文件 (除了这三个文件：/proc、/sys、/mnt/cdrom)\n\n-size 按照文件大小k M 如：find / -size +50k\n\n-type 按照文件类型查找(f=普通 d=目录 l=链接)\n\n-perm 按照权限查找 如：find /root -perm 644\n\n-iname 按照文件名查找，不区分大小写\n\n\n# grep\n\n命令名称：grep\n\n命令所在路径：/bin/grep\n\n执行权限：所有用户\n\n功能描述：查找符合条件的字串\n\ngrep 选项 '字串' 查找路径\n\ngrep -i \"root\" /etc/passwd\n\n-v 反向选择\n\n-i 忽略大小写\n\n管道符 |\n\n命令1 | 命令2 命令1的执行结果，作为命令2的执行条件\n\ncat 文件名 | grep '字串' 提取含有字符串的行\n\nls -l /etc | more 分屏显示ls内容\n\n\n\n\n\n\n# 压缩和解压缩\n\n\n# ➤linux可以识别的常见压缩格式：.gz .bz2\n\n\n# ➤常见的压缩和打包命令：.tar.gz .tar.bz2\n\n\n# ➤压缩/解压 同时打包\n\ntar -zcvf 压缩文件名 源文件\n\ntar -zcvf aa.tar.gz aa\n\n-z 识别.gz格式\n\n-c 压缩\n\n-v 显示压缩过程\n\n-f 指定压缩包名\n\ntar -zxvf 压缩文件名 解压缩同时解打包\n\ntar -jcvf 压缩文件名 源文件 压缩同时打包\n\ntar -jcvf aa.tar.bz2 aa\n\ntar -jxvf aa.tar.bz2 解打包同时解压缩\n\n查看不解包\n\ntar -ztvf aa.tar.gz 查看不解压\n\ntar -jtvf aa.tar.bz2\n\n-t 只查看，不解压\n\ntar -jxvf root.tar.bz2 -C /tmp/ 指定解压缩位置\n\n\n\n\n\n\n# 关机和重启命令\n\n\n# shutdown\n\n命令名称：shutdown\n\n命令所在路径：/sbin/shutdown\n\n执行权限：root\n\n功能描述：关机/重启\n\nshutdown -h now 没有特殊情况，使用此命令\n\n-h 关机\n\n-r 重启\n\n\n# reboot\n\n命令名称：reboot\n\n命令所在路径：/sbin/reboot\n\n执行权限：root\n\n功能描述：关机/重启挂载\n\n挂载命令\n\n\n# mount\n\n命令名称：mount\n\n命令所在路径：/bin/mount\n\n执行权限：所有用户\n\n功能描述：挂载\n\nlinux所有存储设备都必须挂载使用，包括硬盘\n\n\n# 光盘挂载\n\n/dev/sda1 第一个scsi硬盘的第一分区\n\n/dev/cdrom 光盘\n\n/dev/hdc IDE硬盘 centos 5.5\n\n/dev/sr0 光盘 centos 6.x\n\nmount -t 文件系统 设备描述文件 挂载点（已经存在空目录）\n\nmount -t iso9660 /dev/cdrom /mnt/cdrom\n\n\n# 光盘卸载\n\numount /dev/cdrom\n\numount /mnt/cdrom 注意：退出挂载目录，才能卸载\n\nfdisk -l 查看设备名\n\nmount -t vfat /dev/sdb1 /mnt/usb\n\n\n\n\n\n\n# 网络命令\n\n\n# ping\n\n命令名称：ping\n\n命令所在路径：/bin/ping\n\n执行权限：所有用户\n\n功能描述：测试网络畅通性\n\nping -c 次数 ip 探测网络通畅\n\n\n# ifconfig\n\n命令名称：ifconfig\n\n命令英文原意：interface configure\n\n命令所在路径：/sbin/ifconfig\n\n执行权限：root\n\n功能描述：查询本机网络信息",normalizedContent:"# ls\n\n命令名称：ls\n\n命令英文原意：list\n\n命令所在路径：/bin/ls\n\n执行权限：所有用户\n\n功能描述：显示目录文件\n\nls (显示当前目录下文件)\n\nls 目录名 (显示指定目录下文件)\n\nls -l (长格式显示目录文件)\n\nls -l 文件名 (长格式显示指定文件)\n\nls -a (显示所有文件(包含隐藏文件))\n\nls -al (长格式显示当前目录下所有文件)\n\nls -h (文件大小显示为常见大小单位 b kb mb ...)\n\nls -d (显示目录本身，而不是里面的子文件)\n\n\n# 长格式显示项\n\n-rw------- 1 root root 1190 08-10 23:37 anaconda-ks.cfg\n\n① ② ③ ④ ⑤ ⑥ ⑦\n\n第①项：权限位\n\n第②项：引用计数\n\n第③项：属主（所有者）\n\n第④项：属组\n\n第⑤项：大小\n\n第⑥项：最后一次修改时间\n\n第⑦项：文件名\n\n\n# cd\n\n命令名称：cd\n\n命令英文原意：change directory\n\n命令所在路径：shell内置命令\n\n执行权限：所有用户\n\n功能描述：切换所在目录\n\ncd /usr/local/src 切换到指定路径(使用绝对路径方式)\n\ncd ~ 进入当前用户的家目录\n\ncd - 进入上次目录\n\ncd .. 进入上一级目录\n\ncd . 进入当前目录\n\n绝对路径：cd ../usr/local 参照当前所在目录，进行查找。一定要先确定当前所在目录。 相对路径：cd /usr/local 从根目录开始指定，一级一级递归查找。在任何目录下，都能进入指定位置。\n\n\n# pwd\n\n命令名称：pwd\n\n命令英文原意：print working directory\n\n命令所在路径：/bin/pwd\n\n执行权限：所有用户\n\n功能描述：显示当前所在目录(当前工作目录)\n\n\n# linux 常见目录\n\n/ 根目录\n\n/bin 命令保存目录（普通用户就可以读取的命令）\n\n/boot 启动目录，启动相关文件\n\n/dev 设备文件保存目录\n\n/etc 配置文件保存目录\n\n/home 普通用户的家目录\n\n/lib 系统库保存目录\n\n/mnt 系统挂载目录\n\n/media 挂载目录\n\n/root 超级用户的家目录\n\n/tmp 临时目录\n\n/sbin 命令保存目录（超级用户才能使用的目录）\n\n/proc 直接写入内存的\n\n/sys 将内核的一些信息映射，可供应用程序所用\n\n/usr 系统软件资源目录\n\n/usr/bin/ 系统命令（普通用户）\n\n/usr/sbin/ 系统命令（超级用户）\n\n/var 系统相关文档内容\n\n/var/log/ 系统日志位置\n\n/var/spool/mail/ 系统默认邮箱位置\n\n/var/lib/ 默认安装的库文件目录\n\n\n# mkdir\n\n命令名称：mkdir\n\n命令英文原意：make directories\n\n命令所在路径：/bin/mkdir\n\n执行权限：所有用户\n\n功能描述：建立目录\n\nmkdir test 创建名为test的目录\n\nmkdir -p test1/test2/test3 递归创建\n\n\n# rmdir\n\n命令名称：rmdir\n\n命令英文原意：remove empty directories\n\n命令所在路径：/bin/rmdir\n\n执行权限：所有用户\n\n功能描述：删除目录 (只能删除空目录)\n\n![](/assets/屏幕快照 2017-07-19 上午11.05.47.png)\n\n\n\n\n\n\n# 文件操作命令\n\n\n# # touch\n\n命令名称：touch\n\n命令所在路径：/bin/touch\n\n执行权限：所有用户\n\n功能描述：创建空文件 或 修改文件时间\n\ntouch test.py 创建空文件，如果文件存在，则修改文件创建时间\n\n\n# rm\n\n命令名称：rm\n\n命令英文原意：remove\n\n命令所在路径：/bin/rm\n\n执行权限：所有用户\n\n功能描述：删除\n\nrm 文件名 删除文件\n\nrm -r 目录名 递归删除文件和目录\n\nrm -f 文件名 强制删除\n\nrm -rf 目录名 强制删除目录和文件\n\n\n# cat\n\n命令名称：cat\n\n命令所在路径：/bin/cat\n\n执行权限：所有用户\n\n功能描述：查看文件内容，从头到尾的内容。\n\ncat 文件名 查看文件内容内容\n\ncat -n 文件名 查看文件内容，并列出行号\n\n\n# more\n\n命令名称：more\n\n命令所在路径：/bin/more\n\n执行权限：所有用户\n\n功能描述：分屏显示文件内容\n\nmore 文件名 分屏显示文件内容\n\n向上翻页 空格键\n\n向下翻页 b键\n\n退出查看 q键\n\n\n# head\n\n命令名称：head\n\n命令所在路径：/usr/bin/head\n\n执行权限：所有用户\n\n功能描述：显示文件头\n\nhead 文件名 显示文件头几行(默认显示10行)\n\nhead -n 20 文件名 显示文件前20行\n\nhead -n -20 文件名 显示文件最后20行\n\nctrl + c 强制终止查看模式\n\nctrl + l 清屏\n\n\n# ln\n\n命令名称：ln\n\n命令英文原意：link\n\n命令所在路径：/bin/ln\n\n执行权限：所有用户\n\n功能描述：链接文件\n\n等同于windows中的快捷方式\n\n新建的链接，占用不同的硬盘位置\n\n修改一个文件，两边都会改变\n\n删除源文件，软连接文件打不开\n\nln -s 源文件 目标文件 创建链接文件(文件名都必须写绝对路径)\n\n\n\n\n\n\n# 文件和目录都能操作的命令\n\n\n# rm\n\n删除文件或目录\n\n\n# cp\n\n命令名称：cp\n\n命令英文原意：copy\n\n命令所在路径：/bin/cp\n\n执行权限：所有用户\n\n功能描述：复制文件或目录\n\ncp 源文件 目标位置 (复制)\n\n或\n\ncp 源文件 目标位置/目标名称 (复制并改名)\n\ncp -r 复制目录\n\ncp -p 连带文件属性一起复制\n\ncp -d 若源文件是链接文件，则复制链接属性\n\ncp -a 相当于 cp -pdr\n\n\n# mv\n\n命令名称：mv\n\n命令英文原意：move\n\n命令所在路径：/bin/mv\n\n执行权限：所有用户\n\n\n# mv 源文件 目标位置\n\nmv /root/test /tmp/ 将/root/下的test文件移动到/tmp/目录下\n\nmv /root/test /root/newtest 将/root/下的test文件改名为newtest\n\n\n# 权限管理\n\n\n# ➤权限位\n\n-rw-r--r--. 1 root root 44736 7月 18 00:38 install.log\n\n\n# ➤权限位是十位\n\n第一位：代表文件类型\n\n- 普通文件\n\nd 目录文件\n\nl 链接文件\n\n其他九位：代表各用户的权限\n\n(前三位=属主权限u 中间三位=属组权限g 其他人权限o)\n\nr 读 4\n\nw 写 2\n\nx 执行 1\n\n\n# ➤权限意义\n\n✦权限对文件的含义：\n\nr：读取文件内容 如：cat、more、head、tail\n\nw：编辑、新增、修改文件内容 如：vi、echo 但是不包含删除文件\n\nx：可执行 /tmp/11/22/abc ---------\n\n✦权限对目录的含义：\n\nr：可以查询目录下文件名 如：ls\n\nw：具有修改目录结构的权限 如：touch、rm、mv、cp\n\nx：可以进入目录 如：cd\n\n\n# chmod\n\n命令名称：chmod\n\n命令英文原意：change the permissions mode of a file\n\n命令所在路径：/bin/chmod\n\n执行权限：所有用户\n\n功能描述：修改权限\n\nchmod u+x aa aa文件的属主加上执行权限\n\nchmod u-x aa aa文件的属主减去执行权限\n\nchmod g+w,o+w aa aa文件的属组和其他人加上写权限\n\nchmod u=rwx aa aa文件的用户权限改为所有权限(读+写+执行)\n\n另一种表现方式：\n\nchmod 755 aa aa文件的属主权限是rwx，属组和其他人是rx\n\nchmod 644 aa aa文件的属主权限是rw，属组和其他人是r\n\n\n# 属主和属组命令chown\n\n命令名称：chown\n\n命令英文原意：change file ownership\n\n命令所在路径：/bin/chown\n\n执行权限：所有用户\n\n功能描述：修改文件的属主或属组\n\nchown 用户名 文件名 改变文件属主\n\nchown user1 aa user1必须存在\n\nchown user1:user1 aa 改变属主同时改变属组\n\n\n# 用户操作\n\nuseradd 用户名 功能描述：添加用户\n\npasswd 用户名 功能描述：设定用户密码\n\n\n\n\n\n\n# 帮助命令\n\n\n# man\n\n命令名：man\n\n命令英文原意：manual\n\n命令所在路径：/usr/bin/man\n\n执行权限：所有用户\n\n功能描述：查看命令的帮助\n\n\n# --help\n\n命令名：--help\n\n执行权限：所有用户\n\n功能描述：查看命令的帮助\n\n\n\n\n\n\n# 查找命令\n\n\n# whereis\n\n命令名：whereis\n\n命令名称：whereis\n\n命令所在路径：/usr/bin/whereis\n\n执行权限：所有用户\n\n功能描述：查找命令的命令，同时看到帮助文档位置\n\n\n# find\n\n命令名称：find\n\n命令所在路径：/usr/bin/find\n\n执行权限：所有用户\n\n功能描述：搜索命令\n\nfind 查找位置 -name 文件名\n\nfind / -name aabbcc 查找/目录下名为 aabbcc的文件\n\n更多选项：\n\n-name 文件名 按照文件名查找\n\n-user 用户名 按照属主用户名查找文件\n\n-group 组名 按照属组组名查找文件\n\n-nouser 找没有属主的文件 (除了这三个文件：/proc、/sys、/mnt/cdrom)\n\n-size 按照文件大小k m 如：find / -size +50k\n\n-type 按照文件类型查找(f=普通 d=目录 l=链接)\n\n-perm 按照权限查找 如：find /root -perm 644\n\n-iname 按照文件名查找，不区分大小写\n\n\n# grep\n\n命令名称：grep\n\n命令所在路径：/bin/grep\n\n执行权限：所有用户\n\n功能描述：查找符合条件的字串\n\ngrep 选项 '字串' 查找路径\n\ngrep -i \"root\" /etc/passwd\n\n-v 反向选择\n\n-i 忽略大小写\n\n管道符 |\n\n命令1 | 命令2 命令1的执行结果，作为命令2的执行条件\n\ncat 文件名 | grep '字串' 提取含有字符串的行\n\nls -l /etc | more 分屏显示ls内容\n\n\n\n\n\n\n# 压缩和解压缩\n\n\n# ➤linux可以识别的常见压缩格式：.gz .bz2\n\n\n# ➤常见的压缩和打包命令：.tar.gz .tar.bz2\n\n\n# ➤压缩/解压 同时打包\n\ntar -zcvf 压缩文件名 源文件\n\ntar -zcvf aa.tar.gz aa\n\n-z 识别.gz格式\n\n-c 压缩\n\n-v 显示压缩过程\n\n-f 指定压缩包名\n\ntar -zxvf 压缩文件名 解压缩同时解打包\n\ntar -jcvf 压缩文件名 源文件 压缩同时打包\n\ntar -jcvf aa.tar.bz2 aa\n\ntar -jxvf aa.tar.bz2 解打包同时解压缩\n\n查看不解包\n\ntar -ztvf aa.tar.gz 查看不解压\n\ntar -jtvf aa.tar.bz2\n\n-t 只查看，不解压\n\ntar -jxvf root.tar.bz2 -c /tmp/ 指定解压缩位置\n\n\n\n\n\n\n# 关机和重启命令\n\n\n# shutdown\n\n命令名称：shutdown\n\n命令所在路径：/sbin/shutdown\n\n执行权限：root\n\n功能描述：关机/重启\n\nshutdown -h now 没有特殊情况，使用此命令\n\n-h 关机\n\n-r 重启\n\n\n# reboot\n\n命令名称：reboot\n\n命令所在路径：/sbin/reboot\n\n执行权限：root\n\n功能描述：关机/重启挂载\n\n挂载命令\n\n\n# mount\n\n命令名称：mount\n\n命令所在路径：/bin/mount\n\n执行权限：所有用户\n\n功能描述：挂载\n\nlinux所有存储设备都必须挂载使用，包括硬盘\n\n\n# 光盘挂载\n\n/dev/sda1 第一个scsi硬盘的第一分区\n\n/dev/cdrom 光盘\n\n/dev/hdc ide硬盘 centos 5.5\n\n/dev/sr0 光盘 centos 6.x\n\nmount -t 文件系统 设备描述文件 挂载点（已经存在空目录）\n\nmount -t iso9660 /dev/cdrom /mnt/cdrom\n\n\n# 光盘卸载\n\numount /dev/cdrom\n\numount /mnt/cdrom 注意：退出挂载目录，才能卸载\n\nfdisk -l 查看设备名\n\nmount -t vfat /dev/sdb1 /mnt/usb\n\n\n\n\n\n\n# 网络命令\n\n\n# ping\n\n命令名称：ping\n\n命令所在路径：/bin/ping\n\n执行权限：所有用户\n\n功能描述：测试网络畅通性\n\nping -c 次数 ip 探测网络通畅\n\n\n# ifconfig\n\n命令名称：ifconfig\n\n命令英文原意：interface configure\n\n命令所在路径：/sbin/ifconfig\n\n执行权限：root\n\n功能描述：查询本机网络信息",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"进程通信中的管道实现原理是什么？",frontmatter:{title:"进程通信中的管道实现原理是什么？",date:"2022-09-21T23:01:50.000Z",permalink:"/pages/8e880a/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/090.%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/090.进程通信中的管道实现原理是什么？.md",key:"v-303058be",path:"/pages/8e880a/",headers:[{level:2,title:"一、管道的使用",slug:"一、管道的使用",normalizedTitle:"一、管道的使用",charIndex:397},{level:2,title:"二、管道的实现",slug:"二、管道的实现",normalizedTitle:"二、管道的实现",charIndex:1632},{level:3,title:"1. 环形缓冲区（Ring Buffer）",slug:"_1-环形缓冲区-ring-buffer",normalizedTitle:"1. 环形缓冲区（ring buffer）",charIndex:1759},{level:3,title:"2. 管道对象",slug:"_2-管道对象",normalizedTitle:"2. 管道对象",charIndex:2094},{level:3,title:"3. 读操作",slug:"_3-读操作",normalizedTitle:"3. 读操作",charIndex:3362},{level:3,title:"4. 写操作",slug:"_4-写操作",normalizedTitle:"4. 写操作",charIndex:5851},{level:2,title:"三、思考一下",slug:"三、思考一下",normalizedTitle:"三、思考一下",charIndex:8687},{level:3,title:"1. 为什么父子进程可以通过管道来通信？",slug:"_1-为什么父子进程可以通过管道来通信",normalizedTitle:"1. 为什么父子进程可以通过管道来通信？",charIndex:8730},{level:3,title:"2. 为什么内核要使用 16 个内存页进行数据存储？",slug:"_2-为什么内核要使用-16-个内存页进行数据存储",normalizedTitle:"2. 为什么内核要使用 16 个内存页进行数据存储？",charIndex:8854},{level:2,title:"四 参考",slug:"四-参考",normalizedTitle:"四 参考",charIndex:8992}],headersStr:"一、管道的使用 二、管道的实现 1. 环形缓冲区（Ring Buffer） 2. 管道对象 3. 读操作 4. 写操作 三、思考一下 1. 为什么父子进程可以通过管道来通信？ 2. 为什么内核要使用 16 个内存页进行数据存储？ 四 参考",content:'处于安全的考虑，不同进程之间的内存空间是相互隔离的，也就是说 进程A 是不能访问 进程B 的内存空间，反之亦然。如果不同进程间能够相互访问和修改对方的内存，那么当前进程的内存就有可能被其他进程非法修改，从而导致安全隐患。\n\n不同的进程就像是大海上孤立的岛屿，它们之间不能直接相互通信，如下图所示：\n\n\n\n但某些场景下，不同进程间需要相互通信，比如：进程A 负责处理用户的请求，而 进程B 负责保存处理后的数据。那么当 进程A 处理完请求后，就需要把处理后的数据提交给 进程B 进行存储。此时，进程A 就需要与 进程B 进行通信。如下图所示：\n\n\n\n由于不同进程间是相互隔离的，所以必须借助内核来作为桥梁来进行相互通信，内核相当于岛屿之间的轮船，如下图所示：\n\n\n\n内核提供多种进程间通信的方式，如：共享内存，信号，消息队列 和 管道（pipe） 等。本文主要介绍 管道 的原理与实现。\n\n\n# 一、管道的使用\n\n管道 一般用于父子进程之间相互通信，一般的用法如下：\n\n * 父进程使用 pipe 系统调用创建一个管道。\n * 然后父进程使用 fork 系统调用创建一个子进程。\n * 由于子进程会继承父进程打开的文件句柄，所以父子进程可以通过新创建的管道进行通信。\n\n其原理如下图所示：\n\n\n\n由于管道分为读端和写端，所以需要两个文件描述符来管理管道：fd[0] 为读端，fd[1] 为写端。\n\n下面代码介绍了怎么使用 pipe 系统调用来创建一个管道：\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    int ret = -1;\n    int fd[2];  // 用于管理管道的文件描述符\n    pid_t pid;\n    char buf[512] = {0};\n    char *msg = "hello world";\n\n    // 创建一个管理\n    ret = pipe(fd);\n    if (-1 == ret) {\n        printf("failed to create pipe\\n");\n        return -1;\n    }\n  \n    pid = fork();     // 创建子进程\n\n    if (0 == pid) {   // 子进程\n        close(fd[0]); // 关闭管道的读端\n        ret = write(fd[1], msg, strlen(msg)); // 向管道写端写入数据\n        exit(0);\n    } else {          // 父进程\n        close(fd[1]); // 关闭管道的写端\n        ret = read(fd[0], buf, sizeof(buf)); // 从管道的读端读取数据\n        printf("parent read %d bytes data: %s\\n", ret, buf);\n    }\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n复制\n\n编译代码：\n\n[root@localhost pipe]# gcc -g pipe.c -o pipe\n\n\n1\n\n\n复制\n\n运行代码，输出结果如下：\n\n[root@localhost pipe]# ./pipe\nparent read 11 bytes data: hello world\n\n\n1\n2\n\n\n复制\n\n\n# 二、管道的实现\n\n每个进程的用户空间都是独立的，但内核空间却是共用的。所以，进程间通信必须由内核提供服务。前面介绍了 管道(pipe) 的使用，接下来将会介绍管道在内核中的实现方式。\n\n> 本文使用 Linux-2.6.23 内核作为分析对象。\n\n\n# 1. 环形缓冲区（Ring Buffer）\n\n在内核中，管道 使用了环形缓冲区来存储数据。环形缓冲区的原理是：把一个缓冲区当成是首尾相连的环，其中通过读指针和写指针来记录读操作和写操作位置。如下图所示：\n\n\n\n在 Linux 内核中，使用了 16 个内存页作为环形缓冲区，所以这个环形缓冲区的大小为 64KB（16 * 4KB）。\n\n当向管道写数据时，从写指针指向的位置开始写入，并且将写指针向前移动。而从管道读取数据时，从读指针开始读入，并且将读指针向前移动。当对没有数据可读的管道进行读操作，将会阻塞当前进程。而对没有空闲空间的管道进行写操作，也会阻塞当前进程。\n\n> 注意：可以将管道文件描述符设置为非阻塞，这样对管道进行读写操作时，就不会阻塞当前进程。\n\n\n# 2. 管道对象\n\n在 Linux 内核中，管道使用 pipe_inode_info 对象来进行管理。我们先来看看 pipe_inode_info 对象的定义，如下所示：\n\nstruct pipe_inode_info {\n    wait_queue_head_t wait;\n    unsigned int nrbufs,\n    unsigned int curbuf;\n    ...\n    unsigned int readers;\n    unsigned int writers;\n    unsigned int waiting_writers;\n    ...\n    struct inode *inode;\n    struct pipe_buffer bufs[16];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n复制\n\n下面介绍一下 pipe_inode_info 对象各个字段的作用：\n\n * wait：等待队列，用于存储正在等待管道可读或者可写的进程。\n * bufs：环形缓冲区，由 16 个 pipe_buffer 对象组成，每个 pipe_buffer 对象拥有一个内存页 ，后面会介绍。\n * nrbufs：表示未读数据已经占用了环形缓冲区的多少个内存页。\n * curbuf：表示当前正在读取环形缓冲区的哪个内存页中的数据。\n * readers：表示正在读取管道的进程数。\n * writers：表示正在写入管道的进程数。\n * waiting_writers：表示等待管道可写的进程数。\n * inode：与管道关联的 inode 对象。\n\n由于环形缓冲区是由 16 个 pipe_buffer 对象组成，所以下面我们来看看 pipe_buffer 对象的定义：\n\nstruct pipe_buffer {\n    struct page *page;\n    unsigned int offset;\n    unsigned int len;\n    ...\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n复制\n\n下面介绍一下 pipe_buffer 对象各个字段的作用：\n\n * page：指向 pipe_buffer 对象占用的内存页。\n * offset：如果进程正在读取当前内存页的数据，那么 offset 指向正在读取当前内存页的偏移量。\n * len：表示当前内存页拥有未读数据的长度。\n\n下图展示了 pipe_inode_info 对象与 pipe_buffer 对象的关系：\n\n\n\n管道的环形缓冲区实现方式与经典的环形缓冲区实现方式有点区别，经典的环形缓冲区一般先申请一块地址连续的内存块，然后通过读指针与写指针来对读操作与写操作进行定位。\n\n但为了减少对内存的使用，内核不会在创建管道时就申请 64K 的内存块，而是在进程向管道写入数据时，按需来申请内存。\n\n那么当进程从管道读取数据时，内核怎么处理呢？下面我们来看看管道读操作的实现方式。\n\n\n# 3. 读操作\n\n从 经典的环形缓冲区 中读取数据时，首先通过读指针来定位到读取数据的起始地址，然后判断环形缓冲区中是否有数据可读，如果有就从环形缓冲区中读取数据到用户空间的缓冲区中。如下图所示：\n\n\n\n而 管道的环形缓冲区 与 经典的环形缓冲区 实现稍有不同，管道的环形缓冲区 其读指针是由 pipe_inode_info 对象的 curbuf 字段与 pipe_buffer 对象的 offset 字段组合而成：\n\n * pipe_inode_info 对象的 curbuf 字段表示读操作要从 bufs 数组的哪个 pipe_buffer 中读取数据。\n * pipe_buffer 对象的 offset 字段表示读操作要从内存页的哪个位置开始读取数据。\n\n读取数据的过程如下图所示：\n\n\n\n从缓冲区中读取到 n 个字节的数据后，会相应移动读指针 n 个字节的位置（也就是增加 pipe_buffer 对象的 offset 字段），并且减少 n 个字节的可读数据长度（也就是减少 pipe_buffer 对象的 len 字段）。\n\n当 pipe_buffer 对象的 len 字段变为 0 时，表示当前 pipe_buffer 没有可读数据，那么将会对 pipe_inode_info 对象的 curbuf 字段移动一个位置，并且其 nrbufs 字段进行减一操作。\n\n我们来看看管道读操作的代码实现，读操作由 pipe_read 函数完成。为了突出重点，我们只列出关键代码，如下所示：\n\nstatic ssize_t\npipe_read(struct kiocb *iocb, const struct iovec *_iov, unsigned long nr_segs,\n          loff_t pos)\n{\n    ...\n    struct pipe_inode_info *pipe;\n\n    // 1. 获取管道对象\n    pipe = inode->i_pipe;\n\n    for (;;) {\n        // 2. 获取管道未读数据占有多少个内存页\n        int bufs = pipe->nrbufs;\n\n        if (bufs) {\n            // 3. 获取读操作应该从环形缓冲区的哪个内存页处读取数据\n            int curbuf = pipe->curbuf;  \n            struct pipe_buffer *buf = pipe->bufs + curbuf;\n            ...\n\n            /* 4. 通过 pipe_buffer 的 offset 字段获取真正的读指针,\n             *    并且从管道中读取数据到用户缓冲区.\n             */\n            error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);\n            ...\n\n            ret += chars;\n            buf->offset += chars; // 增加 pipe_buffer 对象的 offset 字段的值\n            buf->len -= chars;    // 减少 pipe_buffer 对象的 len 字段的值\n\n            /* 5. 如果当前内存页的数据已经被读取完毕 */\n            if (!buf->len) {\n                ...\n                curbuf = (curbuf + 1) & (PIPE_BUFFERS - 1);\n                pipe->curbuf = curbuf; // 移动 pipe_inode_info 对象的 curbuf 指针\n                pipe->nrbufs = --bufs; // 减少 pipe_inode_info 对象的 nrbufs 字段\n                do_wakeup = 1;\n            }\n\n            total_len -= chars;\n\n            // 6. 如果读取到用户期望的数据长度, 退出循环\n            if (!total_len)\n                break;\n        }\n        ...\n    }\n\n    ...\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n复制\n\n上面代码总结来说分为以下步骤：\n\n * 通过文件 inode 对象来获取到管道的 pipe_inode_info 对象。\n * 通过 pipe_inode_info 对象的 nrbufs 字段获取管道未读数据占有多少个内存页。\n * 通过 pipe_inode_info 对象的 curbuf 字段获取读操作应该从环形缓冲区的哪个内存页处读取数据。\n * 通过 pipe_buffer 对象的 offset 字段获取真正的读指针， 并且从管道中读取数据到用户缓冲区。\n * 如果当前内存页的数据已经被读取完毕，那么移动 pipe_inode_info 对象的 curbuf 指针，并且减少其 nrbufs 字段的值。\n * 如果读取到用户期望的数据长度，退出循环。\n\n\n# 4. 写操作\n\n分析完管道读操作的实现后，接下来，我们分析一下管道写操作的实现。\n\n经典的环形缓冲区 写入数据时，首先通过写指针进行定位要写入的内存地址，然后判断环形缓冲区的空间是否足够，足够就把数据写入到环形缓冲区中。如下图所示：\n\n\n\n但 管道的环形缓冲区 并没有保存 写指针，而是通过 读指针 计算出来。那么怎么通过读指针计算出写指针呢？\n\n其实很简单，就是：\n\n> 写指针 = 读指针 + 未读数据长度\n\n下面我们来看看，向管道写入 200 字节数据的过程示意图，如下所示：\n\n如上图所示，向管道写入数据时：\n\n\n\n * 首先通过 pipe_inode_info 的 curbuf 字段和 nrbufs 字段来定位到，应该向哪个 pipe_buffer 写入数据。\n * 然后再通过 pipe_buffer 对象的 offset 字段和 len 字段来定位到，应该写入到内存页的哪个位置。\n\n下面我们通过源码来分析，写操作是怎么实现的，代码如下（为了特出重点，代码有所删减）：\n\nstatic ssize_t\npipe_write(struct kiocb *iocb, const struct iovec *_iov, unsigned long nr_segs,\n           loff_t ppos)\n{\n    ...\n    struct pipe_inode_info *pipe;\n    ...\n    pipe = inode->i_pipe;\n    ...\n    chars = total_len & (PAGE_SIZE - 1); /* size of the last buffer */\n\n    // 1. 如果最后写入的 pipe_buffer 还有空闲的空间\n    if (pipe->nrbufs && chars != 0) {\n        // 获取写入数据的位置\n        int lastbuf = (pipe->curbuf + pipe->nrbufs - 1) & (PIPE_BUFFERS-1);\n        struct pipe_buffer *buf = pipe->bufs + lastbuf;\n        const struct pipe_buf_operations *ops = buf->ops;\n        int offset = buf->offset + buf->len;\n\n        if (ops->can_merge && offset + chars <= PAGE_SIZE) {\n            ...\n            error = pipe_iov_copy_from_user(offset + addr, iov, chars, atomic);\n            ...\n            buf->len += chars;\n            total_len -= chars;\n            ret = chars;\n\n            // 如果要写入的数据已经全部写入成功, 退出循环\n            if (!total_len)\n                goto out;\n        }\n    }\n\n    // 2. 如果最后写入的 pipe_buffer 空闲空间不足, 那么申请一个新的内存页来存储数据\n    for (;;) {\n        int bufs;\n        ...\n        bufs = pipe->nrbufs;\n\n        if (bufs < PIPE_BUFFERS) {\n            int newbuf = (pipe->curbuf + bufs) & (PIPE_BUFFERS-1);\n            struct pipe_buffer *buf = pipe->bufs + newbuf;\n            ...\n\n            // 申请一个新的内存页\n            if (!page) {\n                page = alloc_page(GFP_HIGHUSER);\n                ...\n            }\n            ...\n            error = pipe_iov_copy_from_user(src, iov, chars, atomic);\n            ...\n            ret += chars;\n\n            buf->page = page;\n            buf->ops = &anon_pipe_buf_ops;\n            buf->offset = 0;\n            buf->len = chars;\n\n            pipe->nrbufs = ++bufs;\n            pipe->tmp_page = NULL;\n\n            // 如果要写入的数据已经全部写入成功, 退出循环\n            total_len -= chars;\n            if (!total_len)\n                break;\n        }\n        ...\n    }\n\nout:\n    ...\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n复制\n\n上面代码有点长，但是逻辑却很简单，主要进行如下操作：\n\n * 如果上次写操作写入的 pipe_buffer 还有空闲的空间，那么就将数据写入到此 pipe_buffer 中，并且增加其 len 字段的值。\n * 如果上次写操作写入的 pipe_buffer 没有足够的空闲空间，那么就新申请一个内存页，并且把数据保存到新的内存页中，并且增加 pipe_inode_info 的 nrbufs 字段的值。\n * 如果写入的数据已经全部写入成功，那么就退出写操作。\n\n\n# 三、思考一下\n\n管道读写操作的实现已经分析完毕，现在我们来思考一下以下问题。\n\n\n# 1. 为什么父子进程可以通过管道来通信？\n\n这是因为父子进程通过 pipe 系统调用打开的管道，在内核空间中指向同一个管道对象（pipe_inode_info）。所以父子进程共享着同一个管道对象，那么就可以通过这个共享的管道对象进行通信。\n\n\n# 2. 为什么内核要使用 16 个内存页进行数据存储？\n\n这是为了减少内存使用。\n\n因为使用 pipe 系统调用打开管道时，并没有立刻申请内存页，而是当有进程向管道写入数据时，才会按需申请内存页。当内存页的数据被读取完后，内核会将此内存页回收，来减少管道对内存的使用。\n\n\n# 四 参考\n\n图解 | Linux进程通信 - 管道实现',normalizedContent:'处于安全的考虑，不同进程之间的内存空间是相互隔离的，也就是说 进程a 是不能访问 进程b 的内存空间，反之亦然。如果不同进程间能够相互访问和修改对方的内存，那么当前进程的内存就有可能被其他进程非法修改，从而导致安全隐患。\n\n不同的进程就像是大海上孤立的岛屿，它们之间不能直接相互通信，如下图所示：\n\n\n\n但某些场景下，不同进程间需要相互通信，比如：进程a 负责处理用户的请求，而 进程b 负责保存处理后的数据。那么当 进程a 处理完请求后，就需要把处理后的数据提交给 进程b 进行存储。此时，进程a 就需要与 进程b 进行通信。如下图所示：\n\n\n\n由于不同进程间是相互隔离的，所以必须借助内核来作为桥梁来进行相互通信，内核相当于岛屿之间的轮船，如下图所示：\n\n\n\n内核提供多种进程间通信的方式，如：共享内存，信号，消息队列 和 管道（pipe） 等。本文主要介绍 管道 的原理与实现。\n\n\n# 一、管道的使用\n\n管道 一般用于父子进程之间相互通信，一般的用法如下：\n\n * 父进程使用 pipe 系统调用创建一个管道。\n * 然后父进程使用 fork 系统调用创建一个子进程。\n * 由于子进程会继承父进程打开的文件句柄，所以父子进程可以通过新创建的管道进行通信。\n\n其原理如下图所示：\n\n\n\n由于管道分为读端和写端，所以需要两个文件描述符来管理管道：fd[0] 为读端，fd[1] 为写端。\n\n下面代码介绍了怎么使用 pipe 系统调用来创建一个管道：\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    int ret = -1;\n    int fd[2];  // 用于管理管道的文件描述符\n    pid_t pid;\n    char buf[512] = {0};\n    char *msg = "hello world";\n\n    // 创建一个管理\n    ret = pipe(fd);\n    if (-1 == ret) {\n        printf("failed to create pipe\\n");\n        return -1;\n    }\n  \n    pid = fork();     // 创建子进程\n\n    if (0 == pid) {   // 子进程\n        close(fd[0]); // 关闭管道的读端\n        ret = write(fd[1], msg, strlen(msg)); // 向管道写端写入数据\n        exit(0);\n    } else {          // 父进程\n        close(fd[1]); // 关闭管道的写端\n        ret = read(fd[0], buf, sizeof(buf)); // 从管道的读端读取数据\n        printf("parent read %d bytes data: %s\\n", ret, buf);\n    }\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n复制\n\n编译代码：\n\n[root@localhost pipe]# gcc -g pipe.c -o pipe\n\n\n1\n\n\n复制\n\n运行代码，输出结果如下：\n\n[root@localhost pipe]# ./pipe\nparent read 11 bytes data: hello world\n\n\n1\n2\n\n\n复制\n\n\n# 二、管道的实现\n\n每个进程的用户空间都是独立的，但内核空间却是共用的。所以，进程间通信必须由内核提供服务。前面介绍了 管道(pipe) 的使用，接下来将会介绍管道在内核中的实现方式。\n\n> 本文使用 linux-2.6.23 内核作为分析对象。\n\n\n# 1. 环形缓冲区（ring buffer）\n\n在内核中，管道 使用了环形缓冲区来存储数据。环形缓冲区的原理是：把一个缓冲区当成是首尾相连的环，其中通过读指针和写指针来记录读操作和写操作位置。如下图所示：\n\n\n\n在 linux 内核中，使用了 16 个内存页作为环形缓冲区，所以这个环形缓冲区的大小为 64kb（16 * 4kb）。\n\n当向管道写数据时，从写指针指向的位置开始写入，并且将写指针向前移动。而从管道读取数据时，从读指针开始读入，并且将读指针向前移动。当对没有数据可读的管道进行读操作，将会阻塞当前进程。而对没有空闲空间的管道进行写操作，也会阻塞当前进程。\n\n> 注意：可以将管道文件描述符设置为非阻塞，这样对管道进行读写操作时，就不会阻塞当前进程。\n\n\n# 2. 管道对象\n\n在 linux 内核中，管道使用 pipe_inode_info 对象来进行管理。我们先来看看 pipe_inode_info 对象的定义，如下所示：\n\nstruct pipe_inode_info {\n    wait_queue_head_t wait;\n    unsigned int nrbufs,\n    unsigned int curbuf;\n    ...\n    unsigned int readers;\n    unsigned int writers;\n    unsigned int waiting_writers;\n    ...\n    struct inode *inode;\n    struct pipe_buffer bufs[16];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n复制\n\n下面介绍一下 pipe_inode_info 对象各个字段的作用：\n\n * wait：等待队列，用于存储正在等待管道可读或者可写的进程。\n * bufs：环形缓冲区，由 16 个 pipe_buffer 对象组成，每个 pipe_buffer 对象拥有一个内存页 ，后面会介绍。\n * nrbufs：表示未读数据已经占用了环形缓冲区的多少个内存页。\n * curbuf：表示当前正在读取环形缓冲区的哪个内存页中的数据。\n * readers：表示正在读取管道的进程数。\n * writers：表示正在写入管道的进程数。\n * waiting_writers：表示等待管道可写的进程数。\n * inode：与管道关联的 inode 对象。\n\n由于环形缓冲区是由 16 个 pipe_buffer 对象组成，所以下面我们来看看 pipe_buffer 对象的定义：\n\nstruct pipe_buffer {\n    struct page *page;\n    unsigned int offset;\n    unsigned int len;\n    ...\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n复制\n\n下面介绍一下 pipe_buffer 对象各个字段的作用：\n\n * page：指向 pipe_buffer 对象占用的内存页。\n * offset：如果进程正在读取当前内存页的数据，那么 offset 指向正在读取当前内存页的偏移量。\n * len：表示当前内存页拥有未读数据的长度。\n\n下图展示了 pipe_inode_info 对象与 pipe_buffer 对象的关系：\n\n\n\n管道的环形缓冲区实现方式与经典的环形缓冲区实现方式有点区别，经典的环形缓冲区一般先申请一块地址连续的内存块，然后通过读指针与写指针来对读操作与写操作进行定位。\n\n但为了减少对内存的使用，内核不会在创建管道时就申请 64k 的内存块，而是在进程向管道写入数据时，按需来申请内存。\n\n那么当进程从管道读取数据时，内核怎么处理呢？下面我们来看看管道读操作的实现方式。\n\n\n# 3. 读操作\n\n从 经典的环形缓冲区 中读取数据时，首先通过读指针来定位到读取数据的起始地址，然后判断环形缓冲区中是否有数据可读，如果有就从环形缓冲区中读取数据到用户空间的缓冲区中。如下图所示：\n\n\n\n而 管道的环形缓冲区 与 经典的环形缓冲区 实现稍有不同，管道的环形缓冲区 其读指针是由 pipe_inode_info 对象的 curbuf 字段与 pipe_buffer 对象的 offset 字段组合而成：\n\n * pipe_inode_info 对象的 curbuf 字段表示读操作要从 bufs 数组的哪个 pipe_buffer 中读取数据。\n * pipe_buffer 对象的 offset 字段表示读操作要从内存页的哪个位置开始读取数据。\n\n读取数据的过程如下图所示：\n\n\n\n从缓冲区中读取到 n 个字节的数据后，会相应移动读指针 n 个字节的位置（也就是增加 pipe_buffer 对象的 offset 字段），并且减少 n 个字节的可读数据长度（也就是减少 pipe_buffer 对象的 len 字段）。\n\n当 pipe_buffer 对象的 len 字段变为 0 时，表示当前 pipe_buffer 没有可读数据，那么将会对 pipe_inode_info 对象的 curbuf 字段移动一个位置，并且其 nrbufs 字段进行减一操作。\n\n我们来看看管道读操作的代码实现，读操作由 pipe_read 函数完成。为了突出重点，我们只列出关键代码，如下所示：\n\nstatic ssize_t\npipe_read(struct kiocb *iocb, const struct iovec *_iov, unsigned long nr_segs,\n          loff_t pos)\n{\n    ...\n    struct pipe_inode_info *pipe;\n\n    // 1. 获取管道对象\n    pipe = inode->i_pipe;\n\n    for (;;) {\n        // 2. 获取管道未读数据占有多少个内存页\n        int bufs = pipe->nrbufs;\n\n        if (bufs) {\n            // 3. 获取读操作应该从环形缓冲区的哪个内存页处读取数据\n            int curbuf = pipe->curbuf;  \n            struct pipe_buffer *buf = pipe->bufs + curbuf;\n            ...\n\n            /* 4. 通过 pipe_buffer 的 offset 字段获取真正的读指针,\n             *    并且从管道中读取数据到用户缓冲区.\n             */\n            error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);\n            ...\n\n            ret += chars;\n            buf->offset += chars; // 增加 pipe_buffer 对象的 offset 字段的值\n            buf->len -= chars;    // 减少 pipe_buffer 对象的 len 字段的值\n\n            /* 5. 如果当前内存页的数据已经被读取完毕 */\n            if (!buf->len) {\n                ...\n                curbuf = (curbuf + 1) & (pipe_buffers - 1);\n                pipe->curbuf = curbuf; // 移动 pipe_inode_info 对象的 curbuf 指针\n                pipe->nrbufs = --bufs; // 减少 pipe_inode_info 对象的 nrbufs 字段\n                do_wakeup = 1;\n            }\n\n            total_len -= chars;\n\n            // 6. 如果读取到用户期望的数据长度, 退出循环\n            if (!total_len)\n                break;\n        }\n        ...\n    }\n\n    ...\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n复制\n\n上面代码总结来说分为以下步骤：\n\n * 通过文件 inode 对象来获取到管道的 pipe_inode_info 对象。\n * 通过 pipe_inode_info 对象的 nrbufs 字段获取管道未读数据占有多少个内存页。\n * 通过 pipe_inode_info 对象的 curbuf 字段获取读操作应该从环形缓冲区的哪个内存页处读取数据。\n * 通过 pipe_buffer 对象的 offset 字段获取真正的读指针， 并且从管道中读取数据到用户缓冲区。\n * 如果当前内存页的数据已经被读取完毕，那么移动 pipe_inode_info 对象的 curbuf 指针，并且减少其 nrbufs 字段的值。\n * 如果读取到用户期望的数据长度，退出循环。\n\n\n# 4. 写操作\n\n分析完管道读操作的实现后，接下来，我们分析一下管道写操作的实现。\n\n经典的环形缓冲区 写入数据时，首先通过写指针进行定位要写入的内存地址，然后判断环形缓冲区的空间是否足够，足够就把数据写入到环形缓冲区中。如下图所示：\n\n\n\n但 管道的环形缓冲区 并没有保存 写指针，而是通过 读指针 计算出来。那么怎么通过读指针计算出写指针呢？\n\n其实很简单，就是：\n\n> 写指针 = 读指针 + 未读数据长度\n\n下面我们来看看，向管道写入 200 字节数据的过程示意图，如下所示：\n\n如上图所示，向管道写入数据时：\n\n\n\n * 首先通过 pipe_inode_info 的 curbuf 字段和 nrbufs 字段来定位到，应该向哪个 pipe_buffer 写入数据。\n * 然后再通过 pipe_buffer 对象的 offset 字段和 len 字段来定位到，应该写入到内存页的哪个位置。\n\n下面我们通过源码来分析，写操作是怎么实现的，代码如下（为了特出重点，代码有所删减）：\n\nstatic ssize_t\npipe_write(struct kiocb *iocb, const struct iovec *_iov, unsigned long nr_segs,\n           loff_t ppos)\n{\n    ...\n    struct pipe_inode_info *pipe;\n    ...\n    pipe = inode->i_pipe;\n    ...\n    chars = total_len & (page_size - 1); /* size of the last buffer */\n\n    // 1. 如果最后写入的 pipe_buffer 还有空闲的空间\n    if (pipe->nrbufs && chars != 0) {\n        // 获取写入数据的位置\n        int lastbuf = (pipe->curbuf + pipe->nrbufs - 1) & (pipe_buffers-1);\n        struct pipe_buffer *buf = pipe->bufs + lastbuf;\n        const struct pipe_buf_operations *ops = buf->ops;\n        int offset = buf->offset + buf->len;\n\n        if (ops->can_merge && offset + chars <= page_size) {\n            ...\n            error = pipe_iov_copy_from_user(offset + addr, iov, chars, atomic);\n            ...\n            buf->len += chars;\n            total_len -= chars;\n            ret = chars;\n\n            // 如果要写入的数据已经全部写入成功, 退出循环\n            if (!total_len)\n                goto out;\n        }\n    }\n\n    // 2. 如果最后写入的 pipe_buffer 空闲空间不足, 那么申请一个新的内存页来存储数据\n    for (;;) {\n        int bufs;\n        ...\n        bufs = pipe->nrbufs;\n\n        if (bufs < pipe_buffers) {\n            int newbuf = (pipe->curbuf + bufs) & (pipe_buffers-1);\n            struct pipe_buffer *buf = pipe->bufs + newbuf;\n            ...\n\n            // 申请一个新的内存页\n            if (!page) {\n                page = alloc_page(gfp_highuser);\n                ...\n            }\n            ...\n            error = pipe_iov_copy_from_user(src, iov, chars, atomic);\n            ...\n            ret += chars;\n\n            buf->page = page;\n            buf->ops = &anon_pipe_buf_ops;\n            buf->offset = 0;\n            buf->len = chars;\n\n            pipe->nrbufs = ++bufs;\n            pipe->tmp_page = null;\n\n            // 如果要写入的数据已经全部写入成功, 退出循环\n            total_len -= chars;\n            if (!total_len)\n                break;\n        }\n        ...\n    }\n\nout:\n    ...\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n复制\n\n上面代码有点长，但是逻辑却很简单，主要进行如下操作：\n\n * 如果上次写操作写入的 pipe_buffer 还有空闲的空间，那么就将数据写入到此 pipe_buffer 中，并且增加其 len 字段的值。\n * 如果上次写操作写入的 pipe_buffer 没有足够的空闲空间，那么就新申请一个内存页，并且把数据保存到新的内存页中，并且增加 pipe_inode_info 的 nrbufs 字段的值。\n * 如果写入的数据已经全部写入成功，那么就退出写操作。\n\n\n# 三、思考一下\n\n管道读写操作的实现已经分析完毕，现在我们来思考一下以下问题。\n\n\n# 1. 为什么父子进程可以通过管道来通信？\n\n这是因为父子进程通过 pipe 系统调用打开的管道，在内核空间中指向同一个管道对象（pipe_inode_info）。所以父子进程共享着同一个管道对象，那么就可以通过这个共享的管道对象进行通信。\n\n\n# 2. 为什么内核要使用 16 个内存页进行数据存储？\n\n这是为了减少内存使用。\n\n因为使用 pipe 系统调用打开管道时，并没有立刻申请内存页，而是当有进程向管道写入数据时，才会按需申请内存页。当内存页的数据被读取完后，内核会将此内存页回收，来减少管道对内存的使用。\n\n\n# 四 参考\n\n图解 | linux进程通信 - 管道实现',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？",frontmatter:{title:"Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？",date:"2022-09-21T23:02:10.000Z",permalink:"/pages/326cf9/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/100.Linux%20%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%20CPU%20%E8%8D%B7%E8%BD%BD%EF%BC%8C%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%AF%B9%E5%BA%94%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/100.Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？.md",key:"v-1f69ea23",path:"/pages/326cf9/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"如何调试服务器内存占用过高的问题？",frontmatter:{title:"如何调试服务器内存占用过高的问题？",date:"2022-09-21T23:02:22.000Z",permalink:"/pages/3653a2/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/110.%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/110.如何调试服务器内存占用过高的问题？.md",key:"v-f6bafd34",path:"/pages/3653a2/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"Linux 如何查看实时的滚动日志？",frontmatter:{title:"Linux 如何查看实时的滚动日志？",date:"2022-09-21T23:02:33.000Z",permalink:"/pages/f6e4d2/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/120.Linux%20%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%97%A5%E5%BF%97%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/120.Linux 如何查看实时的滚动日志？.md",key:"v-129dffb8",path:"/pages/f6e4d2/",headers:[{level:3,title:"滚动实时查看nginx日志",slug:"滚动实时查看nginx日志",normalizedTitle:"滚动实时查看nginx日志",charIndex:2}],headersStr:"滚动实时查看nginx日志",content:"# 滚动实时查看nginx日志\n\ntail -f access.log\n\n\n1\n",normalizedContent:"# 滚动实时查看nginx日志\n\ntail -f access.log\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"为什么进程切换慢，线程切换快？",frontmatter:{title:"为什么进程切换慢，线程切换快？",date:"2022-09-21T23:02:57.000Z",permalink:"/pages/773d64/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/140.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E6%85%A2%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%BF%AB%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/140.为什么进程切换慢，线程切换快？.md",key:"v-c875c5a4",path:"/pages/773d64/",headers:[{level:2,title:"进程切换与线程切换",slug:"进程切换与线程切换",normalizedTitle:"进程切换与线程切换",charIndex:25},{level:2,title:"为什么虚拟地址切换很慢",slug:"为什么虚拟地址切换很慢",normalizedTitle:"为什么虚拟地址切换很慢",charIndex:467},{level:2,title:"什么是虚拟内存",slug:"什么是虚拟内存",normalizedTitle:"什么是虚拟内存",charIndex:830},{level:2,title:"为什么需要虚拟内存",slug:"为什么需要虚拟内存",normalizedTitle:"为什么需要虚拟内存",charIndex:1118},{level:3,title:"为什么内存不够用？",slug:"为什么内存不够用",normalizedTitle:"为什么内存不够用？",charIndex:1485},{level:3,title:"交换（SWAP）技术",slug:"交换-swap-技术",normalizedTitle:"交换（swap）技术",charIndex:1825},{level:3,title:"虚拟内存",slug:"虚拟内存",normalizedTitle:"虚拟内存",charIndex:833},{level:2,title:"进程（线程）在操作系统中切换",slug:"进程-线程-在操作系统中切换",normalizedTitle:"进程（线程）在操作系统中切换",charIndex:3129},{level:2,title:"为什么创建进程开销比线程大？",slug:"为什么创建进程开销比线程大",normalizedTitle:"为什么创建进程开销比线程大？",charIndex:3744},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3938}],headersStr:"进程切换与线程切换 为什么虚拟地址切换很慢 什么是虚拟内存 为什么需要虚拟内存 为什么内存不够用？ 交换（SWAP）技术 虚拟内存 进程（线程）在操作系统中切换 为什么创建进程开销比线程大？ 参考",content:"一言以蔽之：虚拟地址空间的切换是很慢的。\n\n\n# 进程切换与线程切换\n\n进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。\n\n举一个不太恰当的例子，线程切换就好比你从主卧走到次卧，反正主卧和次卧都在同一个房子中(虚拟地址空间)，因此你无需换鞋子、换衣服等等。但是进程切换就不一样了，进程切换就好比从你家到别人家，这是两个不同的房子(不同的虚拟地址空间)，出发时要换好衣服、鞋子等等，到别人家后还要再换鞋子等等。\n\n因此我们可以形象的认为线程是处在同一个屋檐下的，这里的屋檐就是虚拟地址空间，因此线程间切换无需虚拟地址空间的切换；而进程则不同，两个不同进程位于不同的屋檐下，即进程位于不同的虚拟地址空间，因此进程切换涉及到虚拟地址空间的切换，这也是为什么进程切换要比线程切换慢的原因。\n\n有的同学可能还是不太明白，为什么虚拟地址空间切换会比较耗时呢？\n\n\n# 为什么虚拟地址切换很慢\n\n现在我们已经知道了进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB，Translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的。\n\n由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。\n\n\n# 什么是虚拟内存\n\n虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存，当然我们知道最终进程的数据及代码必然要放到物理内存上，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的地址空间映射，也就是虚拟内存地址与物理内存地址的映射关系。\n\n那么操作系统是如何记住这种映射关系的呢，答案就是页表，页表中记录了虚拟内存地址到物理内存地址的映射关系。有了页表就可以将虚拟地址转换为物理内存地址了，这种机制就是虚拟内存。\n\n每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。\n\n\n# 为什么需要虚拟内存\n\n对于程序员来说，我们在编程时实际上是不怎么操心内存问题的，对于使用Java、Python、JavaScript等动态类型语言的程序员来说更是如此，自动内存回收机制的引入使得使用这类语言的程序员几乎完全不用关心内存问题；即使对于编译型语言C/C++来说，程序员需要关心的也仅仅是内存的申请和释放。\n\n总的来说，作为程序员(无论使用什么类型的语言)我们根本就不关心数据以及程序被放在了物理内存的哪个位置上(设计实现操作系统的程序员除外)，我们可以简单的认为我们的程序独占内存，比如在32位系统下我们的进程占用的内存空间为4G；并且我们可以申请超过物理内存大小的空间，比如在只有256MB的系统上程序员可以申请1G大小的内存空间，这种假设极大的解放了程序员的生产力。\n\n而这种假设实现的背后功臣就是虚拟内存。\n\n\n# 为什么内存不够用？\n\n要理解一个技术，就必须理解它为何而存在。总体来说，虚拟化技术是为了解决内存不够用的问题，那么内存为何不够用呢？\n\n主要是因为程序越来越复杂。比如说我现在给你录音的机器上就有 200 个进程，目前内存的消耗是 21G，我的内存是 64G 的，但是多开一些程序还是会被占满。 另外，如果一个程序需要使用大的内存，比如 1T，是不是应该报错？如果报错，那么程序就会不好写，程序员必须小心翼翼地处理内存的使用，避免超过允许的内存使用阈值。以上提到的这些都是需要解决的问题，也是虚拟化技术存在的价值和意义。\n\n那么如何来解决这些问题呢？ 历史上有过不少的解决方案，但最终沉淀下的是虚拟化技术。接下来我为你介绍一种历史上存在过的 Swap 技术以及虚拟化技术。\n\n\n# 交换（SWAP）技术\n\nSwap 技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。注意，这里提到的数据，是完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等。轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（Swap）到磁盘上，把空间腾挪出来给需要的进程。\n\n\n\n上图中，内存被拆分成多个区域。 内核作为一个程序也需要自己的内存。另外每个进程独立得到一个空间——我们称为地址空间（Address Space）。你可以认为地址空间是一块连续分配的内存块。每个进程在不同地址空间中工作，构成了一个原始的虚拟化技术。\n\n比如：当进程 A 想访问地址 100 的时候，实际上访问的地址是基于地址空间本身位置（首字节地址）计算出来的。另外，当进程 A 执行时，CPU 中会保存它地址空间的开始位置和结束位置，当它想访问超过地址空间容量的地址时，CPU 会检查然后报错。\n\n上图描述的这种方法，是一种比较原始的虚拟化技术，进程使用的是基于地址空间的虚拟地址。但是这种方案有很多明显的缺陷，比如：\n\n 1. 碎片问题：上图中我们看到进程来回分配、回收交换，内存之间会产生很多缝隙。经过反反复复使用，内存的情况会变得十分复杂，导致整体性能下降。\n 2. 频繁切换问题：如果进程过多，内存较小，会频繁触发交换。\n\n你可以先思考这两个问题的解决方案，接下来我会带你进行一些更深入地思考——首先重新 Review 下我们的设计目标。\n\n 1. 隔离：每个应用有自己的地址空间，互不影响。\n 2. 性能：高频使用的数据保留在内存中、低频使用的数据持久化到磁盘上。\n 3. 程序好写（降低程序员心智负担）：让程序员不用关心底层设施。\n\n现阶段，Swap 技术已经初步解决了问题 1。关于问题 2，Swap 技术在性能上存在着碎片、频繁切换等明显劣势。关于问题 3，使用 Swap 技术，程序员需要清楚地知道自己的应用用多少内存，并且小心翼翼地使用内存，避免需要重新申请，或者研发不断扩容的算法——这让程序心智负担较大。\n\n经过以上分析，需要更好的解决方案，就是我们接下来要学习的虚拟化技术。\n\n\n# 虚拟内存\n\n虚拟化技术中，操作系统设计了虚拟内存（理论上可以无限大的空间），受限于 CPU 的处理能力，通常 64bit CPU，就是 264 个地址。\n\n虚拟化技术中，应用使用的是虚拟内存，操作系统管理虚拟内存和真实内存之间的映射。操作系统将虚拟内存分成整齐小块，每个小块称为一个页（Page）。之所以这样做，原因主要有以下两个方面。\n\n * 一方面应用使用内存是以页为单位，整齐的页能够避免内存碎片问题。\n * 另一方面，每个应用都有高频使用的数据和低频使用的数据。这样做，操作系统就不必从应用角度去思考哪个进程是高频的，仅需思考哪些页被高频使用、哪些页被低频使用。如果是低频使用，就将它们保存到硬盘上；如果是高频使用，就让它们保留在真实内存中。\n\n如果一个应用需要非常大的内存，应用申请的是虚拟内存中的很多个页，真实内存不一定需要够用。\n\n\n# 进程（线程）在操作系统中切换\n\n进程（线程）在操作系统中是不断切换的，现代操作系统中只有线程的切换。\n\n每次切换需要先保存当前寄存器的值的内存，注意 PC 指针也是一种寄存器。当恢复执行的时候，就需要从内存中读出所有的寄存器，恢复之前的状态，然后执行。\n\n\n\n上面讲到的内容，我们可以概括为以下 5 个步骤：\n\n 1. 当操作系统发现一个进程（线程）需要被切换的时候，直接控制 PC 指针跳转是非常危险的事情，所以操作系统需要发送一个“中断”信号给 CPU，停下正在执行的进程（线程）。\n 2. 当 CPU 收到中断信号后，正在执行的进程（线程）会立即停止。注意，因为进程（线程）马上被停止，它还来不及保存自己的状态，所以后续操作系统必须完成这件事情。\n 3. 操作系统接管中断后，趁寄存器数据还没有被破坏，必须马上执行一小段非常底层的程序（通常是汇编编写），帮助寄存器保存之前进程（线程）的状态。\n 4. 操作系统保存好进程状态后，执行调度程序，决定下一个要被执行的进程（线程）。\n 5. 最后，操作系统执行下一个进程（线程）。\n\n\n\n当然，一个进程（线程）被选择执行后，它会继续完成之前被中断时的任务，这需要操作系统来执行一小段底层的程序帮助进程（线程）恢复状态。\n\n\n\n一种可能的算法就是通过栈这种数据结构。进程（线程）中断后，操作系统负责压栈关键数据（比如寄存器）。恢复执行时，操作系统负责出栈和恢复寄存器的值。\n\n\n# 为什么创建进程开销比线程大？\n\nLinux 中创建一个进程自然会创建一个线程，也就是主线程。创建进程需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。\n\n创建线程则简单得多，只需要确定 PC 指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。\n\n因此，创建进程比创建线程慢，而且进程的内存开销更大。\n\n\n# 参考\n\n17 进程和线程：进程的开销比线程大在了哪里？\n\n进程切换与线程切换的区别？",normalizedContent:"一言以蔽之：虚拟地址空间的切换是很慢的。\n\n\n# 进程切换与线程切换\n\n进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。\n\n举一个不太恰当的例子，线程切换就好比你从主卧走到次卧，反正主卧和次卧都在同一个房子中(虚拟地址空间)，因此你无需换鞋子、换衣服等等。但是进程切换就不一样了，进程切换就好比从你家到别人家，这是两个不同的房子(不同的虚拟地址空间)，出发时要换好衣服、鞋子等等，到别人家后还要再换鞋子等等。\n\n因此我们可以形象的认为线程是处在同一个屋檐下的，这里的屋檐就是虚拟地址空间，因此线程间切换无需虚拟地址空间的切换；而进程则不同，两个不同进程位于不同的屋檐下，即进程位于不同的虚拟地址空间，因此进程切换涉及到虚拟地址空间的切换，这也是为什么进程切换要比线程切换慢的原因。\n\n有的同学可能还是不太明白，为什么虚拟地址空间切换会比较耗时呢？\n\n\n# 为什么虚拟地址切换很慢\n\n现在我们已经知道了进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是tlb，translation lookaside buffer，我们不需要关心这个名字只需要知道tlb本质上就是一个cache，是用来加速页表查找的。\n\n由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后tlb就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致tlb失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。\n\n\n# 什么是虚拟内存\n\n虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存，当然我们知道最终进程的数据及代码必然要放到物理内存上，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的地址空间映射，也就是虚拟内存地址与物理内存地址的映射关系。\n\n那么操作系统是如何记住这种映射关系的呢，答案就是页表，页表中记录了虚拟内存地址到物理内存地址的映射关系。有了页表就可以将虚拟地址转换为物理内存地址了，这种机制就是虚拟内存。\n\n每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。\n\n\n# 为什么需要虚拟内存\n\n对于程序员来说，我们在编程时实际上是不怎么操心内存问题的，对于使用java、python、javascript等动态类型语言的程序员来说更是如此，自动内存回收机制的引入使得使用这类语言的程序员几乎完全不用关心内存问题；即使对于编译型语言c/c++来说，程序员需要关心的也仅仅是内存的申请和释放。\n\n总的来说，作为程序员(无论使用什么类型的语言)我们根本就不关心数据以及程序被放在了物理内存的哪个位置上(设计实现操作系统的程序员除外)，我们可以简单的认为我们的程序独占内存，比如在32位系统下我们的进程占用的内存空间为4g；并且我们可以申请超过物理内存大小的空间，比如在只有256mb的系统上程序员可以申请1g大小的内存空间，这种假设极大的解放了程序员的生产力。\n\n而这种假设实现的背后功臣就是虚拟内存。\n\n\n# 为什么内存不够用？\n\n要理解一个技术，就必须理解它为何而存在。总体来说，虚拟化技术是为了解决内存不够用的问题，那么内存为何不够用呢？\n\n主要是因为程序越来越复杂。比如说我现在给你录音的机器上就有 200 个进程，目前内存的消耗是 21g，我的内存是 64g 的，但是多开一些程序还是会被占满。 另外，如果一个程序需要使用大的内存，比如 1t，是不是应该报错？如果报错，那么程序就会不好写，程序员必须小心翼翼地处理内存的使用，避免超过允许的内存使用阈值。以上提到的这些都是需要解决的问题，也是虚拟化技术存在的价值和意义。\n\n那么如何来解决这些问题呢？ 历史上有过不少的解决方案，但最终沉淀下的是虚拟化技术。接下来我为你介绍一种历史上存在过的 swap 技术以及虚拟化技术。\n\n\n# 交换（swap）技术\n\nswap 技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。注意，这里提到的数据，是完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等。轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（swap）到磁盘上，把空间腾挪出来给需要的进程。\n\n\n\n上图中，内存被拆分成多个区域。 内核作为一个程序也需要自己的内存。另外每个进程独立得到一个空间——我们称为地址空间（address space）。你可以认为地址空间是一块连续分配的内存块。每个进程在不同地址空间中工作，构成了一个原始的虚拟化技术。\n\n比如：当进程 a 想访问地址 100 的时候，实际上访问的地址是基于地址空间本身位置（首字节地址）计算出来的。另外，当进程 a 执行时，cpu 中会保存它地址空间的开始位置和结束位置，当它想访问超过地址空间容量的地址时，cpu 会检查然后报错。\n\n上图描述的这种方法，是一种比较原始的虚拟化技术，进程使用的是基于地址空间的虚拟地址。但是这种方案有很多明显的缺陷，比如：\n\n 1. 碎片问题：上图中我们看到进程来回分配、回收交换，内存之间会产生很多缝隙。经过反反复复使用，内存的情况会变得十分复杂，导致整体性能下降。\n 2. 频繁切换问题：如果进程过多，内存较小，会频繁触发交换。\n\n你可以先思考这两个问题的解决方案，接下来我会带你进行一些更深入地思考——首先重新 review 下我们的设计目标。\n\n 1. 隔离：每个应用有自己的地址空间，互不影响。\n 2. 性能：高频使用的数据保留在内存中、低频使用的数据持久化到磁盘上。\n 3. 程序好写（降低程序员心智负担）：让程序员不用关心底层设施。\n\n现阶段，swap 技术已经初步解决了问题 1。关于问题 2，swap 技术在性能上存在着碎片、频繁切换等明显劣势。关于问题 3，使用 swap 技术，程序员需要清楚地知道自己的应用用多少内存，并且小心翼翼地使用内存，避免需要重新申请，或者研发不断扩容的算法——这让程序心智负担较大。\n\n经过以上分析，需要更好的解决方案，就是我们接下来要学习的虚拟化技术。\n\n\n# 虚拟内存\n\n虚拟化技术中，操作系统设计了虚拟内存（理论上可以无限大的空间），受限于 cpu 的处理能力，通常 64bit cpu，就是 264 个地址。\n\n虚拟化技术中，应用使用的是虚拟内存，操作系统管理虚拟内存和真实内存之间的映射。操作系统将虚拟内存分成整齐小块，每个小块称为一个页（page）。之所以这样做，原因主要有以下两个方面。\n\n * 一方面应用使用内存是以页为单位，整齐的页能够避免内存碎片问题。\n * 另一方面，每个应用都有高频使用的数据和低频使用的数据。这样做，操作系统就不必从应用角度去思考哪个进程是高频的，仅需思考哪些页被高频使用、哪些页被低频使用。如果是低频使用，就将它们保存到硬盘上；如果是高频使用，就让它们保留在真实内存中。\n\n如果一个应用需要非常大的内存，应用申请的是虚拟内存中的很多个页，真实内存不一定需要够用。\n\n\n# 进程（线程）在操作系统中切换\n\n进程（线程）在操作系统中是不断切换的，现代操作系统中只有线程的切换。\n\n每次切换需要先保存当前寄存器的值的内存，注意 pc 指针也是一种寄存器。当恢复执行的时候，就需要从内存中读出所有的寄存器，恢复之前的状态，然后执行。\n\n\n\n上面讲到的内容，我们可以概括为以下 5 个步骤：\n\n 1. 当操作系统发现一个进程（线程）需要被切换的时候，直接控制 pc 指针跳转是非常危险的事情，所以操作系统需要发送一个“中断”信号给 cpu，停下正在执行的进程（线程）。\n 2. 当 cpu 收到中断信号后，正在执行的进程（线程）会立即停止。注意，因为进程（线程）马上被停止，它还来不及保存自己的状态，所以后续操作系统必须完成这件事情。\n 3. 操作系统接管中断后，趁寄存器数据还没有被破坏，必须马上执行一小段非常底层的程序（通常是汇编编写），帮助寄存器保存之前进程（线程）的状态。\n 4. 操作系统保存好进程状态后，执行调度程序，决定下一个要被执行的进程（线程）。\n 5. 最后，操作系统执行下一个进程（线程）。\n\n\n\n当然，一个进程（线程）被选择执行后，它会继续完成之前被中断时的任务，这需要操作系统来执行一小段底层的程序帮助进程（线程）恢复状态。\n\n\n\n一种可能的算法就是通过栈这种数据结构。进程（线程）中断后，操作系统负责压栈关键数据（比如寄存器）。恢复执行时，操作系统负责出栈和恢复寄存器的值。\n\n\n# 为什么创建进程开销比线程大？\n\nlinux 中创建一个进程自然会创建一个线程，也就是主线程。创建进程需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。\n\n创建线程则简单得多，只需要确定 pc 指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。\n\n因此，创建进程比创建线程慢，而且进程的内存开销更大。\n\n\n# 参考\n\n17 进程和线程：进程的开销比线程大在了哪里？\n\n进程切换与线程切换的区别？",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"简述 Linux 零拷贝的原理",frontmatter:{title:"简述 Linux 零拷贝的原理",date:"2022-09-21T23:02:44.000Z",permalink:"/pages/b43547/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/130.%E7%AE%80%E8%BF%B0%20Linux%20%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8E%9F%E7%90%86.html",relativePath:"02.计算机基础/20.操作系统/130.简述 Linux 零拷贝的原理.md",key:"v-7abb1115",path:"/pages/b43547/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"简述 Linux 虚拟内存的页面置换算法",frontmatter:{title:"简述 Linux 虚拟内存的页面置换算法",date:"2022-09-21T23:03:19.000Z",permalink:"/pages/93b870/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/160.%E7%AE%80%E8%BF%B0%20Linux%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.html",relativePath:"02.计算机基础/20.操作系统/160.简述 Linux 虚拟内存的页面置换算法.md",key:"v-1a49912a",path:"/pages/93b870/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"简述创建进程的流程",frontmatter:{title:"简述创建进程的流程",date:"2022-09-21T23:03:08.000Z",permalink:"/pages/c64d20/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/150.%E7%AE%80%E8%BF%B0%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%B5%81%E7%A8%8B.html",relativePath:"02.计算机基础/20.操作系统/150.简述创建进程的流程.md",key:"v-63719191",path:"/pages/c64d20/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/26, 09:00:38",lastUpdatedTimestamp:1664154038e3},{title:"简述 Linux 进程调度的算法",frontmatter:{title:"简述 Linux 进程调度的算法",date:"2022-09-21T23:03:30.000Z",permalink:"/pages/36fd29/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/170.%E7%AE%80%E8%BF%B0%20Linux%20%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95.html",relativePath:"02.计算机基础/20.操作系统/170.简述 Linux 进程调度的算法.md",key:"v-85af5b9e",path:"/pages/36fd29/",headers:[{level:3,title:"分时和调度",slug:"分时和调度",normalizedTitle:"分时和调度",charIndex:2},{level:4,title:"分配时间片段",slug:"分配时间片段",normalizedTitle:"分配时间片段",charIndex:179}],headersStr:"分时和调度 分配时间片段",content:"# 分时和调度\n\n因为通常机器中 CPU 核心数量少（从几个到几十个）、进程&线程数量很多（从几十到几百甚至更多），你可以类比为发动机少，而机器多，因此进程们在操作系统中只能排着队一个个执行。每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。再强调一下，现代操作系统都是直接调度线程，不会调度进程。\n\n# 分配时间片段\n\n如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始。这个就是分时技术。\n\n\n\n下面这张图更加直观一些，进程 P1 先执行一个时间片段，然后进程 P2 开始执行一个时间片段， 然后进程 P3，然后进程 P4……\n\n\n\n注意，上面的两张图是以进程为单位演示，如果换成线程，操作系统依旧是这么处理。",normalizedContent:"# 分时和调度\n\n因为通常机器中 cpu 核心数量少（从几个到几十个）、进程&线程数量很多（从几十到几百甚至更多），你可以类比为发动机少，而机器多，因此进程们在操作系统中只能排着队一个个执行。每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。再强调一下，现代操作系统都是直接调度线程，不会调度进程。\n\n# 分配时间片段\n\n如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始。这个就是分时技术。\n\n\n\n下面这张图更加直观一些，进程 p1 先执行一个时间片段，然后进程 p2 开始执行一个时间片段， 然后进程 p3，然后进程 p4……\n\n\n\n注意，上面的两张图是以进程为单位演示，如果换成线程，操作系统依旧是这么处理。",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"Linux 下如何查看端口被哪个进程占用？",frontmatter:{title:"Linux 下如何查看端口被哪个进程占用？",date:"2022-09-21T23:03:52.000Z",permalink:"/pages/4c2d8e/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/190.Linux%20%E4%B8%8B%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%93%AA%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/190.Linux 下如何查看端口被哪个进程占用？.md",key:"v-1ea2064a",path:"/pages/4c2d8e/",headers:[{level:2,title:"方法一",slug:"方法一",normalizedTitle:"方法一",charIndex:2},{level:2,title:"方法二",slug:"方法二",normalizedTitle:"方法二",charIndex:30}],headersStr:"方法一 方法二",content:"# 方法一\n\nlsof -i:端口号\n\n\n1\n\n\n\n\n\n# 方法二\n\nnetstat -tunpl |grep 端口号\n\n\n1\n\n\n",normalizedContent:"# 方法一\n\nlsof -i:端口号\n\n\n1\n\n\n\n\n\n# 方法二\n\nnetstat -tunpl |grep 端口号\n\n\n1\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"什么时候会由用户态陷入内核态？",frontmatter:{title:"什么时候会由用户态陷入内核态？",date:"2022-09-21T23:03:41.000Z",permalink:"/pages/b84950/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/180.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%B1%E7%94%A8%E6%88%B7%E6%80%81%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/180.什么时候会由用户态陷入内核态？.md",key:"v-8c3da672",path:"/pages/b84950/",headers:[{level:3,title:"什么是用户态和内核态",slug:"什么是用户态和内核态",normalizedTitle:"什么是用户态和内核态",charIndex:543},{level:4,title:"用户态和内核态",slug:"用户态和内核态",normalizedTitle:"用户态和内核态",charIndex:336},{level:4,title:"系统调用过程",slug:"系统调用过程",normalizedTitle:"系统调用过程",charIndex:837},{level:3,title:"线程模型",slug:"线程模型",normalizedTitle:"线程模型",charIndex:1139},{level:4,title:"进程和线程",slug:"进程和线程",normalizedTitle:"进程和线程",charIndex:1166},{level:4,title:"用户态线程",slug:"用户态线程",normalizedTitle:"用户态线程",charIndex:0},{level:4,title:"内核态线程",slug:"内核态线程",normalizedTitle:"内核态线程",charIndex:13},{level:3,title:"用户态线程和内核态线程之间的映射关系",slug:"用户态线程和内核态线程之间的映射关系",normalizedTitle:"用户态线程和内核态线程之间的映射关系",charIndex:2486},{level:4,title:"多对一（Many to One）",slug:"多对一-many-to-one",normalizedTitle:"多对一（many to one）",charIndex:2975},{level:4,title:"一对一（One to One）",slug:"一对一-one-to-one",normalizedTitle:"一对一（one to one）",charIndex:3159},{level:4,title:"多对多（Many To Many）",slug:"多对多-many-to-many",normalizedTitle:"多对多（many to many）",charIndex:3322},{level:4,title:"两层设计（Two Level）",slug:"两层设计-two-level",normalizedTitle:"两层设计（two level）",charIndex:3450},{level:3,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3684}],headersStr:"什么是用户态和内核态 用户态和内核态 系统调用过程 线程模型 进程和线程 用户态线程 内核态线程 用户态线程和内核态线程之间的映射关系 多对一（Many to One） 一对一（One to One） 多对多（Many To Many） 两层设计（Two Level） 参考",content:"用户态线程工作在用户空间，内核态线程工作在内核空间。用户态线程调度完全由进程负责，通常就是由进程的主线程负责。\n\n相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由内核维护，由操作系统调度。\n\n用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。\n\n这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。\n\n因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。\n\n实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。\n\n这是一个组合型的问题，由很多小问题组装而成，比如：\n\n * 用户态和内核态是什么？\n * 用户级线程和内核级线程是一个怎样的对应关系？\n * 内核响应系统调用是一个怎样的过程？\n * ……\n\n而且这个问题还关联到了我们后面要学习的多线程、I/O 模型、网络优化等。 所以这是一道很不错的面试题目，它不是简单考某个概念，而是通过让求职者比较两种东西，从而考察你对知识整体的认知和理解。\n\n今天就请你顺着这个问题，深入学习内核的工作机制，和我一起去理解用户态和内核态。\n\n\n# 什么是用户态和内核态\n\nKernel 运行在超级权限模式（Supervisor Mode）下，所以拥有很高的权限。按照权限管理的原则，多数应用程序应该运行在最小权限下。因此，很多操作系统，将内存分成了两个区域：\n\n * 内核空间（Kernal Space），这个空间只有内核程序可以访问；\n * 用户空间（User Space），这部分内存专门给应用程序使用。\n\n# 用户态和内核态\n\n用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态（User Mode） 执行。内核空间中的代码可以访问所有内存，我们称这些程序在内核态（Kernal Mode） 执行。\n\n# 系统调用过程\n\n如果用户态程序需要执行系统调用，就需要切换到内核态执行。下面我们来讲讲这个过程的原理。\n\n\n\n如上图所示：内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。当发生系统调用时，用户态的程序发起系统调用。因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。\n\n发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。关于中断，我们将在“15 课时”进行详细讨论。\n\n\n# 线程模型\n\n上面我们学习了用户态和内核态，接下来我们从进程和线程的角度进一步思考本课时开头抛出的问题。\n\n# 进程和线程\n\n一个应用程序启动后会在内存中创建一个执行副本，这就是进程。Linux 的内核是一个 Monolithic Kernel（宏内核），因此可以看作一个进程。也就是开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。\n\n进程可以分成用户态进程和内核态进程两类。用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。\n\n那么用户态进程如果要执行程序，是否也要向内核申请呢？\n\n程序在现代操作系统中并不是以进程为单位在执行，而是以一种轻量级进程（Light Weighted Process），也称作线程（Thread）的形式执行。\n\n一个进程可以拥有多个线程。进程创建的时候，一般会有一个主线程随着进程创建而创建。\n\n\n\n如果进程想要创造更多的线程，就需要思考一件事情，这个线程创建在用户态还是内核态。\n\n你可能会问，难道不是用户态的进程创建用户态的线程，内核态的进程创建内核态的线程吗？\n\n其实不是，进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程，接下来我们说说用户态的线程和内核态的线程。\n\n# 用户态线程\n\n用户态线程也称作用户级线程（User Level Thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。\n\n用户级线程有很多优势，比如。\n\n * 管理开销小：创建、销毁不需要系统调用。\n * 切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。\n\n但是这种线程也有很多的缺点。\n\n * 与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。\n * 线程间协作成本高：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。\n * 无法利用多核优势：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。\n * 操作系统无法针对线程调度进行优化：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。\n\n# 内核态线程\n\n内核态线程也称作内核级线程（Kernel Level Thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。\n\n内核级线程有很多优势。\n\n * 可以利用多核 CPU 优势：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。\n * 操作系统级优化：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。\n\n当然内核线程也有一些缺点。\n\n * 创建成本高：创建的时候需要系统调用，也就是切换到内核态。\n * 扩展性差：由一个内核程序管理，不可能数量太多。\n * 切换成本较高：切换的时候，也同样存在需要内核操作，需要切换内核态。\n\n\n# 用户态线程和内核态线程之间的映射关系\n\n线程简单理解，就是要执行一段程序。程序不会自发的执行，需要操作系统进行调度。我们思考这样一个问题，如果有一个用户态的进程，它下面有多个线程。如果这个进程想要执行下面的某一个线程，应该如何做呢？\n\n这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。毕竟，内核线程是真正的线程。因为它会分配到 CPU 的执行资源。\n\n如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。\n\n这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。\n\n由此可见，用户态线程创建成本低，问题明显，不可以利用多核。内核态线程，创建成本高，可以利用多核，切换速度慢。因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。这样，用户态线程和内核态线程之间就构成了下面 4 种可能的关系：\n\n# 多对一（Many to One）\n\n用户态进程中的多线程复用一个内核态线程。这样，极大地减少了创建内核态线程的成本，但是线程不可以并发。因此，这种模型现在基本上用的很少。我再多说一句，这里你可能会有疑问，比如：用户态线程怎么用内核态线程执行程序？\n\n程序是存储在内存中的指令，用户态线程是可以准备好程序让内核态线程执行的。后面的几种方式也是利用这样的方法。\n\n\n\n# 一对一（One to One）\n\n该模型为每个用户态的线程分配一个单独的内核态线程，在这种情况下，每个用户态都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。 这种模型允许所有线程并发执行，能够充分利用多核优势，Windows NT 内核采取的就是这种模型。但是因为线程较多，对内核调度的压力会明显增加。\n\n\n\n# 多对多（Many To Many）\n\n这种模式下会为 n 个用户态线程分配 m 个内核态线程。m 通常可以小于 n。一种可行的策略是将 m 设置为核数。这种多对多的关系，减少了内核线程，同时也保证了多核心并发。Linux 目前采用的就是该模型。\n\n\n\n# 两层设计（Two Level）\n\n这种模型混合了多对多和一对一的特点。多数用户态线程和内核线程是 n 对 m 的关系，少量用户线程可以指定成 1 对 1 的关系。\n\n\n\n上图所展现的是一个非常经典的设计。\n\n我们这节课讲解的问题、考虑到的情况以及解决方法，将为你今后解决实际工作场景中的问题打下坚实的基础。比如处理并发问题、I/O 性能瓶颈、思考数据库连接池的配置等，要想完美地解决问题，就必须掌握这些模型，了解问题的本质上才能更好地思考问题衍生出来的问题。\n\n\n# 参考\n\n用户态和内核态：用户态线程和内核态线程有什么区别？",normalizedContent:"用户态线程工作在用户空间，内核态线程工作在内核空间。用户态线程调度完全由进程负责，通常就是由进程的主线程负责。\n\n相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由内核维护，由操作系统调度。\n\n用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。\n\n这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。\n\n因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。\n\n实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。\n\n这是一个组合型的问题，由很多小问题组装而成，比如：\n\n * 用户态和内核态是什么？\n * 用户级线程和内核级线程是一个怎样的对应关系？\n * 内核响应系统调用是一个怎样的过程？\n * ……\n\n而且这个问题还关联到了我们后面要学习的多线程、i/o 模型、网络优化等。 所以这是一道很不错的面试题目，它不是简单考某个概念，而是通过让求职者比较两种东西，从而考察你对知识整体的认知和理解。\n\n今天就请你顺着这个问题，深入学习内核的工作机制，和我一起去理解用户态和内核态。\n\n\n# 什么是用户态和内核态\n\nkernel 运行在超级权限模式（supervisor mode）下，所以拥有很高的权限。按照权限管理的原则，多数应用程序应该运行在最小权限下。因此，很多操作系统，将内存分成了两个区域：\n\n * 内核空间（kernal space），这个空间只有内核程序可以访问；\n * 用户空间（user space），这部分内存专门给应用程序使用。\n\n# 用户态和内核态\n\n用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态（user mode） 执行。内核空间中的代码可以访问所有内存，我们称这些程序在内核态（kernal mode） 执行。\n\n# 系统调用过程\n\n如果用户态程序需要执行系统调用，就需要切换到内核态执行。下面我们来讲讲这个过程的原理。\n\n\n\n如上图所示：内核程序执行在内核态（kernal mode），用户程序执行在用户态（user mode）。当发生系统调用时，用户态的程序发起系统调用。因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 trap（trap 是一种中断）。\n\n发生中断后，当前 cpu 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。内核处理完成后，主动触发 trap，这样会再次发生中断，切换回用户态工作。关于中断，我们将在“15 课时”进行详细讨论。\n\n\n# 线程模型\n\n上面我们学习了用户态和内核态，接下来我们从进程和线程的角度进一步思考本课时开头抛出的问题。\n\n# 进程和线程\n\n一个应用程序启动后会在内存中创建一个执行副本，这就是进程。linux 的内核是一个 monolithic kernel（宏内核），因此可以看作一个进程。也就是开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。\n\n进程可以分成用户态进程和内核态进程两类。用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。\n\n那么用户态进程如果要执行程序，是否也要向内核申请呢？\n\n程序在现代操作系统中并不是以进程为单位在执行，而是以一种轻量级进程（light weighted process），也称作线程（thread）的形式执行。\n\n一个进程可以拥有多个线程。进程创建的时候，一般会有一个主线程随着进程创建而创建。\n\n\n\n如果进程想要创造更多的线程，就需要思考一件事情，这个线程创建在用户态还是内核态。\n\n你可能会问，难道不是用户态的进程创建用户态的线程，内核态的进程创建内核态的线程吗？\n\n其实不是，进程可以通过 api 创建用户态的线程，也可以通过系统调用创建内核态的线程，接下来我们说说用户态的线程和内核态的线程。\n\n# 用户态线程\n\n用户态线程也称作用户级线程（user level thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。\n\n用户级线程有很多优势，比如。\n\n * 管理开销小：创建、销毁不需要系统调用。\n * 切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。\n\n但是这种线程也有很多的缺点。\n\n * 与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 i/o 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。\n * 线程间协作成本高：设想两个线程需要通信，通信需要 i/o，i/o 需要系统调用，因此用户态线程需要支付额外的系统调用成本。\n * 无法利用多核优势：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。\n * 操作系统无法针对线程调度进行优化：当一个进程的一个用户态线程阻塞（block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。\n\n# 内核态线程\n\n内核态线程也称作内核级线程（kernel level thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。\n\n内核级线程有很多优势。\n\n * 可以利用多核 cpu 优势：内核拥有较高权限，因此可以在多个 cpu 核心上执行内核线程。\n * 操作系统级优化：内核中的线程操作 i/o 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。\n\n当然内核线程也有一些缺点。\n\n * 创建成本高：创建的时候需要系统调用，也就是切换到内核态。\n * 扩展性差：由一个内核程序管理，不可能数量太多。\n * 切换成本较高：切换的时候，也同样存在需要内核操作，需要切换内核态。\n\n\n# 用户态线程和内核态线程之间的映射关系\n\n线程简单理解，就是要执行一段程序。程序不会自发的执行，需要操作系统进行调度。我们思考这样一个问题，如果有一个用户态的进程，它下面有多个线程。如果这个进程想要执行下面的某一个线程，应该如何做呢？\n\n这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。毕竟，内核线程是真正的线程。因为它会分配到 cpu 的执行资源。\n\n如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。\n\n这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。\n\n由此可见，用户态线程创建成本低，问题明显，不可以利用多核。内核态线程，创建成本高，可以利用多核，切换速度慢。因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。这样，用户态线程和内核态线程之间就构成了下面 4 种可能的关系：\n\n# 多对一（many to one）\n\n用户态进程中的多线程复用一个内核态线程。这样，极大地减少了创建内核态线程的成本，但是线程不可以并发。因此，这种模型现在基本上用的很少。我再多说一句，这里你可能会有疑问，比如：用户态线程怎么用内核态线程执行程序？\n\n程序是存储在内存中的指令，用户态线程是可以准备好程序让内核态线程执行的。后面的几种方式也是利用这样的方法。\n\n\n\n# 一对一（one to one）\n\n该模型为每个用户态的线程分配一个单独的内核态线程，在这种情况下，每个用户态都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。 这种模型允许所有线程并发执行，能够充分利用多核优势，windows nt 内核采取的就是这种模型。但是因为线程较多，对内核调度的压力会明显增加。\n\n\n\n# 多对多（many to many）\n\n这种模式下会为 n 个用户态线程分配 m 个内核态线程。m 通常可以小于 n。一种可行的策略是将 m 设置为核数。这种多对多的关系，减少了内核线程，同时也保证了多核心并发。linux 目前采用的就是该模型。\n\n\n\n# 两层设计（two level）\n\n这种模型混合了多对多和一对一的特点。多数用户态线程和内核线程是 n 对 m 的关系，少量用户线程可以指定成 1 对 1 的关系。\n\n\n\n上图所展现的是一个非常经典的设计。\n\n我们这节课讲解的问题、考虑到的情况以及解决方法，将为你今后解决实际工作场景中的问题打下坚实的基础。比如处理并发问题、i/o 性能瓶颈、思考数据库连接池的配置等，要想完美地解决问题，就必须掌握这些模型，了解问题的本质上才能更好地思考问题衍生出来的问题。\n\n\n# 参考\n\n用户态和内核态：用户态线程和内核态线程有什么区别？",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"Linux 中虚拟内存和物理内存有什么区别？有什么优点？",frontmatter:{title:"Linux 中虚拟内存和物理内存有什么区别？有什么优点？",date:"2022-09-21T23:04:03.000Z",permalink:"/pages/3bab8c/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/200.Linux%20%E4%B8%AD%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F.html",relativePath:"02.计算机基础/20.操作系统/200.Linux 中虚拟内存和物理内存有什么区别？有什么优点？.md",key:"v-db80e4da",path:"/pages/3bab8c/",headers:[{level:3,title:"为什么内存不够用？",slug:"为什么内存不够用",normalizedTitle:"为什么内存不够用？",charIndex:2},{level:4,title:"交换（Swap）技术",slug:"交换-swap-技术",normalizedTitle:"交换（swap）技术",charIndex:341},{level:4,title:"虚拟内存",slug:"虚拟内存",normalizedTitle:"虚拟内存",charIndex:1268},{level:3,title:"页（Page）和页表",slug:"页-page-和页表",normalizedTitle:"页（page）和页表",charIndex:1644},{level:4,title:"MMU",slug:"mmu",normalizedTitle:"mmu",charIndex:2396},{level:4,title:"页表条目",slug:"页表条目",normalizedTitle:"页表条目",charIndex:2944},{level:3,title:"大页面问题",slug:"大页面问题",normalizedTitle:"大页面问题",charIndex:3717}],headersStr:"为什么内存不够用？ 交换（Swap）技术 虚拟内存 页（Page）和页表 MMU 页表条目 大页面问题",content:"# 为什么内存不够用？\n\n要理解一个技术，就必须理解它为何而存在。总体来说，虚拟化技术是为了解决内存不够用的问题，那么内存为何不够用呢？\n\n主要是因为程序越来越复杂。比如说我现在给你录音的机器上就有 200 个进程，目前内存的消耗是 21G，我的内存是 64G 的，但是多开一些程序还是会被占满。 另外，如果一个程序需要使用大的内存，比如 1T，是不是应该报错？如果报错，那么程序就会不好写，程序员必须小心翼翼地处理内存的使用，避免超过允许的内存使用阈值。以上提到的这些都是需要解决的问题，也是虚拟化技术存在的价值和意义。\n\n那么如何来解决这些问题呢？ 历史上有过不少的解决方案，但最终沉淀下的是虚拟化技术。接下来我为你介绍一种历史上存在过的 Swap 技术以及虚拟化技术。\n\n# 交换（Swap）技术\n\nSwap 技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。注意，这里提到的数据，是完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等。轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（Swap）到磁盘上，把空间腾挪出来给需要的进程。\n\n\n\n上图中，内存被拆分成多个区域。 内核作为一个程序也需要自己的内存。另外每个进程独立得到一个空间——我们称为地址空间（Address Space）。你可以认为地址空间是一块连续分配的内存块。每个进程在不同地址空间中工作，构成了一个原始的虚拟化技术。\n\n比如：当进程 A 想访问地址 100 的时候，实际上访问的地址是基于地址空间本身位置（首字节地址）计算出来的。另外，当进程 A 执行时，CPU 中会保存它地址空间的开始位置和结束位置，当它想访问超过地址空间容量的地址时，CPU 会检查然后报错。\n\n上图描述的这种方法，是一种比较原始的虚拟化技术，进程使用的是基于地址空间的虚拟地址。但是这种方案有很多明显的缺陷，比如：\n\n 1. 碎片问题：上图中我们看到进程来回分配、回收交换，内存之间会产生很多缝隙。经过反反复复使用，内存的情况会变得十分复杂，导致整体性能下降。\n 2. 频繁切换问题：如果进程过多，内存较小，会频繁触发交换。\n\n你可以先思考这两个问题的解决方案，接下来我会带你进行一些更深入地思考——首先重新 Review 下我们的设计目标。\n\n 1. 隔离：每个应用有自己的地址空间，互不影响。\n 2. 性能：高频使用的数据保留在内存中、低频使用的数据持久化到磁盘上。\n 3. 程序好写（降低程序员心智负担）：让程序员不用关心底层设施。\n\n现阶段，Swap 技术已经初步解决了问题 1。关于问题 2，Swap 技术在性能上存在着碎片、频繁切换等明显劣势。关于问题 3，使用 Swap 技术，程序员需要清楚地知道自己的应用用多少内存，并且小心翼翼地使用内存，避免需要重新申请，或者研发不断扩容的算法——这让程序心智负担较大。\n\n经过以上分析，需要更好的解决方案，就是我们接下来要学习的虚拟化技术。\n\n# 虚拟内存\n\n虚拟化技术中，操作系统设计了虚拟内存（理论上可以无限大的空间），受限于 CPU 的处理能力，通常 64bit CPU，就是 264 个地址。\n\n虚拟化技术中，应用使用的是虚拟内存，操作系统管理虚拟内存和真实内存之间的映射。操作系统将虚拟内存分成整齐小块，每个小块称为一个页（Page）。之所以这样做，原因主要有以下两个方面。\n\n * 一方面应用使用内存是以页为单位，整齐的页能够避免内存碎片问题。\n * 另一方面，每个应用都有高频使用的数据和低频使用的数据。这样做，操作系统就不必从应用角度去思考哪个进程是高频的，仅需思考哪些页被高频使用、哪些页被低频使用。如果是低频使用，就将它们保存到硬盘上；如果是高频使用，就让它们保留在真实内存中。\n\n如果一个应用需要非常大的内存，应用申请的是虚拟内存中的很多个页，真实内存不一定需要够用。\n\n\n# 页（Page）和页表\n\n接下来，我们详细讨论下这个设计。操作系统将虚拟内存分块，每个小块称为一个页（Page）；真实内存也需要分块，每个小块我们称为一个 Frame。Page 到 Frame 的映射，需要一种叫作页表的结构。\n\n上图展示了 Page、Frame 和页表 （PageTable）三者之间的关系。 Page 大小和 Frame 大小通常相等，页表中记录的某个 Page 对应的 Frame 编号。页表也需要存储空间，比如虚拟内存大小为 10G， Page 大小是 4K，那么需要 10G/4K = 2621440 个条目。如果每个条目是 64bit，那么一共需要 20480K = 20M 页表。操作系统在内存中划分出小块区域给页表，并负责维护页表。\n\n页表维护了虚拟地址到真实地址的映射。每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：\n\n 1. 通过虚拟地址计算 Page 编号；\n 2. 查页表，根据 Page 编号，找到 Frame 编号；\n 3. 将虚拟地址换算成物理地址。\n\n下面我通过一个例子给你讲解上面这个换算的过程：如果页大小是 4K，假设程序要访问地址：100,000。那么计算过程如下。\n\n 1. 页编号（Page Number） = 100,000/4096 = 24 余1619。 24 是页编号，1619 是地址偏移量（Offset）。\n 2. 查询页表，得到 24 关联的 Frame 编号（假设查到 Frame 编号 = 10）。\n 3. 换算：通常 Frame 和 Page 大小相等，替换 Page Number 为 Frame Number 物理地址 = 4096 * 10 + 1619 = 42579。\n\n# MMU\n\n上面的过程发生在 CPU 中一个小型的设备——内存管理单元（Memory Management Unit， MMU）中。如下图所示：\n\n\n\n当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后，MMU 连接了地址总线，帮助 CPU 操作真实地址。\n\n这样的设计，就不需要在编写应用程序的时候担心虚拟地址到物理地址映射的问题。我们把全部难题都丢给了操作系统——操作系统要确定MMU 可以读懂自己的页表格式。所以，操作系统的设计者要看 MMU 的说明书完成工作。\n\n难点在于不同 CPU 的 MMU 可能是不同的，因此这里会遇到很多跨平台的问题。解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧，Unix 最初期的移植性（跨平台）是 C 语言作者丹尼斯·里奇实现的。\n\n学到这里，细心的同学可能会有疑问：MMU 需要查询页表（这是内存操作），而 CPU 执行一条指令通过 MMU 获取内存数据，难道可以容忍在执行一条指令的过程中，发生多次内存读取（查询）操作？难道一次普通的读取操作，还要附加几次查询页表的开销吗？当然不是，这里还有一些高速缓存的设计，这部分我们放到“25 讲”中详细讨论。\n\n# 页表条目\n\n上面我们笼统介绍了页表将 Page 映射到 Frame。那么，页表中的每一项（页表条目）长什么样子呢？下图是一个页表格式的一个演示。\n\n页表条目本身的编号可以不存在页表中，而是通过偏移量计算。 比如地址 100,000 的编号，可以用 100,000 除以页大小确定。\n\n * Absent（“在”）位，是一个 bit。0 表示页的数据在磁盘中（不再内存中），1 表示在内存中。如果读取页表发现 Absent = 0，那么会触发缺页中断，去磁盘读取数据。\n * Protection（保护）字段可以实现成 3 个 bit，它决定页表用于读、写、执行。比如 000 代表什么都不能做，100 代表只读等。\n * Reference（访问）位，代表这个页被读写过，这个记录对回收内存有帮助。\n * Dirty（“脏”）位，代表页的内容被修改过，如果 Dirty =1，那么意味着页面必须回写到磁盘上才能置换（Swap)。如果 Dirty = 0，如果需要回收这个页，可以考虑直接丢弃它（什么也不做，其他程序可以直接覆盖）。\n * Caching（缓存位），描述页可不可以被 CPU 缓存。CPU 缓存会造成内存不一致问题，在上个模块的加餐中我们讨论了内存一致性问题，具体你可以参考“模块四”的加餐内容。\n * Frame Number（Frame 编号），这个是真实内存的位置。用 Frame 编号乘以页大小，就可以得到 Frame 的基地址。\n\n在 64bit 的系统中，考虑到 Absent、Protection 等字段需要占用一定的位，因此不能将 64bit 都用来描述真实地址。但是 64bit 可以寻址的空间已经远远超过了 EB 的级别（1EB = 220TB），这已经足够了。在真实世界，我们还造不出这么大的内存呢。\n\n\n# 大页面问题\n\n最后，我们讨论一下大页面的问题。假设有一个应用，初始化后需要 12M 内存，操作系统页大小是 4K。那么应该如何设计呢？\n\n为了简化模型，下图中，假设这个应用只有 3 个区域（3 个段）——正文段（程序）、数据段（常量、全局变量）、堆栈段。一开始我们 3 个段都分配了 4M 的空间。随着程序执行，堆栈段的空间会继续增加，上不封顶。\n\n上图中，进程内部需要一个页表存储进程的数据。如果进程的内存上不封顶，那么页表有多少个条目合适呢？ 进程分配多少空间合适呢？ 如果页表大小为 1024 个条目，那么可以支持 1024*4K = 4M 空间。按照这个计算，如果进程需要 1G 空间，则需要 256K 个条目。我们预先为进程分配这 256K 个条目吗？ 创建一个进程就划分这么多条目是不是成本太高了？\n\n为了减少条目的创建，可以考虑进程内部用一个更大的页表（比如 4M），操作系统继续用 4K 的页表。这就形成了一个二级页表的结构，如下图所示：\n\n\n\n这样 MMU 会先查询 1 级页表，再查询 2 级页表。在这个模型下，进程如果需要 1G 空间，也只需要 1024 个条目。比如 1 级页编号是 2， 那么对应 2 级页表中 [2* 1024, 3*1024-1] 的部分条目。而访问一个地址，需要同时给出一级页编号和二级页编号。整个地址，还可以用 64bit 组装，如下图所示：\n\n\n\nMMU 根据 1 级编号找到 1 级页表条目，1 级页表条目中记录了对应 2 级页表的位置。然后 MMU 再查询 2 级页表，找到 Frame。最后通过地址偏移量和 Frame 编号计算最终的物理地址。这种设计是一个递归的过程，因此还可增加 3 级、4 级……每增加 1 级，对空间的利用都会提高——当然也会带来一定的开销。这对于大应用非常划算，比如需要 1T 空间，那么使用 2 级页表，页表的空间就节省得多了。而且，这种多级页表，顶级页表在进程中可以先只创建需要用到的部分，就这个例子而言，一开始只需要 3 个条目，从 256K 个条目到 3 个，这就大大减少了进程创建的成本。",normalizedContent:"# 为什么内存不够用？\n\n要理解一个技术，就必须理解它为何而存在。总体来说，虚拟化技术是为了解决内存不够用的问题，那么内存为何不够用呢？\n\n主要是因为程序越来越复杂。比如说我现在给你录音的机器上就有 200 个进程，目前内存的消耗是 21g，我的内存是 64g 的，但是多开一些程序还是会被占满。 另外，如果一个程序需要使用大的内存，比如 1t，是不是应该报错？如果报错，那么程序就会不好写，程序员必须小心翼翼地处理内存的使用，避免超过允许的内存使用阈值。以上提到的这些都是需要解决的问题，也是虚拟化技术存在的价值和意义。\n\n那么如何来解决这些问题呢？ 历史上有过不少的解决方案，但最终沉淀下的是虚拟化技术。接下来我为你介绍一种历史上存在过的 swap 技术以及虚拟化技术。\n\n# 交换（swap）技术\n\nswap 技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。注意，这里提到的数据，是完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等。轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（swap）到磁盘上，把空间腾挪出来给需要的进程。\n\n\n\n上图中，内存被拆分成多个区域。 内核作为一个程序也需要自己的内存。另外每个进程独立得到一个空间——我们称为地址空间（address space）。你可以认为地址空间是一块连续分配的内存块。每个进程在不同地址空间中工作，构成了一个原始的虚拟化技术。\n\n比如：当进程 a 想访问地址 100 的时候，实际上访问的地址是基于地址空间本身位置（首字节地址）计算出来的。另外，当进程 a 执行时，cpu 中会保存它地址空间的开始位置和结束位置，当它想访问超过地址空间容量的地址时，cpu 会检查然后报错。\n\n上图描述的这种方法，是一种比较原始的虚拟化技术，进程使用的是基于地址空间的虚拟地址。但是这种方案有很多明显的缺陷，比如：\n\n 1. 碎片问题：上图中我们看到进程来回分配、回收交换，内存之间会产生很多缝隙。经过反反复复使用，内存的情况会变得十分复杂，导致整体性能下降。\n 2. 频繁切换问题：如果进程过多，内存较小，会频繁触发交换。\n\n你可以先思考这两个问题的解决方案，接下来我会带你进行一些更深入地思考——首先重新 review 下我们的设计目标。\n\n 1. 隔离：每个应用有自己的地址空间，互不影响。\n 2. 性能：高频使用的数据保留在内存中、低频使用的数据持久化到磁盘上。\n 3. 程序好写（降低程序员心智负担）：让程序员不用关心底层设施。\n\n现阶段，swap 技术已经初步解决了问题 1。关于问题 2，swap 技术在性能上存在着碎片、频繁切换等明显劣势。关于问题 3，使用 swap 技术，程序员需要清楚地知道自己的应用用多少内存，并且小心翼翼地使用内存，避免需要重新申请，或者研发不断扩容的算法——这让程序心智负担较大。\n\n经过以上分析，需要更好的解决方案，就是我们接下来要学习的虚拟化技术。\n\n# 虚拟内存\n\n虚拟化技术中，操作系统设计了虚拟内存（理论上可以无限大的空间），受限于 cpu 的处理能力，通常 64bit cpu，就是 264 个地址。\n\n虚拟化技术中，应用使用的是虚拟内存，操作系统管理虚拟内存和真实内存之间的映射。操作系统将虚拟内存分成整齐小块，每个小块称为一个页（page）。之所以这样做，原因主要有以下两个方面。\n\n * 一方面应用使用内存是以页为单位，整齐的页能够避免内存碎片问题。\n * 另一方面，每个应用都有高频使用的数据和低频使用的数据。这样做，操作系统就不必从应用角度去思考哪个进程是高频的，仅需思考哪些页被高频使用、哪些页被低频使用。如果是低频使用，就将它们保存到硬盘上；如果是高频使用，就让它们保留在真实内存中。\n\n如果一个应用需要非常大的内存，应用申请的是虚拟内存中的很多个页，真实内存不一定需要够用。\n\n\n# 页（page）和页表\n\n接下来，我们详细讨论下这个设计。操作系统将虚拟内存分块，每个小块称为一个页（page）；真实内存也需要分块，每个小块我们称为一个 frame。page 到 frame 的映射，需要一种叫作页表的结构。\n\n上图展示了 page、frame 和页表 （pagetable）三者之间的关系。 page 大小和 frame 大小通常相等，页表中记录的某个 page 对应的 frame 编号。页表也需要存储空间，比如虚拟内存大小为 10g， page 大小是 4k，那么需要 10g/4k = 2621440 个条目。如果每个条目是 64bit，那么一共需要 20480k = 20m 页表。操作系统在内存中划分出小块区域给页表，并负责维护页表。\n\n页表维护了虚拟地址到真实地址的映射。每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：\n\n 1. 通过虚拟地址计算 page 编号；\n 2. 查页表，根据 page 编号，找到 frame 编号；\n 3. 将虚拟地址换算成物理地址。\n\n下面我通过一个例子给你讲解上面这个换算的过程：如果页大小是 4k，假设程序要访问地址：100,000。那么计算过程如下。\n\n 1. 页编号（page number） = 100,000/4096 = 24 余1619。 24 是页编号，1619 是地址偏移量（offset）。\n 2. 查询页表，得到 24 关联的 frame 编号（假设查到 frame 编号 = 10）。\n 3. 换算：通常 frame 和 page 大小相等，替换 page number 为 frame number 物理地址 = 4096 * 10 + 1619 = 42579。\n\n# mmu\n\n上面的过程发生在 cpu 中一个小型的设备——内存管理单元（memory management unit， mmu）中。如下图所示：\n\n\n\n当 cpu 需要执行一条指令时，如果指令中涉及内存读写操作，cpu 会把虚拟地址给 mmu，mmu 自动完成虚拟地址到真实地址的计算；然后，mmu 连接了地址总线，帮助 cpu 操作真实地址。\n\n这样的设计，就不需要在编写应用程序的时候担心虚拟地址到物理地址映射的问题。我们把全部难题都丢给了操作系统——操作系统要确定mmu 可以读懂自己的页表格式。所以，操作系统的设计者要看 mmu 的说明书完成工作。\n\n难点在于不同 cpu 的 mmu 可能是不同的，因此这里会遇到很多跨平台的问题。解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧，unix 最初期的移植性（跨平台）是 c 语言作者丹尼斯·里奇实现的。\n\n学到这里，细心的同学可能会有疑问：mmu 需要查询页表（这是内存操作），而 cpu 执行一条指令通过 mmu 获取内存数据，难道可以容忍在执行一条指令的过程中，发生多次内存读取（查询）操作？难道一次普通的读取操作，还要附加几次查询页表的开销吗？当然不是，这里还有一些高速缓存的设计，这部分我们放到“25 讲”中详细讨论。\n\n# 页表条目\n\n上面我们笼统介绍了页表将 page 映射到 frame。那么，页表中的每一项（页表条目）长什么样子呢？下图是一个页表格式的一个演示。\n\n页表条目本身的编号可以不存在页表中，而是通过偏移量计算。 比如地址 100,000 的编号，可以用 100,000 除以页大小确定。\n\n * absent（“在”）位，是一个 bit。0 表示页的数据在磁盘中（不再内存中），1 表示在内存中。如果读取页表发现 absent = 0，那么会触发缺页中断，去磁盘读取数据。\n * protection（保护）字段可以实现成 3 个 bit，它决定页表用于读、写、执行。比如 000 代表什么都不能做，100 代表只读等。\n * reference（访问）位，代表这个页被读写过，这个记录对回收内存有帮助。\n * dirty（“脏”）位，代表页的内容被修改过，如果 dirty =1，那么意味着页面必须回写到磁盘上才能置换（swap)。如果 dirty = 0，如果需要回收这个页，可以考虑直接丢弃它（什么也不做，其他程序可以直接覆盖）。\n * caching（缓存位），描述页可不可以被 cpu 缓存。cpu 缓存会造成内存不一致问题，在上个模块的加餐中我们讨论了内存一致性问题，具体你可以参考“模块四”的加餐内容。\n * frame number（frame 编号），这个是真实内存的位置。用 frame 编号乘以页大小，就可以得到 frame 的基地址。\n\n在 64bit 的系统中，考虑到 absent、protection 等字段需要占用一定的位，因此不能将 64bit 都用来描述真实地址。但是 64bit 可以寻址的空间已经远远超过了 eb 的级别（1eb = 220tb），这已经足够了。在真实世界，我们还造不出这么大的内存呢。\n\n\n# 大页面问题\n\n最后，我们讨论一下大页面的问题。假设有一个应用，初始化后需要 12m 内存，操作系统页大小是 4k。那么应该如何设计呢？\n\n为了简化模型，下图中，假设这个应用只有 3 个区域（3 个段）——正文段（程序）、数据段（常量、全局变量）、堆栈段。一开始我们 3 个段都分配了 4m 的空间。随着程序执行，堆栈段的空间会继续增加，上不封顶。\n\n上图中，进程内部需要一个页表存储进程的数据。如果进程的内存上不封顶，那么页表有多少个条目合适呢？ 进程分配多少空间合适呢？ 如果页表大小为 1024 个条目，那么可以支持 1024*4k = 4m 空间。按照这个计算，如果进程需要 1g 空间，则需要 256k 个条目。我们预先为进程分配这 256k 个条目吗？ 创建一个进程就划分这么多条目是不是成本太高了？\n\n为了减少条目的创建，可以考虑进程内部用一个更大的页表（比如 4m），操作系统继续用 4k 的页表。这就形成了一个二级页表的结构，如下图所示：\n\n\n\n这样 mmu 会先查询 1 级页表，再查询 2 级页表。在这个模型下，进程如果需要 1g 空间，也只需要 1024 个条目。比如 1 级页编号是 2， 那么对应 2 级页表中 [2* 1024, 3*1024-1] 的部分条目。而访问一个地址，需要同时给出一级页编号和二级页编号。整个地址，还可以用 64bit 组装，如下图所示：\n\n\n\nmmu 根据 1 级编号找到 1 级页表条目，1 级页表条目中记录了对应 2 级页表的位置。然后 mmu 再查询 2 级页表，找到 frame。最后通过地址偏移量和 frame 编号计算最终的物理地址。这种设计是一个递归的过程，因此还可增加 3 级、4 级……每增加 1 级，对空间的利用都会提高——当然也会带来一定的开销。这对于大应用非常划算，比如需要 1t 空间，那么使用 2 级页表，页表的空间就节省得多了。而且，这种多级页表，顶级页表在进程中可以先只创建需要用到的部分，就这个例子而言，一开始只需要 3 个条目，从 256k 个条目到 3 个，这就大大减少了进程创建的成本。",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"简述 traceroute 命令的原理",frontmatter:{title:"简述 traceroute 命令的原理",date:"2022-09-21T23:04:14.000Z",permalink:"/pages/655f8f/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/210.%E7%AE%80%E8%BF%B0%20traceroute%20%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86.html",relativePath:"02.计算机基础/20.操作系统/210.简述 traceroute 命令的原理.md",key:"v-e048e838",path:"/pages/655f8f/",headers:[{level:2,title:"traceroute命令",slug:"traceroute命令",normalizedTitle:"traceroute命令",charIndex:100},{level:2,title:"traceroute原理",slug:"traceroute原理",normalizedTitle:"traceroute原理",charIndex:1920},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3447}],headersStr:"traceroute命令 traceroute原理 参考",content:"一个 IP 包需要经过一系列路由的转发，才能到达目的地。下图是一个典型的例子，一个从主机 ant 出发，去往主机 apple 的 IP 包，需要经过中间路由 R1 、R2 以及 R3 ：\n\n\n\n\n# traceroute命令\n\n分析网络问题、排查网络故障时，我们经常需要知道：去往某个 IP 的数据包需要经过哪些路由？那么，有办法将通往某个 IP 的路由路径找出来吗？\n\n其实是有的，traceroute 命令就可以做到。traceroute 命令是一个很常用的网络工具，你可能已经听过，甚至已经用过了。它可以用来探测、跟踪去往某个目的地 IP 包需要经过的路由路径。\n\n那么，traceroute 命令该如何使用呢？我们以上图中的拓扑为实验环境，简单演示下它的用法。实验环境同样由 Docker 容器提供，只需执行下面这个 docker 命令即可一键打开：\n\n1   DOCKER RUN --NAME TRACEROUTE-LAB --RM -IT --PRIVILEGED\n    --CAP-ADD=NET_ADMIN --CAP-ADD=SYS_ADMIN -V /DATA\n    FASIONCHAN/NETBOX:0.5 BASH /SCRIPT/ROUTINE.SH\n    \n\n实验环境打开后，自动进入主机 ant 。我们先 ping 一下主机 apple ，确认网络是通的：\n\n1 2 3 4 5 6 7 8 9 10   ROOT@ANT [ ~ ] ➜ PING -N 10.0.2.2 PING 10.0.2.2 (10.0.2.2)\n                       56(84) BYTES OF DATA. 64 BYTES FROM 10.0.2.2: ICMP_SEQ=1\n                       TTL=61 TIME=0.082 MS 64 BYTES FROM 10.0.2.2: ICMP_SEQ=2\n                       TTL=61 TIME=0.207 MS 64 BYTES FROM 10.0.2.2: ICMP_SEQ=3\n                       TTL=61 TIME=0.219 MS 64 BYTES FROM 10.0.2.2: ICMP_SEQ=4\n                       TTL=61 TIME=0.218 MS ^C --- 10.0.2.2 PING STATISTICS --- 4\n                       PACKETS TRANSMITTED, 4 RECEIVED, 0% PACKET LOSS, TIME 3111MS\n                       RTT MIN/AVG/MAX/MDEV = 0.082/0.181/0.219/0.057 MS\n                       \n\n接下来，执行 traceroute 命令探测从到主机 apple 的网络路径：\n\n1 2 3 4 5 6   ROOT@ANT [ ~ ] ➜ TRACEROUTE -N 10.0.2.2 TRACEROUTE TO\n              10.0.2.2 (10.0.2.2), 30 HOPS MAX, 60 BYTE PACKETS 1 10.0.1.1\n              0.771 MS 0.717 MS 0.603 MS 2 10.2.0.1 0.573 MS 0.538 MS\n              0.516 MS 3 10.4.0.1 0.487 MS 0.456 MS 0.437 MS 4 10.0.2.2\n              0.406 MS 0.340 MS 0.303 MS\n              \n\n> -n 选项表示，输出结果不用将 IP 地址反解析成主机名（域名）。由于域名解析可能有很大延迟，因此加上 -n 选项可以减少卡顿。很多网络工具都支持 -n 选项，ping 命令也是。\n\n从 traceroute 命令的输出，我们可以获悉去往 10.0.2.2 时，需要经过 4 跳：\n\n * 第 1 跳是 10.0.1.1 ，即路由器 R1 ；\n * 第 2 跳是 10.2.0.1 ，即路由器 R2 ；\n * 第 3 跳是 10.4.0.1 ，即路由器 R3 ；\n * 最后一跳是目的地 10.0.2.2 ，即主机 apple 本身；\n\n\n# traceroute原理\n\n你可能会很好奇，traceroute 是如何探测路由路径的呢？它是使用了什么黑科技吗？其实并没有什么黑科技，它的原理很简单：利用 IP 包 TTL 特性来完成路径探测。\n\nIP 包每经过一跳路由， TTL 减一；当 TTL 减到零，路由器便将它丢弃。这样可避免 IP 包因陷入路由环路而在网络中永远存在。\n\n路由器在将超时包丢弃的同时，负责向源 IP 发送一个 ICMP 报文，报告 传输超时 （ time to live exceeded in transit ）错误，ICMP 类型为 11 。\n\n\n\n> 原包进入路由时 TTL 等于 1 ，路由转发前将 TTL 减 1 ， TTL 便降为 0 了。因此对路由而言，入站包 TTL 为 1 即视为超时。\n\n注意到，路由还将原 IP 包的头部以及数据的前 8 个字节作为数据附在 ICMP 报文中。发送者只需检查这部分数据，即可获悉超时包的上下文信息。\n\n这样一来，ant 发一个 TTL=1 的 IP 包给 apple ，然后等待第一跳路由的超时差错，不就探测到第一跳路由了吗？\n\n\n\n以此类推，ant 发 TTL=2 的 IP 包可以探测到第二跳路由，最终探测到 apple 本身。\n\n\n\n问题来了，当 traceroute 收到路由发来的 ICMP 超时差错后，如何判读该路由是第几跳呢？问题答案就藏在 ICMP 差错报文中附带的原包头部中。\n\ntraceroute 发出的探测包，可以是一个 ICMP 回显请求，也可以是一个 UDP 请求。它默认使用兼容性更好的 UDP ，因为不少系统和网络都封杀了 ICMP 回显相关报文。\n\nUDP 我们在后续章节才学习，因此这里先以 ICMP 为例进行讲解，但思路都是相通的。与 ping 命令类似，traceroute 通过 ICMP 报文中的 序号 字段来匹配探测包。\n\n实际上，traceroute 默认会连续发 3 个 TTL=1 的探测包（ ICMP 回显请求），再连续发 3 个 TTL=2 的探测包，以此类推。发包的同时，它在内存中建立一张从序号到 TTL 的映射表：\n\n序号   TTL\n1    1\n2    1\n3    1\n4    2\n5    2\n6    2\n…    …\n\n探测包 TTL 耗尽后，路由将它丢弃，并向发送者报告 ICMP 超时差错。traceroute 收到超时差错后，取出原探测包的头部信息。然后根据序号查出该包发出去时的 TTL ，也就知道该差错是第几跳路由发出的。\n\n下图是一个简单的例子：\n\n\n\n 1. traceroute 发出第五个探测包，序号为 5 ， TTL 为 2 ，并将对应关系保存在映射表；\n 2. 该探测包是一个 ICMP 回显请求，类型为 8 ，目的地址 10.0.2.2 为探测目标 apple ；\n 3. 该包走到第二跳路由 R2 时，TTL 就耗尽了，路由 R2 向原包发送方报告超时差错；\n 4. 路由将原探测包的 IP 头部和数据前 8 字节（ ICMP 头部）作为数据附在 ICMP 差错报文中；\n 5. 差错包到达主机 ant 后，traceroute 取出差错包中附带的原探测包的头部；\n 6. 检查原探测包 ICMP 头部中的标识符字段，traceroute 确认原探测包是自己发的（区分其他进程）；\n 7. 根据原探测包 ICMP 头部中的序号字段，traceroute 从映射表中查到原探测包的 TTL 为 2；\n 8. traceroute 确定该差错包是第 2 跳路由发来的，源地址 10.2.0.1 就是路由的地址；\n\n\n# 参考\n\ntraceroute命令原理",normalizedContent:"一个 ip 包需要经过一系列路由的转发，才能到达目的地。下图是一个典型的例子，一个从主机 ant 出发，去往主机 apple 的 ip 包，需要经过中间路由 r1 、r2 以及 r3 ：\n\n\n\n\n# traceroute命令\n\n分析网络问题、排查网络故障时，我们经常需要知道：去往某个 ip 的数据包需要经过哪些路由？那么，有办法将通往某个 ip 的路由路径找出来吗？\n\n其实是有的，traceroute 命令就可以做到。traceroute 命令是一个很常用的网络工具，你可能已经听过，甚至已经用过了。它可以用来探测、跟踪去往某个目的地 ip 包需要经过的路由路径。\n\n那么，traceroute 命令该如何使用呢？我们以上图中的拓扑为实验环境，简单演示下它的用法。实验环境同样由 docker 容器提供，只需执行下面这个 docker 命令即可一键打开：\n\n1   docker run --name traceroute-lab --rm -it --privileged\n    --cap-add=net_admin --cap-add=sys_admin -v /data\n    fasionchan/netbox:0.5 bash /script/routine.sh\n    \n\n实验环境打开后，自动进入主机 ant 。我们先 ping 一下主机 apple ，确认网络是通的：\n\n1 2 3 4 5 6 7 8 9 10   root@ant [ ~ ] ➜ ping -n 10.0.2.2 ping 10.0.2.2 (10.0.2.2)\n                       56(84) bytes of data. 64 bytes from 10.0.2.2: icmp_seq=1\n                       ttl=61 time=0.082 ms 64 bytes from 10.0.2.2: icmp_seq=2\n                       ttl=61 time=0.207 ms 64 bytes from 10.0.2.2: icmp_seq=3\n                       ttl=61 time=0.219 ms 64 bytes from 10.0.2.2: icmp_seq=4\n                       ttl=61 time=0.218 ms ^c --- 10.0.2.2 ping statistics --- 4\n                       packets transmitted, 4 received, 0% packet loss, time 3111ms\n                       rtt min/avg/max/mdev = 0.082/0.181/0.219/0.057 ms\n                       \n\n接下来，执行 traceroute 命令探测从到主机 apple 的网络路径：\n\n1 2 3 4 5 6   root@ant [ ~ ] ➜ traceroute -n 10.0.2.2 traceroute to\n              10.0.2.2 (10.0.2.2), 30 hops max, 60 byte packets 1 10.0.1.1\n              0.771 ms 0.717 ms 0.603 ms 2 10.2.0.1 0.573 ms 0.538 ms\n              0.516 ms 3 10.4.0.1 0.487 ms 0.456 ms 0.437 ms 4 10.0.2.2\n              0.406 ms 0.340 ms 0.303 ms\n              \n\n> -n 选项表示，输出结果不用将 ip 地址反解析成主机名（域名）。由于域名解析可能有很大延迟，因此加上 -n 选项可以减少卡顿。很多网络工具都支持 -n 选项，ping 命令也是。\n\n从 traceroute 命令的输出，我们可以获悉去往 10.0.2.2 时，需要经过 4 跳：\n\n * 第 1 跳是 10.0.1.1 ，即路由器 r1 ；\n * 第 2 跳是 10.2.0.1 ，即路由器 r2 ；\n * 第 3 跳是 10.4.0.1 ，即路由器 r3 ；\n * 最后一跳是目的地 10.0.2.2 ，即主机 apple 本身；\n\n\n# traceroute原理\n\n你可能会很好奇，traceroute 是如何探测路由路径的呢？它是使用了什么黑科技吗？其实并没有什么黑科技，它的原理很简单：利用 ip 包 ttl 特性来完成路径探测。\n\nip 包每经过一跳路由， ttl 减一；当 ttl 减到零，路由器便将它丢弃。这样可避免 ip 包因陷入路由环路而在网络中永远存在。\n\n路由器在将超时包丢弃的同时，负责向源 ip 发送一个 icmp 报文，报告 传输超时 （ time to live exceeded in transit ）错误，icmp 类型为 11 。\n\n\n\n> 原包进入路由时 ttl 等于 1 ，路由转发前将 ttl 减 1 ， ttl 便降为 0 了。因此对路由而言，入站包 ttl 为 1 即视为超时。\n\n注意到，路由还将原 ip 包的头部以及数据的前 8 个字节作为数据附在 icmp 报文中。发送者只需检查这部分数据，即可获悉超时包的上下文信息。\n\n这样一来，ant 发一个 ttl=1 的 ip 包给 apple ，然后等待第一跳路由的超时差错，不就探测到第一跳路由了吗？\n\n\n\n以此类推，ant 发 ttl=2 的 ip 包可以探测到第二跳路由，最终探测到 apple 本身。\n\n\n\n问题来了，当 traceroute 收到路由发来的 icmp 超时差错后，如何判读该路由是第几跳呢？问题答案就藏在 icmp 差错报文中附带的原包头部中。\n\ntraceroute 发出的探测包，可以是一个 icmp 回显请求，也可以是一个 udp 请求。它默认使用兼容性更好的 udp ，因为不少系统和网络都封杀了 icmp 回显相关报文。\n\nudp 我们在后续章节才学习，因此这里先以 icmp 为例进行讲解，但思路都是相通的。与 ping 命令类似，traceroute 通过 icmp 报文中的 序号 字段来匹配探测包。\n\n实际上，traceroute 默认会连续发 3 个 ttl=1 的探测包（ icmp 回显请求），再连续发 3 个 ttl=2 的探测包，以此类推。发包的同时，它在内存中建立一张从序号到 ttl 的映射表：\n\n序号   ttl\n1    1\n2    1\n3    1\n4    2\n5    2\n6    2\n…    …\n\n探测包 ttl 耗尽后，路由将它丢弃，并向发送者报告 icmp 超时差错。traceroute 收到超时差错后，取出原探测包的头部信息。然后根据序号查出该包发出去时的 ttl ，也就知道该差错是第几跳路由发出的。\n\n下图是一个简单的例子：\n\n\n\n 1. traceroute 发出第五个探测包，序号为 5 ， ttl 为 2 ，并将对应关系保存在映射表；\n 2. 该探测包是一个 icmp 回显请求，类型为 8 ，目的地址 10.0.2.2 为探测目标 apple ；\n 3. 该包走到第二跳路由 r2 时，ttl 就耗尽了，路由 r2 向原包发送方报告超时差错；\n 4. 路由将原探测包的 ip 头部和数据前 8 字节（ icmp 头部）作为数据附在 icmp 差错报文中；\n 5. 差错包到达主机 ant 后，traceroute 取出差错包中附带的原探测包的头部；\n 6. 检查原探测包 icmp 头部中的标识符字段，traceroute 确认原探测包是自己发的（区分其他进程）；\n 7. 根据原探测包 icmp 头部中的序号字段，traceroute 从映射表中查到原探测包的 ttl 为 2；\n 8. traceroute 确定该差错包是第 2 跳路由发来的，源地址 10.2.0.1 就是路由的地址；\n\n\n# 参考\n\ntraceroute命令原理",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"简述IO模型",frontmatter:{title:"简述IO模型",date:"2022-10-09T11:07:13.000Z",permalink:"/pages/782c23/",categories:["计算机基础","操作系统"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220.%E7%AE%80%E8%BF%B0IO%E6%A8%A1%E5%9E%8B.html",relativePath:"02.计算机基础/20.操作系统/220.简述IO模型.md",key:"v-d41ba7ec",path:"/pages/782c23/",headers:[{level:3,title:"## 阻塞式 I/O",slug:"阻塞式-i-o",normalizedTitle:"## 阻塞式 i/o",charIndex:232},{level:3,title:"## 非阻塞式 I/O",slug:"非阻塞式-i-o",normalizedTitle:"## 非阻塞式 i/o",charIndex:569},{level:3,title:"## I/O 复用",slug:"i-o-复用",normalizedTitle:"## i/o 复用",charIndex:706},{level:3,title:"## 信号驱动 I/O",slug:"信号驱动-i-o",normalizedTitle:"## 信号驱动 i/o",charIndex:998},{level:2,title:"异步I/O",slug:"异步i-o",normalizedTitle:"异步i/o",charIndex:1187},{level:3,title:"## 五大 I/O 模型比较",slug:"五大-i-o-模型比较",normalizedTitle:"## 五大 i/o 模型比较",charIndex:1345}],headersStr:"## 阻塞式 I/O ## 非阻塞式 I/O ## I/O 复用 ## 信号驱动 I/O 异步I/O ## 五大 I/O 模型比较",content:"一个输入操作通常包括两个阶段：\n\n * 等待数据准备好\n * 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nUnix 有五种 I/O 模型：\n\n * 阻塞式 I/O\n * 非阻塞式 I/O\n * I/O 复用（select 和 poll）\n * 信号驱动式 I/O（SIGIO）\n * 异步 I/O（AIO）\n\n\n# ## 阻塞式 I/O\n\n应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。\n\n下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n1\n\n\n\n\n\n# ## 非阻塞式 I/O\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。\n\n由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。\n\n\n\n\n# ## I/O 复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n\n\n\n# ## 信号驱动 I/O\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n\n\n\n# 异步I/O\n\n应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。\n\n\n\n\n# ## 五大 I/O 模型比较\n\n * 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。\n * 异步 I/O：第二阶段应用进程不会阻塞。\n\n同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。\n\n非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。\n\n",normalizedContent:"一个输入操作通常包括两个阶段：\n\n * 等待数据准备好\n * 从内核向进程复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\nunix 有五种 i/o 模型：\n\n * 阻塞式 i/o\n * 非阻塞式 i/o\n * i/o 复用（select 和 poll）\n * 信号驱动式 i/o（sigio）\n * 异步 i/o（aio）\n\n\n# ## 阻塞式 i/o\n\n应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。\n\n应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 cpu 时间，这种模型的 cpu 利用率会比较高。\n\n下图中，recvfrom() 用于接收 socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。\n\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n1\n\n\n\n\n\n# ## 非阻塞式 i/o\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 i/o 是否完成，这种方式称为轮询（polling）。\n\n由于 cpu 要处理更多的系统调用，因此这种模型的 cpu 利用率比较低。\n\n\n\n\n# ## i/o 复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。\n\n它可以让单个进程具有处理多个 i/o 事件的能力。又被称为 event driven i/o，即事件驱动 i/o。\n\n如果一个 web 服务器没有 i/o 复用，那么每一个 socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，i/o 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n\n\n\n# ## 信号驱动 i/o\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 sigio 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 i/o 的轮询方式，信号驱动 i/o 的 cpu 利用率更高。\n\n\n\n\n# 异步i/o\n\n应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步 i/o 与信号驱动 i/o 的区别在于，异步 i/o 的信号是通知应用进程 i/o 完成，而信号驱动 i/o 的信号是通知应用进程可以开始 i/o。\n\n\n\n\n# ## 五大 i/o 模型比较\n\n * 同步 i/o：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。\n * 异步 i/o：第二阶段应用进程不会阻塞。\n\n同步 i/o 包括阻塞式 i/o、非阻塞式 i/o、i/o 复用和信号驱动 i/o ，它们的主要区别在第一个阶段。\n\n非阻塞式 i/o 、信号驱动 i/o 和异步 i/o 在第一阶段不会阻塞。\n\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"数组",frontmatter:{title:"数组",date:"2022-03-11T00:38:43.000Z",permalink:"/pages/a25c3a/",categories:["计算机基础","CSS"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E6%95%B0%E7%BB%84.html",relativePath:"02.计算机基础/30.数据结构/01.数组.md",key:"v-0c4b3c8a",path:"/pages/a25c3a/",headers:[{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2},{level:2,title:"数组的操作数组的操作",slug:"数组的操作数组的操作",normalizedTitle:"数组的操作数组的操作",charIndex:435},{level:3,title:"读取元素",slug:"读取元素",normalizedTitle:"读取元素",charIndex:450},{level:3,title:"查找元素",slug:"查找元素",normalizedTitle:"查找元素",charIndex:956},{level:3,title:"插入元素",slug:"插入元素",normalizedTitle:"插入元素",charIndex:1218},{level:3,title:"删除元素",slug:"删除元素",normalizedTitle:"删除元素",charIndex:1483},{level:2,title:"二维数组",slug:"二维数组",normalizedTitle:"二维数组",charIndex:1696},{level:3,title:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Array.html#示例)示例",slug:"示例",normalizedTitle:'<a href="https://javakeeper.starfish.ink/data-structure-algorithms/array.html#%e7%a4%ba%e4%be%8b" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>示例',charIndex:null}],headersStr:"数组 数组的操作数组的操作 读取元素 查找元素 插入元素 删除元素 二维数组 [#](https://javakeeper.starfish.ink/data-structure-algorithms/Array.html#示例)示例",content:"# 数组\n\n数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。\n\n正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。\n\n那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：索引。\n\n首先，数组会用一些名为 索引 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 0 算起的。我们可以根据数组中的索引，快速访问数组中的元素。\n\n\n\n而列表中没有索引，这是数组与列表最大的不同点。\n\n其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。\n\n\n\n相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。\n\n\n# 数组的操作数组的操作\n\n\n# 读取元素\n\n读取数组中的元素，即通过数组的索引访问数组中的元素。\n\n这里的索引其实就是内存地址，值得一提的是，计算机可以跳跃到任意的内存地址上，这就意味着只要计算出数组中元素的内存地址，则可以一步访问到数组中的元素。\n\n可以形象地将计算机中的内存看作一系列排列好的格子，这些格子中，每一个格子对应一个内存地址，数据会存储在不同的格子中。\n\n\n\n而对于数组，计算机会在内存中申请一段 连续 的空间，并且会记下索引为 0 处的内存地址。例如对于一个数组 ['oranges', 'apples', 'bananas', 'pears', 'tomatoes']，为了方便起见，我们假设每个元素只占用一个字节，它的索引与内存地址的关系如下图所示。\n\n\n\n当我们访问数组中索引为 3 处的元素时，计算机会进行如下计算：\n\n * 找到该数组的索引 0 的内存地址： 2008；\n * pears 的索引为 3，计算该元素的内存地址为 2008 + 3 = 2011；\n\n接下来，计算机就可以在直接通过该地址访问到数组中索引为 3 的元素了，计算过程很快，因此可以将整个访问过程只看作一个动作，因此时间复杂度为 。\n\n\n# 查找元素\n\n前面我们谈到计算机只会保存数组中索引为 0 处元素的内存地址，因此当计算机想要知道数组中是否包含某个元素时，只能从索引 0 处开始，逐步向后查询。\n\n还是上面的例子，如果我们要查找数组中是否包含元素 pears，计算机会从索引 0 开始，逐个比较对应的元素，直到找到该元素后停止搜索，或到达数组的末尾后停止。\n\n\n\n我们发现，该数组的长度为 5，最坏情况下（比如我们查找元素 tomatoes 或查找数组中不包含的元素），我们需要查询数组中的每个元素，因此时间复杂度为$ O(N)$，N 为数组的长度。\n\n\n# 插入元素\n\n假如我们想在原有的数组中再插入一个元素 flowers 呢？\n\n如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。\n\n\n\n然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置腾出 空间，然后进行插入操作。比如，我们想要在索引 2 处插入 flowers。\n\n\n\n我们发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题。\n\n\n# 删除元素\n\n删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 空缺 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 填补 操作。\n\n以删除索引 1 中的元素 apples 为例，具体过程如图所示。\n\n\n\n同样地，数组的长度为 5，最坏情况下，我们删除第一个元素，后面的 4 个元素需要向前移动，加上删除操作，共需执行 5 步，因此时间复杂度为 ，N 为数组的长度。\n\n\n# 二维数组\n\n二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。\n\n\n\n所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 0 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。\n\n\n# #示例\n\n类似一维数组，对于一个二维数组 A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]，计算机同样会在内存中申请一段 连续 的空间，并记录第一行数组的索引位置，即 A[0][0] 的内存地址，它的索引与内存地址的关系如下图所示。\n\n\n\n注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 1。\n\n实际题目中，往往使用二维数据处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。",normalizedContent:"# 数组\n\n数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。\n\n正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 c++ 和 java 中，数组中的元素类型必须保持一致，而 python 中则可以不同。python 中的数组叫做 list，具有更多的高级功能。\n\n那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：索引。\n\n首先，数组会用一些名为 索引 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 0 算起的。我们可以根据数组中的索引，快速访问数组中的元素。\n\n\n\n而列表中没有索引，这是数组与列表最大的不同点。\n\n其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。\n\n\n\n相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。\n\n\n# 数组的操作数组的操作\n\n\n# 读取元素\n\n读取数组中的元素，即通过数组的索引访问数组中的元素。\n\n这里的索引其实就是内存地址，值得一提的是，计算机可以跳跃到任意的内存地址上，这就意味着只要计算出数组中元素的内存地址，则可以一步访问到数组中的元素。\n\n可以形象地将计算机中的内存看作一系列排列好的格子，这些格子中，每一个格子对应一个内存地址，数据会存储在不同的格子中。\n\n\n\n而对于数组，计算机会在内存中申请一段 连续 的空间，并且会记下索引为 0 处的内存地址。例如对于一个数组 ['oranges', 'apples', 'bananas', 'pears', 'tomatoes']，为了方便起见，我们假设每个元素只占用一个字节，它的索引与内存地址的关系如下图所示。\n\n\n\n当我们访问数组中索引为 3 处的元素时，计算机会进行如下计算：\n\n * 找到该数组的索引 0 的内存地址： 2008；\n * pears 的索引为 3，计算该元素的内存地址为 2008 + 3 = 2011；\n\n接下来，计算机就可以在直接通过该地址访问到数组中索引为 3 的元素了，计算过程很快，因此可以将整个访问过程只看作一个动作，因此时间复杂度为 。\n\n\n# 查找元素\n\n前面我们谈到计算机只会保存数组中索引为 0 处元素的内存地址，因此当计算机想要知道数组中是否包含某个元素时，只能从索引 0 处开始，逐步向后查询。\n\n还是上面的例子，如果我们要查找数组中是否包含元素 pears，计算机会从索引 0 开始，逐个比较对应的元素，直到找到该元素后停止搜索，或到达数组的末尾后停止。\n\n\n\n我们发现，该数组的长度为 5，最坏情况下（比如我们查找元素 tomatoes 或查找数组中不包含的元素），我们需要查询数组中的每个元素，因此时间复杂度为$ o(n)$，n 为数组的长度。\n\n\n# 插入元素\n\n假如我们想在原有的数组中再插入一个元素 flowers 呢？\n\n如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。\n\n\n\n然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置腾出 空间，然后进行插入操作。比如，我们想要在索引 2 处插入 flowers。\n\n\n\n我们发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题。\n\n\n# 删除元素\n\n删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 空缺 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 填补 操作。\n\n以删除索引 1 中的元素 apples 为例，具体过程如图所示。\n\n\n\n同样地，数组的长度为 5，最坏情况下，我们删除第一个元素，后面的 4 个元素需要向前移动，加上删除操作，共需执行 5 步，因此时间复杂度为 ，n 为数组的长度。\n\n\n# 二维数组\n\n二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。\n\n\n\n所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 0 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。\n\n\n# #示例\n\n类似一维数组，对于一个二维数组 a = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]，计算机同样会在内存中申请一段 连续 的空间，并记录第一行数组的索引位置，即 a[0][0] 的内存地址，它的索引与内存地址的关系如下图所示。\n\n\n\n注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 1。\n\n实际题目中，往往使用二维数据处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"树",frontmatter:{title:"树",date:"2022-10-11T22:51:14.000Z",permalink:"/pages/c29bff/",categories:["计算机基础","数据结构"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/30.%E6%A0%91.html",relativePath:"02.计算机基础/30.数据结构/30.树.md",key:"v-a380136c",path:"/pages/c29bff/",headers:[{level:2,title:"二叉树的分类",slug:"二叉树的分类",normalizedTitle:"二叉树的分类",charIndex:681},{level:3,title:"满二叉树",slug:"满二叉树",normalizedTitle:"满二叉树",charIndex:849},{level:3,title:"完全二叉树",slug:"完全二叉树",normalizedTitle:"完全二叉树",charIndex:1037},{level:3,title:"平衡二叉树",slug:"平衡二叉树",normalizedTitle:"平衡二叉树",charIndex:1337},{level:2,title:"二叉树的存储",slug:"二叉树的存储",normalizedTitle:"二叉树的存储",charIndex:1320},{level:3,title:"链式存储",slug:"链式存储",normalizedTitle:"链式存储",charIndex:1801},{level:3,title:"顺序存储",slug:"顺序存储",normalizedTitle:"顺序存储",charIndex:1808},{level:2,title:"二叉树的遍历",slug:"二叉树的遍历",normalizedTitle:"二叉树的遍历",charIndex:2275},{level:3,title:"先序遍历",slug:"先序遍历",normalizedTitle:"先序遍历",charIndex:2286},{level:3,title:"中序遍历",slug:"中序遍历",normalizedTitle:"中序遍历",charIndex:2550},{level:3,title:"后序遍历",slug:"后序遍历",normalizedTitle:"后序遍历",charIndex:2820}],headersStr:"二叉树的分类 满二叉树 完全二叉树 平衡二叉树 二叉树的存储 链式存储 顺序存储 二叉树的遍历 先序遍历 中序遍历 后序遍历",content:"树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。\n\n一棵树具有以下特点：\n\n 1. 一棵树中的任意两个结点有且仅有唯一的一条路径连通。\n 2. 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。\n 3. 一棵树不包含回路。\n\n下图就是一颗树，并且是一颗二叉树。\n\n\n\n如上图所示，通过上面这张图说明一下树中的常用概念：\n\n * 节点 ：树中的每个元素都可以统称为节点。\n * 根节点 ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。\n * 父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。\n * 子节点 ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。\n * 兄弟节点 ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。\n * 叶子节点 ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。\n * 节点的高度 ：该节点到叶子节点的最长路径所包含的边数。\n * 节点的深度 ：根节点到该节点的路径所包含的边数\n * 节点的层数 ：节点的深度+1。\n * 树的高度 ：根节点的高度。\n\n> 关于树的深度和高度的定义可以看 stackoverflow 上的这个问题：What is the difference between tree depth and height?open in new window 。\n\n\n# 二叉树的分类\n\n二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。\n\n二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。\n\n二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^(k+1)-1 个节点（满二叉树的情况），至少有 2^(k) 个节点（关于节点的深度的定义国内争议比较多，我个人比较认可维基百科对节点深度的定义open in new window）。\n\n\n\n\n# 满二叉树\n\n一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 满二叉树。如下图所示：\n\n\n\n\n# 完全二叉树\n\n除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 完全二叉树 。\n\n大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：\n\n\n\n完全二叉树有一个很好的性质：父结点和子节点的序号有着对应关系。\n\n细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。\n\n\n# 平衡二叉树\n\n平衡二叉树 是一棵二叉排序树，且具有以下性质：\n\n 1. 可以是一棵空树\n 2. 如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。\n\n平衡二叉树的常用实现方法有 红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等。\n\n在给大家展示平衡二叉树之前，先给大家看一棵树：\n\n\n\n你管这玩意儿叫树？？？\n\n没错，这玩意儿还真叫树，只不过这棵树已经退化为一个链表了，我们管它叫 斜树。\n\n如果这样，那我为啥不直接用链表呢?\n\n谁说不是呢？\n\n二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行搜索和修改时，相对于链表更加快捷便利。\n\n但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做 “家长”（父结点） 的，都 一碗水端平，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：\n\n\n\n\n# 二叉树的存储\n\n二叉树的存储主要分为 链式存储 和 顺序存储 两种：\n\n\n# 链式存储\n\n和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。\n\n每个节点包括三个属性：\n\n * 数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。\n * 左节点指针 left\n * 右节点指针 right。\n\n可是 JAVA 没有指针啊！\n\n那就直接引用对象呗（别问我对象哪里找）\n\n\n\n\n# 顺序存储\n\n顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。\n\n一棵完全二叉树的数组顺序存储如下图所示：\n\n\n\n大家可以试着填写一下存储如下二叉树的数组，比较一下和完全二叉树的顺序存储有何区别：\n\n\n\n可以看到，如果我们要存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低\n\n\n# 二叉树的遍历\n\n\n# 先序遍历\n\n\n\n二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。\n\n代码如下：\n\npublic void preOrder(TreeNode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tsystem.out.println(root.data);\n\tpreOrder(root.left);\n\tpreOrder(root.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 中序遍历\n\n\n\n二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：\n\n\n\n代码如下：\n\npublic void inOrder(TreeNode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tinOrder(root.left);\n\tsystem.out.println(root.data);\n\tinOrder(root.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 后序遍历\n\n\n\n二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值\n\n代码如下：\n\npublic void postOrder(TreeNode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tpostOrder(root.left);\n\tpostOrder(root.right);\n\tsystem.out.println(root.data);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n参考：\n\n数据结构-树",normalizedContent:"树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。\n\n一棵树具有以下特点：\n\n 1. 一棵树中的任意两个结点有且仅有唯一的一条路径连通。\n 2. 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。\n 3. 一棵树不包含回路。\n\n下图就是一颗树，并且是一颗二叉树。\n\n\n\n如上图所示，通过上面这张图说明一下树中的常用概念：\n\n * 节点 ：树中的每个元素都可以统称为节点。\n * 根节点 ：顶层节点或者说没有父节点的节点。上图中 a 节点就是根节点。\n * 父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 b 节点是 d 节点、e 节点的父节点。\n * 子节点 ：一个节点含有的子树的根节点称为该节点的子节点。上图中 d 节点、e 节点是 b 节点的子节点。\n * 兄弟节点 ：具有相同父节点的节点互称为兄弟节点。上图中 d 节点、e 节点的共同父节点是 b 节点，故 d 和 e 为兄弟节点。\n * 叶子节点 ：没有子节点的节点。上图中的 d、f、h、i 都是叶子节点。\n * 节点的高度 ：该节点到叶子节点的最长路径所包含的边数。\n * 节点的深度 ：根节点到该节点的路径所包含的边数\n * 节点的层数 ：节点的深度+1。\n * 树的高度 ：根节点的高度。\n\n> 关于树的深度和高度的定义可以看 stackoverflow 上的这个问题：what is the difference between tree depth and height?open in new window 。\n\n\n# 二叉树的分类\n\n二叉树（binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。\n\n二叉树 的分支通常被称作“左子树”或“右子树”。并且，二叉树 的分支具有左右次序，不能随意颠倒。\n\n二叉树 的第 i 层至多拥有 2^(i-1) 个节点，深度为 k 的二叉树至多总共有 2^(k+1)-1 个节点（满二叉树的情况），至少有 2^(k) 个节点（关于节点的深度的定义国内争议比较多，我个人比较认可维基百科对节点深度的定义open in new window）。\n\n\n\n\n# 满二叉树\n\n一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树。也就是说，如果一个二叉树的层数为 k，且结点总数是(2^k) -1 ，则它就是 满二叉树。如下图所示：\n\n\n\n\n# 完全二叉树\n\n除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 完全二叉树 。\n\n大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：\n\n\n\n完全二叉树有一个很好的性质：父结点和子节点的序号有着对应关系。\n\n细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。\n\n\n# 平衡二叉树\n\n平衡二叉树 是一棵二叉排序树，且具有以下性质：\n\n 1. 可以是一棵空树\n 2. 如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。\n\n平衡二叉树的常用实现方法有 红黑树、avl 树、替罪羊树、加权平衡树、伸展树 等。\n\n在给大家展示平衡二叉树之前，先给大家看一棵树：\n\n\n\n你管这玩意儿叫树？？？\n\n没错，这玩意儿还真叫树，只不过这棵树已经退化为一个链表了，我们管它叫 斜树。\n\n如果这样，那我为啥不直接用链表呢?\n\n谁说不是呢？\n\n二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行搜索和修改时，相对于链表更加快捷便利。\n\n但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做 “家长”（父结点） 的，都 一碗水端平，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：\n\n\n\n\n# 二叉树的存储\n\n二叉树的存储主要分为 链式存储 和 顺序存储 两种：\n\n\n# 链式存储\n\n和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。\n\n每个节点包括三个属性：\n\n * 数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。\n * 左节点指针 left\n * 右节点指针 right。\n\n可是 java 没有指针啊！\n\n那就直接引用对象呗（别问我对象哪里找）\n\n\n\n\n# 顺序存储\n\n顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。\n\n一棵完全二叉树的数组顺序存储如下图所示：\n\n\n\n大家可以试着填写一下存储如下二叉树的数组，比较一下和完全二叉树的顺序存储有何区别：\n\n\n\n可以看到，如果我们要存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低\n\n\n# 二叉树的遍历\n\n\n# 先序遍历\n\n\n\n二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。\n\n代码如下：\n\npublic void preorder(treenode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tsystem.out.println(root.data);\n\tpreorder(root.left);\n\tpreorder(root.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 中序遍历\n\n\n\n二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：\n\n\n\n代码如下：\n\npublic void inorder(treenode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tinorder(root.left);\n\tsystem.out.println(root.data);\n\tinorder(root.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 后序遍历\n\n\n\n二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值\n\n代码如下：\n\npublic void postorder(treenode root){\n\tif(root == null){\n\t\treturn;\n\t}\n\tpostorder(root.left);\n\tpostorder(root.right);\n\tsystem.out.println(root.data);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n参考：\n\n数据结构-树",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"队列",frontmatter:{title:"队列",date:"2022-10-11T22:46:47.000Z",permalink:"/pages/308e3b/",categories:["计算机基础","数据结构"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20.%E9%98%9F%E5%88%97.html",relativePath:"02.计算机基础/30.数据结构/20.队列.md",key:"v-e66c56a0",path:"/pages/308e3b/",headers:[{level:3,title:"如何理解“队列”",slug:"如何理解-队列",normalizedTitle:"如何理解“队列”",charIndex:85},{level:3,title:"顺序队列和链式队列",slug:"顺序队列和链式队列",normalizedTitle:"顺序队列和链式队列",charIndex:292},{level:3,title:"循环队列",slug:"循环队列",normalizedTitle:"循环队列",charIndex:2464},{level:3,title:"阻塞队列和并发队列",slug:"阻塞队列和并发队列",normalizedTitle:"阻塞队列和并发队列",charIndex:3847},{level:3,title:"解答开篇",slug:"解答开篇",normalizedTitle:"解答开篇",charIndex:4414},{level:3,title:"内容小结",slug:"内容小结",normalizedTitle:"内容小结",charIndex:5001},{level:3,title:"思考",slug:"思考",normalizedTitle:"思考",charIndex:5304},{level:3,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5407}],headersStr:"如何理解“队列” 顺序队列和链式队列 循环队列 阻塞队列和并发队列 解答开篇 内容小结 思考 参考",content:"> 当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？\n\n\n# 如何理解“队列”\n\n可以把它想象成排队买票，先来的先买，后来的人只能站在末尾，不允许插队。先进者先出，这就是典型的“队列”。\n\n我们知道栈只支持两个基本操作：入栈push()和出栈pop()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。\n\n\n\n所以队列和栈一样，也是一种操作受限的线性表数据结构。\n\n\n# 顺序队列和链式队列\n\n跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫顺序栈，用链表实现的栈叫链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。\n\n// 用数组实现的队列\npublic class ArrayQueue {\n  // 数组：items，数组大小：n\n  private String[] items;\n  private int n = 0;\n  // head 表示队头下标，tail 表示队尾下标\n  private int head = 0;\n  private int tail = 0;\n\n  // 申请一个大小为 capacity 的数组\n  public ArrayQueue(int capacity) {\n    items = new String[capacity];\n    n = capacity;\n  }\n\n  // 入队\n  public boolean enqueue(String item) {\n    // 如果 tail == n 表示队列已经满了\n    if (tail == n) return false;\n    items[tail] = item;\n    ++tail;\n    return true;\n  }\n\n  // 出队\n  public String dequeue() {\n    // 如果 head == tail 表示队列为空\n    if (head == tail) return null;\n    // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了\n    String ret = items[head];\n    ++head;\n    return ret;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。\n\n可以结合下图来理解。当a、b、c、d依次入队之后，队列中的head指针指向下标为0的位置，tail指针指向下标为4的位置。\n\n\n\n当我们调用两次出队操作之后，队列中head指针指向下标为2的位置，tail指针仍然指向下标为4的位置。\n\n\n\n随着不停地进行入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。如何解决这个问题呢？\n\n用数据搬移是一种解决方式，但是每次进行出队操作都相当于删除数组下标为0的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会由原来的O(1)变为O(n)。\n\n但是我们可以优化一下，在出队时我们不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数dequeue()保持不变，我们稍微改造下入队函数enqueue()的实现就可以了。\n\n   // 入队操作，将 item 放入队尾\n  public boolean enqueue(String item) {\n    // tail == n 表示队列末尾没有空间了\n    if (tail == n) {\n      // tail ==n && head==0，表示整个队列都占满了\n      if (head == 0) return false;\n      // 数据搬移\n      for (int i = head; i < tail; ++i) {\n        items[i-head] = items[i];\n      }\n      // 搬移完之后重新更新 head 和 tail\n      tail -= head;\n      head = 0;\n    }\n    \n    items[tail] = item;\n    ++tail;\n    return true;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n从代码中得知，当队列的tail指针移动到数组的最右边，如果有新的数据入队，我们可以将head到tail之间的数据，整体搬移到数组中0到tail-head的位置。\n\n\n\n这种实现思路，出队操作的时间复杂度仍然是O(1)，但入队操作的时间复杂度还是O(1)吗？\n\n> 用均摊时间复杂度分析下，最好情况下入队操作时间复杂度是O(1)，最坏情况下时间复杂度是O(n)，由于大部分入栈操作时间复杂度都是O(1)，所以均摊下来入队操作时间复杂度仍然是O(1)。\n\n基于链表的队列实现方法\n\n基于链表的实现，我们仍然需要两个指针：head和tail。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail->next=new_node，tail = tail->next；出队时，head=head->next。\n\n\n\n\n# 循环队列\n\n当用数组来实现队列的时候，当tail==n时，会有数据搬移操作，这样入队操作性能就会受到影响。我们可以用循环队列来解决这个问题。\n\n循环队列，它长得像一个环。原本数组是有头有尾的，是一条直线，现在我们把首尾相连，扳成了一个环。如图所示\n\n\n\n如图所示，这个队列的大小为8，当前head=4，tail=7。当有一个新的元素a入队时，我们放入下标为7的位置。但这个时候，我们并不把tail更新为8，而是将其在环中后移一位，到下标为0到位置。当再有一个元素b入队时，我们将b放入下标为0的位置，然后tail加1更新为1。所以，在a、b依次入队之后，循环队列中的元素就变成了下面这个样子\n\n\n\n通过这样的方法，我们成功避免了数据搬移操作。但要想写出没有bug的循环队列的实现代码。最关键的是，确定好队空和队满的判定条件。\n\n在用数组实现的非循环队列中，队满的判定条件是tail == n，队空的判定条件是head == tail。那针对循环队列，如何判断队空和队满呢？\n\n队列为空的判定条件仍然是head == tail。但是队满的判定条件比较复杂了，如下图所示，总结一下规律\n\n\n\n如图所示，tail=3，head=4，n=8，总结规律就是：(3+1)%8 = 4。多画几张图就会发现，当队满时，(tail+1)%n = head。\n\n但是当队满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费一格数组的存储空间。\n\n没理解？看代码\n\npublic class CircularQueue {\n  // 数组：items，数组大小：n\n  private String[] items;\n  private int n = 0;\n  // head 表示队头下标，tail 表示队尾下标\n  private int head = 0;\n  private int tail = 0;\n\n  // 申请一个大小为 capacity 的数组\n  public CircularQueue(int capacity) {\n    items = new String[capacity];\n    n = capacity;\n  }\n\n  // 入队\n  public boolean enqueue(String item) {\n    // 队列满了\n    if ((tail + 1) % n == head) return false;\n    items[tail] = item;\n    tail = (tail + 1) % n;\n    return true;\n  }\n\n  // 出队\n  public String dequeue() {\n    // 如果 head == tail 表示队列为空\n    if (head == tail) return null;\n    String ret = items[head];\n    head = (head + 1) % n;\n    return ret;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 阻塞队列和并发队列\n\n阻塞队列其实就是在队列基础上增加了阻塞操作。简单讲就是队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，知道队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。\n\n\n\n上述的定义就是一个“生产者 - 消费者模型”。\n\n> 这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。\n\n基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如多配置几个“消费者”，来对应一个生产过快的“生产者”。\n\n\n\n在多线程情况下，会有多个线程同时操作队列，这个时候会存在线程安全问题。该如何实现线程安全的队列呢？\n\n线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度就会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。\n\n\n# 解答开篇\n\n线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？\n\n有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？\n\n我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？\n\n基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。\n\n而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。\n\n队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。\n\n\n# 内容小结\n\n队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。\n\n循环队列是重点。要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。\n\n除此之外，几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。\n\n\n# 思考\n\n 1. 除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？\n 2. 关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？\n\n\n# 参考\n\n数据结构与算法之美-队列",normalizedContent:"> 当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？\n\n\n# 如何理解“队列”\n\n可以把它想象成排队买票，先来的先买，后来的人只能站在末尾，不允许插队。先进者先出，这就是典型的“队列”。\n\n我们知道栈只支持两个基本操作：入栈push()和出栈pop()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。\n\n\n\n所以队列和栈一样，也是一种操作受限的线性表数据结构。\n\n\n# 顺序队列和链式队列\n\n跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫顺序栈，用链表实现的栈叫链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。\n\n// 用数组实现的队列\npublic class arrayqueue {\n  // 数组：items，数组大小：n\n  private string[] items;\n  private int n = 0;\n  // head 表示队头下标，tail 表示队尾下标\n  private int head = 0;\n  private int tail = 0;\n\n  // 申请一个大小为 capacity 的数组\n  public arrayqueue(int capacity) {\n    items = new string[capacity];\n    n = capacity;\n  }\n\n  // 入队\n  public boolean enqueue(string item) {\n    // 如果 tail == n 表示队列已经满了\n    if (tail == n) return false;\n    items[tail] = item;\n    ++tail;\n    return true;\n  }\n\n  // 出队\n  public string dequeue() {\n    // 如果 head == tail 表示队列为空\n    if (head == tail) return null;\n    // 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了\n    string ret = items[head];\n    ++head;\n    return ret;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。\n\n可以结合下图来理解。当a、b、c、d依次入队之后，队列中的head指针指向下标为0的位置，tail指针指向下标为4的位置。\n\n\n\n当我们调用两次出队操作之后，队列中head指针指向下标为2的位置，tail指针仍然指向下标为4的位置。\n\n\n\n随着不停地进行入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。如何解决这个问题呢？\n\n用数据搬移是一种解决方式，但是每次进行出队操作都相当于删除数组下标为0的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会由原来的o(1)变为o(n)。\n\n但是我们可以优化一下，在出队时我们不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数dequeue()保持不变，我们稍微改造下入队函数enqueue()的实现就可以了。\n\n   // 入队操作，将 item 放入队尾\n  public boolean enqueue(string item) {\n    // tail == n 表示队列末尾没有空间了\n    if (tail == n) {\n      // tail ==n && head==0，表示整个队列都占满了\n      if (head == 0) return false;\n      // 数据搬移\n      for (int i = head; i < tail; ++i) {\n        items[i-head] = items[i];\n      }\n      // 搬移完之后重新更新 head 和 tail\n      tail -= head;\n      head = 0;\n    }\n    \n    items[tail] = item;\n    ++tail;\n    return true;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n从代码中得知，当队列的tail指针移动到数组的最右边，如果有新的数据入队，我们可以将head到tail之间的数据，整体搬移到数组中0到tail-head的位置。\n\n\n\n这种实现思路，出队操作的时间复杂度仍然是o(1)，但入队操作的时间复杂度还是o(1)吗？\n\n> 用均摊时间复杂度分析下，最好情况下入队操作时间复杂度是o(1)，最坏情况下时间复杂度是o(n)，由于大部分入栈操作时间复杂度都是o(1)，所以均摊下来入队操作时间复杂度仍然是o(1)。\n\n基于链表的队列实现方法\n\n基于链表的实现，我们仍然需要两个指针：head和tail。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail->next=new_node，tail = tail->next；出队时，head=head->next。\n\n\n\n\n# 循环队列\n\n当用数组来实现队列的时候，当tail==n时，会有数据搬移操作，这样入队操作性能就会受到影响。我们可以用循环队列来解决这个问题。\n\n循环队列，它长得像一个环。原本数组是有头有尾的，是一条直线，现在我们把首尾相连，扳成了一个环。如图所示\n\n\n\n如图所示，这个队列的大小为8，当前head=4，tail=7。当有一个新的元素a入队时，我们放入下标为7的位置。但这个时候，我们并不把tail更新为8，而是将其在环中后移一位，到下标为0到位置。当再有一个元素b入队时，我们将b放入下标为0的位置，然后tail加1更新为1。所以，在a、b依次入队之后，循环队列中的元素就变成了下面这个样子\n\n\n\n通过这样的方法，我们成功避免了数据搬移操作。但要想写出没有bug的循环队列的实现代码。最关键的是，确定好队空和队满的判定条件。\n\n在用数组实现的非循环队列中，队满的判定条件是tail == n，队空的判定条件是head == tail。那针对循环队列，如何判断队空和队满呢？\n\n队列为空的判定条件仍然是head == tail。但是队满的判定条件比较复杂了，如下图所示，总结一下规律\n\n\n\n如图所示，tail=3，head=4，n=8，总结规律就是：(3+1)%8 = 4。多画几张图就会发现，当队满时，(tail+1)%n = head。\n\n但是当队满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费一格数组的存储空间。\n\n没理解？看代码\n\npublic class circularqueue {\n  // 数组：items，数组大小：n\n  private string[] items;\n  private int n = 0;\n  // head 表示队头下标，tail 表示队尾下标\n  private int head = 0;\n  private int tail = 0;\n\n  // 申请一个大小为 capacity 的数组\n  public circularqueue(int capacity) {\n    items = new string[capacity];\n    n = capacity;\n  }\n\n  // 入队\n  public boolean enqueue(string item) {\n    // 队列满了\n    if ((tail + 1) % n == head) return false;\n    items[tail] = item;\n    tail = (tail + 1) % n;\n    return true;\n  }\n\n  // 出队\n  public string dequeue() {\n    // 如果 head == tail 表示队列为空\n    if (head == tail) return null;\n    string ret = items[head];\n    head = (head + 1) % n;\n    return ret;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 阻塞队列和并发队列\n\n阻塞队列其实就是在队列基础上增加了阻塞操作。简单讲就是队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，知道队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。\n\n\n\n上述的定义就是一个“生产者 - 消费者模型”。\n\n> 这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。\n\n基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如多配置几个“消费者”，来对应一个生产过快的“生产者”。\n\n\n\n在多线程情况下，会有多个线程同时操作队列，这个时候会存在线程安全问题。该如何实现线程安全的队列呢？\n\n线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度就会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用cas原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。\n\n\n# 解答开篇\n\n线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？\n\n有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？\n\n我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？\n\n基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。\n\n而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。\n\n队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。\n\n\n# 内容小结\n\n队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。\n\n循环队列是重点。要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。\n\n除此之外，几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。\n\n\n# 思考\n\n 1. 除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？\n 2. 关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？\n\n\n# 参考\n\n数据结构与算法之美-队列",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"链表",frontmatter:{title:"链表",date:"2022-10-11T22:41:10.000Z",permalink:"/pages/f376bd/",categories:["计算机基础","数据结构"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E9%93%BE%E8%A1%A8.html",relativePath:"02.计算机基础/30.数据结构/02.链表.md",key:"v-7193df75",path:"/pages/f376bd/",headers:[{level:2,title:"单链表",slug:"单链表",normalizedTitle:"单链表",charIndex:128},{level:3,title:"查找",slug:"查找",normalizedTitle:"查找",charIndex:1216},{level:3,title:"添加",slug:"添加",normalizedTitle:"添加",charIndex:1754},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:2670},{level:2,title:"双向链表",slug:"双向链表",normalizedTitle:"双向链表",charIndex:3444},{level:3,title:"查找",slug:"查找-2",normalizedTitle:"查找",charIndex:1216},{level:3,title:"添加",slug:"添加-2",normalizedTitle:"添加",charIndex:1754},{level:3,title:"删除",slug:"删除-2",normalizedTitle:"删除",charIndex:2670},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:6886}],headersStr:"单链表 查找 添加 删除 双向链表 查找 添加 删除 参考",content:"与数组相似，链表也是一种线性数据结构。\n\n链表是一系列的存储数据元素的单元通过指针串接起来形成的，因此每个单元至少有两个域，一个域用于数据元素的存储，另一个域是指向其他单元的指针。这里具有一个数据域和多个指针域的存储单元通常称为结点（node）。\n\n\n# 单链表\n\n\n\n一种最简单的结点结构如上图所示，它是构成单链表的基本结点结构。在结点中数据域用来存储数据元素，指针域用于指向下一个具有相同结构的结点。\n\n单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。\n\n\n\n链表的第一个结点和最后一个结点，分别称为链表的首结点和尾结点。尾结点的特征是其 next 引用为空（null）。链表中每个结点的 next 引用都相当于一个指针，指向另一个结点，借助这些 next 引用，我们可以从链表的首结点移动到尾结点。如此定义的结点就称为单链表（single linked list）。\n\n上图蓝色箭头显示单个链接列表中的结点是如何组合在一起的。\n\n在单链表中通常使用 head 引用来指向链表的首结点，由 head 引用可以完成对整个链表中所有节点的访问。有时也可以根据需要使用指向尾结点的 tail 引用来方便某些操作的实现。\n\n在单链表结构中还需要注意的一点是，由于每个结点的数据域都是一个 Object 类的对象，因此，每个数据元素并非真正如图中那样，而是在结点中的数据域通过一个 Object 类的对象引用来指向数据元素的。\n\n与数组类似，单链表中的结点也具有一个线性次序，即如果结点 P 的 next 引用指向结点 S，则 P 就是 S 的直接前驱，S 是 P 的直接后续。单链表的一个重要特性就是只能通过前驱结点找到后续结点，而无法从后续结点找到前驱结点。\n\n接着我们来看下单链表的 CRUD：\n\n> 707. 设计链表 (opens new window)搞定一题\n\n以下是单链表中结点的典型定义，值 + 链接到下一个元素的指针：\n\n// Definition for singly-linked list.\npublic class SinglyListNode {\n    int val;\n    SinglyListNode next;\n    SinglyListNode(int x) { val = x; }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n有了结点，还需要一个“链” 把所有结点串起来\n\nclass MyLinkedList {\n    private SinglyListNode head;\n    /** Initialize your data structure here. */\n    public MyLinkedList() {\n        head = null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 查找\n\n与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费 时间，其中 N 是链表的长度。\n\n使用 Java 语言实现整个过程的关键语句是：\n\n/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\npublic int get(int index) {\n  // if index is invalid\n  if (index < 0 || index >= size) return -1;\n\n  ListNode curr = head;\n  // index steps needed \n  // to move from sentinel node to wanted index\n  for(int i = 0; i < index + 1; ++i) {\n    curr = curr.next;\n  }\n  return curr.val;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 添加\n\n单链表中数据元素的插入，是通过在链表中插入数据元素所属的结点来完成的。对于链表的不同位置，插入的过程会有细微的差别。\n\n\n\n除了单链表的首结点由于没有直接前驱结点，所以可以直接在首结点之前插入一个新的结点之外，在单链表中的其他任何位置插入一个新结点时，都只能是在已知某个特定结点引用的基础上在其后面插入一个新结点。并且在已知单链表中某个结点引用的基础上，完成结点的插入操作需要的时间是 。\n\n> 思考：如果是带头结点的单链表进行插入操作，是什么样子呢？\n\n\t//最外层有个链表长度，便于我们头插和尾插操作\n\tint size;\n\n  public void addAtHead(int val) {\n    addAtIndex(0, val);\n  }\n\n  //尾插就是从最后一个\n  public void addAtTail(int val) {\n    addAtIndex(size, val);\n  }\n\n  public void addAtIndex(int index, int val) {\n    \n    if (index > size) return;\n\n    if (index < 0) index = 0;\n\n    ++size;\n    // find predecessor of the node to be added\n    ListNode pred = head;\n    for(int i = 0; i < index; ++i) {\n      pred = pred.next;\n    }\n\n    // node to be added\n    ListNode toAdd = new ListNode(val);\n    // insertion itself\n    toAdd.next = pred.next;\n    pred.next = toAdd;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 删除\n\n类似的，在单链表中数据元素的删除也是通过结点的删除来完成的。在链表的不同位置删除结点，其操作过程也会有一些差别。\n\n\n\n在单链表中删除一个结点时，除首结点外都必须知道该结点的直接前驱结点的引用。并且在已知单链表中某个结点引用的基础上，完成其后续结点的删除操作需要的时间是 。\n\n> 在使用单链表实现线性表的时候，为了使程序更加简洁，我们通常在单链表的最前面添加一个哑元结点，也称为头结点。在头结点中不存储任何实质的数据对象，其 next 域指向线性表中 0 号元素所在的结点，头结点的引入可以使线性表运算中的一些边界条件更容易处理。\n> \n> 对于任何基于序号的插入、删除，以及任何基于数据元素所在结点的前面或后面的插入、删除，在带头结点的单链表中均可转化为在某个特定结点之后完成结点的插入、删除，而不用考虑插入、删除是在链表的首部、中间、还是尾部等不同情况。\n\n\n\n  public void deleteAtIndex(int index) {\n    // if the index is invalid, do nothing\n    if (index < 0 || index >= size) return;\n\n    size--;\n    // find predecessor of the node to be deleted\n    ListNode pred = head;\n    for(int i = 0; i < index; ++i) {\n      pred = pred.next;\n    }\n\n    // delete pred.next \n    pred.next = pred.next.next;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 双向链表\n\n单链表的一个优点是结构简单，但是它也有一个缺点，即在单链表中只能通过一个结点的引用访问其后续结点，而无法直接访问其前驱结点，要在单链表中找到某个结点的前驱结点，必须从链表的首结点出发依次向后寻找，但是需要 时间。\n\n所以我们在单链表结点结构中新增加一个域，该域用于指向结点的直接前驱结点。\n\n\n\n双向链表是通过上述定义的结点使用 pre 以及 next 域依次串联在一起而形成的。一个双向链表的结构如下图所示。\n\n\n\n接着我们来看下双向链表的 CRUD：\n\n以下是双链表中结点的典型定义：\n\npublic class ListNode {\n  int val;\n  ListNode next;\n  ListNode prev;\n  ListNode(int x) { val = x; }\n}\n\nclass MyLinkedList {\n  int size;\n  // sentinel nodes as pseudo-head and pseudo-tail\n  ListNode head, tail;\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n    tail = new ListNode(0);\n    head.next = tail;\n    tail.prev = head;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 查找\n\n在双向链表中进行查找与在单链表中类似，只不过在双向链表中查找操作可以从链表的首结点开始，也可以从尾结点开始，但是需要的时间和在单链表中一样。\n\n  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n  public int get(int index) {\n    if (index < 0 || index >= size) return -1;\n\n    ListNode curr = head;\n    if (index + 1 < size - index)\n      for(int i = 0; i < index + 1; ++i) {\n        curr = curr.next;\n      }\n    else {\n      curr = tail;\n      for(int i = 0; i < size - index; ++i) {\n        curr = curr.prev;\n      }\n    }\n\n    return curr.val;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 添加\n\n单链表的插入操作，除了首结点之外必须在某个已知结点后面进行，而在双向链表中插入操作在一个已知的结点之前或之后都可以进行，如下表示在结点 11 之前 插入 9。\n\n\n\n使用 Java 语言实现整个过程的关键语句是\n\n  public void addAtHead(int val) {\n    ListNode pred = head, succ = head.next;\n\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n  /** Append a node of value val to the last element of the linked list. */\n  public void addAtTail(int val) {\n    ListNode succ = tail, pred = tail.prev;\n\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n  public void addAtIndex(int index, int val) {\n    if (index > size) return;\n\n    if (index < 0) index = 0;\n\n    ListNode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index; ++i) succ = succ.prev;\n      pred = succ.prev;\n    }\n\n    // insertion itself\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n在结点 p 之后插入一个新结点的操作与上述操作对称，这里不再赘述。\n\n插入操作除了上述情况，还可以在双向链表的首结点之前、双向链表的尾结点之后进行，此时插入操作与上述插入操作相比更为简单。\n\n\n# 删除\n\n单链表的删除操作，除了首结点之外必须在知道待删结点的前驱结点的基础上才能进行，而在双向链表中在已知某个结点引用的前提下，可以完成该结点自身的删除。如下表示删除 16 的过程。\n\n\n\n\t/** Delete the index-th node in the linked list, if the index is valid. */\n  public void deleteAtIndex(int index) {\n    if (index < 0 || index >= size) return;\n\n    ListNode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index - 1; ++i) succ = succ.prev;\n      pred = succ.prev.prev;\n    }\n\n    // delete pred.next \n    --size;\n    pred.next = succ;\n    succ.prev = pred;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n对线性表的操作，无非就是排序、加法、减法、反转，说的好像很简单，我们去下一章刷题吧\n\n\n# 参考\n\n链表",normalizedContent:"与数组相似，链表也是一种线性数据结构。\n\n链表是一系列的存储数据元素的单元通过指针串接起来形成的，因此每个单元至少有两个域，一个域用于数据元素的存储，另一个域是指向其他单元的指针。这里具有一个数据域和多个指针域的存储单元通常称为结点（node）。\n\n\n# 单链表\n\n\n\n一种最简单的结点结构如上图所示，它是构成单链表的基本结点结构。在结点中数据域用来存储数据元素，指针域用于指向下一个具有相同结构的结点。\n\n单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。\n\n\n\n链表的第一个结点和最后一个结点，分别称为链表的首结点和尾结点。尾结点的特征是其 next 引用为空（null）。链表中每个结点的 next 引用都相当于一个指针，指向另一个结点，借助这些 next 引用，我们可以从链表的首结点移动到尾结点。如此定义的结点就称为单链表（single linked list）。\n\n上图蓝色箭头显示单个链接列表中的结点是如何组合在一起的。\n\n在单链表中通常使用 head 引用来指向链表的首结点，由 head 引用可以完成对整个链表中所有节点的访问。有时也可以根据需要使用指向尾结点的 tail 引用来方便某些操作的实现。\n\n在单链表结构中还需要注意的一点是，由于每个结点的数据域都是一个 object 类的对象，因此，每个数据元素并非真正如图中那样，而是在结点中的数据域通过一个 object 类的对象引用来指向数据元素的。\n\n与数组类似，单链表中的结点也具有一个线性次序，即如果结点 p 的 next 引用指向结点 s，则 p 就是 s 的直接前驱，s 是 p 的直接后续。单链表的一个重要特性就是只能通过前驱结点找到后续结点，而无法从后续结点找到前驱结点。\n\n接着我们来看下单链表的 crud：\n\n> 707. 设计链表 (opens new window)搞定一题\n\n以下是单链表中结点的典型定义，值 + 链接到下一个元素的指针：\n\n// definition for singly-linked list.\npublic class singlylistnode {\n    int val;\n    singlylistnode next;\n    singlylistnode(int x) { val = x; }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n有了结点，还需要一个“链” 把所有结点串起来\n\nclass mylinkedlist {\n    private singlylistnode head;\n    /** initialize your data structure here. */\n    public mylinkedlist() {\n        head = null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 查找\n\n与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费 时间，其中 n 是链表的长度。\n\n使用 java 语言实现整个过程的关键语句是：\n\n/** get the value of the index-th node in the linked list. if the index is invalid, return -1. */\npublic int get(int index) {\n  // if index is invalid\n  if (index < 0 || index >= size) return -1;\n\n  listnode curr = head;\n  // index steps needed \n  // to move from sentinel node to wanted index\n  for(int i = 0; i < index + 1; ++i) {\n    curr = curr.next;\n  }\n  return curr.val;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 添加\n\n单链表中数据元素的插入，是通过在链表中插入数据元素所属的结点来完成的。对于链表的不同位置，插入的过程会有细微的差别。\n\n\n\n除了单链表的首结点由于没有直接前驱结点，所以可以直接在首结点之前插入一个新的结点之外，在单链表中的其他任何位置插入一个新结点时，都只能是在已知某个特定结点引用的基础上在其后面插入一个新结点。并且在已知单链表中某个结点引用的基础上，完成结点的插入操作需要的时间是 。\n\n> 思考：如果是带头结点的单链表进行插入操作，是什么样子呢？\n\n\t//最外层有个链表长度，便于我们头插和尾插操作\n\tint size;\n\n  public void addathead(int val) {\n    addatindex(0, val);\n  }\n\n  //尾插就是从最后一个\n  public void addattail(int val) {\n    addatindex(size, val);\n  }\n\n  public void addatindex(int index, int val) {\n    \n    if (index > size) return;\n\n    if (index < 0) index = 0;\n\n    ++size;\n    // find predecessor of the node to be added\n    listnode pred = head;\n    for(int i = 0; i < index; ++i) {\n      pred = pred.next;\n    }\n\n    // node to be added\n    listnode toadd = new listnode(val);\n    // insertion itself\n    toadd.next = pred.next;\n    pred.next = toadd;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 删除\n\n类似的，在单链表中数据元素的删除也是通过结点的删除来完成的。在链表的不同位置删除结点，其操作过程也会有一些差别。\n\n\n\n在单链表中删除一个结点时，除首结点外都必须知道该结点的直接前驱结点的引用。并且在已知单链表中某个结点引用的基础上，完成其后续结点的删除操作需要的时间是 。\n\n> 在使用单链表实现线性表的时候，为了使程序更加简洁，我们通常在单链表的最前面添加一个哑元结点，也称为头结点。在头结点中不存储任何实质的数据对象，其 next 域指向线性表中 0 号元素所在的结点，头结点的引入可以使线性表运算中的一些边界条件更容易处理。\n> \n> 对于任何基于序号的插入、删除，以及任何基于数据元素所在结点的前面或后面的插入、删除，在带头结点的单链表中均可转化为在某个特定结点之后完成结点的插入、删除，而不用考虑插入、删除是在链表的首部、中间、还是尾部等不同情况。\n\n\n\n  public void deleteatindex(int index) {\n    // if the index is invalid, do nothing\n    if (index < 0 || index >= size) return;\n\n    size--;\n    // find predecessor of the node to be deleted\n    listnode pred = head;\n    for(int i = 0; i < index; ++i) {\n      pred = pred.next;\n    }\n\n    // delete pred.next \n    pred.next = pred.next.next;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 双向链表\n\n单链表的一个优点是结构简单，但是它也有一个缺点，即在单链表中只能通过一个结点的引用访问其后续结点，而无法直接访问其前驱结点，要在单链表中找到某个结点的前驱结点，必须从链表的首结点出发依次向后寻找，但是需要 时间。\n\n所以我们在单链表结点结构中新增加一个域，该域用于指向结点的直接前驱结点。\n\n\n\n双向链表是通过上述定义的结点使用 pre 以及 next 域依次串联在一起而形成的。一个双向链表的结构如下图所示。\n\n\n\n接着我们来看下双向链表的 crud：\n\n以下是双链表中结点的典型定义：\n\npublic class listnode {\n  int val;\n  listnode next;\n  listnode prev;\n  listnode(int x) { val = x; }\n}\n\nclass mylinkedlist {\n  int size;\n  // sentinel nodes as pseudo-head and pseudo-tail\n  listnode head, tail;\n  public mylinkedlist() {\n    size = 0;\n    head = new listnode(0);\n    tail = new listnode(0);\n    head.next = tail;\n    tail.prev = head;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 查找\n\n在双向链表中进行查找与在单链表中类似，只不过在双向链表中查找操作可以从链表的首结点开始，也可以从尾结点开始，但是需要的时间和在单链表中一样。\n\n  /** get the value of the index-th node in the linked list. if the index is invalid, return -1. */\n  public int get(int index) {\n    if (index < 0 || index >= size) return -1;\n\n    listnode curr = head;\n    if (index + 1 < size - index)\n      for(int i = 0; i < index + 1; ++i) {\n        curr = curr.next;\n      }\n    else {\n      curr = tail;\n      for(int i = 0; i < size - index; ++i) {\n        curr = curr.prev;\n      }\n    }\n\n    return curr.val;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 添加\n\n单链表的插入操作，除了首结点之外必须在某个已知结点后面进行，而在双向链表中插入操作在一个已知的结点之前或之后都可以进行，如下表示在结点 11 之前 插入 9。\n\n\n\n使用 java 语言实现整个过程的关键语句是\n\n  public void addathead(int val) {\n    listnode pred = head, succ = head.next;\n\n    ++size;\n    listnode toadd = new listnode(val);\n    toadd.prev = pred;\n    toadd.next = succ;\n    pred.next = toadd;\n    succ.prev = toadd;\n  }\n\n  /** append a node of value val to the last element of the linked list. */\n  public void addattail(int val) {\n    listnode succ = tail, pred = tail.prev;\n\n    ++size;\n    listnode toadd = new listnode(val);\n    toadd.prev = pred;\n    toadd.next = succ;\n    pred.next = toadd;\n    succ.prev = toadd;\n  }\n\n  public void addatindex(int index, int val) {\n    if (index > size) return;\n\n    if (index < 0) index = 0;\n\n    listnode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index; ++i) succ = succ.prev;\n      pred = succ.prev;\n    }\n\n    // insertion itself\n    ++size;\n    listnode toadd = new listnode(val);\n    toadd.prev = pred;\n    toadd.next = succ;\n    pred.next = toadd;\n    succ.prev = toadd;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n在结点 p 之后插入一个新结点的操作与上述操作对称，这里不再赘述。\n\n插入操作除了上述情况，还可以在双向链表的首结点之前、双向链表的尾结点之后进行，此时插入操作与上述插入操作相比更为简单。\n\n\n# 删除\n\n单链表的删除操作，除了首结点之外必须在知道待删结点的前驱结点的基础上才能进行，而在双向链表中在已知某个结点引用的前提下，可以完成该结点自身的删除。如下表示删除 16 的过程。\n\n\n\n\t/** delete the index-th node in the linked list, if the index is valid. */\n  public void deleteatindex(int index) {\n    if (index < 0 || index >= size) return;\n\n    listnode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index - 1; ++i) succ = succ.prev;\n      pred = succ.prev.prev;\n    }\n\n    // delete pred.next \n    --size;\n    pred.next = succ;\n    succ.prev = pred;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n对线性表的操作，无非就是排序、加法、减法、反转，说的好像很简单，我们去下一章刷题吧\n\n\n# 参考\n\n链表",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"图",frontmatter:{title:"图",date:"2022-10-11T22:56:33.000Z",permalink:"/pages/83330c/",categories:["计算机基础","数据结构"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/40.%E5%9B%BE.html",relativePath:"02.计算机基础/30.数据结构/40.图.md",key:"v-8228d7f2",path:"/pages/83330c/",headers:[{level:2,title:"图的基本概念",slug:"图的基本概念",normalizedTitle:"图的基本概念",charIndex:298},{level:3,title:"顶点",slug:"顶点",normalizedTitle:"顶点",charIndex:161},{level:3,title:"边",slug:"边",normalizedTitle:"边",charIndex:176},{level:3,title:"度",slug:"度",normalizedTitle:"度",charIndex:427},{level:3,title:"无向图和有向图",slug:"无向图和有向图",normalizedTitle:"无向图和有向图",charIndex:520},{level:3,title:"无权图和带权图",slug:"无权图和带权图",normalizedTitle:"无权图和带权图",charIndex:720},{level:2,title:"图的存储",slug:"图的存储",normalizedTitle:"图的存储",charIndex:887},{level:3,title:"邻接矩阵存储",slug:"邻接矩阵存储",normalizedTitle:"邻接矩阵存储",charIndex:896},{level:3,title:"邻接表存储",slug:"邻接表存储",normalizedTitle:"邻接表存储",charIndex:1217},{level:2,title:"图的搜索",slug:"图的搜索",normalizedTitle:"图的搜索",charIndex:1507},{level:3,title:"广度优先搜索",slug:"广度优先搜索",normalizedTitle:"广度优先搜索",charIndex:1516},{level:3,title:"深度优先搜索",slug:"深度优先搜索",normalizedTitle:"深度优先搜索",charIndex:1656}],headersStr:"图的基本概念 顶点 边 度 无向图和有向图 无权图和带权图 图的存储 邻接矩阵存储 邻接表存储 图的搜索 广度优先搜索 深度优先搜索",content:"图是一种较为复杂的非线性结构。 为啥说其较为复杂呢？\n\n根据前面的内容，我们知道：\n\n * 线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。\n * 树形数据结构的元素之间有着明显的层次关系。\n\n但是，图形结构的元素之间的关系是任意的。\n\n何为图呢？ 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：G(V,E)，其中，G表示一个图，V表示顶点的集合，E表示边的集合。\n\n下图所展示的就是图这种数据结构，并且还是一张有向图。\n\n\n\n图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。\n\n\n# 图的基本概念\n\n\n# 顶点\n\n图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）\n\n对应到好友关系图，每一个用户就代表一个顶点。\n\n\n# 边\n\n顶点之间的关系用边表示。\n\n对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。\n\n\n# 度\n\n度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。\n\n对应到好友关系图，度就代表了某个人的好友数量。\n\n\n# 无向图和有向图\n\n边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。\n\n有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。\n\n\n# 无权图和带权图\n\n对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。\n\n对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。\n\n下图就是一个带权有向图。\n\n\n\n\n# 图的存储\n\n\n# 邻接矩阵存储\n\n邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。\n\n如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 A[i][j]=n 。\n\n在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。如下图所示：\n\n\n\n值得注意的是：无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。\n\n\n\n邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，\n\n\n# 邻接表存储\n\n针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—邻接表 。\n\n邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 邻接表。如下图所示：\n\n\n\n\n\n大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：\n\n * 在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。\n * 在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。\n\n\n# 图的搜索\n\n\n# 广度优先搜索\n\n广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：\n\n\n\n广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列 。具体过程如下图所示：\n\n第1步：\n\n\n\n第2步：\n\n\n\n第3步：\n\n\n\n第4步：\n\n\n\n第5步：\n\n\n\n第6步：\n\n\n\n\n# 深度优先搜索\n\n深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：\n\n\n\n和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈 。具体过程如下图所示：\n\n第1步：\n\n\n\n第2步：\n\n\n\n第3步：\n\n\n\n第4步：\n\n\n\n第5步：\n\n\n\n第6步：\n\n",normalizedContent:"图是一种较为复杂的非线性结构。 为啥说其较为复杂呢？\n\n根据前面的内容，我们知道：\n\n * 线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。\n * 树形数据结构的元素之间有着明显的层次关系。\n\n但是，图形结构的元素之间的关系是任意的。\n\n何为图呢？ 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：g(v,e)，其中，g表示一个图，v表示顶点的集合，e表示边的集合。\n\n下图所展示的就是图这种数据结构，并且还是一张有向图。\n\n\n\n图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。\n\n\n# 图的基本概念\n\n\n# 顶点\n\n图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）\n\n对应到好友关系图，每一个用户就代表一个顶点。\n\n\n# 边\n\n顶点之间的关系用边表示。\n\n对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。\n\n\n# 度\n\n度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。\n\n对应到好友关系图，度就代表了某个人的好友数量。\n\n\n# 无向图和有向图\n\n边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，a是b的同学，那么b也肯定是a的同学，那么在表示a和b的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。\n\n有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，a是b的爸爸，但b肯定不是a的爸爸，a关注b，b不一定关注a。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。\n\n\n# 无权图和带权图\n\n对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。\n\n对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。\n\n下图就是一个带权有向图。\n\n\n\n\n# 图的存储\n\n\n# 邻接矩阵存储\n\n邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。\n\n如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 a[i][j]=n 。\n\n在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，a[i][j]=1，当顶点i和顶点j没有关系时，a[i][j]=0。如下图所示：\n\n\n\n值得注意的是：无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。\n\n\n\n邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，\n\n\n# 邻接表存储\n\n针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—邻接表 。\n\n邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点vi，把所有邻接于vi的顶点vj链成一个单链表，这个单链表称为顶点vi的 邻接表。如下图所示：\n\n\n\n\n\n大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：\n\n * 在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。\n * 在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。\n\n\n# 图的搜索\n\n\n# 广度优先搜索\n\n广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：\n\n\n\n广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列 。具体过程如下图所示：\n\n第1步：\n\n\n\n第2步：\n\n\n\n第3步：\n\n\n\n第4步：\n\n\n\n第5步：\n\n\n\n第6步：\n\n\n\n\n# 深度优先搜索\n\n深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：\n\n\n\n和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈 。具体过程如下图所示：\n\n第1步：\n\n\n\n第2步：\n\n\n\n第3步：\n\n\n\n第4步：\n\n\n\n第5步：\n\n\n\n第6步：\n\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"递归",frontmatter:{title:"递归",date:"2022-03-11T00:38:43.000Z",permalink:"/pages/92288a/",categories:["计算机基础","CSS"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/40.%E7%AE%97%E6%B3%95/01.%E9%80%92%E5%BD%92.html",relativePath:"02.计算机基础/40.算法/01.递归.md",key:"v-774fbc7c",path:"/pages/92288a/",headers:[{level:2,title:"基础篇之递归",slug:"基础篇之递归",normalizedTitle:"基础篇之递归",charIndex:2},{level:3,title:"如何理解递归",slug:"如何理解递归",normalizedTitle:"如何理解递归",charIndex:162},{level:3,title:"递归需要满足的三个条件",slug:"递归需要满足的三个条件",normalizedTitle:"递归需要满足的三个条件",charIndex:757},{level:3,title:"怎样编写递归代码",slug:"怎样编写递归代码",normalizedTitle:"怎样编写递归代码",charIndex:1112},{level:3,title:"递归代码要警惕堆栈溢出",slug:"递归代码要警惕堆栈溢出",normalizedTitle:"递归代码要警惕堆栈溢出",charIndex:2574},{level:3,title:"递归代码要警惕重复计算",slug:"递归代码要警惕重复计算",normalizedTitle:"递归代码要警惕重复计算",charIndex:3210},{level:3,title:"怎么将递归代码改写为非递归代码",slug:"怎么将递归代码改写为非递归代码",normalizedTitle:"怎么将递归代码改写为非递归代码",charIndex:3952},{level:3,title:"解答开篇",slug:"解答开篇",normalizedTitle:"解答开篇",charIndex:4702},{level:3,title:"内容小结",slug:"内容小结",normalizedTitle:"内容小结",charIndex:5228},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:267},{level:3,title:"案例1：斐波那契数列",slug:"案例1-斐波那契数列",normalizedTitle:"案例1：斐波那契数列",charIndex:5441},{level:3,title:"案例2：小青蛙跳台阶",slug:"案例2-小青蛙跳台阶",normalizedTitle:"案例2：小青蛙跳台阶",charIndex:6145},{level:2,title:"有关递归的一些优化思路",slug:"有关递归的一些优化思路",normalizedTitle:"有关递归的一些优化思路",charIndex:7339}],headersStr:"基础篇之递归 如何理解递归 递归需要满足的三个条件 怎样编写递归代码 递归代码要警惕堆栈溢出 递归代码要警惕重复计算 怎么将递归代码改写为非递归代码 解答开篇 内容小结 案例 案例1：斐波那契数列 案例2：小青蛙跳台阶 有关递归的一些优化思路",content:"# 基础篇之递归\n\n> 现在很多 App 都有这个推荐注册返佣金功能。这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。基于此，如何查找指定用户的“最终推荐人”？\n\n\n# 如何理解递归\n\n递归是一种应用非常广泛的算法或者编程技巧。很多数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等等。所以搞懂递归对学习一些复杂的数据结构和算法是非常有必要的。\n\n案例：周末带着女朋友去电影院看电影，女朋友问，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在怎么办？\n\n于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。\n\n这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。比如上面的案例我们用递推公式将它表示出来就是这样：\n\nf(n) = f(n-1) + 1 其中 f(1) = 1\n\n\n1\n\n\nf(n)表示想知道自己在哪一排，f(n-1)表示前面一排所在的排数，f(1) = 1表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码：\n\nint f(int n) {\n  if (n == 1) return 1;\n  return f(n - 1) + 1;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 递归需要满足的三个条件\n\n只要同时满足以下三个条件，就可以用递归来解决。\n\n 1. 一个问题的解可以分解为几个子问题的解\n    \n    何为子问题？子问题就是数据规模更小的问题。比如前面的案例，要知道“自己在哪一排”，可以分解为“前一排的人在哪一排”这样的一个子问题。\n\n 2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样\n    \n    如案例所示，求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路是一模一样的。\n\n 3. 存在递归终止条件\n    \n    把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。前面的案例：第一排的人知道自己在哪一排，不需要再问别人，f(1) = 1就是递归的终止条件。\n\n\n# 怎样编写递归代码\n\n写递归代码最关键的是写出递推公式，找到终止条件，剩下就是将递推公式转化为代码。\n\n案例：假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？\n\n我们可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法 加上先走2阶后，n-2个台阶的走法，用公式表示：\n\nf(n) = f(n-1) + f(n-2)\n\n\n1\n\n\n再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以f(1) = 1。这个递归终止条件足够吗？我们试试用n = 2， n = 3这样比较小的数实验一下。\n\nn = 2时，f(2) = f(1) + f(0)。如果递归终止条件只有一个f(1) = 1，那f(2)就无法求解了。所以除了f(1) = 1这一个递归终止条件外，还要有f(0) = 1，表示走0个台阶有一种走法，不过这样看起来不符合正常的逻辑思维。所以，我们可以把f(2) = 2作为一种终止条件，表示走2个台阶，只有两种走法，一步走完或者分两步走。\n\n所以，递归终止条件就是f(1) = 1，f(2) = 2。这个时候，可以再拿n = 3，n = 4来验证下，这个终止条件是否足够并且正确。\n\n我们把递归终止条件和刚刚得到的递推公式放在一起就是这样：\n\nf(1) = 1;\nf(2) = 2;\nf(n) = f(n - 1) + f(n - 2);\n\n\n1\n2\n3\n\n\n最终的递归代码就是这样：\n\nint f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  return f(n -1) + f(n - 2);\n}\n\n\n1\n2\n3\n4\n5\n\n\n写递归代码的关键就是找到如何将大问题分解为小问题的规律，请求基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。\n\n> 当我们面对一个问题需要分解为多个子问题的时候，递归代码往往没那么好理解，比如第二个案例，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。\n> \n> 计算机擅长做重复的事情，所以递归正符合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。\n> \n> 对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？\n> \n> 如果一个问题 A 可以分解为若干子问题 B、C、D，可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。\n\n所以，编写递归代码的关键是：只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。\n\n\n# 递归代码要警惕堆栈溢出\n\n在实际开发中，编写递归代码我们通常会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果非常严重。为什么递归代码容易造成堆栈溢出呢？\n\n我们知道在函数调用时，会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险，出现java.lang.StackOverflowError。\n\n如何避免出现堆栈溢出？\n\n可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度(比如1000)之后，我们就不再继续往下递归了，直接返回报错。比如前面电影院的案例，改造后的伪代码如下：\n\n// 全局变量，表示递归的深度。\nint depth = 0;\n\nint f(int n) {\n  ++depth;\n  if (depth > 1000) throw exception;\n  \n  if (n == 1) return 1;\n  return f(n-1) + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码又会过于复杂，影响到代码的可读性。所以如果最大深度比较小，比如10、50，还可以用这种方法，否则这种方法不是很实用。\n\n\n# 递归代码要警惕重复计算\n\n使用递归时要注意重复计算的问题，比如案例二，我们把整个递归过程分解一下，那就是这样的：\n\n\n\n从图中，我们可以看到，想要计算f(5)，需要先计算f(4)和f(3)，而计算f(4)还需要计算f(3)，因此，f(3)就被计算了很多次，这就是重复计算的问题。\n\n为了解决重复计算，我们可以通过散列表等数据结构来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，就不再重复计算了。\n\n如上思路，改造下刚才到代码：\n\npublic int f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  \n  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)\n  if (hasSolvedList.containsKey(n)) {\n    return hasSovledList.get(n);\n  }\n  \n  int ret = f(n-1) + f(n-2);\n  hasSovledList.put(n, ret);\n  return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n除了堆栈溢出、重复计算这两个常见的问题，递归代码还有很多别的问题。\n\n在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积累成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如前面的案例一的递归代码，空间复杂度并不是O(1)，而是O(n)。\n\n\n# 怎么将递归代码改写为非递归代码\n\n递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以在开发中，我们要根据实际情况来选择是否需要用递归的方式来实现。\n\n所以刚才的递归案例代码可以做如下修改：\n\n//案例一\nint f(int n) {\n  int ret = 1;\n  for (int i = 2; i <= n; ++i) {\n    ret = ret + 1;\n  }\n  return ret;\n}\n//案例二\nint f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  \n  int ret = 0;\n  int pre = 2;\n  int prepre = 1;\n  for (int i = 3; i <= n; ++i) {\n    ret = pre + prepre;\n    prepre = pre;\n    pre = ret;\n  }\n  return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n笼统地讲，所有的递归代码都可以改为这种迭代循环的非递归代码。\n\n> 因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。\n> \n> 但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。\n\n\n# 解答开篇\n\n如何找到“最终推荐人”？解决方案：\n\nlong findRootReferrerId(long actorId) {\n  Long referrerId = select referrer_id from [table] where actor_id = actorId;\n  if (referrerId == null) return actorId;\n  return findRootReferrerId(referrerId);\n}\n\n\n1\n2\n3\n4\n5\n\n\n以上三行代码就搞定了，不过在实际项目中，可能会出现两个问题。\n\n 1. 如果递归很深，可能会有堆栈溢出的问题。\n\n 2. 如果数据库存在脏数据，可能会出现无限递归的问题。\n    \n    比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C的推荐人是A，这样就会发生死循环。\n\n如何解决？\n\n第一个问题可以用前面解答过的限制递归深度来解决。\n\n第二个问题也可以用限制递归深度来解决，但还有一个高级的处理办法，就是自动检测A->B->C->A这种“环”存在。如何自动检测，后面再谈。\n\n\n# 内容小结\n\n递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。\n\n不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。\n\n递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。\n\n\n# 案例\n\n\n# 案例1：斐波那契数列\n\n> 斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34....，即第一项 f(1) = 1,第二项 f(2) = 1.....,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。\n\n1、第一递归函数功能\n\n假设 f(n) 的功能是求第 n 项的值，代码如下：\n\nint f(int n){\n    \n}\n\n\n1\n2\n3\n\n\n2、找出递归结束的条件\n\n显然，当 n = 1 或者 n = 2 ,我们可以轻易着知道结果 f(1) = f(2) = 1。所以递归结束条件可以为 n <= 2。代码如下：\n\nint f(int n){\n    if(n <= 2){\n        return 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三要素：找出函数的等价关系式\n\n题目已经把等价关系式给我们了，所以我们很容易就能够知道 f(n) = f(n-1) + f(n-2)。我说过，等价关系式是最难找的一个，而这个题目却把关系式给我们了，这也太容易，好吧，我这是为了兼顾几乎零基础的读者。\n\n所以最终代码如下：\n\nint f(int n){\n    // 1.先写递归结束条件\n    if(n <= 2){\n        return 1;\n    }\n    // 2.接着写等价关系式\n    return f(n-1) + f(n - 2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n搞定，是不是很简单？\n\n> 零基础的可能还是不大懂，没关系，之后慢慢按照这个模式练习！好吧，有大佬可能在吐槽太简单了。\n\n\n# 案例2：小青蛙跳台阶\n\n> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n1、第一递归函数功能\n\n假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：\n\nint f(int n){\n    \n}\n\n\n1\n2\n3\n\n\n2、找出递归结束的条件\n\n我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下：\n\nint f(int n){\n    if(n == 1){\n        return 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三要素：找出函数的等价关系式\n\n每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。\n\n第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。\n\n第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。\n\n所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：\n\nint f(int n){\n    if(n == 1){\n        return 1;\n    }\n    ruturn f(n-1) + f(n-2);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n大家觉得上面的代码对不对？\n\n答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。\n\n这也是我要和你们说的，关于递归结束条件是否够严谨问题，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：\n\nint f(int n){\n    //f(0) = 0,f(1) = 1，等价于 n<=1时，f(n) = n。\n    if(n <= 1){\n        return n;\n    }\n    ruturn f(n-1) + f(n-2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 有关递归的一些优化思路\n\n1. 考虑是否重复计算\n\n告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。\n\n> 啥是子问题？ f(n-1),f(n-2)....就是 f(n) 的子问题了。\n\n例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：\n\n\n\n看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。\n\n如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。\n\n用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。\n\n当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：\n\n// 我们实现假定 arr 数组已经初始化好的了。\nint f(int n){\n    if(n <= 1){\n        return n;\n    }\n    //先判断有没计算过\n    if(arr[n] != -1){\n        //计算过，直接返回\n        return arr[n];\n    }else{\n        // 没有计算过，递归计算,并且把结果保存到 arr数组里\n        arr[n] = f(n-1) + f(n-1);\n        reutrn arr[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。\n\n2. 考虑是否可以自底向上\n\n对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。\n\n不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n <=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。\n\n对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道\n\nf(1) = 1;\n\nf(2) = 2;\n\n那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下：\n\npublic int f(int n) {\n       if(n <= 2)\n           return n;\n       int f1 = 1;\n       int f2 = 2;\n       int sum = 0;\n\n       for (int i = 3; i <= n; i++) {\n           sum = f1 + f2;\n           f1 = f2;\n           f2 = sum;\n       }\n       return sum;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这种方法，其实也被称之为递推。",normalizedContent:"# 基础篇之递归\n\n> 现在很多 app 都有这个推荐注册返佣金功能。这个功能中，用户 a 推荐用户 b 来注册，用户 b 又推荐了用户 c 来注册。我们可以说，用户 c 的“最终推荐人”为用户 a，用户 b 的“最终推荐人”也为用户 a，而用户 a 没有“最终推荐人”。基于此，如何查找指定用户的“最终推荐人”？\n\n\n# 如何理解递归\n\n递归是一种应用非常广泛的算法或者编程技巧。很多数据结构和算法的编码实现都要用到递归，比如dfs深度优先搜索、前中后序二叉树遍历等等。所以搞懂递归对学习一些复杂的数据结构和算法是非常有必要的。\n\n案例：周末带着女朋友去电影院看电影，女朋友问，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在怎么办？\n\n于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。\n\n这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。比如上面的案例我们用递推公式将它表示出来就是这样：\n\nf(n) = f(n-1) + 1 其中 f(1) = 1\n\n\n1\n\n\nf(n)表示想知道自己在哪一排，f(n-1)表示前面一排所在的排数，f(1) = 1表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码：\n\nint f(int n) {\n  if (n == 1) return 1;\n  return f(n - 1) + 1;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 递归需要满足的三个条件\n\n只要同时满足以下三个条件，就可以用递归来解决。\n\n 1. 一个问题的解可以分解为几个子问题的解\n    \n    何为子问题？子问题就是数据规模更小的问题。比如前面的案例，要知道“自己在哪一排”，可以分解为“前一排的人在哪一排”这样的一个子问题。\n\n 2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样\n    \n    如案例所示，求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路是一模一样的。\n\n 3. 存在递归终止条件\n    \n    把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。前面的案例：第一排的人知道自己在哪一排，不需要再问别人，f(1) = 1就是递归的终止条件。\n\n\n# 怎样编写递归代码\n\n写递归代码最关键的是写出递推公式，找到终止条件，剩下就是将递推公式转化为代码。\n\n案例：假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？\n\n我们可以根据第一步的走法把所有走法分为两类，第一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以n个台阶的走法就等于先走1阶后，n-1个台阶的走法 加上先走2阶后，n-2个台阶的走法，用公式表示：\n\nf(n) = f(n-1) + f(n-2)\n\n\n1\n\n\n再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以f(1) = 1。这个递归终止条件足够吗？我们试试用n = 2， n = 3这样比较小的数实验一下。\n\nn = 2时，f(2) = f(1) + f(0)。如果递归终止条件只有一个f(1) = 1，那f(2)就无法求解了。所以除了f(1) = 1这一个递归终止条件外，还要有f(0) = 1，表示走0个台阶有一种走法，不过这样看起来不符合正常的逻辑思维。所以，我们可以把f(2) = 2作为一种终止条件，表示走2个台阶，只有两种走法，一步走完或者分两步走。\n\n所以，递归终止条件就是f(1) = 1，f(2) = 2。这个时候，可以再拿n = 3，n = 4来验证下，这个终止条件是否足够并且正确。\n\n我们把递归终止条件和刚刚得到的递推公式放在一起就是这样：\n\nf(1) = 1;\nf(2) = 2;\nf(n) = f(n - 1) + f(n - 2);\n\n\n1\n2\n3\n\n\n最终的递归代码就是这样：\n\nint f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  return f(n -1) + f(n - 2);\n}\n\n\n1\n2\n3\n4\n5\n\n\n写递归代码的关键就是找到如何将大问题分解为小问题的规律，请求基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。\n\n> 当我们面对一个问题需要分解为多个子问题的时候，递归代码往往没那么好理解，比如第二个案例，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。\n> \n> 计算机擅长做重复的事情，所以递归正符合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。\n> \n> 对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？\n> \n> 如果一个问题 a 可以分解为若干子问题 b、c、d，可以假设子问题 b、c、d 已经解决，在此基础上思考如何解决问题 a。而且，只需要思考问题 a 与子问题 b、c、d 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。\n\n所以，编写递归代码的关键是：只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。\n\n\n# 递归代码要警惕堆栈溢出\n\n在实际开发中，编写递归代码我们通常会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果非常严重。为什么递归代码容易造成堆栈溢出呢？\n\n我们知道在函数调用时，会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险，出现java.lang.stackoverflowerror。\n\n如何避免出现堆栈溢出？\n\n可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度(比如1000)之后，我们就不再继续往下递归了，直接返回报错。比如前面电影院的案例，改造后的伪代码如下：\n\n// 全局变量，表示递归的深度。\nint depth = 0;\n\nint f(int n) {\n  ++depth;\n  if (depth > 1000) throw exception;\n  \n  if (n == 1) return 1;\n  return f(n-1) + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码又会过于复杂，影响到代码的可读性。所以如果最大深度比较小，比如10、50，还可以用这种方法，否则这种方法不是很实用。\n\n\n# 递归代码要警惕重复计算\n\n使用递归时要注意重复计算的问题，比如案例二，我们把整个递归过程分解一下，那就是这样的：\n\n\n\n从图中，我们可以看到，想要计算f(5)，需要先计算f(4)和f(3)，而计算f(4)还需要计算f(3)，因此，f(3)就被计算了很多次，这就是重复计算的问题。\n\n为了解决重复计算，我们可以通过散列表等数据结构来保存已经求解过的f(k)。当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，就不再重复计算了。\n\n如上思路，改造下刚才到代码：\n\npublic int f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  \n  // hassolvedlist 可以理解成一个 map，key 是 n，value 是 f(n)\n  if (hassolvedlist.containskey(n)) {\n    return hassovledlist.get(n);\n  }\n  \n  int ret = f(n-1) + f(n-2);\n  hassovledlist.put(n, ret);\n  return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n除了堆栈溢出、重复计算这两个常见的问题，递归代码还有很多别的问题。\n\n在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积累成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如前面的案例一的递归代码，空间复杂度并不是o(1)，而是o(n)。\n\n\n# 怎么将递归代码改写为非递归代码\n\n递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以在开发中，我们要根据实际情况来选择是否需要用递归的方式来实现。\n\n所以刚才的递归案例代码可以做如下修改：\n\n//案例一\nint f(int n) {\n  int ret = 1;\n  for (int i = 2; i <= n; ++i) {\n    ret = ret + 1;\n  }\n  return ret;\n}\n//案例二\nint f(int n) {\n  if (n == 1) return 1;\n  if (n == 2) return 2;\n  \n  int ret = 0;\n  int pre = 2;\n  int prepre = 1;\n  for (int i = 3; i <= n; ++i) {\n    ret = pre + prepre;\n    prepre = pre;\n    pre = ret;\n  }\n  return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n笼统地讲，所有的递归代码都可以改为这种迭代循环的非递归代码。\n\n> 因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。\n> \n> 但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。\n\n\n# 解答开篇\n\n如何找到“最终推荐人”？解决方案：\n\nlong findrootreferrerid(long actorid) {\n  long referrerid = select referrer_id from [table] where actor_id = actorid;\n  if (referrerid == null) return actorid;\n  return findrootreferrerid(referrerid);\n}\n\n\n1\n2\n3\n4\n5\n\n\n以上三行代码就搞定了，不过在实际项目中，可能会出现两个问题。\n\n 1. 如果递归很深，可能会有堆栈溢出的问题。\n\n 2. 如果数据库存在脏数据，可能会出现无限递归的问题。\n    \n    比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果a的推荐人是b，b的推荐人是c，c的推荐人是a，这样就会发生死循环。\n\n如何解决？\n\n第一个问题可以用前面解答过的限制递归深度来解决。\n\n第二个问题也可以用限制递归深度来解决，但还有一个高级的处理办法，就是自动检测a->b->c->a这种“环”存在。如何自动检测，后面再谈。\n\n\n# 内容小结\n\n递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。\n\n不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。\n\n递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。\n\n\n# 案例\n\n\n# 案例1：斐波那契数列\n\n> 斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34....，即第一项 f(1) = 1,第二项 f(2) = 1.....,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。\n\n1、第一递归函数功能\n\n假设 f(n) 的功能是求第 n 项的值，代码如下：\n\nint f(int n){\n    \n}\n\n\n1\n2\n3\n\n\n2、找出递归结束的条件\n\n显然，当 n = 1 或者 n = 2 ,我们可以轻易着知道结果 f(1) = f(2) = 1。所以递归结束条件可以为 n <= 2。代码如下：\n\nint f(int n){\n    if(n <= 2){\n        return 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三要素：找出函数的等价关系式\n\n题目已经把等价关系式给我们了，所以我们很容易就能够知道 f(n) = f(n-1) + f(n-2)。我说过，等价关系式是最难找的一个，而这个题目却把关系式给我们了，这也太容易，好吧，我这是为了兼顾几乎零基础的读者。\n\n所以最终代码如下：\n\nint f(int n){\n    // 1.先写递归结束条件\n    if(n <= 2){\n        return 1;\n    }\n    // 2.接着写等价关系式\n    return f(n-1) + f(n - 2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n搞定，是不是很简单？\n\n> 零基础的可能还是不大懂，没关系，之后慢慢按照这个模式练习！好吧，有大佬可能在吐槽太简单了。\n\n\n# 案例2：小青蛙跳台阶\n\n> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n1、第一递归函数功能\n\n假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：\n\nint f(int n){\n    \n}\n\n\n1\n2\n3\n\n\n2、找出递归结束的条件\n\n我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下：\n\nint f(int n){\n    if(n == 1){\n        return 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三要素：找出函数的等价关系式\n\n每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。\n\n第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。\n\n第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。\n\n所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：\n\nint f(int n){\n    if(n == 1){\n        return 1;\n    }\n    ruturn f(n-1) + f(n-2);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n大家觉得上面的代码对不对？\n\n答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入死循环。\n\n这也是我要和你们说的，关于递归结束条件是否够严谨问题，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：\n\nint f(int n){\n    //f(0) = 0,f(1) = 1，等价于 n<=1时，f(n) = n。\n    if(n <= 1){\n        return n;\n    }\n    ruturn f(n-1) + f(n-2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 有关递归的一些优化思路\n\n1. 考虑是否重复计算\n\n告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。\n\n> 啥是子问题？ f(n-1),f(n-2)....就是 f(n) 的子问题了。\n\n例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：\n\n\n\n看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。\n\n如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。\n\n用什么保存呢？可以用数组或者 hashmap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。\n\n当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：\n\n// 我们实现假定 arr 数组已经初始化好的了。\nint f(int n){\n    if(n <= 1){\n        return n;\n    }\n    //先判断有没计算过\n    if(arr[n] != -1){\n        //计算过，直接返回\n        return arr[n];\n    }else{\n        // 没有计算过，递归计算,并且把结果保存到 arr数组里\n        arr[n] = f(n-1) + f(n-1);\n        reutrn arr[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。\n\n2. 考虑是否可以自底向上\n\n对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。\n\n不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n <=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。\n\n对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道\n\nf(1) = 1;\n\nf(2) = 2;\n\n那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下：\n\npublic int f(int n) {\n       if(n <= 2)\n           return n;\n       int f1 = 1;\n       int f2 = 2;\n       int sum = 0;\n\n       for (int i = 3; i <= n; i++) {\n           sum = f1 + f2;\n           f1 = f2;\n           f2 = sum;\n       }\n       return sum;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这种方法，其实也被称之为递推。",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"栈",frontmatter:{title:"栈",date:"2022-10-11T22:44:06.000Z",permalink:"/pages/f27af6/",categories:["计算机基础","数据结构"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%A0%88.html",relativePath:"02.计算机基础/30.数据结构/10.栈.md",key:"v-2680fed9",path:"/pages/f27af6/",headers:[{level:2,title:"一、概述",slug:"一、概述",normalizedTitle:"一、概述",charIndex:2},{level:3,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:11},{level:3,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:463},{level:2,title:"二、栈的顺序存储与实现",slug:"二、栈的顺序存储与实现",normalizedTitle:"二、栈的顺序存储与实现",charIndex:973},{level:2,title:"三、栈的链式存储与实现",slug:"三、栈的链式存储与实现",normalizedTitle:"三、栈的链式存储与实现",charIndex:2647},{level:2,title:"四、JDK 中的栈实现 Stack",slug:"四、jdk-中的栈实现-stack",normalizedTitle:"四、jdk 中的栈实现 stack",charIndex:4638},{level:3,title:"Stack的继承关系",slug:"stack的继承关系",normalizedTitle:"stack的继承关系",charIndex:4772},{level:2,title:"五、栈应用",slug:"五、栈应用",normalizedTitle:"五、栈应用",charIndex:5005},{level:3,title:"有效的括号",slug:"有效的括号",normalizedTitle:"有效的括号",charIndex:5042}],headersStr:"一、概述 定义 基本操作 二、栈的顺序存储与实现 三、栈的链式存储与实现 四、JDK 中的栈实现 Stack Stack的继承关系 五、栈应用 有效的括号",content:'# 一、概述\n\n\n# 定义\n\n注意：本文所说的栈是数据结构中的栈，而不是内存模型中栈\n\n栈（stack）是限定仅在表尾一端进行插入或删除操作的特殊线性表。又称为堆栈。\n\n对于栈来说, 允许进行插入或删除操作的一端称为栈顶（top），而另一端称为栈底（bottom）。不含元素栈称为空栈，向栈中插入一个新元素称为入栈或压栈， 从栈中删除一个元素称为出栈或退栈。\n\n假设有一个栈Ｓ＝（a1, a2, …, an)，a1先进栈， an最后进栈。称 a1 为栈底元素，an 为栈顶元素。出栈时只允许在栈顶进行，所以 an 先出栈，a1最后出栈。因此又称栈为后进先出（Last In First Out，LIFO）的线性表。\n\n栈（stack），是一种线性存储结构，它有以下几个特点：\n\n * 栈中数据是按照"后进先出（LIFO, Last In First Out）"方式进出栈的。\n * 向栈中添加/删除数据时，只能从栈顶进行操作。\n\n\n\n在上图中，当 ABCD 均已入栈后，出栈时得到的序列为 DCBA，这就是后进先出。\n\n\n# 基本操作\n\n栈的基本操作除了进栈 push()，出栈 pop() 之外，还有判空 isEmpty()、取栈顶元素 peek() 等操作。\n\n抽象成接口如下：\n\npublic interface MyStack {\n\n    /**\n     * 返回堆栈的大小\n     */\n    public int getSize();\n\n    /**\n     * 判断堆栈是否为空\n     */\n    public boolean isEmpty();\n\n    /**\n     * 入栈\n     */\n    public void push(Object e);\n\n    /**\n     * 出栈，并删除\n     */\n    public Object pop();\n\n    /**\n     * 返回栈顶元素\n     */\n    public Object peek();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n和线性表类似，栈也有两种存储结构：顺序存储和链式存储。\n\n\n# 二、栈的顺序存储与实现\n\n顺序栈是使用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放栈中的数据元素。由于栈是一种特殊的线性表，因此在线性表的顺序存储结构的基础上，选择线性表的一端作为栈顶即可。那么根据数组操作的特性，选择数组下标大的一端，即线性表顺序存储的表尾来作为栈顶，此时入栈、出栈操作可以 时间完成。\n\n由于栈的操作都是在栈顶完成，因此在顺序栈的实现中需要附设一个指针 top 来动态地指示栈顶元素在数组中的位置。通常 top 可以用栈顶元素所在的数组下标来表示，top=-1时表示空栈。\n\n栈在使用过程中所需的最大空间难以估计，所以，一般构造栈的时候不应设定最大容量。一种合理的做法和线性表类似，先为栈分配一个基本容量，然后在实际的使用过程中，当栈的空间不够用时再倍增存储空间。\n\npublic class MyArrayStack implements MyStack {\n\n    private final int capacity = 2;  //默认容量\n    private Object[] arrs;   //数据元素数组\n    private int top;   //栈顶指针\n\n    MyArrayStack(){\n        top = -1;\n        arrs = new Object[capacity];\n    }\n\n    public int getSize() {\n        return top + 1;\n    }\n\n    public boolean isEmpty() {\n        return top < 0;\n    }\n\n    public void push(Object e) {\n        if(getSize() >= arrs.length){\n           expandSapce();  //扩容\n        }\n        arrs[++top]=e;\n    }\n\n    private void expandSapce() {\n        Object[] a = new Object[arrs.length * 2];\n        for (int i = 0; i < arrs.length; i++) {\n            a[i] = arrs[i];\n        }\n        arrs = a;\n    }\n\n    public Object pop() {\n        if(getSize()<1){\n            throw new RuntimeException("栈为空");\n        }\n        Object obj = arrs[top];\n        arrs[top--] = null;\n        return obj;\n    }\n\n    public Object peek() {\n        if(getSize()<1){\n            throw new RuntimeException("栈为空");\n        }\n        return arrs[top];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n以上基于数据实现的栈代码并不难理解。由于有 top 指针的存在，所以size()、isEmpty()方法均可在 $O(1) $ 时间内完成。push()、pop()和peek()方法，除了需要ensureCapacity()外，都执行常数基本操作，因此它们的运行时间也是\n\n\n# 三、栈的链式存储与实现\n\n栈的链式存储即采用链表实现栈。当采用单链表存储线性表后，根据单链表的操作特性选择单链表的头部作为栈顶，此时，入栈和出栈等操作可以在 时间内完成。\n\n由于栈的操作只在线性表的一端进行，在这里使用带头结点的单链表或不带头结点的单链表都可以。使用带头结点的单链表时，结点的插入和删除都在头结点之后进行；使用不带头结点的单链表时，结点的插入和删除都在链表的首结点上进行。\n\n下面以不带头结点的单链表为例实现栈，如下示意图所示：\n\n\n\n在上图中，top 为栈顶结点的引用，始终指向当前栈顶元素所在的结点。若 top 为null，则表示空栈。入栈操作是在 top 所指结点之前插入新的结点，使新结点的 next 域指向 top，top 前移即可；出栈则直接让 top 后移即可。\n\npublic class MyLinkedStack implements MyStack {\n\n    class Node {\n        private Object element;\n        private Node next;\n\n        public Node() {\n            this(null, null);\n        }\n\n        public Node(Object ele, Node next) {\n            this.element = ele;\n            this.next = next;\n        }\n\n        public Node getNext() {\n            return next;\n        }\n\n        public void setNext(Node next) {\n            this.next = next;\n        }\n\n        public Object getData() {\n            return element;\n        }\n\n        public void setData(Object obj) {\n            element = obj;\n        }\n    }\n\n    private Node top;\n    private int size;\n\n    public MyLinkedStack() {\n        top = null;\n        size = 0;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public void push(Object e) {\n        Node node = new Node(e, top);\n        top = node;\n        size++;\n    }\n\n    public Object pop() {\n        if (size < 1) {\n            throw new RuntimeException("堆栈为空");\n        }\n        Object obj = top.getData();\n        top = top.getNext();\n        size--;\n        return obj;\n    }\n\n    public Object peek() {\n        if (size < 1) {\n            throw new RuntimeException("堆栈为空");\n        }\n        return top.getData();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n上述 MyLinkedStack 类中有两个成员变量，其中 top 表示首结点，也就是栈顶元素所在的结点；size 指示栈的大小，即栈中数据元素的个数。不难理解，所有的操作均可以在 时间内完成。\n\n\n# 四、JDK 中的栈实现 Stack\n\nJava 工具包中的 Stack 是继承于 Vector(矢量队列)的，由于 Vector 是通过数组实现的，这就意味着，Stack 也是通过数组实现的，而非链表。当然，我们也可以将 LinkedList 当作栈来使用。\n\n\n# Stack的继承关系\n\njava.lang.Object\n     java.util.AbstractCollection<E>\n        java.util.AbstractList<E>\n            java.util.Vector<E>\n                 java.util.Stack<E>\n\npublic class Stack<E> extends Vector<E> {}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 五、栈应用\n\n栈有一个很重要的应用，在程序设计语言里实现了递归。\n\n\n# 有效的括号\n\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串，判断字符串是否有效。\n> \n> 有效字符串需满足：\n> \n>  1. 左括号必须用相同类型的右括号闭合。\n>  2. 左括号必须以正确的顺序闭合。\n> \n> 注意空字符串可被认为是有效字符串。\n> \n> 输入: "{[]}"\n> 输出: true\n> 输入: "([)]"\n> 输出: false\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n> 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n> \n> 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n> \n> 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。',normalizedContent:'# 一、概述\n\n\n# 定义\n\n注意：本文所说的栈是数据结构中的栈，而不是内存模型中栈\n\n栈（stack）是限定仅在表尾一端进行插入或删除操作的特殊线性表。又称为堆栈。\n\n对于栈来说, 允许进行插入或删除操作的一端称为栈顶（top），而另一端称为栈底（bottom）。不含元素栈称为空栈，向栈中插入一个新元素称为入栈或压栈， 从栈中删除一个元素称为出栈或退栈。\n\n假设有一个栈ｓ＝（a1, a2, …, an)，a1先进栈， an最后进栈。称 a1 为栈底元素，an 为栈顶元素。出栈时只允许在栈顶进行，所以 an 先出栈，a1最后出栈。因此又称栈为后进先出（last in first out，lifo）的线性表。\n\n栈（stack），是一种线性存储结构，它有以下几个特点：\n\n * 栈中数据是按照"后进先出（lifo, last in first out）"方式进出栈的。\n * 向栈中添加/删除数据时，只能从栈顶进行操作。\n\n\n\n在上图中，当 abcd 均已入栈后，出栈时得到的序列为 dcba，这就是后进先出。\n\n\n# 基本操作\n\n栈的基本操作除了进栈 push()，出栈 pop() 之外，还有判空 isempty()、取栈顶元素 peek() 等操作。\n\n抽象成接口如下：\n\npublic interface mystack {\n\n    /**\n     * 返回堆栈的大小\n     */\n    public int getsize();\n\n    /**\n     * 判断堆栈是否为空\n     */\n    public boolean isempty();\n\n    /**\n     * 入栈\n     */\n    public void push(object e);\n\n    /**\n     * 出栈，并删除\n     */\n    public object pop();\n\n    /**\n     * 返回栈顶元素\n     */\n    public object peek();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n和线性表类似，栈也有两种存储结构：顺序存储和链式存储。\n\n\n# 二、栈的顺序存储与实现\n\n顺序栈是使用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放栈中的数据元素。由于栈是一种特殊的线性表，因此在线性表的顺序存储结构的基础上，选择线性表的一端作为栈顶即可。那么根据数组操作的特性，选择数组下标大的一端，即线性表顺序存储的表尾来作为栈顶，此时入栈、出栈操作可以 时间完成。\n\n由于栈的操作都是在栈顶完成，因此在顺序栈的实现中需要附设一个指针 top 来动态地指示栈顶元素在数组中的位置。通常 top 可以用栈顶元素所在的数组下标来表示，top=-1时表示空栈。\n\n栈在使用过程中所需的最大空间难以估计，所以，一般构造栈的时候不应设定最大容量。一种合理的做法和线性表类似，先为栈分配一个基本容量，然后在实际的使用过程中，当栈的空间不够用时再倍增存储空间。\n\npublic class myarraystack implements mystack {\n\n    private final int capacity = 2;  //默认容量\n    private object[] arrs;   //数据元素数组\n    private int top;   //栈顶指针\n\n    myarraystack(){\n        top = -1;\n        arrs = new object[capacity];\n    }\n\n    public int getsize() {\n        return top + 1;\n    }\n\n    public boolean isempty() {\n        return top < 0;\n    }\n\n    public void push(object e) {\n        if(getsize() >= arrs.length){\n           expandsapce();  //扩容\n        }\n        arrs[++top]=e;\n    }\n\n    private void expandsapce() {\n        object[] a = new object[arrs.length * 2];\n        for (int i = 0; i < arrs.length; i++) {\n            a[i] = arrs[i];\n        }\n        arrs = a;\n    }\n\n    public object pop() {\n        if(getsize()<1){\n            throw new runtimeexception("栈为空");\n        }\n        object obj = arrs[top];\n        arrs[top--] = null;\n        return obj;\n    }\n\n    public object peek() {\n        if(getsize()<1){\n            throw new runtimeexception("栈为空");\n        }\n        return arrs[top];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n以上基于数据实现的栈代码并不难理解。由于有 top 指针的存在，所以size()、isempty()方法均可在 $o(1) $ 时间内完成。push()、pop()和peek()方法，除了需要ensurecapacity()外，都执行常数基本操作，因此它们的运行时间也是\n\n\n# 三、栈的链式存储与实现\n\n栈的链式存储即采用链表实现栈。当采用单链表存储线性表后，根据单链表的操作特性选择单链表的头部作为栈顶，此时，入栈和出栈等操作可以在 时间内完成。\n\n由于栈的操作只在线性表的一端进行，在这里使用带头结点的单链表或不带头结点的单链表都可以。使用带头结点的单链表时，结点的插入和删除都在头结点之后进行；使用不带头结点的单链表时，结点的插入和删除都在链表的首结点上进行。\n\n下面以不带头结点的单链表为例实现栈，如下示意图所示：\n\n\n\n在上图中，top 为栈顶结点的引用，始终指向当前栈顶元素所在的结点。若 top 为null，则表示空栈。入栈操作是在 top 所指结点之前插入新的结点，使新结点的 next 域指向 top，top 前移即可；出栈则直接让 top 后移即可。\n\npublic class mylinkedstack implements mystack {\n\n    class node {\n        private object element;\n        private node next;\n\n        public node() {\n            this(null, null);\n        }\n\n        public node(object ele, node next) {\n            this.element = ele;\n            this.next = next;\n        }\n\n        public node getnext() {\n            return next;\n        }\n\n        public void setnext(node next) {\n            this.next = next;\n        }\n\n        public object getdata() {\n            return element;\n        }\n\n        public void setdata(object obj) {\n            element = obj;\n        }\n    }\n\n    private node top;\n    private int size;\n\n    public mylinkedstack() {\n        top = null;\n        size = 0;\n    }\n\n    public int getsize() {\n        return size;\n    }\n\n    public boolean isempty() {\n        return size == 0;\n    }\n\n    public void push(object e) {\n        node node = new node(e, top);\n        top = node;\n        size++;\n    }\n\n    public object pop() {\n        if (size < 1) {\n            throw new runtimeexception("堆栈为空");\n        }\n        object obj = top.getdata();\n        top = top.getnext();\n        size--;\n        return obj;\n    }\n\n    public object peek() {\n        if (size < 1) {\n            throw new runtimeexception("堆栈为空");\n        }\n        return top.getdata();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n上述 mylinkedstack 类中有两个成员变量，其中 top 表示首结点，也就是栈顶元素所在的结点；size 指示栈的大小，即栈中数据元素的个数。不难理解，所有的操作均可以在 时间内完成。\n\n\n# 四、jdk 中的栈实现 stack\n\njava 工具包中的 stack 是继承于 vector(矢量队列)的，由于 vector 是通过数组实现的，这就意味着，stack 也是通过数组实现的，而非链表。当然，我们也可以将 linkedlist 当作栈来使用。\n\n\n# stack的继承关系\n\njava.lang.object\n     java.util.abstractcollection<e>\n        java.util.abstractlist<e>\n            java.util.vector<e>\n                 java.util.stack<e>\n\npublic class stack<e> extends vector<e> {}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 五、栈应用\n\n栈有一个很重要的应用，在程序设计语言里实现了递归。\n\n\n# 有效的括号\n\n> 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串，判断字符串是否有效。\n> \n> 有效字符串需满足：\n> \n>  1. 左括号必须用相同类型的右括号闭合。\n>  2. 左括号必须以正确的顺序闭合。\n> \n> 注意空字符串可被认为是有效字符串。\n> \n> 输入: "{[]}"\n> 输出: true\n> 输入: "([)]"\n> 输出: false\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n> 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n> \n> 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n> \n> 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"堆",frontmatter:{title:"堆",date:"2022-10-11T23:00:21.000Z",permalink:"/pages/6db356/",categories:["计算机基础","数据结构"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/50%E5%A0%86.html",relativePath:"02.计算机基础/30.数据结构/50堆.md",key:"v-e8b2cf00",path:"/pages/6db356/",headers:[{level:2,title:"什么是堆",slug:"什么是堆",normalizedTitle:"什么是堆",charIndex:2},{level:2,title:"堆的用途",slug:"堆的用途",normalizedTitle:"堆的用途",charIndex:457},{level:2,title:"堆的分类",slug:"堆的分类",normalizedTitle:"堆的分类",charIndex:794},{level:2,title:"堆的存储",slug:"堆的存储",normalizedTitle:"堆的存储",charIndex:924},{level:2,title:"堆的操作",slug:"堆的操作",normalizedTitle:"堆的操作",charIndex:161},{level:3,title:"插入元素",slug:"插入元素",normalizedTitle:"插入元素",charIndex:1097},{level:3,title:"删除堆顶元素",slug:"删除堆顶元素",normalizedTitle:"删除堆顶元素",charIndex:1104},{level:3,title:"自底向上堆化",slug:"自底向上堆化",normalizedTitle:"自底向上堆化",charIndex:1570},{level:3,title:"自顶向下堆化",slug:"自顶向下堆化",normalizedTitle:"自顶向下堆化",charIndex:1506},{level:3,title:"堆的操作总结",slug:"堆的操作总结",normalizedTitle:"堆的操作总结",charIndex:2031},{level:2,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:2165},{level:3,title:"建堆",slug:"建堆",normalizedTitle:"建堆",charIndex:2190},{level:3,title:"排序",slug:"排序",normalizedTitle:"排序",charIndex:824}],headersStr:"什么是堆 堆的用途 堆的分类 堆的存储 堆的操作 插入元素 删除堆顶元素 自底向上堆化 自顶向下堆化 堆的操作总结 堆排序 建堆 排序",content:'# 什么是堆\n\n堆是一种满足以下条件的树：\n\n堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。\n\n> 大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。\n\n!!!特别提示：\n\n * 很多博客说堆是完全二叉树，其实并非如此，堆不一定是完全二叉树，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。\n * （二叉）堆是一个数组，它可以被看成是一个 近似的完全二叉树。——《算法导论》第三版\n\n大家可以尝试判断下面给出的图是否是堆？\n\n\n\n第1个和第2个是堆。第1个是最大堆，每个节点都比子树中所有节点大。第2个是最小堆，每个节点都比子树中所有节点小。\n\n第3个不是，第三个中，根结点1比2和15小，而15却比3大，19比5大，不满足堆的性质。\n\n\n# 堆的用途\n\n当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。\n\n有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 O(nlog(n))，查找最大值或者最小值时间复杂度都是 O(1)，但是，涉及到更新（插入或删除）数据时，时间复杂度为 O(n)，即使是使用复杂度为 O(log(n)) 的二分法找到要插入或者删除的数据，在移动数据时也需要 O(n) 的时间复杂度。\n\n相对于有序数组而言，堆的主要优势在于更新数据效率较高。 堆的初始化时间复杂度为 O(nlog(n))，堆可以做到O(1)时间复杂度取出最大值或者最小值，O(log(n))时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。\n\n\n# 堆的分类\n\n堆分为 最大堆 和 最小堆。二者的区别在于节点的排序方式。\n\n * 最大堆 ：堆中的每一个节点的值都大于等于子树中所有节点的值\n * 最小堆 ：堆中的每一个节点的值都小于等于子树中所有节点的值\n\n如下图所示，图1是最大堆，图2是最小堆\n\n\n\n\n# 堆的存储\n\n之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 2*i，右子节点序号为 2*i+1）。\n\n为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：\n\n\n\n\n# 堆的操作\n\n堆的更新操作主要包括两种 : 插入元素 和 删除堆顶元素。操作过程需要着重掌握和理解。\n\n> 在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置\n\n\n# 插入元素\n\n> 插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起\n\n1.将要插入的元素放到最后\n\n\n\n> 有能力的人会逐渐升职加薪，是金子总会发光的！！！\n\n2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换\n\n\n\n\n\n\n# 删除堆顶元素\n\n根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。\n\n删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为"堆化"，堆化的方法分为两种：\n\n * 一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。\n * 另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。\n\n\n# 自底向上堆化\n\n> 在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了\n\n首先删除堆顶元素，使得数组中下标为1的位置空出。\n\n\n\n> 那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗\n\n比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。\n\n\n\n> 这个时候又空出一个位置了，老规矩，谁有能力谁上\n\n一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部\n\n\n\n这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。\n\n\n# 自顶向下堆化\n\n自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。\n\n\n\n然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。\n\n\n\n\n\n\n# 堆的操作总结\n\n * 插入元素 ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮\n * 删除堆顶元素 ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。\n\n\n# 堆排序\n\n堆排序的过程分为两步：\n\n * 第一步是建堆，将一个无序的数组建立为一个堆\n * 第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。\n\n\n# 建堆\n\n如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。\n\n首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。\n\n具体过程如下图：\n\n\n\n将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。 3号节点堆化结果：\n\n\n\n2号节点堆化结果：\n\n\n\n1号节点堆化结果：\n\n\n\n至此，数组所对应的树已经成为了一个最大堆，建堆完成！\n\n\n# 排序\n\n由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。\n\n现在思考两个问题：\n\n * 删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？\n * 取出的堆顶元素存在哪，新建一个数组存？\n\n先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。\n\n机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。\n\n详细过程如下图所示：\n\n取出第一个元素并堆化：\n\n\n\n取出第二个元素并堆化：\n\n\n\n取出第三个元素并堆化：\n\n\n\n取出第四个元素并堆化：\n\n\n\n取出第五个元素并堆化：\n\n\n\n取出第六个元素并堆化：\n\n\n\n堆排序完成！',normalizedContent:'# 什么是堆\n\n堆是一种满足以下条件的树：\n\n堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。\n\n> 大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。\n\n!!!特别提示：\n\n * 很多博客说堆是完全二叉树，其实并非如此，堆不一定是完全二叉树，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。\n * （二叉）堆是一个数组，它可以被看成是一个 近似的完全二叉树。——《算法导论》第三版\n\n大家可以尝试判断下面给出的图是否是堆？\n\n\n\n第1个和第2个是堆。第1个是最大堆，每个节点都比子树中所有节点大。第2个是最小堆，每个节点都比子树中所有节点小。\n\n第3个不是，第三个中，根结点1比2和15小，而15却比3大，19比5大，不满足堆的性质。\n\n\n# 堆的用途\n\n当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。\n\n有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 o(nlog(n))，查找最大值或者最小值时间复杂度都是 o(1)，但是，涉及到更新（插入或删除）数据时，时间复杂度为 o(n)，即使是使用复杂度为 o(log(n)) 的二分法找到要插入或者删除的数据，在移动数据时也需要 o(n) 的时间复杂度。\n\n相对于有序数组而言，堆的主要优势在于更新数据效率较高。 堆的初始化时间复杂度为 o(nlog(n))，堆可以做到o(1)时间复杂度取出最大值或者最小值，o(log(n))时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。\n\n\n# 堆的分类\n\n堆分为 最大堆 和 最小堆。二者的区别在于节点的排序方式。\n\n * 最大堆 ：堆中的每一个节点的值都大于等于子树中所有节点的值\n * 最小堆 ：堆中的每一个节点的值都小于等于子树中所有节点的值\n\n如下图所示，图1是最大堆，图2是最小堆\n\n\n\n\n# 堆的存储\n\n之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 2*i，右子节点序号为 2*i+1）。\n\n为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：\n\n\n\n\n# 堆的操作\n\n堆的更新操作主要包括两种 : 插入元素 和 删除堆顶元素。操作过程需要着重掌握和理解。\n\n> 在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置\n\n\n# 插入元素\n\n> 插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起\n\n1.将要插入的元素放到最后\n\n\n\n> 有能力的人会逐渐升职加薪，是金子总会发光的！！！\n\n2.从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换\n\n\n\n\n\n\n# 删除堆顶元素\n\n根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。\n\n删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为"堆化"，堆化的方法分为两种：\n\n * 一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。\n * 另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。\n\n\n# 自底向上堆化\n\n> 在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了\n\n首先删除堆顶元素，使得数组中下标为1的位置空出。\n\n\n\n> 那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗\n\n比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。\n\n\n\n> 这个时候又空出一个位置了，老规矩，谁有能力谁上\n\n一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部\n\n\n\n这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。\n\n\n# 自顶向下堆化\n\n自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。\n\n\n\n然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。\n\n\n\n\n\n\n# 堆的操作总结\n\n * 插入元素 ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮\n * 删除堆顶元素 ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。\n\n\n# 堆排序\n\n堆排序的过程分为两步：\n\n * 第一步是建堆，将一个无序的数组建立为一个堆\n * 第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。\n\n\n# 建堆\n\n如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。\n\n首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。\n\n具体过程如下图：\n\n\n\n将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。 3号节点堆化结果：\n\n\n\n2号节点堆化结果：\n\n\n\n1号节点堆化结果：\n\n\n\n至此，数组所对应的树已经成为了一个最大堆，建堆完成！\n\n\n# 排序\n\n由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。\n\n现在思考两个问题：\n\n * 删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？\n * 取出的堆顶元素存在哪，新建一个数组存？\n\n先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。\n\n机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。\n\n详细过程如下图所示：\n\n取出第一个元素并堆化：\n\n\n\n取出第二个元素并堆化：\n\n\n\n取出第三个元素并堆化：\n\n\n\n取出第四个元素并堆化：\n\n\n\n取出第五个元素并堆化：\n\n\n\n取出第六个元素并堆化：\n\n\n\n堆排序完成！',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"时间复杂度",frontmatter:{title:"时间复杂度",date:"2022-10-11T23:15:37.000Z",permalink:"/pages/fd9be6/",categories:["计算机基础","算法"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/40.%E7%AE%97%E6%B3%95/10.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html",relativePath:"02.计算机基础/40.算法/10.时间复杂度.md",key:"v-016a9bfe",path:"/pages/fd9be6/",headers:[{level:2,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:171},{level:3,title:"常数阶",slug:"常数阶",normalizedTitle:"常数阶",charIndex:864},{level:3,title:"线性阶",slug:"线性阶",normalizedTitle:"线性阶",charIndex:871},{level:3,title:"平方阶",slug:"平方阶",normalizedTitle:"平方阶",charIndex:878},{level:3,title:"指数阶",slug:"指数阶",normalizedTitle:"指数阶",charIndex:908},{level:3,title:"对数阶",slug:"对数阶",normalizedTitle:"对数阶",charIndex:892},{level:3,title:"线性对数阶",slug:"线性对数阶",normalizedTitle:"线性对数阶",charIndex:899},{level:2,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:215},{level:3,title:"空间复杂度",slug:"空间复杂度-2",normalizedTitle:"空间复杂度",charIndex:215},{level:3,title:"空间复杂度",slug:"空间复杂度-3",normalizedTitle:"空间复杂度",charIndex:215},{level:2,title:"复杂度速查表",slug:"复杂度速查表",normalizedTitle:"复杂度速查表",charIndex:2964},{level:3,title:"图例",slug:"图例",normalizedTitle:"图例",charIndex:3063},{level:3,title:"大-O 复杂度曲线",slug:"大-o-复杂度曲线",normalizedTitle:"大-o 复杂度曲线",charIndex:3072},{level:3,title:"抽象数据结构的操作复杂度",slug:"抽象数据结构的操作复杂度",normalizedTitle:"抽象数据结构的操作复杂度",charIndex:3088},{level:3,title:"数组排序",slug:"数组排序",normalizedTitle:"数组排序",charIndex:3107},{level:3,title:"图操作",slug:"图操作",normalizedTitle:"图操作",charIndex:3118},{level:3,title:"堆操作",slug:"堆操作",normalizedTitle:"堆操作",charIndex:3128}],headersStr:"时间复杂度 常数阶 线性阶 平方阶 指数阶 对数阶 线性对数阶 空间复杂度 空间复杂度 空间复杂度 复杂度速查表 图例 大-O 复杂度曲线 抽象数据结构的操作复杂度 数组排序 图操作 堆操作",content:"算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。\n\n那么我们应该如何去衡量不同算法之间的优劣呢？\n\n主要还是从算法所占用的「时间」和「空间」两个维度去考量。\n\n * 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。\n * 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。\n\n因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。\n\n> 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？\n> \n> 就是：时间、空间复杂度\n\n\n# 时间复杂度\n\n一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。而且测试环境中的硬件性能和测试数据规模都会对其有很大的影响。我们也不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或「时间频度」。记为T(n)。\n\n时间频度T(n)中，n 称为问题的规模，当 n 不断变化时，时间频度 T(n) 也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。算法的时间复杂度也就是算法的时间度量，记作：。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称「时间复杂度」。\n\n这种表示方法我们称为「 大O符号表示法 」，又称为渐进符号，是用于描述函数渐进行为的数学符号\n\n常见的时间复杂度量级有：\n\n * 常数阶\n * 线性阶\n * 平方阶\n * 立方阶\n * 对数阶\n * 线性对数阶\n * 指数阶\n\n\n# 常数阶\n\n，表示该算法的执行时间（或执行时占用空间）总是为一个常量，不论输入的数据集是大是小，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：\n\nint i = 1;\nint j = 2;\nint k = i + j;\n\n\n1\n2\n3\n\n\n上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用来表示它的时间复杂度。\n\n\n# 线性阶\n\n，表示一个算法的性能会随着输入数据的大小变化而线性变化，如\n\nfor (int i = 0; i < n; i++) {\n   j = i;\n   j++;\n}\n\n\n1\n2\n3\n4\n\n\n这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用来表示它的时间复杂度。\n\n\n# 平方阶\n\n² 表示一个算法的性能将会随着输入数据的增长而呈现出二次增长。最常见的就是对输入数据进行嵌套循环。如果嵌套层级不断深入的话，算法的性能将会变为立方阶，，以此类推\n\nfor(x=1; i<=n; x++){\n   for(i=1; i<=n; i++){\n       j = i;\n       j++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 指数阶\n\n，表示一个算法的性能会随着输入数据的每次增加而增大两倍，典型的方法就是裴波那契数列的递归计算实现\n\nint Fibonacci(int number)\n{\n    if (number <= 1) return number;\n\n    return Fibonacci(number - 2) + Fibonacci(number - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 对数阶\n\nint i = 1;\nwhile(i<n)\n{\n    i = i * 2;\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面的代码，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了，直到i不小于n退出。我们试着求解一下，假设循环次数为x，也就是说 2 的 x 次方等于 n，则由2^x=n得出x=log₂n。因此这个代码的时间复杂度为\n\n\n# 线性对数阶\n\n线性对数阶$O(nlogn) ，就是将时间复杂度为对数阶O(logn)的代码循环遍的话，那么它的时间复杂度就是，也就是了O(nlogn)$，如下，\n\nfor(m=1; m<n; m++)\n{\n    i = 1;\n    while(i<n)\n    {\n        i = i * 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n除此之外，其实还有平均情况复杂度、最好时间复杂度、最坏时间复杂度。。。一般没有特殊说明的情况下，都是值最坏时间复杂度。\n\n----------------------------------------\n\n\n# 空间复杂度\n\n空间复杂度（Space Complexity）是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，一个算法所需的存储空间用f(n)表示。，其中 n 为问题的规模，S(n) 表示空间复杂度。\n\n一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。\n\n一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为 。当一个算法的空间复杂度与n成线性比例关系时，可表示为，类比时间复杂度。\n\n空间复杂度比较常用的有：、、²\n\n\n# 空间复杂度\n\n如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1) 举例：\n\nint i = 1;\nint j = 2;\n++i;\nj++;\nint m = i + j;\n\n\n1\n2\n3\n4\n5\n\n\n代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)\n\n\n# 空间复杂度\n\nint[] m = new int[n]\nfor(i=1; i<=n; ++i)\n{\n   j = i;\n   j++;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)\n\n----------------------------------------\n\n\n# 复杂度速查表\n\n来源：https://liam.page/2016/06/20/big-O-cheat-sheet/ 源地址：https://www.bigocheatsheet.com/\n\n\n# 图例\n\n\n\n\n# 大-O 复杂度曲线\n\n\n\n\n# 抽象数据结构的操作复杂度\n\n\n\n\n# 数组排序\n\n\n\n\n# 图操作\n\n\n\n\n# 堆操作\n\n",normalizedContent:"算法（algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。\n\n那么我们应该如何去衡量不同算法之间的优劣呢？\n\n主要还是从算法所占用的「时间」和「空间」两个维度去考量。\n\n * 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。\n * 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。\n\n因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。\n\n> 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？\n> \n> 就是：时间、空间复杂度\n\n\n# 时间复杂度\n\n一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。而且测试环境中的硬件性能和测试数据规模都会对其有很大的影响。我们也不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或「时间频度」。记为t(n)。\n\n时间频度t(n)中，n 称为问题的规模，当 n 不断变化时，时间频度 t(n) 也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。算法的时间复杂度也就是算法的时间度量，记作：。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称「时间复杂度」。\n\n这种表示方法我们称为「 大o符号表示法 」，又称为渐进符号，是用于描述函数渐进行为的数学符号\n\n常见的时间复杂度量级有：\n\n * 常数阶\n * 线性阶\n * 平方阶\n * 立方阶\n * 对数阶\n * 线性对数阶\n * 指数阶\n\n\n# 常数阶\n\n，表示该算法的执行时间（或执行时占用空间）总是为一个常量，不论输入的数据集是大是小，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是o(1)，如：\n\nint i = 1;\nint j = 2;\nint k = i + j;\n\n\n1\n2\n3\n\n\n上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用来表示它的时间复杂度。\n\n\n# 线性阶\n\n，表示一个算法的性能会随着输入数据的大小变化而线性变化，如\n\nfor (int i = 0; i < n; i++) {\n   j = i;\n   j++;\n}\n\n\n1\n2\n3\n4\n\n\n这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用来表示它的时间复杂度。\n\n\n# 平方阶\n\n² 表示一个算法的性能将会随着输入数据的增长而呈现出二次增长。最常见的就是对输入数据进行嵌套循环。如果嵌套层级不断深入的话，算法的性能将会变为立方阶，，以此类推\n\nfor(x=1; i<=n; x++){\n   for(i=1; i<=n; i++){\n       j = i;\n       j++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 指数阶\n\n，表示一个算法的性能会随着输入数据的每次增加而增大两倍，典型的方法就是裴波那契数列的递归计算实现\n\nint fibonacci(int number)\n{\n    if (number <= 1) return number;\n\n    return fibonacci(number - 2) + fibonacci(number - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 对数阶\n\nint i = 1;\nwhile(i<n)\n{\n    i = i * 2;\n}\n\n\n1\n2\n3\n4\n5\n\n\n上面的代码，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了，直到i不小于n退出。我们试着求解一下，假设循环次数为x，也就是说 2 的 x 次方等于 n，则由2^x=n得出x=log₂n。因此这个代码的时间复杂度为\n\n\n# 线性对数阶\n\n线性对数阶$o(nlogn) ，就是将时间复杂度为对数阶o(logn)的代码循环遍的话，那么它的时间复杂度就是，也就是了o(nlogn)$，如下，\n\nfor(m=1; m<n; m++)\n{\n    i = 1;\n    while(i<n)\n    {\n        i = i * 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n除此之外，其实还有平均情况复杂度、最好时间复杂度、最坏时间复杂度。。。一般没有特殊说明的情况下，都是值最坏时间复杂度。\n\n----------------------------------------\n\n\n# 空间复杂度\n\n空间复杂度（space complexity）是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，一个算法所需的存储空间用f(n)表示。，其中 n 为问题的规模，s(n) 表示空间复杂度。\n\n一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。\n\n一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为 。当一个算法的空间复杂度与n成线性比例关系时，可表示为，类比时间复杂度。\n\n空间复杂度比较常用的有：、、²\n\n\n# 空间复杂度\n\n如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 o(1) 举例：\n\nint i = 1;\nint j = 2;\n++i;\nj++;\nint m = i + j;\n\n\n1\n2\n3\n4\n5\n\n\n代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 s(n) = o(1)\n\n\n# 空间复杂度\n\nint[] m = new int[n]\nfor(i=1; i<=n; ++i)\n{\n   j = i;\n   j++;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 s(n) = o(n)\n\n----------------------------------------\n\n\n# 复杂度速查表\n\n来源：https://liam.page/2016/06/20/big-o-cheat-sheet/ 源地址：https://www.bigocheatsheet.com/\n\n\n# 图例\n\n\n\n\n# 大-o 复杂度曲线\n\n\n\n\n# 抽象数据结构的操作复杂度\n\n\n\n\n# 数组排序\n\n\n\n\n# 图操作\n\n\n\n\n# 堆操作\n\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"排序",frontmatter:{title:"排序",date:"2022-10-11T23:42:27.000Z",permalink:"/pages/3205b9/",categories:["计算机基础","算法"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/40.%E7%AE%97%E6%B3%95/20.%E6%8E%92%E5%BA%8F.html",relativePath:"02.计算机基础/40.算法/20.排序.md",key:"v-57b9b0cf",path:"/pages/3205b9/",headers:[{level:2,title:"冒泡排序",slug:"冒泡排序",normalizedTitle:"冒泡排序",charIndex:104},{level:3,title:"1. 算法步骤",slug:"_1-算法步骤",normalizedTitle:"1. 算法步骤",charIndex:915},{level:3,title:"2. 动图演示",slug:"_2-动图演示",normalizedTitle:"2. 动图演示",charIndex:1060},{level:3,title:"3. 什么时候最快",slug:"_3-什么时候最快",normalizedTitle:"3. 什么时候最快",charIndex:1074},{level:3,title:"4. 什么时候最慢",slug:"_4-什么时候最慢",normalizedTitle:"4. 什么时候最慢",charIndex:1125},{level:2,title:"选择排序",slug:"选择排序",normalizedTitle:"选择排序",charIndex:99},{level:3,title:"1. 算法步骤",slug:"_1-算法步骤-2",normalizedTitle:"1. 算法步骤",charIndex:915},{level:3,title:"2. 动图演示",slug:"_2-动图演示-2",normalizedTitle:"2. 动图演示",charIndex:1060},{level:2,title:"插入排序",slug:"插入排序",normalizedTitle:"插入排序",charIndex:89},{level:3,title:"1. 算法步骤",slug:"_1-算法步骤-3",normalizedTitle:"1. 算法步骤",charIndex:915},{level:3,title:"2. 动图演示",slug:"_2-动图演示-3",normalizedTitle:"2. 动图演示",charIndex:1060},{level:2,title:"快速排序",slug:"快速排序",normalizedTitle:"快速排序",charIndex:114},{level:3,title:"1. 算法步骤",slug:"_1-算法步骤-4",normalizedTitle:"1. 算法步骤",charIndex:915},{level:3,title:"2. 动图演示",slug:"_2-动图演示-4",normalizedTitle:"2. 动图演示",charIndex:1060},{level:3,title:"单边扫描",slug:"单边扫描",normalizedTitle:"单边扫描",charIndex:4345},{level:3,title:"双边扫描",slug:"双边扫描",normalizedTitle:"双边扫描",charIndex:5292},{level:2,title:"希尔排序",slug:"希尔排序",normalizedTitle:"希尔排序",charIndex:94},{level:3,title:"1. 算法步骤",slug:"_1-算法步骤-5",normalizedTitle:"1. 算法步骤",charIndex:915},{level:3,title:"2. 动图演示",slug:"_2-动图演示-5",normalizedTitle:"2. 动图演示",charIndex:1060},{level:2,title:"归并排序",slug:"归并排序",normalizedTitle:"归并排序",charIndex:109},{level:3,title:"2. 算法步骤",slug:"_2-算法步骤",normalizedTitle:"2. 算法步骤",charIndex:7844},{level:3,title:"3. 动图演示",slug:"_3-动图演示",normalizedTitle:"3. 动图演示",charIndex:8027},{level:2,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:119},{level:3,title:"1. 算法步骤",slug:"_1-算法步骤-6",normalizedTitle:"1. 算法步骤",charIndex:915},{level:3,title:"2. 动图演示",slug:"_2-动图演示-6",normalizedTitle:"2. 动图演示",charIndex:1060},{level:2,title:"计数排序",slug:"计数排序",normalizedTitle:"计数排序",charIndex:8466},{level:3,title:"1. 动图演示",slug:"_1-动图演示",normalizedTitle:"1. 动图演示",charIndex:8549},{level:2,title:"桶排序",slug:"桶排序",normalizedTitle:"桶排序",charIndex:8581},{level:3,title:"1. 什么时候最快",slug:"_1-什么时候最快",normalizedTitle:"1. 什么时候最快",charIndex:8756},{level:3,title:"2. 什么时候最慢",slug:"_2-什么时候最慢",normalizedTitle:"2. 什么时候最慢",charIndex:8792},{level:2,title:"基数排序",slug:"基数排序",normalizedTitle:"基数排序",charIndex:123},{level:3,title:"1. 基数排序 vs 计数排序 vs 桶排序",slug:"_1-基数排序-vs-计数排序-vs-桶排序",normalizedTitle:"1. 基数排序 vs 计数排序 vs 桶排序",charIndex:8933},{level:3,title:"2. LSD 基数排序动图演示",slug:"_2-lsd-基数排序动图演示",normalizedTitle:"2. lsd 基数排序动图演示",charIndex:9077}],headersStr:"冒泡排序 1. 算法步骤 2. 动图演示 3. 什么时候最快 4. 什么时候最慢 选择排序 1. 算法步骤 2. 动图演示 插入排序 1. 算法步骤 2. 动图演示 快速排序 1. 算法步骤 2. 动图演示 单边扫描 双边扫描 希尔排序 1. 算法步骤 2. 动图演示 归并排序 2. 算法步骤 3. 动图演示 堆排序 1. 算法步骤 2. 动图演示 计数排序 1. 动图演示 桶排序 1. 什么时候最快 2. 什么时候最慢 基数排序 1. 基数排序 vs 计数排序 vs 桶排序 2. LSD 基数排序动图演示",content:'排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：\n\n\n\n关于时间复杂度：\n\n 1. 平方阶 () 排序 各类简单排序：直接插入、直接选择和冒泡排序。\n 2. 线性对数阶 (O(nlog2n)) 排序： 快速排序、堆排序和归并排序；\n 3. O(n1+§) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序\n 4. 线性阶 (O(n)) 排序： 基数排序，此外还有桶、箱排序。\n\n关于稳定性：\n\n稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。\n\n不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。\n\n名词解释：\n\nn：数据规模\n\nk：“桶”的个数\n\nIn-place：占用常数内存，不占用额外内存\n\nOut-place：占用额外内存\n\n稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同\n\n十种常见排序算法可以分为两大类：\n\n非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破，因此称为非线性时间比较类排序。\n\n线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。\n\n\n# 冒泡排序\n\n冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。\n\n\n# 1. 算法步骤\n\n 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n 2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n 3. 针对所有的元素重复以上的步骤，除了最后一个。\n 4. 重复步骤1~3，直到排序完成。\n\n\n# 2. 动图演示\n\n\n\n\n# 3. 什么时候最快\n\n当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。\n\n\n# 4. 什么时候最慢\n\n当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。\n\npublic class BubbleSort {\n\n    public static void main(String[] args) {\n        int[] arrs = {1, 3, 4, 2, 6, 5};\n\n        for (int i = 0; i < arrs.length; i++) {\n            for (int j = 0; j < arrs.length - 1 - i; j++) {\n                if (arrs[j] > arrs[j + 1]) {\n                    int tmp = arrs[j];\n                    arrs[j] = arrs[j + 1];\n                    arrs[j + 1] = tmp;\n                }\n            }\n        }\n\n        for (int arr : arrs) {\n            System.out.print(arr + " ");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n嵌套循环，应该立马就可以得出这个算法的时间复杂度为 ²。\n\n\n# 选择排序\n\n选择排序的思路是这样的：首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。\n\n选择排序是一种简单直观的排序算法，无论什么数据进去都是 ² 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n\n\n# 1. 算法步骤\n\n 1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n 2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n 3. 重复第二步，直到所有元素均排序完毕。\n\n\n# 2. 动图演示\n\n\n\npublic class SelectionSort {\n\n    public static void main(String[] args) {\n        int[] arrs = {5, 2, 4, 6, 1, 3};\n\n        for (int i = 0; i < arrs.length; i++) {\n            //最小元素下标\n            int min = i;\n            for (int j = i +1; j < arrs.length; j++) {\n                if (arrs[j] < arrs[min]) {\n                    min = j;\n                }\n            }\n            //交换位置\n            int temp = arrs[i];\n            arrs[i] = arrs[min];\n            arrs[min] = temp;\n        }\n        for (int arr : arrs) {\n            System.out.println(arr);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 插入排序\n\n插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\n\n\n# 1. 算法步骤\n\n 1. 从第一个元素开始，该元素可以认为已经被排序；\n 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n 5. 将新元素插入到该位置后；\n 6. 重复步骤2~5。\n\n\n# 2. 动图演示\n\n\n\npublic static void main(String[] args) {\n    int[] arr = {5, 2, 4, 6, 1, 3};\n    // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的\n    for (int i = 1; i < arr.length; i++) {\n\n        // 记录要插入的数据\n        int tmp = arr[i];\n\n        // 从已经排序的序列最右边的开始比较，找到比其小的数\n        int j = i;\n        while (j > 0 && tmp < arr[j - 1]) {\n            arr[j] = arr[j - 1];\n            j--;\n        }\n\n        // 存在比其小的数，插入\n        if (j != i) {\n            arr[j] = tmp;\n        }\n    }\n\n    for (int i : arr) {\n        System.out.println(i);\n    }\n}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 快速排序\n\n这篇很好：https://www.cxyxiaowu.com/5262.html\n\n快速排序的核心思想也是分治法，分而治之。它的实现方式是每次从序列中选出一个基准值，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边，然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动，重复步骤，直到最后都变成单个元素，整个数组就成了有序的序列。\n\n> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。\n\n\n# 1. 算法步骤\n\n 1. 从数列中挑出一个元素，称为 “基准”（pivot）;\n 2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n 3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n\n\n# 2. 动图演示\n\n\n\n\n# 单边扫描\n\n快速排序的关键之处在于切分，切分的同时要进行比较和移动，这里介绍一种叫做单边扫描的做法。\n\n我们随意抽取一个数作为基准值，同时设定一个标记 mark 代表左边序列最右侧的下标位置，当然初始为 0 ，接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换位置，mark 这个位置存储的是比基准值小的数据，当遍历结束后，将基准值与 mark 所在元素交换位置即可。\n\npublic static void sort(int[] arrs, int startIndex, int endIndex) {\n  if (startIndex > endIndex) {\n    return;\n  }\n  int pivotIndex = partion(arrs, startIndex, endIndex);\n  sort(arrs, startIndex, pivotIndex - 1);\n  sort(arrs, pivotIndex + 1, endIndex);\n}\n\npublic static int partion(int[] arrs, int startIndex, int endIndex) {\n  int pivot = arrs[startIndex];\n  int mark = startIndex;\n\n  for (int i = startIndex + 1; i < arrs.length; i++) {\n    if (arrs[i] < pivot) {\n      mark++;\n      int tmp = arrs[mark];\n      arrs[mark] = arrs[i];\n      arrs[i] = tmp;\n    }\n  }\n  arrs[startIndex] = arrs[mark];\n  arrs[mark] = pivot;\n  return mark;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 双边扫描\n\n另外还有一种双边扫描的做法，看起来比较直观：我们随意抽取一个数作为基准值，然后从数组左右两边进行扫描，先从左往右找到一个大于基准值的元素，将下标指针记录下来，然后转到从右往左扫描，找到一个小于基准值的元素，交换这两个元素的位置，重复步骤，直到左右两个指针相遇，再将基准值与左侧最右边的元素交换。\n\n我们来看一下实现代码，不同之处只有 partition 方法：\n\npublic static void sort(int[] arr) {\n    sort(arr， 0， arr.length - 1);\n}\n\nprivate static void sort(int[] arr， int startIndex， int endIndex) {\n    if (endIndex <= startIndex) {\n        return;\n    }\n    //切分\n    int pivotIndex = partition(arr， startIndex， endIndex);\n    sort(arr， startIndex， pivotIndex-1);\n    sort(arr， pivotIndex+1， endIndex);\n}\n\n\nprivate static int partition(int[] arr， int startIndex， int endIndex) {\n    int left = startIndex;\n    int right = endIndex;\n    int pivot = arr[startIndex];//取第一个元素为基准值\n\n    while (true) {\n        //从左往右扫描\n        while (arr[left] <= pivot) {\n            left++;\n            if (left == right) {\n                break;\n            }\n        }\n\n        //从右往左扫描\n        while (pivot < arr[right]) {\n            right--;\n            if (left == right) {\n                break;\n            }\n        }\n\n        //左右指针相遇\n        if (left >= right) {\n            break;\n        }\n\n        //交换左右数据\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n    }\n\n    //将基准值插入序列\n    int temp = arr[startIndex];\n    arr[startIndex] = arr[right];\n    arr[right] = temp;\n    return right;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 希尔排序\n\n希尔排序这个名字，来源于它的发明者希尔，也称作“缩小增量排序”，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n\n * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n\n希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\n\n\n# 1. 算法步骤\n\n 1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n 2. 按增量序列个数 k，对序列进行 k 趟排序；\n 3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n\n# 2. 动图演示\n\n\n\n\n# 归并排序\n\n> https://www.cnblogs.com/chengxiao/p/6194356.html\n\n归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n * 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n * 自下而上的迭代；\n\n在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：\n\n> However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.\n> \n> 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。\n\n说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。\n\n和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。\n\n\n# 2. 算法步骤\n\n 1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n 2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n 3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n 4. 重复步骤 3 直到某一指针达到序列尾；\n 5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n\n# 3. 动图演示\n\n\n\n\n# 堆排序\n\n堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：\n\n 1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；\n 2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；\n\n堆排序的平均时间复杂度为 Ο(nlogn)。\n\n\n# 1. 算法步骤\n\n 1. 将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；\n 2. 把堆首（最大值）和堆尾互换；\n 3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n 4. 重复步骤 2，直到堆的尺寸为 1。\n\n\n# 2. 动图演示\n\n(opens new window)\n\n\n# 计数排序\n\n计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n\n\n# 1. 动图演示\n\n(opens new window)\n\n\n# 桶排序\n\n桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：\n\n 1. 在额外空间充足的情况下，尽量增大桶的数量\n 2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中\n\n同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。\n\n\n# 1. 什么时候最快\n\n当输入的数据可以均匀的分配到每一个桶中。\n\n\n# 2. 什么时候最慢\n\n当输入的数据被分配到了同一个桶中。\n\n\n# 基数排序\n\n基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n\n# 1. 基数排序 vs 计数排序 vs 桶排序\n\n基数排序有两种方法：\n\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：\n\n * 基数排序：根据键值的每位数字来分配桶；\n * 计数排序：每个桶只存储单一键值；\n * 桶排序：每个桶存储一定范围的数值；\n\n\n# 2. LSD 基数排序动图演示\n\n',normalizedContent:'排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：\n\n\n\n关于时间复杂度：\n\n 1. 平方阶 () 排序 各类简单排序：直接插入、直接选择和冒泡排序。\n 2. 线性对数阶 (o(nlog2n)) 排序： 快速排序、堆排序和归并排序；\n 3. o(n1+§) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序\n 4. 线性阶 (o(n)) 排序： 基数排序，此外还有桶、箱排序。\n\n关于稳定性：\n\n稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。\n\n不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。\n\n名词解释：\n\nn：数据规模\n\nk：“桶”的个数\n\nin-place：占用常数内存，不占用额外内存\n\nout-place：占用额外内存\n\n稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同\n\n十种常见排序算法可以分为两大类：\n\n非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破，因此称为非线性时间比较类排序。\n\n线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。\n\n\n# 冒泡排序\n\n冒泡排序（bubble sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n作为最简单的排序算法之一，冒泡排序给我的感觉就像 abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。\n\n\n# 1. 算法步骤\n\n 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n 2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n 3. 针对所有的元素重复以上的步骤，除了最后一个。\n 4. 重复步骤1~3，直到排序完成。\n\n\n# 2. 动图演示\n\n\n\n\n# 3. 什么时候最快\n\n当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。\n\n\n# 4. 什么时候最慢\n\n当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。\n\npublic class bubblesort {\n\n    public static void main(string[] args) {\n        int[] arrs = {1, 3, 4, 2, 6, 5};\n\n        for (int i = 0; i < arrs.length; i++) {\n            for (int j = 0; j < arrs.length - 1 - i; j++) {\n                if (arrs[j] > arrs[j + 1]) {\n                    int tmp = arrs[j];\n                    arrs[j] = arrs[j + 1];\n                    arrs[j + 1] = tmp;\n                }\n            }\n        }\n\n        for (int arr : arrs) {\n            system.out.print(arr + " ");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n嵌套循环，应该立马就可以得出这个算法的时间复杂度为 ²。\n\n\n# 选择排序\n\n选择排序的思路是这样的：首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。\n\n选择排序是一种简单直观的排序算法，无论什么数据进去都是 ² 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n\n\n# 1. 算法步骤\n\n 1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n 2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n 3. 重复第二步，直到所有元素均排序完毕。\n\n\n# 2. 动图演示\n\n\n\npublic class selectionsort {\n\n    public static void main(string[] args) {\n        int[] arrs = {5, 2, 4, 6, 1, 3};\n\n        for (int i = 0; i < arrs.length; i++) {\n            //最小元素下标\n            int min = i;\n            for (int j = i +1; j < arrs.length; j++) {\n                if (arrs[j] < arrs[min]) {\n                    min = j;\n                }\n            }\n            //交换位置\n            int temp = arrs[i];\n            arrs[i] = arrs[min];\n            arrs[min] = temp;\n        }\n        for (int arr : arrs) {\n            system.out.println(arr);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 插入排序\n\n插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\n\n\n# 1. 算法步骤\n\n 1. 从第一个元素开始，该元素可以认为已经被排序；\n 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n 5. 将新元素插入到该位置后；\n 6. 重复步骤2~5。\n\n\n# 2. 动图演示\n\n\n\npublic static void main(string[] args) {\n    int[] arr = {5, 2, 4, 6, 1, 3};\n    // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的\n    for (int i = 1; i < arr.length; i++) {\n\n        // 记录要插入的数据\n        int tmp = arr[i];\n\n        // 从已经排序的序列最右边的开始比较，找到比其小的数\n        int j = i;\n        while (j > 0 && tmp < arr[j - 1]) {\n            arr[j] = arr[j - 1];\n            j--;\n        }\n\n        // 存在比其小的数，插入\n        if (j != i) {\n            arr[j] = tmp;\n        }\n    }\n\n    for (int i : arr) {\n        system.out.println(i);\n    }\n}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 快速排序\n\n这篇很好：https://www.cxyxiaowu.com/5262.html\n\n快速排序的核心思想也是分治法，分而治之。它的实现方式是每次从序列中选出一个基准值，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边，然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动，重复步骤，直到最后都变成单个元素，整个数组就成了有序的序列。\n\n> 快速排序的最坏运行情况是 o(n²)，比如说顺序数列的快排。但它的平摊期望时间是 o(nlogn)，且 o(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 o(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。\n\n\n# 1. 算法步骤\n\n 1. 从数列中挑出一个元素，称为 “基准”（pivot）;\n 2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n 3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n\n\n# 2. 动图演示\n\n\n\n\n# 单边扫描\n\n快速排序的关键之处在于切分，切分的同时要进行比较和移动，这里介绍一种叫做单边扫描的做法。\n\n我们随意抽取一个数作为基准值，同时设定一个标记 mark 代表左边序列最右侧的下标位置，当然初始为 0 ，接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换位置，mark 这个位置存储的是比基准值小的数据，当遍历结束后，将基准值与 mark 所在元素交换位置即可。\n\npublic static void sort(int[] arrs, int startindex, int endindex) {\n  if (startindex > endindex) {\n    return;\n  }\n  int pivotindex = partion(arrs, startindex, endindex);\n  sort(arrs, startindex, pivotindex - 1);\n  sort(arrs, pivotindex + 1, endindex);\n}\n\npublic static int partion(int[] arrs, int startindex, int endindex) {\n  int pivot = arrs[startindex];\n  int mark = startindex;\n\n  for (int i = startindex + 1; i < arrs.length; i++) {\n    if (arrs[i] < pivot) {\n      mark++;\n      int tmp = arrs[mark];\n      arrs[mark] = arrs[i];\n      arrs[i] = tmp;\n    }\n  }\n  arrs[startindex] = arrs[mark];\n  arrs[mark] = pivot;\n  return mark;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 双边扫描\n\n另外还有一种双边扫描的做法，看起来比较直观：我们随意抽取一个数作为基准值，然后从数组左右两边进行扫描，先从左往右找到一个大于基准值的元素，将下标指针记录下来，然后转到从右往左扫描，找到一个小于基准值的元素，交换这两个元素的位置，重复步骤，直到左右两个指针相遇，再将基准值与左侧最右边的元素交换。\n\n我们来看一下实现代码，不同之处只有 partition 方法：\n\npublic static void sort(int[] arr) {\n    sort(arr， 0， arr.length - 1);\n}\n\nprivate static void sort(int[] arr， int startindex， int endindex) {\n    if (endindex <= startindex) {\n        return;\n    }\n    //切分\n    int pivotindex = partition(arr， startindex， endindex);\n    sort(arr， startindex， pivotindex-1);\n    sort(arr， pivotindex+1， endindex);\n}\n\n\nprivate static int partition(int[] arr， int startindex， int endindex) {\n    int left = startindex;\n    int right = endindex;\n    int pivot = arr[startindex];//取第一个元素为基准值\n\n    while (true) {\n        //从左往右扫描\n        while (arr[left] <= pivot) {\n            left++;\n            if (left == right) {\n                break;\n            }\n        }\n\n        //从右往左扫描\n        while (pivot < arr[right]) {\n            right--;\n            if (left == right) {\n                break;\n            }\n        }\n\n        //左右指针相遇\n        if (left >= right) {\n            break;\n        }\n\n        //交换左右数据\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n    }\n\n    //将基准值插入序列\n    int temp = arr[startindex];\n    arr[startindex] = arr[right];\n    arr[right] = temp;\n    return right;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 希尔排序\n\n希尔排序这个名字，来源于它的发明者希尔，也称作“缩小增量排序”，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n\n * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n\n希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\n\n\n# 1. 算法步骤\n\n 1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n 2. 按增量序列个数 k，对序列进行 k 趟排序；\n 3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n\n# 2. 动图演示\n\n\n\n\n# 归并排序\n\n> https://www.cnblogs.com/chengxiao/p/6194356.html\n\n归并排序（merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（divide and conquer）的一个非常典型的应用。\n\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n * 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n * 自下而上的迭代；\n\n在《数据结构与算法 javascript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：\n\n> however, it is not possible to do so in javascript, as the recursion goes too deep for the language to handle.\n> \n> 然而，在 javascript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。\n\n说实话，我不太理解这句话。意思是 javascript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。\n\n和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 o(nlogn) 的时间复杂度。代价是需要额外的内存空间。\n\n\n# 2. 算法步骤\n\n 1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n 2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n 3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n 4. 重复步骤 3 直到某一指针达到序列尾；\n 5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n\n# 3. 动图演示\n\n\n\n\n# 堆排序\n\n堆排序（heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：\n\n 1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；\n 2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；\n\n堆排序的平均时间复杂度为 ο(nlogn)。\n\n\n# 1. 算法步骤\n\n 1. 将待排序序列构建成一个堆 h[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；\n 2. 把堆首（最大值）和堆尾互换；\n 3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n 4. 重复步骤 2，直到堆的尺寸为 1。\n\n\n# 2. 动图演示\n\n(opens new window)\n\n\n# 计数排序\n\n计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n\n\n# 1. 动图演示\n\n(opens new window)\n\n\n# 桶排序\n\n桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：\n\n 1. 在额外空间充足的情况下，尽量增大桶的数量\n 2. 使用的映射函数能够将输入的 n 个数据均匀的分配到 k 个桶中\n\n同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。\n\n\n# 1. 什么时候最快\n\n当输入的数据可以均匀的分配到每一个桶中。\n\n\n# 2. 什么时候最慢\n\n当输入的数据被分配到了同一个桶中。\n\n\n# 基数排序\n\n基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n\n# 1. 基数排序 vs 计数排序 vs 桶排序\n\n基数排序有两种方法：\n\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：\n\n * 基数排序：根据键值的每位数字来分配桶；\n * 计数排序：每个桶只存储单一键值；\n * 桶排序：每个桶存储一定范围的数值；\n\n\n# 2. lsd 基数排序动图演示\n\n',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"二分查找",frontmatter:{title:"二分查找",date:"2022-10-11T23:47:58.000Z",permalink:"/pages/e53094/",categories:["计算机基础","算法"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/40.%E7%AE%97%E6%B3%95/30.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"02.计算机基础/40.算法/30.二分查找.md",key:"v-13949e6a",path:"/pages/e53094/",headers:[{level:3,title:"二分查找",slug:"二分查找",normalizedTitle:"二分查找",charIndex:2},{level:3,title:"寻找左侧边界的二分搜索",slug:"寻找左侧边界的二分搜索",normalizedTitle:"寻找左侧边界的二分搜索",charIndex:769},{level:3,title:"寻找右侧边界的二分查找",slug:"寻找右侧边界的二分查找",normalizedTitle:"寻找右侧边界的二分查找",charIndex:2390},{level:3,title:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_153-寻找旋转排序数组中的最小值)153. 寻找旋转排序数组中的最小值(opens new window)",slug:"_153-寻找旋转排序数组中的最小值-opens-new-window",normalizedTitle:'<a href="https://javakeeper.starfish.ink/data-structure-algorithms/binary-search.html#_153-%e5%af%bb%e6%89%be%e6%97%8b%e8%bd%ac%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9c%80%e5%b0%8f%e5%80%bc" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>153. 寻找旋转排序数组中的最小值(opens new window)',charIndex:null},{level:3,title:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_33-搜索旋转排序数组)33. 搜索旋转排序数组(opens new window)",slug:"_33-搜索旋转排序数组-opens-new-window",normalizedTitle:'<a href="https://javakeeper.starfish.ink/data-structure-algorithms/binary-search.html#_33-%e6%90%9c%e7%b4%a2%e6%97%8b%e8%bd%ac%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>33. 搜索旋转排序数组(opens new window)',charIndex:null},{level:3,title:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_34-在排序数组中查找元素的第一个和最后一个位置)34. 在排序数组中查找元素的第一个和最后一个位置(opens new window)",slug:"_34-在排序数组中查找元素的第一个和最后一个位置-opens-new-window",normalizedTitle:'<a href="https://javakeeper.starfish.ink/data-structure-algorithms/binary-search.html#_34-%e5%9c%a8%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e6%9f%a5%e6%89%be%e5%85%83%e7%b4%a0%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%92%8c%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e4%bd%8d%e7%bd%ae" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>34. 在排序数组中查找元素的第一个和最后一个位置(opens new window)',charIndex:null},{level:3,title:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_287-寻找重复数)287. 寻找重复数(opens new window)",slug:"_287-寻找重复数-opens-new-window",normalizedTitle:'<a href="https://javakeeper.starfish.ink/data-structure-algorithms/binary-search.html#_287-%e5%af%bb%e6%89%be%e9%87%8d%e5%a4%8d%e6%95%b0" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>287. 寻找重复数(opens new window)',charIndex:null},{level:3,title:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_162-寻找峰值)162. 寻找峰值(opens new window)",slug:"_162-寻找峰值-opens-new-window",normalizedTitle:'<a href="https://javakeeper.starfish.ink/data-structure-algorithms/binary-search.html#_162-%e5%af%bb%e6%89%be%e5%b3%b0%e5%80%bc" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>162. 寻找峰值(opens new window)',charIndex:null},{level:3,title:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_240-搜索二维矩阵-ii)240. 搜索二维矩阵 II(opens new window)",slug:"_240-搜索二维矩阵-ii-opens-new-window",normalizedTitle:'<a href="https://javakeeper.starfish.ink/data-structure-algorithms/binary-search.html#_240-%e6%90%9c%e7%b4%a2%e4%ba%8c%e7%bb%b4%e7%9f%a9%e9%98%b5-ii" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>240. 搜索二维矩阵 ii(opens new window)',charIndex:null}],headersStr:"二分查找 寻找左侧边界的二分搜索 寻找右侧边界的二分查找 [#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_153-寻找旋转排序数组中的最小值)153. 寻找旋转排序数组中的最小值(opens new window) [#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_33-搜索旋转排序数组)33. 搜索旋转排序数组(opens new window) [#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_34-在排序数组中查找元素的第一个和最后一个位置)34. 在排序数组中查找元素的第一个和最后一个位置(opens new window) [#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_287-寻找重复数)287. 寻找重复数(opens new window) [#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_162-寻找峰值)162. 寻找峰值(opens new window) [#](https://javakeeper.starfish.ink/data-structure-algorithms/Binary-Search.html#_240-搜索二维矩阵-ii)240. 搜索二维矩阵 II(opens new window)",content:"# 二分查找\n\nint binarySearch(int[] nums, int target) {\n    int left = 0; \n    int right = nums.length - 1; // 注意\n\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(nums[mid] == target)\n            return mid; \n        else if (nums[mid] < target)\n            left = mid + 1; // 注意\n        else if (nums[mid] > target)\n            right = mid - 1; // 注意\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n1、为什么 while 循环的条件中是 <=，而不是 <？\n\n答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。\n\n2、为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？\n\n答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。\n\n刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下一步应该去搜索哪里呢？\n\n\n# 寻找左侧边界的二分搜索\n\npublic static int getLeftNums(int[] nums,int target) {\n  int left = 0;\n  int right = nums.length;\n  while (left < right) {\n    int mid = left + (right - left) / 2;\n    if (nums[mid] == target) {\n      right = mid;\n    } else if (nums[mid] > target) {\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return left;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n1、为什么 while 中是 < 而不是 <=?\n\n答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。\n\nwhile(left < right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。\n\n为什么 left = mid + 1，right = mid ？和之前的算法不一样？\n\n答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。\n\n4、为什么该算法能够搜索左侧边界？\n\n答：关键在于对于 nums[mid] == target 这种情况的处理：\n\n    if (nums[mid] == target)\n        right = mid;\n\n\n1\n2\n\n\n可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\n\nint left_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    // 搜索区间为 [left, right]\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            // 搜索区间变为 [mid+1, right]\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            // 搜索区间变为 [left, mid-1]\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 收缩右侧边界\n            right = mid - 1;\n        }\n    }\n    // 检查出界情况\n    if (left >= nums.length || nums[left] != target) {\n        return -1;\n    }\n    return left;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 寻找右侧边界的二分查找\n\n左闭右开的写法\n\nint right_bound(int[] nums, int target) {\n    if (nums.length == 0) return -1;\n    int left = 0, right = nums.length;\n    \n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            left = mid + 1; // 注意\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid;\n        }\n    }\n    return left - 1; // 注意\n}\nint right_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 这里改成收缩左侧边界即可\n            left = mid + 1;\n        }\n    }\n    // 这里改为检查 right 越界的情况，见下图\n    if (right < 0 || nums[right] != target) {\n        return -1;\n    }\n    return right;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：\n\nint binary_search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1; \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1; \n        } else if(nums[mid] == target) {\n            // 直接返回\n            return mid;\n        }\n    }\n    // 直接返回\n    return -1;\n}\n\nint left_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 别返回，锁定左侧边界\n            right = mid - 1;\n        }\n    }\n    // 最后要检查 left 越界的情况\n    if (left >= nums.length || nums[left] != target) {\n        return -1;\n    }\n    return left;\n}\n\nint right_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 别返回，锁定右侧边界\n            left = mid + 1;\n        }\n    }\n    // 最后要检查 right 越界的情况\n    if (right < 0 || nums[right] != target) {\n        return -1;\n    }\n    return right;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# #153. 寻找旋转排序数组中的最小值(opens new window)\n\n> 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n> \n> 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n> \n> 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n> \n> 输入：nums = [3,4,5,1,2]\n> 输出：1\n> 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n> 输入：nums = [11,13,15,17]\n> 输出：11\n> 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n\n思路：\n\n升序数组+旋转，仍然是部分有序，考虑用二分查找。\n\n> 这种二分查找难就难在，arr[mid] 跟谁比。\n> \n> 我们的目的是：当进行一次比较时，一定能够确定答案在 mid 的某一侧。一次比较为 arr[mid] 跟谁比的问题。 一般的比较原则有：\n> \n>  * 如果有目标值 target，那么直接让 arr[mid] 和 target 比较即可。\n>  * 如果没有目标值，一般可以考虑 端点\n\n旋转数组，那最小值右侧的元素肯定都小于数组中的最后一个元素 nums[n-1]，左侧元素都大于 num[n-1]\n\npublic static int findMin(int[] nums) {\n  int left = 0;\n  int right = nums.length - 1;\n  //左闭右开\n  while (left < right) {\n    int mid = left + (right - left) / 2;\n    //疑问：为什么right = mid;而不是 right = mid-1;\n    //解答：{4,5,1,2,3}，如果right = mid-1，则丢失了最小值1\n    if (nums[mid] < nums[right]) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return nums[left];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果是求旋转数组中的最大值呢\n\npublic static int findMax(int[] nums) {\n  int left = 0;\n  int right = nums.length - 1;\n\n  while (left < right) {\n    int mid = left + (right - left) >> 1;\n\n    //因为向下取整，left可能会等于mid，所以要考虑\n    if (nums[left] < nums[right]) {\n      return nums[right];\n    }\n\n    //[left,mid] 是递增的，最大值只会在[mid,right]中\n    if (nums[left] < nums[mid]) {\n      left = mid;\n    } else {\n      //[mid,right]递增，最大值只会在[left, mid-1]中\n      right = mid - 1;\n    }\n  }\n  return nums[left];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# #33. 搜索旋转排序数组(opens new window)\n\n> 整数数组 nums 按升序排列，数组中的值 互不相同 。\n> \n> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n> \n> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n> \n> 输入：nums = [4,5,6,7,0,1,2], target = 0\n> 输出：4\n> 输入：nums = [4,5,6,7,0,1,2], target = 3\n> 输出：-1\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n思路：\n\n旋转数组后，依然是局部有序，从数组中间分成左右两部分后，一定有一部分是有序的\n\n * 如果 [l, mid - 1] 是有序数组，且 target 的大小满足 [{nums}[l],{nums}[mid]))，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。\n * 如果 [mid, r] 是有序数组，且 target 的大小满足 ({nums}[mid+1],{nums}[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。\n\npublic static int search(int[] nums,int target) {\n  int n = nums.length;\n  //特例\n  if (n == 0) {\n    return -1;\n  }\n  if (n == 1) {\n    return nums[0] == target ? 0 : -1;\n  }\n\n  int left = 0;\n  int right = nums.length - 1;\n\n  while (left <= right) {\n    int mid = left + (right - left) / 2;\n    if (target == nums[mid]) {\n      return mid;\n    }\n    //左侧有序的话\n    if (nums[0] <= nums[mid]) {\n      if (nums[0] <= target && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {  //右侧有序\n      if (nums[mid] < target && target <= nums[n - 1]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# #34. 在排序数组中查找元素的第一个和最后一个位置(opens new window)\n\n> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n> \n> 如果数组中不存在目标值 target，返回 [-1, -1]。\n> \n> 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？\n> \n> 输入：nums = [5,7,7,8,8,10], target = 8\n> 输出：[3,4]\n> 输入：nums = [5,7,7,8,8,10], target = 6\n> 输出：[-1,-1]\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n思路：二分法寻找左右边界值\n\npublic int[] searchRange(int[] nums, int target) {\n  int first = binarySearch(nums, target, true);\n  int last = binarySearch(nums, target, false);\n  return new int[]{first, last};\n}\n\npublic int binarySearch(int[] nums, int target, boolean findLast) {\n  int length = nums.length;\n  int left = 0, right = length - 1;\n  //结果，因为可能有多个值，所以需要先保存起来\n  int index = -1;\n  while (left <= right) {\n    //取中间值\n    int middle = left + (right - left) / 2;\n\n    //找到相同的值（只有这个地方和普通二分查找有不同）\n    if (nums[middle] == target) {\n      //先赋值一下，肯定是找到了，只是不知道这个值是不是在区域的边界内\n      index = middle;\n      //如果是查找最后的\n      if (findLast) {\n        //那我们将浮标移动到下一个值试探一下后面的值还是否有target\n        left = middle + 1;\n      } else {\n        //否则，就是查找第一个值，也是同理，移动指针到上一个值去试探一下上一个值是不是等于target\n        right = middle - 1;\n      }\n\n      //下面2个就是普通的二分查找流程，大于小于都移动指针\n    } else if (nums[middle] < target) {\n      left = middle + 1;\n    } else {\n      right = middle - 1;\n    }\n\n  }\n  return index;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# #287. 寻找重复数(opens new window)\n\n> 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\n> \n> 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\n> \n> 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。\n> \n> 输入：nums = [1,3,4,2,2]\n> 输出：2\n> 输入：nums = [3,1,3,4,2]\n> 输出：3\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n思路：\n\n二分查找的思路是先猜一个数（有效范围 [left..right] 里位于中间的数 mid），然后统计原始数组中 小于等于 mid 的元素的个数 cnt：\n\n如果 cnt 严格大于 mid。根据抽屉原理，重复元素就在区间 [left..mid] 里； 否则，重复元素就在区间 [mid + 1..right] 里。 与绝大多数使用二分查找问题不同的是，这道题正着思考是容易的，即：思考哪边区间存在重复数是容易的，因为有抽屉原理做保证。\n\npublic int findDuplicate(int[] nums) {\n  int len = nums.length;\n  int left = 1;\n  int right = len - 1;\n  while (left < right) {\n    int mid = left + (right - left) / 2;\n\n    int cnt = 0;\n    for (int num : nums) {\n      if (num <= mid) {\n        cnt += 1;\n      }\n    }\n\n    // 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个，此时重复元素一定出现在 [1..4] 区间里\n    if (cnt > mid) {\n      // 重复元素位于区间 [left..mid]\n      right = mid;\n    } else {\n      // if 分析正确了以后，else 搜索的区间就是 if 的反面区间 [mid + 1..right]\n      left = mid + 1;\n    }\n  }\n  return left;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# #162. 寻找峰值(opens new window)\n\n> 峰值元素是指其值严格大于左右相邻值的元素。\n> \n> 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n> \n> 你可以假设 nums[-1] = nums[n] = -∞ 。\n> \n> 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n> \n> 输入：nums = [1,2,3,1]\n> 输出：2\n> 解释：3 是峰值元素，你的函数应该返回其索引 2。\n> 输入：nums = [1,2,1,3,5,6,4]\n> 输出：1 或 5 \n> 解释：你的函数可以返回索引 1，其峰值元素为 2；\n>      或者返回索引 5， 其峰值元素为 6。\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n思路：\n\n这题，最简单的思路就是直接找最大值，但这样复杂度是\n\n在二分查找中，每次会找到一个位置 midmid。我们发现，midmid 只有如下三种情况：\n\n * midmid 为一个峰值，此时我们通过比较 midmid 位置元素与两边元素大小即可。\n * midmid 在一个峰值右侧，此时有 nums[mid] < nums[mid + 1]nums[mid]<nums[mid+1]，此时我们向右调整搜索范围，在 [mid + 1, r][mid+1,r] 范围内继续查找。\n * midmid 在一个峰值左侧，此时有 nums[mid] < nums[mid - 1]nums[mid]<nums[mid−1]，此时我们向左调整搜索范围，在 [l + 1, mid][l+1,mid] 范围内继续查找。\n\npublic int findPeakElement(int[] nums) {\n  int n = nums.length;\n  if (n == 1) {\n    return 0;\n  }\n\n  // 先特判两边情况\n  if (nums[0] > nums[1]) return 0;\n  if (nums[n - 1] > nums[n - 2]) return n - 1;\n\n  int l = 0, r = n - 1;\n  while (l <= r) {\n    int mid = (l + r) / 2;\n\n    // 当前为峰值\n    if (mid >= 1 && mid < n - 1 && nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n      return mid;\n    } else if (mid >= 1 && nums[mid] < nums[mid - 1]) {\n      // 峰值在 mid 左侧\n      r = mid - 1;\n    } else if (mid < n - 1 && nums[mid] < nums[mid + 1]) {\n      // 峰值在 mid 右侧\n      l = mid + 1;\n    }\n  }\n  return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# #240. 搜索二维矩阵 II(opens new window)\n\n> 剑指 Offer 04. 二维数组中的查找 (opens new window)一样的题目\n> \n> 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n> \n> 现有矩阵 matrix 如下：\n> \n> [\n>   [1,   4,  7, 11, 15],\n>   [2,   5,  8, 12, 19],\n>   [3,   6,  9, 16, 22],\n>   [10, 13, 14, 17, 24],\n>   [18, 21, 23, 26, 30]\n> ]\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 给定 target = 5，返回 true。\n> \n> 给定 target = 20，返回 false。\n\n思路：\n\n站在右上角看。这个矩阵其实就像是一个Binary Search Tree。然后，聪明的大家应该知道怎么做了。\n\npublic static boolean findNumberIn2DArray(int[][] matrix, int target) {\n\n  if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n    return false;\n  }\n\n  int rows = matrix.length;\n  int columns = matrix[0].length;\n  for (int i = 0; i < rows; i++) {\n    for (int j = 0; j < columns; j++) {\n      if (matrix[i][j] == target) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果你写出这样的暴力解法，面试官可能就会反问你了：你还有什么想问的吗？\n\n言归正传，有序的数组，我们首先应该想到二分\n\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        for (int[] row : matrix) {\n            int index = search(row, target);\n            if (index >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        while (low <= high) {\n            int mid = (high - low) / 2 + low;\n            int num = nums[mid];\n            if (num == target) {\n                return mid;\n            } else if (num > target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nZ 字形查找\n\n> 假设arr数组，val，tar如下图所示： 如果我们把二分值定在右上角或者左下角，就可以进行二分。这里以右上角为例，左下角可自行分析： 1）我么设初始值为右上角元素，arr[0][5] = val，目标tar = arr[3][1] 2）接下来进行二分操作： 3）如果val == target,直接返回 4）如果 tar > val, 说明target在更大的位置，val左边的元素显然都是 < val，间接 < tar，说明第 0 行都是无效的，所以val下移到arr[1][5] 5）如果 tar < val, 说明target在更小的位置，val下边的元素显然都是 > val，间接 > tar，说明第 5 列都是无效的，所以val左移到arr[0][4] 6）继续步骤2)\n\npublic static boolean findNumberIn2DArray(int[][] matrix, int target) {\n\n  if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n    return false;\n  }\n\n  int rows = matrix.length;\n  int columns = matrix[0].length;\n  //右上角坐标\n  int row = 0;\n  int col = columns - 1;\n  while (row < rows && col >= 0) {\n    int num = matrix[row][col];\n    if (num == target) {\n      return true;\n    } else if (target > num) {\n      row++;\n    } else {\n      col--;\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"# 二分查找\n\nint binarysearch(int[] nums, int target) {\n    int left = 0; \n    int right = nums.length - 1; // 注意\n\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(nums[mid] == target)\n            return mid; \n        else if (nums[mid] < target)\n            left = mid + 1; // 注意\n        else if (nums[mid] > target)\n            right = mid - 1; // 注意\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n1、为什么 while 循环的条件中是 <=，而不是 <？\n\n答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。\n\n2、为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？\n\n答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。\n\n刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下一步应该去搜索哪里呢？\n\n\n# 寻找左侧边界的二分搜索\n\npublic static int getleftnums(int[] nums,int target) {\n  int left = 0;\n  int right = nums.length;\n  while (left < right) {\n    int mid = left + (right - left) / 2;\n    if (nums[mid] == target) {\n      right = mid;\n    } else if (nums[mid] > target) {\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return left;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n1、为什么 while 中是 < 而不是 <=?\n\n答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。\n\nwhile(left < right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。\n\n为什么 left = mid + 1，right = mid ？和之前的算法不一样？\n\n答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。\n\n4、为什么该算法能够搜索左侧边界？\n\n答：关键在于对于 nums[mid] == target 这种情况的处理：\n\n    if (nums[mid] == target)\n        right = mid;\n\n\n1\n2\n\n\n可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\n\nint left_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    // 搜索区间为 [left, right]\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            // 搜索区间变为 [mid+1, right]\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            // 搜索区间变为 [left, mid-1]\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 收缩右侧边界\n            right = mid - 1;\n        }\n    }\n    // 检查出界情况\n    if (left >= nums.length || nums[left] != target) {\n        return -1;\n    }\n    return left;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 寻找右侧边界的二分查找\n\n左闭右开的写法\n\nint right_bound(int[] nums, int target) {\n    if (nums.length == 0) return -1;\n    int left = 0, right = nums.length;\n    \n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            left = mid + 1; // 注意\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid;\n        }\n    }\n    return left - 1; // 注意\n}\nint right_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 这里改成收缩左侧边界即可\n            left = mid + 1;\n        }\n    }\n    // 这里改为检查 right 越界的情况，见下图\n    if (right < 0 || nums[right] != target) {\n        return -1;\n    }\n    return right;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：\n\nint binary_search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1; \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1; \n        } else if(nums[mid] == target) {\n            // 直接返回\n            return mid;\n        }\n    }\n    // 直接返回\n    return -1;\n}\n\nint left_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 别返回，锁定左侧边界\n            right = mid - 1;\n        }\n    }\n    // 最后要检查 left 越界的情况\n    if (left >= nums.length || nums[left] != target) {\n        return -1;\n    }\n    return left;\n}\n\nint right_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 别返回，锁定右侧边界\n            left = mid + 1;\n        }\n    }\n    // 最后要检查 right 越界的情况\n    if (right < 0 || nums[right] != target) {\n        return -1;\n    }\n    return right;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# #153. 寻找旋转排序数组中的最小值(opens new window)\n\n> 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。\n> \n> 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n> \n> 你必须设计一个时间复杂度为 o(log n) 的算法解决此问题。\n> \n> 输入：nums = [3,4,5,1,2]\n> 输出：1\n> 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n> 输入：nums = [11,13,15,17]\n> 输出：11\n> 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n\n思路：\n\n升序数组+旋转，仍然是部分有序，考虑用二分查找。\n\n> 这种二分查找难就难在，arr[mid] 跟谁比。\n> \n> 我们的目的是：当进行一次比较时，一定能够确定答案在 mid 的某一侧。一次比较为 arr[mid] 跟谁比的问题。 一般的比较原则有：\n> \n>  * 如果有目标值 target，那么直接让 arr[mid] 和 target 比较即可。\n>  * 如果没有目标值，一般可以考虑 端点\n\n旋转数组，那最小值右侧的元素肯定都小于数组中的最后一个元素 nums[n-1]，左侧元素都大于 num[n-1]\n\npublic static int findmin(int[] nums) {\n  int left = 0;\n  int right = nums.length - 1;\n  //左闭右开\n  while (left < right) {\n    int mid = left + (right - left) / 2;\n    //疑问：为什么right = mid;而不是 right = mid-1;\n    //解答：{4,5,1,2,3}，如果right = mid-1，则丢失了最小值1\n    if (nums[mid] < nums[right]) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return nums[left];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果是求旋转数组中的最大值呢\n\npublic static int findmax(int[] nums) {\n  int left = 0;\n  int right = nums.length - 1;\n\n  while (left < right) {\n    int mid = left + (right - left) >> 1;\n\n    //因为向下取整，left可能会等于mid，所以要考虑\n    if (nums[left] < nums[right]) {\n      return nums[right];\n    }\n\n    //[left,mid] 是递增的，最大值只会在[mid,right]中\n    if (nums[left] < nums[mid]) {\n      left = mid;\n    } else {\n      //[mid,right]递增，最大值只会在[left, mid-1]中\n      right = mid - 1;\n    }\n  }\n  return nums[left];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# #33. 搜索旋转排序数组(opens new window)\n\n> 整数数组 nums 按升序排列，数组中的值 互不相同 。\n> \n> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n> \n> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n> \n> 输入：nums = [4,5,6,7,0,1,2], target = 0\n> 输出：4\n> 输入：nums = [4,5,6,7,0,1,2], target = 3\n> 输出：-1\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n思路：\n\n旋转数组后，依然是局部有序，从数组中间分成左右两部分后，一定有一部分是有序的\n\n * 如果 [l, mid - 1] 是有序数组，且 target 的大小满足 [{nums}[l],{nums}[mid]))，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。\n * 如果 [mid, r] 是有序数组，且 target 的大小满足 ({nums}[mid+1],{nums}[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。\n\npublic static int search(int[] nums,int target) {\n  int n = nums.length;\n  //特例\n  if (n == 0) {\n    return -1;\n  }\n  if (n == 1) {\n    return nums[0] == target ? 0 : -1;\n  }\n\n  int left = 0;\n  int right = nums.length - 1;\n\n  while (left <= right) {\n    int mid = left + (right - left) / 2;\n    if (target == nums[mid]) {\n      return mid;\n    }\n    //左侧有序的话\n    if (nums[0] <= nums[mid]) {\n      if (nums[0] <= target && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {  //右侧有序\n      if (nums[mid] < target && target <= nums[n - 1]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# #34. 在排序数组中查找元素的第一个和最后一个位置(opens new window)\n\n> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n> \n> 如果数组中不存在目标值 target，返回 [-1, -1]。\n> \n> 你可以设计并实现时间复杂度为 o(log n) 的算法解决此问题吗？\n> \n> 输入：nums = [5,7,7,8,8,10], target = 8\n> 输出：[3,4]\n> 输入：nums = [5,7,7,8,8,10], target = 6\n> 输出：[-1,-1]\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n思路：二分法寻找左右边界值\n\npublic int[] searchrange(int[] nums, int target) {\n  int first = binarysearch(nums, target, true);\n  int last = binarysearch(nums, target, false);\n  return new int[]{first, last};\n}\n\npublic int binarysearch(int[] nums, int target, boolean findlast) {\n  int length = nums.length;\n  int left = 0, right = length - 1;\n  //结果，因为可能有多个值，所以需要先保存起来\n  int index = -1;\n  while (left <= right) {\n    //取中间值\n    int middle = left + (right - left) / 2;\n\n    //找到相同的值（只有这个地方和普通二分查找有不同）\n    if (nums[middle] == target) {\n      //先赋值一下，肯定是找到了，只是不知道这个值是不是在区域的边界内\n      index = middle;\n      //如果是查找最后的\n      if (findlast) {\n        //那我们将浮标移动到下一个值试探一下后面的值还是否有target\n        left = middle + 1;\n      } else {\n        //否则，就是查找第一个值，也是同理，移动指针到上一个值去试探一下上一个值是不是等于target\n        right = middle - 1;\n      }\n\n      //下面2个就是普通的二分查找流程，大于小于都移动指针\n    } else if (nums[middle] < target) {\n      left = middle + 1;\n    } else {\n      right = middle - 1;\n    }\n\n  }\n  return index;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# #287. 寻找重复数(opens new window)\n\n> 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\n> \n> 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\n> \n> 你设计的解决方案必须 不修改 数组 nums 且只用常量级 o(1) 的额外空间。\n> \n> 输入：nums = [1,3,4,2,2]\n> 输出：2\n> 输入：nums = [3,1,3,4,2]\n> 输出：3\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n思路：\n\n二分查找的思路是先猜一个数（有效范围 [left..right] 里位于中间的数 mid），然后统计原始数组中 小于等于 mid 的元素的个数 cnt：\n\n如果 cnt 严格大于 mid。根据抽屉原理，重复元素就在区间 [left..mid] 里； 否则，重复元素就在区间 [mid + 1..right] 里。 与绝大多数使用二分查找问题不同的是，这道题正着思考是容易的，即：思考哪边区间存在重复数是容易的，因为有抽屉原理做保证。\n\npublic int findduplicate(int[] nums) {\n  int len = nums.length;\n  int left = 1;\n  int right = len - 1;\n  while (left < right) {\n    int mid = left + (right - left) / 2;\n\n    int cnt = 0;\n    for (int num : nums) {\n      if (num <= mid) {\n        cnt += 1;\n      }\n    }\n\n    // 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个，此时重复元素一定出现在 [1..4] 区间里\n    if (cnt > mid) {\n      // 重复元素位于区间 [left..mid]\n      right = mid;\n    } else {\n      // if 分析正确了以后，else 搜索的区间就是 if 的反面区间 [mid + 1..right]\n      left = mid + 1;\n    }\n  }\n  return left;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# #162. 寻找峰值(opens new window)\n\n> 峰值元素是指其值严格大于左右相邻值的元素。\n> \n> 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n> \n> 你可以假设 nums[-1] = nums[n] = -∞ 。\n> \n> 你必须实现时间复杂度为 o(log n) 的算法来解决此问题。\n> \n> 输入：nums = [1,2,3,1]\n> 输出：2\n> 解释：3 是峰值元素，你的函数应该返回其索引 2。\n> 输入：nums = [1,2,1,3,5,6,4]\n> 输出：1 或 5 \n> 解释：你的函数可以返回索引 1，其峰值元素为 2；\n>      或者返回索引 5， 其峰值元素为 6。\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n思路：\n\n这题，最简单的思路就是直接找最大值，但这样复杂度是\n\n在二分查找中，每次会找到一个位置 midmid。我们发现，midmid 只有如下三种情况：\n\n * midmid 为一个峰值，此时我们通过比较 midmid 位置元素与两边元素大小即可。\n * midmid 在一个峰值右侧，此时有 nums[mid] < nums[mid + 1]nums[mid]<nums[mid+1]，此时我们向右调整搜索范围，在 [mid + 1, r][mid+1,r] 范围内继续查找。\n * midmid 在一个峰值左侧，此时有 nums[mid] < nums[mid - 1]nums[mid]<nums[mid−1]，此时我们向左调整搜索范围，在 [l + 1, mid][l+1,mid] 范围内继续查找。\n\npublic int findpeakelement(int[] nums) {\n  int n = nums.length;\n  if (n == 1) {\n    return 0;\n  }\n\n  // 先特判两边情况\n  if (nums[0] > nums[1]) return 0;\n  if (nums[n - 1] > nums[n - 2]) return n - 1;\n\n  int l = 0, r = n - 1;\n  while (l <= r) {\n    int mid = (l + r) / 2;\n\n    // 当前为峰值\n    if (mid >= 1 && mid < n - 1 && nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n      return mid;\n    } else if (mid >= 1 && nums[mid] < nums[mid - 1]) {\n      // 峰值在 mid 左侧\n      r = mid - 1;\n    } else if (mid < n - 1 && nums[mid] < nums[mid + 1]) {\n      // 峰值在 mid 右侧\n      l = mid + 1;\n    }\n  }\n  return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# #240. 搜索二维矩阵 ii(opens new window)\n\n> 剑指 offer 04. 二维数组中的查找 (opens new window)一样的题目\n> \n> 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n> \n> 现有矩阵 matrix 如下：\n> \n> [\n>   [1,   4,  7, 11, 15],\n>   [2,   5,  8, 12, 19],\n>   [3,   6,  9, 16, 22],\n>   [10, 13, 14, 17, 24],\n>   [18, 21, 23, 26, 30]\n> ]\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 给定 target = 5，返回 true。\n> \n> 给定 target = 20，返回 false。\n\n思路：\n\n站在右上角看。这个矩阵其实就像是一个binary search tree。然后，聪明的大家应该知道怎么做了。\n\npublic static boolean findnumberin2darray(int[][] matrix, int target) {\n\n  if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n    return false;\n  }\n\n  int rows = matrix.length;\n  int columns = matrix[0].length;\n  for (int i = 0; i < rows; i++) {\n    for (int j = 0; j < columns; j++) {\n      if (matrix[i][j] == target) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果你写出这样的暴力解法，面试官可能就会反问你了：你还有什么想问的吗？\n\n言归正传，有序的数组，我们首先应该想到二分\n\nclass solution {\n    public boolean searchmatrix(int[][] matrix, int target) {\n        for (int[] row : matrix) {\n            int index = search(row, target);\n            if (index >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        while (low <= high) {\n            int mid = (high - low) / 2 + low;\n            int num = nums[mid];\n            if (num == target) {\n                return mid;\n            } else if (num > target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nz 字形查找\n\n> 假设arr数组，val，tar如下图所示： 如果我们把二分值定在右上角或者左下角，就可以进行二分。这里以右上角为例，左下角可自行分析： 1）我么设初始值为右上角元素，arr[0][5] = val，目标tar = arr[3][1] 2）接下来进行二分操作： 3）如果val == target,直接返回 4）如果 tar > val, 说明target在更大的位置，val左边的元素显然都是 < val，间接 < tar，说明第 0 行都是无效的，所以val下移到arr[1][5] 5）如果 tar < val, 说明target在更小的位置，val下边的元素显然都是 > val，间接 > tar，说明第 5 列都是无效的，所以val左移到arr[0][4] 6）继续步骤2)\n\npublic static boolean findnumberin2darray(int[][] matrix, int target) {\n\n  if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n    return false;\n  }\n\n  int rows = matrix.length;\n  int columns = matrix[0].length;\n  //右上角坐标\n  int row = 0;\n  int col = columns - 1;\n  while (row < rows && col >= 0) {\n    int num = matrix[row][col];\n    if (num == target) {\n      return true;\n    } else if (target > num) {\n      row++;\n    } else {\n      col--;\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"双指针",frontmatter:{title:"双指针",date:"2022-10-11T23:53:40.000Z",permalink:"/pages/30153a/",categories:["计算机基础","算法"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/40.%E7%AE%97%E6%B3%95/40.%E5%8F%8C%E6%8C%87%E9%92%88.html",relativePath:"02.计算机基础/40.算法/40.双指针.md",key:"v-a406533a",path:"/pages/30153a/",headers:[{level:4,title:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Double-Pointer.html#_42-接雨水)42. 接雨水(opens new window)",slug:"_42-接雨水-opens-new-window",normalizedTitle:'<a href="https://javakeeper.starfish.ink/data-structure-algorithms/double-pointer.html#_42-%e6%8e%a5%e9%9b%a8%e6%b0%b4" target="_blank" rel="noopener noreferrer">#<outboundlink/></a>42. 接雨水(opens new window)',charIndex:null},{level:2,title:"一、左右指针",slug:"一、左右指针",normalizedTitle:"一、左右指针",charIndex:100},{level:3,title:"两数之和 II - 输入有序数组",slug:"两数之和-ii-输入有序数组",normalizedTitle:"两数之和 ii - 输入有序数组",charIndex:343},{level:3,title:"三数之和",slug:"三数之和",normalizedTitle:"三数之和",charIndex:310},{level:3,title:"盛最多水的容器",slug:"盛最多水的容器",normalizedTitle:"盛最多水的容器",charIndex:275},{level:3,title:"验证回文串",slug:"验证回文串",normalizedTitle:"验证回文串",charIndex:388},{level:3,title:"反转字符串",slug:"反转字符串",normalizedTitle:"反转字符串",charIndex:422},{level:3,title:"二分查找",slug:"二分查找",normalizedTitle:"二分查找",charIndex:488},{level:2,title:"二、快慢指针",slug:"二、快慢指针",normalizedTitle:"二、快慢指针",charIndex:5672},{level:3,title:"环形链表",slug:"环形链表",normalizedTitle:"环形链表",charIndex:5705},{level:3,title:"环形链表 II",slug:"环形链表-ii",normalizedTitle:"环形链表 ii",charIndex:6445},{level:3,title:"链表的中间结点",slug:"链表的中间结点",normalizedTitle:"链表的中间结点",charIndex:5815},{level:3,title:"删除链表的倒数第 N 个结点",slug:"删除链表的倒数第-n-个结点",normalizedTitle:"删除链表的倒数第 n 个结点",charIndex:5772},{level:3,title:"删除有序数组中的重复项",slug:"删除有序数组中的重复项",normalizedTitle:"删除有序数组中的重复项",charIndex:5850},{level:3,title:"最长连续递增序列",slug:"最长连续递增序列",normalizedTitle:"最长连续递增序列",charIndex:8695},{level:2,title:"三、滑动窗口",slug:"三、滑动窗口",normalizedTitle:"三、滑动窗口",charIndex:9402},{level:3,title:"3.1 同向交替移动的两个变量",slug:"_3-1-同向交替移动的两个变量",normalizedTitle:"3.1 同向交替移动的两个变量",charIndex:9993},{level:4,title:"子数组最大平均数 I",slug:"子数组最大平均数-i",normalizedTitle:"子数组最大平均数 i",charIndex:9563},{level:3,title:"3.2 不定长度的滑动窗口",slug:"_3-2-不定长度的滑动窗口",normalizedTitle:"3.2 不定长度的滑动窗口",charIndex:10718},{level:4,title:"无重复字符的最长子串",slug:"无重复字符的最长子串",normalizedTitle:"无重复字符的最长子串",charIndex:9638},{level:4,title:"最小覆盖子串",slug:"最小覆盖子串",normalizedTitle:"最小覆盖子串",charIndex:9676},{level:4,title:"替换后的最长重复字符",slug:"替换后的最长重复字符",normalizedTitle:"替换后的最长重复字符",charIndex:9711},{level:3,title:"3.3 计数问题",slug:"_3-3-计数问题",normalizedTitle:"3.3 计数问题",charIndex:13005},{level:4,title:"至多包含两个不同字符的最长子串",slug:"至多包含两个不同字符的最长子串",normalizedTitle:"至多包含两个不同字符的最长子串",charIndex:13017},{level:4,title:"至多包含 K 个不同字符的最长子串",slug:"至多包含-k-个不同字符的最长子串",normalizedTitle:"至多包含 k 个不同字符的最长子串",charIndex:13197},{level:4,title:"区间子数组个数",slug:"区间子数组个数",normalizedTitle:"区间子数组个数",charIndex:13337},{level:4,title:"K 个不同整数的子数组",slug:"k-个不同整数的子数组",normalizedTitle:"k 个不同整数的子数组",charIndex:13556},{level:3,title:"3.4 使用数据结构维护窗口性质",slug:"_3-4-使用数据结构维护窗口性质",normalizedTitle:"3.4 使用数据结构维护窗口性质",charIndex:13576},{level:4,title:"滑动窗口最大值",slug:"滑动窗口最大值",normalizedTitle:"滑动窗口最大值",charIndex:13677},{level:4,title:"滑动窗口中位数",slug:"滑动窗口中位数",normalizedTitle:"滑动窗口中位数",charIndex:13688},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:13700}],headersStr:"[#](https://javakeeper.starfish.ink/data-structure-algorithms/Double-Pointer.html#_42-接雨水)42. 接雨水(opens new window) 一、左右指针 两数之和 II - 输入有序数组 三数之和 盛最多水的容器 验证回文串 反转字符串 二分查找 二、快慢指针 环形链表 环形链表 II 链表的中间结点 删除链表的倒数第 N 个结点 删除有序数组中的重复项 最长连续递增序列 三、滑动窗口 3.1 同向交替移动的两个变量 子数组最大平均数 I 3.2 不定长度的滑动窗口 无重复字符的最长子串 最小覆盖子串 替换后的最长重复字符 3.3 计数问题 至多包含两个不同字符的最长子串 至多包含 K 个不同字符的最长子串 区间子数组个数 K 个不同整数的子数组 3.4 使用数据结构维护窗口性质 滑动窗口最大值 滑动窗口中位数 总结",content:'归纳下双指针算法，其实总共就三类\n\n * 左右指针，数组和字符串问题\n * 快慢指针，主要是成环问题\n * 滑动窗口，针对子串问题\n\n# #42. 接雨水(opens new window)\n\n\n# 一、左右指针\n\n左右指针在数组中其实就是两个索引值，\n\nTODO: 一般都是有序数组？或者先排序后？\n\nJavaer 一般这么表示：\n\nint left = i + 1;\nint right = nums.length - 1;\nwhile(left < right)\n  ***\n\n\n1\n2\n3\n4\n\n\n这两个指针 相向交替移动\n\n\n\n> 11. 盛最多水的容器(opens new window)\n> \n> 15. 三数之和(opens new window)\n> \n> 167. 两数之和 II - 输入有序数组(opens new window)\n> \n> 125. 验证回文串(opens new window)\n> \n> 344. 反转字符串(opens new window)\n> \n> 283. 移动零(opens new window)\n> \n> 704. 二分查找(opens new window)\n> \n> 34. 在排序数组中查找元素的第一个和最后一个位置(opens new window)\n\nTODO: 画图对比各个算法\n\n\n# 两数之和 II - 输入有序数组\n\n> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n> \n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n> \n> 你可以按任意顺序返回答案。\n> \n> 输入：nums = [2,7,11,15], target = 9\n> 输出：[0,1]\n> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n> \n> \n> 1\n> 2\n> 3\n\n直接用左右指针套就可以\n\npublic static int[] towSum(int[] nums, int target) {\n    int left = 0;\n    int rigth = nums.length - 1;\n    while(left < rigth){\n        int tmp = nums[left] + nums[rigth];\n        if (target == tmp) {\n            return new int[]{left, rigth};\n        } else if (tmp > target) {\n            rigth--; //右移\n        } else {\n            left++;  //左移\n        }\n    }\n    return new int[]{-1, -1};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 三数之和\n\n排序、双指针、去重\n\n第一个想法是，这三个数，两个指针？\n\n * 对数组排序，固定一个数 ，然后遍历数组，并移动左右指针求和，判断是否有等于 0 的情况\n * 特例：\n   * 排序后第一个数就大于 0，不干了\n   * 有三个需要去重的地方\n     * nums[i] == nums[i - 1] 直接跳过本次遍历\n     * nums[left] == nums[left + 1] 移动指针，即去重\n     * nums[right] == nums[right - 1] 移动指针\n\n\n\npublic static List<List<Integer>> threeSum(int[] nums) {\n  //存放结果list\n  List<List<Integer>> result = new ArrayList<>();\n  int length = nums.length;\n  //特例判断\n  if (length < 3) {\n    return result;\n  }\n  Arrays.sort(nums);\n  for (int i = 0; i < length; i++) {\n    //排序后的第一个数字就大于0，就说明没有符合要求的结果\n    if (nums[i] > 0) break;\n\n    //去重\n    if (i > 0 && nums[i] == nums[i - 1]) continue;\n    //左右指针\n    int l = i + 1;\n    int r = length - 1;\n    while (l < r) {\n      int sum = nums[i] + nums[l] + nums[r];\n      if (sum == 0) {\n        result.add(Arrays.asList(nums[i], nums[l], nums[r]));\n        //去重（相同数字的话就移动指针）\n        while (nums[l] == nums[l + 1]) l++;\n        while (nums[r] == nums[r - 1]) r--;\n        //移动指针\n        l++;\n        r--;\n      } else if (sum < 0) {\n        l++;\n      } else if (sum > 0) {\n        r--;\n      }\n    }\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 盛最多水的容器\n\n> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n> \n> 输入：[1,8,6,2,5,4,8,3,7]\n> 输出：49 \n> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 求得是水量，水量 = 两个指针指向的数字中较小值 * 指针之间的距离（水桶原理，最短的板才不会漏水）\n * 为了求最大水量，我们需要存储所有条件的水量，进行比较才行\n * 双指针相向移动，循环收窄，直到两个指针相遇\n * 往哪个方向移动，需要考虑清楚，如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会更小，所以我们移动数字较小的那个指针\n\npublic int maxArea(int[] height){\n  int left = 0;\n  int right = height.length - 1;\n  //需要保存各个阶段的值\n  int result = 0;\n  while(left < right){\n    //水量 = 两个指针指向的数字中较小值∗指针之间的距离\n    int area = Math.min(height[left],height[right]) * (right - left);\n    result = Math.max(result,area);\n    //移动数字较小的指针\n    if(height[left] <= height[right]){\n      left ++;\n    }else{\n      right--;\n    }\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 验证回文串\n\n> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n> \n> 说明：本题中，我们将空字符串定义为有效的回文串。\n> \n> 输入: "A man, a plan, a canal: Panama"\n> 输出: true\n> 解释："amanaplanacanalpanama" 是回文串\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 没看题解前，因为这个例子中有各种逗号、空格啥的，我第一想到的其实就是先遍历放在一个数组里，然后再去判断，看题解可以在原字符串完成，降低了空间复杂度\n * 首先需要知道三个 API\n   * Character.isLetterOrDigit 确定指定的字符是否为字母或数字\n   * Character.toLowerCase 将大写字符转换为小写\n   * public char charAt(int index) String 中的方法，用于返回指定索引处的字符\n * 双指针，每移动一步，判断这两个值是不是相同\n * 两个指针相遇，则是回文串\n\npublic boolean isPalindrome(String s) {\n  int left = 0;\n  int right = s.length() - 1;\n  while (left < right) {\n    //这里还得加个left<right，小心while死循环,这两步就是用来过滤非字符，逗号啥的\n    while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n      left++;\n    }\n    while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n      right--;\n    }\n\n    if (left < right) {\n      if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\n        return false;\n      }\n      //同时相向移动指针\n      left++;\n      right--;\n    }\n  }\n  return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 反转字符串\n\n> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n> \n> 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n> \n> 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n> \n> 输入：["h","e","l","l","o"]\n> 输出：["o","l","l","e","h"]\n> 输入：["H","a","n","n","a","h"]\n> 输出：["h","a","n","n","a","H"]\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n思路：\n\n * 因为要反转，所以就不需要相向移动了，如果用双指针思路的话，其实就是遍历中交换左右指针的字符\n\npublic void reverseString(char[] s) {\n  int left = 0;\n  int right = s.length - 1;\n  while (left < right){\n    char tmp = s[left];\n    s[left] = s[right];\n    s[right] = tmp;\n    left++;\n    right--;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 二分查找\n\n有重复数字的话，返回的其实就是最右匹配\n\npublic static int search(int[] nums, int target) {\n  int left = 0;\n  int right = nums.length - 1;\n  while (left <= right) {\n    //不直接使用（right+left）/2 是考虑数据大的时候溢出\n    int mid = (right - left) / 2 + left;\n    int tmp = nums[mid];\n    if (tmp == target) {\n      return mid;\n    } else if (tmp > target) {\n      //右指针移到中间位置 - 1,也避免不存在的target造成死循环\n      right = mid - 1;\n    } else {\n      //\n      left = mid + 1;\n    }\n  }\n  return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 二、快慢指针\n\n「快慢指针」，也称为「同步指针」\n\n> 141. 环形链表(opens new window)\n> \n> 142. 环形链表II(opens new window)\n> \n> 19. 删除链表的倒数第 N 个结点(opens new window)\n> \n> 876. 链表的中间结点(opens new window)\n> \n> 26. 删除有序数组中的重复项(opens new window)\n\n\n# 环形链表\n\n思路：\n\n * 快慢指针，两个指针，一块一慢的话，慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。\n\npublic boolean hasCycle(ListNode head) {\n  if (head == null || head.next == null) {\n    return false;\n  }\n  // 龟兔起跑\n  ListNode fast = head;\n  ListNode slow = head;\n\n  while (fast != null && fast.next != null) {\n    // 龟走一步\n    slow = slow.next;\n    // 兔走两步\n    fast = fast.next.next;\n    if (slow == fast) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 环形链表 II\n\n> 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n> \n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：返回索引为 1 的链表节点\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 最初，我就把有环理解错了，看题解觉得快慢指针相交的地方就是入环的节点\n * 假设环是这样的，slow 指针进入环后，又走了 b 的距离与 fast 相遇\n * \n\n\n# 链表的中间结点\n\n> 给定一个头结点为 head 的非空单链表，返回链表的中间结点。\n> \n> 如果有两个中间结点，则返回第二个中间结点。(给定链表的结点数介于 1 和 100 之间。)\n> \n> 输入：[1,2,3,4,5]\n> 输出：此列表中的结点 3 (序列化形式：[3,4,5])\n> 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n> 注意，我们返回了一个 ListNode 类型的对象 ans，这样：\n> ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n思路：\n\n * 快慢指针遍历，当 fast 到达链表的末尾时，slow 必然位于中间\n\npublic ListNode middleNode(ListNode head) {\n  ListNode fast = head;\n  ListNode slow = head;\n  while (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 删除链表的倒数第 N 个结点\n\n> 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n> \n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n> \n> \n> 1\n> 2\n\n\n# 删除有序数组中的重复项\n\n> 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n> \n> 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 额外空间的条件下完成。\n> \n> 说明:\n> \n> 为什么返回数值是整数，但输出的答案是数组呢?\n> \n> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n> \n> 你可以想象内部操作如下:\n> \n> // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\n> int len = removeDuplicates(nums);\n> // 在函数里修改输入数组对于调用者是可见的。\n> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n> for (int i = 0; i < len; i++) {\n>  \tprint(nums[i]);\n> }\n> 输入：nums = [1,1,2]\n> 输出：2, nums = [1,2]\n> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n> 输入：nums = [0,0,1,1,1,2,2,3,3,4]\n> 输出：5, nums = [0,1,2,3,4]\n> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n\n思路：\n\n * 数组有序，那相等的元素在数组中的下标一定是连续的\n * 使用快慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置\n * 第一个元素不需要删除，所有快慢指针都从下标 1 开始\n\npublic static int removeDuplicates(int[] nums) {\n  if (nums == null) {\n    return 0;\n  }\n  int fast = 1;\n  int slow = 1;\n  while (fast < nums.length) {\n    //和前一个值比较\n    if (nums[fast] != nums[fast - 1]) {\n      //不一样的话，把快指针的值放在慢指针上，实现了去重，并往前移动慢指针\n      nums[slow] = nums[fast];\n      ++slow;\n    }\n    //相等的话，移动快指针就行\n    ++fast;\n  }\n  //慢指针的位置就是不重复的数量\n  return slow;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 最长连续递增序列\n\n> 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。\n> \n> 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。\n> \n> 输入：nums = [1,3,5,4,7]\n> 输出：3\n> 解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \n> \n> \n> 1\n> 2\n> 3\n\n思路分析：\n\n * 这个题的思路和删除有序数组中的重复项，很像\n\npublic int findLengthOfLCIS(int[] nums) {\n  int result = 0;\n  int fast = 0;\n  int slow = 0;\n  while (fast < nums.length) {\n    //前一个数大于后一个数的时候\n    if (fast > 0 || nums[fast - 1] > nums[fast]) {\n      slow = fast;\n    }\n    fast++;\n    result = Math.max(result, fast - slow);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 三、滑动窗口\n\n有一类数组上的问题，需要使用两个指针变量（我们称为左指针和右指针），同向、交替向右移动完成任务。这样的过程像极了一个窗口在平面上滑动的过程，因此我们将解决这一类问题的算法称为「滑动窗口」问题\n\n\n\n滑动窗口，就是两个指针齐头并进，好像一个窗口一样，不断往前滑\n\n子串问题，几乎都是滑动窗口\n\n> 643. 子数组最大平均数 I(opens new window)\n> \n> 1052. 爱生气的书店老板(opens new window)\n> \n> 3. 无重复字符的最长子串(opens new window)\n> \n> 76. 最小覆盖子串(opens new window)\n> \n> 424. 替换后的最长重复字符(opens new window)\n\nint left = 0, right = 0;\n\nwhile (right < s.size()) {\n    // 增大窗口\n    window.add(s[right]);\n    right++;\n    \n    while (window needs shrink) {\n        // 缩小窗口\n        window.remove(s[left]);\n        left++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.1 同向交替移动的两个变量\n\n有一类数组上的问题，问我们固定长度的滑动窗口的性质，这类问题还算相对简单。\n\n# 子数组最大平均数 I\n\n> 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。\n> \n> 输入：[1,12,-5,-6,50,3], k = 4\n> 输出：12.75\n> 解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 长度为固定的 K，想到用滑动窗口\n * 保存每个窗口的值，取这 k 个数的最大和就可以得出最大平均数\n * 怎么保存每个窗口的值，这一步\n\npublic static double getMaxAverage(int[] nums, int k) {\n  int sum = 0;\n  //先求出前k个数的和\n  for (int i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  //目前最大的数是前k个数\n  int result = sum;\n  //然后从第 K 个数开始移动，保存移动中的和值，返回最大的\n  for (int i = k; i < nums.length; i++) {\n    sum = sum - nums[i - k] + nums[i];\n    result = Math.max(result, sum);\n  }\n  //返回的是double\n  return 1.0 * result / k;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.2 不定长度的滑动窗口\n\n# 无重复字符的最长子串\n\n> 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n> \n> 输入: s = "abcabcbb"\n> 输出: 3 \n> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 滑动窗口，其实就是一个队列，比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列\n * 如何移动？我们只要把队列的左边的元素移出就行了，直到满足题目要求！\n * 一直维持这样的队列，找出队列出现最长的长度时候，求出解！\n\npublic static int lengthOfLongestSubstring(String s){\n  HashMap<Character, Integer> map = new HashMap<>();\n  int result = 0;\n  int left = 0;\n  //为了有左右指针的思想，我把我们常用的 i 写成了 right\n  for (int right = 0; right < s.length(); right++) {\n    //当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，\n    //那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；\n    //相当于左指针往前移动了一位\n    if (map.containsKey(s.charAt(right))) {\n      left = Math.max(left, map.get(s.charAt(right)) + 1);\n    }\n    //右指针一直往前移动\n    map.put(s.charAt(right), right);\n    result = Math.max(result, right - left + 1);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 最小覆盖子串\n\n> 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。\n> \n> 输入：s = "ADOBECODEBANC", t = "ABC"\n> 输出："BANC"\n> \n> \n> 1\n> 2\n\n# 替换后的最长重复字符\n\n> 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。\n> \n> 注意：字符串长度 和 k 不会超过 10^4\n> \n> 输入：s = "ABAB", k = 2\n> 输出：4\n> 解释：用两个\'A\'替换为两个\'B\',反之亦然。\n> 输入：s = "AABABBA", k = 1\n> 输出：4\n> 解释：将中间的一个\'A\'替换为\'B\',字符串变为 "AABBBBA"。子串 "BBBB" 有最长重复字母, 答案为 4。\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n\n思路：\n\n * \n\npublic int characterReplacement(String s, int k) {\n  int len = s.length();\n  if (len < 2) {\n    return len;\n  }\n\n  char[] charArray = s.toCharArray();\n  int left = 0;\n  int right = 0;\n\n  int res = 0;\n  int maxCount = 0;\n  int[] freq = new int[26];\n  // [left, right) 内最多替换 k 个字符可以得到只有一种字符的子串\n  while (right < len){\n    freq[charArray[right] - \'A\']++;\n    // 在这里维护 maxCount，因为每一次右边界读入一个字符，字符频数增加，才会使得 maxCount 增加\n    maxCount = Math.max(maxCount, freq[charArray[right] - \'A\']);\n    right++;\n\n    if (right - left > maxCount + k){\n      // 说明此时 k 不够用\n      // 把其它不是最多出现的字符替换以后，都不能填满这个滑动的窗口，这个时候须要考虑左边界向右移动\n      // 移出滑动窗口的时候，频数数组须要相应地做减法\n      freq[charArray[left] - \'A\']--;\n      left++;\n    }\n    res = Math.max(res, right - left);\n  }\n  return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3.3 计数问题\n\n# 至多包含两个不同字符的最长子串\n\n> 给定一个字符串 s，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。\n> \n> 输入: "eceba"\n> 输出: 3\n> 解释: t 是 "ece"，长度为3。\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 这种字符串用滑动窗口的题目，一般用 toCharArray() 先转成字符数组\n\n# 至多包含 K 个不同字符的最长子串\n\n> 给定一个字符串 s，找出 至多 包含 k 个不同字符的最长子串 T。\n> \n> 输入: s = "eceba", k = 2\n> 输出: 3\n> 解释: 则 T 为 "ece"，所以长度为 3。\n> \n> \n> 1\n> 2\n> 3\n\n# 区间子数组个数\n\n> 给定一个元素都是正整数的数组A ，正整数 L 以及 R (L <= R)。\n> \n> 求连续、非空且其中最大元素满足大于等于L 小于等于R的子数组个数。\n> \n> 例如 :\n> 输入: \n> A = [2, 1, 4, 3]\n> L = 2\n> R = 3\n> 输出: 3\n> 解释: 满足条件的子数组: [2], [2, 1], [3].\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n# K 个不同整数的子数组\n\n> \n\n\n# 3.4 使用数据结构维护窗口性质\n\n有一类问题只是名字上叫「滑动窗口」，但解决这一类问题需要用到常见的数据结构。这一节给出的问题可以当做例题进行学习，一些比较复杂的问题是基于这些问题衍生出来的。\n\n# 滑动窗口最大值\n\n# 滑动窗口中位数\n\n\n# 总结\n\n区间不同的定义决定了不同的初始化逻辑、遍历过程中的逻辑。\n\n * 移除元素\n * 删除排序数组中的重复项 II\n * 移动零',normalizedContent:'归纳下双指针算法，其实总共就三类\n\n * 左右指针，数组和字符串问题\n * 快慢指针，主要是成环问题\n * 滑动窗口，针对子串问题\n\n# #42. 接雨水(opens new window)\n\n\n# 一、左右指针\n\n左右指针在数组中其实就是两个索引值，\n\ntodo: 一般都是有序数组？或者先排序后？\n\njavaer 一般这么表示：\n\nint left = i + 1;\nint right = nums.length - 1;\nwhile(left < right)\n  ***\n\n\n1\n2\n3\n4\n\n\n这两个指针 相向交替移动\n\n\n\n> 11. 盛最多水的容器(opens new window)\n> \n> 15. 三数之和(opens new window)\n> \n> 167. 两数之和 ii - 输入有序数组(opens new window)\n> \n> 125. 验证回文串(opens new window)\n> \n> 344. 反转字符串(opens new window)\n> \n> 283. 移动零(opens new window)\n> \n> 704. 二分查找(opens new window)\n> \n> 34. 在排序数组中查找元素的第一个和最后一个位置(opens new window)\n\ntodo: 画图对比各个算法\n\n\n# 两数之和 ii - 输入有序数组\n\n> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n> \n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n> \n> 你可以按任意顺序返回答案。\n> \n> 输入：nums = [2,7,11,15], target = 9\n> 输出：[0,1]\n> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n> \n> \n> 1\n> 2\n> 3\n\n直接用左右指针套就可以\n\npublic static int[] towsum(int[] nums, int target) {\n    int left = 0;\n    int rigth = nums.length - 1;\n    while(left < rigth){\n        int tmp = nums[left] + nums[rigth];\n        if (target == tmp) {\n            return new int[]{left, rigth};\n        } else if (tmp > target) {\n            rigth--; //右移\n        } else {\n            left++;  //左移\n        }\n    }\n    return new int[]{-1, -1};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 三数之和\n\n排序、双指针、去重\n\n第一个想法是，这三个数，两个指针？\n\n * 对数组排序，固定一个数 ，然后遍历数组，并移动左右指针求和，判断是否有等于 0 的情况\n * 特例：\n   * 排序后第一个数就大于 0，不干了\n   * 有三个需要去重的地方\n     * nums[i] == nums[i - 1] 直接跳过本次遍历\n     * nums[left] == nums[left + 1] 移动指针，即去重\n     * nums[right] == nums[right - 1] 移动指针\n\n\n\npublic static list<list<integer>> threesum(int[] nums) {\n  //存放结果list\n  list<list<integer>> result = new arraylist<>();\n  int length = nums.length;\n  //特例判断\n  if (length < 3) {\n    return result;\n  }\n  arrays.sort(nums);\n  for (int i = 0; i < length; i++) {\n    //排序后的第一个数字就大于0，就说明没有符合要求的结果\n    if (nums[i] > 0) break;\n\n    //去重\n    if (i > 0 && nums[i] == nums[i - 1]) continue;\n    //左右指针\n    int l = i + 1;\n    int r = length - 1;\n    while (l < r) {\n      int sum = nums[i] + nums[l] + nums[r];\n      if (sum == 0) {\n        result.add(arrays.aslist(nums[i], nums[l], nums[r]));\n        //去重（相同数字的话就移动指针）\n        while (nums[l] == nums[l + 1]) l++;\n        while (nums[r] == nums[r - 1]) r--;\n        //移动指针\n        l++;\n        r--;\n      } else if (sum < 0) {\n        l++;\n      } else if (sum > 0) {\n        r--;\n      }\n    }\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 盛最多水的容器\n\n> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n> \n> 输入：[1,8,6,2,5,4,8,3,7]\n> 输出：49 \n> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 求得是水量，水量 = 两个指针指向的数字中较小值 * 指针之间的距离（水桶原理，最短的板才不会漏水）\n * 为了求最大水量，我们需要存储所有条件的水量，进行比较才行\n * 双指针相向移动，循环收窄，直到两个指针相遇\n * 往哪个方向移动，需要考虑清楚，如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会更小，所以我们移动数字较小的那个指针\n\npublic int maxarea(int[] height){\n  int left = 0;\n  int right = height.length - 1;\n  //需要保存各个阶段的值\n  int result = 0;\n  while(left < right){\n    //水量 = 两个指针指向的数字中较小值∗指针之间的距离\n    int area = math.min(height[left],height[right]) * (right - left);\n    result = math.max(result,area);\n    //移动数字较小的指针\n    if(height[left] <= height[right]){\n      left ++;\n    }else{\n      right--;\n    }\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 验证回文串\n\n> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n> \n> 说明：本题中，我们将空字符串定义为有效的回文串。\n> \n> 输入: "a man, a plan, a canal: panama"\n> 输出: true\n> 解释："amanaplanacanalpanama" 是回文串\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 没看题解前，因为这个例子中有各种逗号、空格啥的，我第一想到的其实就是先遍历放在一个数组里，然后再去判断，看题解可以在原字符串完成，降低了空间复杂度\n * 首先需要知道三个 api\n   * character.isletterordigit 确定指定的字符是否为字母或数字\n   * character.tolowercase 将大写字符转换为小写\n   * public char charat(int index) string 中的方法，用于返回指定索引处的字符\n * 双指针，每移动一步，判断这两个值是不是相同\n * 两个指针相遇，则是回文串\n\npublic boolean ispalindrome(string s) {\n  int left = 0;\n  int right = s.length() - 1;\n  while (left < right) {\n    //这里还得加个left<right，小心while死循环,这两步就是用来过滤非字符，逗号啥的\n    while (left < right && !character.isletterordigit(s.charat(left))) {\n      left++;\n    }\n    while (left < right && !character.isletterordigit(s.charat(right))) {\n      right--;\n    }\n\n    if (left < right) {\n      if (character.tolowercase(s.charat(left)) != character.tolowercase(s.charat(right))) {\n        return false;\n      }\n      //同时相向移动指针\n      left++;\n      right--;\n    }\n  }\n  return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 反转字符串\n\n> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n> \n> 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 o(1) 的额外空间解决这一问题。\n> \n> 你可以假设数组中的所有字符都是 ascii 码表中的可打印字符。\n> \n> 输入：["h","e","l","l","o"]\n> 输出：["o","l","l","e","h"]\n> 输入：["h","a","n","n","a","h"]\n> 输出：["h","a","n","n","a","h"]\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n思路：\n\n * 因为要反转，所以就不需要相向移动了，如果用双指针思路的话，其实就是遍历中交换左右指针的字符\n\npublic void reversestring(char[] s) {\n  int left = 0;\n  int right = s.length - 1;\n  while (left < right){\n    char tmp = s[left];\n    s[left] = s[right];\n    s[right] = tmp;\n    left++;\n    right--;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 二分查找\n\n有重复数字的话，返回的其实就是最右匹配\n\npublic static int search(int[] nums, int target) {\n  int left = 0;\n  int right = nums.length - 1;\n  while (left <= right) {\n    //不直接使用（right+left）/2 是考虑数据大的时候溢出\n    int mid = (right - left) / 2 + left;\n    int tmp = nums[mid];\n    if (tmp == target) {\n      return mid;\n    } else if (tmp > target) {\n      //右指针移到中间位置 - 1,也避免不存在的target造成死循环\n      right = mid - 1;\n    } else {\n      //\n      left = mid + 1;\n    }\n  }\n  return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 二、快慢指针\n\n「快慢指针」，也称为「同步指针」\n\n> 141. 环形链表(opens new window)\n> \n> 142. 环形链表ii(opens new window)\n> \n> 19. 删除链表的倒数第 n 个结点(opens new window)\n> \n> 876. 链表的中间结点(opens new window)\n> \n> 26. 删除有序数组中的重复项(opens new window)\n\n\n# 环形链表\n\n思路：\n\n * 快慢指针，两个指针，一块一慢的话，慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。\n\npublic boolean hascycle(listnode head) {\n  if (head == null || head.next == null) {\n    return false;\n  }\n  // 龟兔起跑\n  listnode fast = head;\n  listnode slow = head;\n\n  while (fast != null && fast.next != null) {\n    // 龟走一步\n    slow = slow.next;\n    // 兔走两步\n    fast = fast.next.next;\n    if (slow == fast) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 环形链表 ii\n\n> 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n> \n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：返回索引为 1 的链表节点\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 最初，我就把有环理解错了，看题解觉得快慢指针相交的地方就是入环的节点\n * 假设环是这样的，slow 指针进入环后，又走了 b 的距离与 fast 相遇\n * \n\n\n# 链表的中间结点\n\n> 给定一个头结点为 head 的非空单链表，返回链表的中间结点。\n> \n> 如果有两个中间结点，则返回第二个中间结点。(给定链表的结点数介于 1 和 100 之间。)\n> \n> 输入：[1,2,3,4,5]\n> 输出：此列表中的结点 3 (序列化形式：[3,4,5])\n> 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n> 注意，我们返回了一个 listnode 类型的对象 ans，这样：\n> ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = null.\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n思路：\n\n * 快慢指针遍历，当 fast 到达链表的末尾时，slow 必然位于中间\n\npublic listnode middlenode(listnode head) {\n  listnode fast = head;\n  listnode slow = head;\n  while (fast != null && fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 删除链表的倒数第 n 个结点\n\n> 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n> \n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n> \n> \n> 1\n> 2\n\n\n# 删除有序数组中的重复项\n\n> 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n> \n> 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 额外空间的条件下完成。\n> \n> 说明:\n> \n> 为什么返回数值是整数，但输出的答案是数组呢?\n> \n> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n> \n> 你可以想象内部操作如下:\n> \n> // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\n> int len = removeduplicates(nums);\n> // 在函数里修改输入数组对于调用者是可见的。\n> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\n> for (int i = 0; i < len; i++) {\n>  \tprint(nums[i]);\n> }\n> 输入：nums = [1,1,2]\n> 输出：2, nums = [1,2]\n> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n> 输入：nums = [0,0,1,1,1,2,2,3,3,4]\n> 输出：5, nums = [0,1,2,3,4]\n> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n\n思路：\n\n * 数组有序，那相等的元素在数组中的下标一定是连续的\n * 使用快慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置\n * 第一个元素不需要删除，所有快慢指针都从下标 1 开始\n\npublic static int removeduplicates(int[] nums) {\n  if (nums == null) {\n    return 0;\n  }\n  int fast = 1;\n  int slow = 1;\n  while (fast < nums.length) {\n    //和前一个值比较\n    if (nums[fast] != nums[fast - 1]) {\n      //不一样的话，把快指针的值放在慢指针上，实现了去重，并往前移动慢指针\n      nums[slow] = nums[fast];\n      ++slow;\n    }\n    //相等的话，移动快指针就行\n    ++fast;\n  }\n  //慢指针的位置就是不重复的数量\n  return slow;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 最长连续递增序列\n\n> 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。\n> \n> 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。\n> \n> 输入：nums = [1,3,5,4,7]\n> 输出：3\n> 解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \n> \n> \n> 1\n> 2\n> 3\n\n思路分析：\n\n * 这个题的思路和删除有序数组中的重复项，很像\n\npublic int findlengthoflcis(int[] nums) {\n  int result = 0;\n  int fast = 0;\n  int slow = 0;\n  while (fast < nums.length) {\n    //前一个数大于后一个数的时候\n    if (fast > 0 || nums[fast - 1] > nums[fast]) {\n      slow = fast;\n    }\n    fast++;\n    result = math.max(result, fast - slow);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 三、滑动窗口\n\n有一类数组上的问题，需要使用两个指针变量（我们称为左指针和右指针），同向、交替向右移动完成任务。这样的过程像极了一个窗口在平面上滑动的过程，因此我们将解决这一类问题的算法称为「滑动窗口」问题\n\n\n\n滑动窗口，就是两个指针齐头并进，好像一个窗口一样，不断往前滑\n\n子串问题，几乎都是滑动窗口\n\n> 643. 子数组最大平均数 i(opens new window)\n> \n> 1052. 爱生气的书店老板(opens new window)\n> \n> 3. 无重复字符的最长子串(opens new window)\n> \n> 76. 最小覆盖子串(opens new window)\n> \n> 424. 替换后的最长重复字符(opens new window)\n\nint left = 0, right = 0;\n\nwhile (right < s.size()) {\n    // 增大窗口\n    window.add(s[right]);\n    right++;\n    \n    while (window needs shrink) {\n        // 缩小窗口\n        window.remove(s[left]);\n        left++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.1 同向交替移动的两个变量\n\n有一类数组上的问题，问我们固定长度的滑动窗口的性质，这类问题还算相对简单。\n\n# 子数组最大平均数 i\n\n> 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。\n> \n> 输入：[1,12,-5,-6,50,3], k = 4\n> 输出：12.75\n> 解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 长度为固定的 k，想到用滑动窗口\n * 保存每个窗口的值，取这 k 个数的最大和就可以得出最大平均数\n * 怎么保存每个窗口的值，这一步\n\npublic static double getmaxaverage(int[] nums, int k) {\n  int sum = 0;\n  //先求出前k个数的和\n  for (int i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  //目前最大的数是前k个数\n  int result = sum;\n  //然后从第 k 个数开始移动，保存移动中的和值，返回最大的\n  for (int i = k; i < nums.length; i++) {\n    sum = sum - nums[i - k] + nums[i];\n    result = math.max(result, sum);\n  }\n  //返回的是double\n  return 1.0 * result / k;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.2 不定长度的滑动窗口\n\n# 无重复字符的最长子串\n\n> 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n> \n> 输入: s = "abcabcbb"\n> 输出: 3 \n> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 滑动窗口，其实就是一个队列，比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列\n * 如何移动？我们只要把队列的左边的元素移出就行了，直到满足题目要求！\n * 一直维持这样的队列，找出队列出现最长的长度时候，求出解！\n\npublic static int lengthoflongestsubstring(string s){\n  hashmap<character, integer> map = new hashmap<>();\n  int result = 0;\n  int left = 0;\n  //为了有左右指针的思想，我把我们常用的 i 写成了 right\n  for (int right = 0; right < s.length(); right++) {\n    //当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，\n    //那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；\n    //相当于左指针往前移动了一位\n    if (map.containskey(s.charat(right))) {\n      left = math.max(left, map.get(s.charat(right)) + 1);\n    }\n    //右指针一直往前移动\n    map.put(s.charat(right), right);\n    result = math.max(result, right - left + 1);\n  }\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 最小覆盖子串\n\n> 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。\n> \n> 输入：s = "adobecodebanc", t = "abc"\n> 输出："banc"\n> \n> \n> 1\n> 2\n\n# 替换后的最长重复字符\n\n> 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。\n> \n> 注意：字符串长度 和 k 不会超过 10^4\n> \n> 输入：s = "abab", k = 2\n> 输出：4\n> 解释：用两个\'a\'替换为两个\'b\',反之亦然。\n> 输入：s = "aababba", k = 1\n> 输出：4\n> 解释：将中间的一个\'a\'替换为\'b\',字符串变为 "aabbbba"。子串 "bbbb" 有最长重复字母, 答案为 4。\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n\n思路：\n\n * \n\npublic int characterreplacement(string s, int k) {\n  int len = s.length();\n  if (len < 2) {\n    return len;\n  }\n\n  char[] chararray = s.tochararray();\n  int left = 0;\n  int right = 0;\n\n  int res = 0;\n  int maxcount = 0;\n  int[] freq = new int[26];\n  // [left, right) 内最多替换 k 个字符可以得到只有一种字符的子串\n  while (right < len){\n    freq[chararray[right] - \'a\']++;\n    // 在这里维护 maxcount，因为每一次右边界读入一个字符，字符频数增加，才会使得 maxcount 增加\n    maxcount = math.max(maxcount, freq[chararray[right] - \'a\']);\n    right++;\n\n    if (right - left > maxcount + k){\n      // 说明此时 k 不够用\n      // 把其它不是最多出现的字符替换以后，都不能填满这个滑动的窗口，这个时候须要考虑左边界向右移动\n      // 移出滑动窗口的时候，频数数组须要相应地做减法\n      freq[chararray[left] - \'a\']--;\n      left++;\n    }\n    res = math.max(res, right - left);\n  }\n  return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3.3 计数问题\n\n# 至多包含两个不同字符的最长子串\n\n> 给定一个字符串 s，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。\n> \n> 输入: "eceba"\n> 输出: 3\n> 解释: t 是 "ece"，长度为3。\n> \n> \n> 1\n> 2\n> 3\n\n思路：\n\n * 这种字符串用滑动窗口的题目，一般用 tochararray() 先转成字符数组\n\n# 至多包含 k 个不同字符的最长子串\n\n> 给定一个字符串 s，找出 至多 包含 k 个不同字符的最长子串 t。\n> \n> 输入: s = "eceba", k = 2\n> 输出: 3\n> 解释: 则 t 为 "ece"，所以长度为 3。\n> \n> \n> 1\n> 2\n> 3\n\n# 区间子数组个数\n\n> 给定一个元素都是正整数的数组a ，正整数 l 以及 r (l <= r)。\n> \n> 求连续、非空且其中最大元素满足大于等于l 小于等于r的子数组个数。\n> \n> 例如 :\n> 输入: \n> a = [2, 1, 4, 3]\n> l = 2\n> r = 3\n> 输出: 3\n> 解释: 满足条件的子数组: [2], [2, 1], [3].\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n# k 个不同整数的子数组\n\n> \n\n\n# 3.4 使用数据结构维护窗口性质\n\n有一类问题只是名字上叫「滑动窗口」，但解决这一类问题需要用到常见的数据结构。这一节给出的问题可以当做例题进行学习，一些比较复杂的问题是基于这些问题衍生出来的。\n\n# 滑动窗口最大值\n\n# 滑动窗口中位数\n\n\n# 总结\n\n区间不同的定义决定了不同的初始化逻辑、遍历过程中的逻辑。\n\n * 移除元素\n * 删除排序数组中的重复项 ii\n * 移动零',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"数组与矩阵",frontmatter:{title:"数组与矩阵",date:"2022-10-12T21:50:30.000Z",permalink:"/pages/5fd35f/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/01.%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5.html",relativePath:"02.计算机基础/50.剑指Offer题解/01.数组与矩阵.md",key:"v-3bb878ba",path:"/pages/5fd35f/",headers:[{level:2,title:"3. 数组中重复的数字",slug:"_3-数组中重复的数字",normalizedTitle:"3. 数组中重复的数字",charIndex:2},{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:201},{level:2,title:"4. 二维数组中的查找",slug:"_4-二维数组中的查找",normalizedTitle:"4. 二维数组中的查找",charIndex:901},{level:3,title:"题目链接",slug:"题目链接-2",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-2",normalizedTitle:"解题思路",charIndex:201},{level:2,title:"5. 替换空格",slug:"_5-替换空格",normalizedTitle:"5. 替换空格",charIndex:1923},{level:3,title:"题目链接",slug:"题目链接-3",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-3",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-3",normalizedTitle:"解题思路",charIndex:201},{level:2,title:"29. 顺时针打印矩阵",slug:"_29-顺时针打印矩阵",normalizedTitle:"29. 顺时针打印矩阵",charIndex:2900},{level:3,title:"题目链接",slug:"题目链接-4",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-4",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-4",normalizedTitle:"解题思路",charIndex:201},{level:2,title:"50. 第一个只出现一次的字符位置",slug:"_50-第一个只出现一次的字符位置",normalizedTitle:"50. 第一个只出现一次的字符位置",charIndex:4068},{level:3,title:"题目链接",slug:"题目链接-5",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-5",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-5",normalizedTitle:"解题思路",charIndex:201}],headersStr:"3. 数组中重复的数字 题目链接 题目描述 解题思路 4. 二维数组中的查找 题目链接 题目描述 解题思路 5. 替换空格 题目链接 题目描述 解题思路 29. 顺时针打印矩阵 题目链接 题目描述 解题思路 50. 第一个只出现一次的字符位置 题目链接 题目描述 解题思路",content:"# 3. 数组中重复的数字\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。\n\nInput:\n{2, 3, 1, 0, 2, 5}\n\nOutput:\n2\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。\n\n对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。\n\n以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：\n\n\n\npublic int duplicate(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n        while (nums[i] != i) {\n            if (nums[i] == nums[nums[i]]) {\n                return  nums[i];\n            }\n            swap(nums, i, nums[i]);\n        }\n        swap(nums, i, nums[i]);\n    }\n    return -1;\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int t = nums[i];\n    nums[i] = nums[j];\n    nums[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 4. 二维数组中的查找\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。\n\nConsider the following matrix:\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\nGiven target = 5, return true.\nGiven target = 20, return false.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 解题思路\n\n要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。\n\n该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。\n\n\n\npublic boolean Find(int target, int[][] matrix) {\n    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\n        return false;\n    int rows = matrix.length, cols = matrix[0].length;\n    int r = 0, c = cols - 1; // 从右上角开始\n    while (r <= rows - 1 && c >= 0) {\n        if (target == matrix[r][c])\n            return true;\n        else if (target > matrix[r][c])\n            r++;\n        else\n            c--;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5. 替换空格\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n将一个字符串中的空格替换成 \"%20\"。\n\nInput:\n\"A B\"\n\nOutput:\n\"A%20B\"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。\n\n② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。\n\n③ 当 P2 遇到 P1 时（P2 <= P1），或者遍历结束（P1 < 0），退出。\n\n\n\npublic String replaceSpace(StringBuffer str) {\n    int P1 = str.length() - 1;\n    for (int i = 0; i <= P1; i++)\n        if (str.charAt(i) == ' ')\n            str.append(\"  \");\n\n    int P2 = str.length() - 1;\n    while (P1 >= 0 && P2 > P1) {\n        char c = str.charAt(P1--);\n        if (c == ' ') {\n            str.setCharAt(P2--, '0');\n            str.setCharAt(P2--, '2');\n            str.setCharAt(P2--, '%');\n        } else {\n            str.setCharAt(P2--, c);\n        }\n    }\n    return str.toString();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 29. 顺时针打印矩阵\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10\n\n\n\n\n# 解题思路\n\n一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 r1, r2, c1, c2 分别存储上下左右边界值，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行->从上到下打印最右一行->从右到左打印最下一行->从下到上打印最左一行。应当注意只有在 r1 != r2 时才打印最下一行，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。\n\n\n\npublic ArrayList<Integer> printMatrix(int[][] matrix) {\n    ArrayList<Integer> ret = new ArrayList<>();\n    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;\n    while (r1 <= r2 && c1 <= c2) {\n        // 上\n        for (int i = c1; i <= c2; i++)\n            ret.add(matrix[r1][i]);\n        // 右\n        for (int i = r1 + 1; i <= r2; i++)\n            ret.add(matrix[i][c2]);\n        if (r1 != r2)\n            // 下\n            for (int i = c2 - 1; i >= c1; i--)\n                ret.add(matrix[r2][i]);\n        if (c1 != c2)\n            // 左\n            for (int i = r2 - 1; i > r1; i--)\n                ret.add(matrix[i][c1]);\n        r1++; r2--; c1++; c2--;\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 50. 第一个只出现一次的字符位置\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。\n\nInput: abacc\nOutput: b\n\n\n1\n2\n\n\n\n# 解题思路\n\n最直观的解法是使用 HashMap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 HashMap 就可以找出出现次数为 1 的字符。\n\n考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。\n\npublic int FirstNotRepeatingChar(String str) {\n    int[] cnts = new int[128];\n    for (int i = 0; i < str.length(); i++)\n        cnts[str.charAt(i)]++;\n    for (int i = 0; i < str.length(); i++)\n        if (cnts[str.charAt(i)] == 1)\n            return i;\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。\n\npublic int FirstNotRepeatingChar2(String str) {\n    BitSet bs1 = new BitSet(128);\n    BitSet bs2 = new BitSet(128);\n    for (char c : str.toCharArray()) {\n        if (!bs1.get(c) && !bs2.get(c))\n            bs1.set(c);     // 0 0 -> 0 1\n        else if (bs1.get(c) && !bs2.get(c))\n            bs2.set(c);     // 0 1 -> 1 1\n    }\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (bs1.get(c) && !bs2.get(c))  // 0 1\n            return i;\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# 3. 数组中重复的数字\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。\n\ninput:\n{2, 3, 1, 0, 2, 5}\n\noutput:\n2\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n要求时间复杂度 o(n)，空间复杂度 o(1)。因此不能使用排序的方法，也不能使用额外的标记数组。\n\n对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。\n\n以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：\n\n\n\npublic int duplicate(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n        while (nums[i] != i) {\n            if (nums[i] == nums[nums[i]]) {\n                return  nums[i];\n            }\n            swap(nums, i, nums[i]);\n        }\n        swap(nums, i, nums[i]);\n    }\n    return -1;\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int t = nums[i];\n    nums[i] = nums[j];\n    nums[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 4. 二维数组中的查找\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。\n\nconsider the following matrix:\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\ngiven target = 5, return true.\ngiven target = 20, return false.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 解题思路\n\n要求时间复杂度 o(m + n)，空间复杂度 o(1)。其中 m 为行数，n 为 列数。\n\n该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。\n\n\n\npublic boolean find(int target, int[][] matrix) {\n    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\n        return false;\n    int rows = matrix.length, cols = matrix[0].length;\n    int r = 0, c = cols - 1; // 从右上角开始\n    while (r <= rows - 1 && c >= 0) {\n        if (target == matrix[r][c])\n            return true;\n        else if (target > matrix[r][c])\n            r++;\n        else\n            c--;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5. 替换空格\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n将一个字符串中的空格替换成 \"%20\"。\n\ninput:\n\"a b\"\n\noutput:\n\"a%20b\"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。\n\n② 令 p1 指向字符串原来的末尾位置，p2 指向字符串现在的末尾位置。p1 和 p2 从后向前遍历，当 p1 遍历到一个空格时，就需要令 p2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 p1 指向字符的值。从后向前遍是为了在改变 p2 所指向的内容时，不会影响到 p1 遍历原来字符串的内容。\n\n③ 当 p2 遇到 p1 时（p2 <= p1），或者遍历结束（p1 < 0），退出。\n\n\n\npublic string replacespace(stringbuffer str) {\n    int p1 = str.length() - 1;\n    for (int i = 0; i <= p1; i++)\n        if (str.charat(i) == ' ')\n            str.append(\"  \");\n\n    int p2 = str.length() - 1;\n    while (p1 >= 0 && p2 > p1) {\n        char c = str.charat(p1--);\n        if (c == ' ') {\n            str.setcharat(p2--, '0');\n            str.setcharat(p2--, '2');\n            str.setcharat(p2--, '%');\n        } else {\n            str.setcharat(p2--, c);\n        }\n    }\n    return str.tostring();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 29. 顺时针打印矩阵\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10\n\n\n\n\n# 解题思路\n\n一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 r1, r2, c1, c2 分别存储上下左右边界值，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行->从上到下打印最右一行->从右到左打印最下一行->从下到上打印最左一行。应当注意只有在 r1 != r2 时才打印最下一行，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。\n\n\n\npublic arraylist<integer> printmatrix(int[][] matrix) {\n    arraylist<integer> ret = new arraylist<>();\n    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;\n    while (r1 <= r2 && c1 <= c2) {\n        // 上\n        for (int i = c1; i <= c2; i++)\n            ret.add(matrix[r1][i]);\n        // 右\n        for (int i = r1 + 1; i <= r2; i++)\n            ret.add(matrix[i][c2]);\n        if (r1 != r2)\n            // 下\n            for (int i = c2 - 1; i >= c1; i--)\n                ret.add(matrix[r2][i]);\n        if (c1 != c2)\n            // 左\n            for (int i = r2 - 1; i > r1; i--)\n                ret.add(matrix[i][c1]);\n        r1++; r2--; c1++; c2--;\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 50. 第一个只出现一次的字符位置\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ascii 码字符。\n\ninput: abacc\noutput: b\n\n\n1\n2\n\n\n\n# 解题思路\n\n最直观的解法是使用 hashmap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 hashmap 就可以找出出现次数为 1 的字符。\n\n考虑到要统计的字符范围有限，也可以使用整型数组代替 hashmap。ascii 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。\n\npublic int firstnotrepeatingchar(string str) {\n    int[] cnts = new int[128];\n    for (int i = 0; i < str.length(); i++)\n        cnts[str.charat(i)]++;\n    for (int i = 0; i < str.length(); i++)\n        if (cnts[str.charat(i)] == 1)\n            return i;\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。\n\npublic int firstnotrepeatingchar2(string str) {\n    bitset bs1 = new bitset(128);\n    bitset bs2 = new bitset(128);\n    for (char c : str.tochararray()) {\n        if (!bs1.get(c) && !bs2.get(c))\n            bs1.set(c);     // 0 0 -> 0 1\n        else if (bs1.get(c) && !bs2.get(c))\n            bs2.set(c);     // 0 1 -> 1 1\n    }\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charat(i);\n        if (bs1.get(c) && !bs2.get(c))  // 0 1\n            return i;\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"栈队列堆",frontmatter:{title:"栈队列堆",date:"2022-10-12T22:16:40.000Z",permalink:"/pages/8d145e/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/05.%E6%A0%88%E9%98%9F%E5%88%97%E5%A0%86.html",relativePath:"02.计算机基础/50.剑指Offer题解/05.栈队列堆.md",key:"v-5c643de7",path:"/pages/8d145e/",headers:[{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:93},{level:2,title:"30. 包含 min 函数的栈",slug:"_30-包含-min-函数的栈",normalizedTitle:"30. 包含 min 函数的栈",charIndex:641},{level:3,title:"题目链接",slug:"题目链接-2",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-2",normalizedTitle:"解题思路",charIndex:93},{level:2,title:"31. 栈的压入、弹出序列",slug:"_31-栈的压入、弹出序列",normalizedTitle:"31. 栈的压入、弹出序列",charIndex:1371},{level:3,title:"题目链接",slug:"题目链接-3",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-3",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-3",normalizedTitle:"解题思路",charIndex:93},{level:2,title:"40. 最小的 K 个数",slug:"_40-最小的-k-个数",normalizedTitle:"40. 最小的 k 个数",charIndex:2184},{level:3,title:"题目链接",slug:"题目链接-4",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"解题思路",slug:"解题思路-4",normalizedTitle:"解题思路",charIndex:93},{level:4,title:"大小为 K 的最小堆",slug:"大小为-k-的最小堆",normalizedTitle:"大小为 k 的最小堆",charIndex:2241},{level:4,title:"快速选择",slug:"快速选择",normalizedTitle:"快速选择",charIndex:2972},{level:2,title:"41.1 数据流中的中位数",slug:"_41-1-数据流中的中位数",normalizedTitle:"41.1 数据流中的中位数",charIndex:4329},{level:3,title:"题目链接",slug:"题目链接-5",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-4",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"示例1",slug:"示例1",normalizedTitle:"示例1",charIndex:4483},{level:3,title:"示例2",slug:"示例2",normalizedTitle:"示例2",charIndex:4641},{level:3,title:"解题思路",slug:"解题思路-5",normalizedTitle:"解题思路",charIndex:93},{level:2,title:"41.2 字符流中第一个不重复的字符",slug:"_41-2-字符流中第一个不重复的字符",normalizedTitle:"41.2 字符流中第一个不重复的字符",charIndex:5528},{level:3,title:"题目描述",slug:"题目描述-5",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"题目描述",slug:"题目描述-6",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"示例1",slug:"示例1-2",normalizedTitle:"示例1",charIndex:4483},{level:3,title:"示例2",slug:"示例2-2",normalizedTitle:"示例2",charIndex:4641},{level:3,title:"解题思路",slug:"解题思路-6",normalizedTitle:"解题思路",charIndex:93},{level:2,title:"59. 滑动窗口的最大值",slug:"_59-滑动窗口的最大值",normalizedTitle:"59. 滑动窗口的最大值",charIndex:6318},{level:3,title:"题目链接",slug:"题目链接-6",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-7",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-7",normalizedTitle:"解题思路",charIndex:93}],headersStr:"题目链接 题目描述 解题思路 30. 包含 min 函数的栈 题目链接 题目描述 解题思路 31. 栈的压入、弹出序列 题目链接 题目描述 解题思路 40. 最小的 K 个数 题目链接 解题思路 大小为 K 的最小堆 快速选择 41.1 数据流中的中位数 题目链接 题目描述 示例1 示例2 解题思路 41.2 字符流中第一个不重复的字符 题目描述 题目描述 示例1 示例2 解题思路 59. 滑动窗口的最大值 题目链接 题目描述 解题思路",content:'# 9. 用两个栈实现队列\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。\n\n\n# 解题思路\n\nin 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。\n\n\n\nStack<Integer> in = new Stack<Integer>();\nStack<Integer> out = new Stack<Integer>();\n\npublic void push(int node) {\n    in.push(node);\n}\n\npublic int pop() throws Exception {\n    if (out.isEmpty())\n        while (!in.isEmpty())\n            out.push(in.pop());\n\n    if (out.isEmpty())\n        throw new Exception("queue is empty");\n\n    return out.pop();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 30. 包含 min 函数的栈\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n实现一个包含 min() 函数的栈，该方法返回当前栈中最小的值。\n\n\n# 解题思路\n\n使用一个额外的 minStack，栈顶元素为当前栈中最小的值。在对栈进行 push 入栈和 pop 出栈操作时，同样需要对 minStack 进行入栈出栈操作，从而使 minStack 栈顶元素一直为当前栈中最小的值。在进行 push 操作时，需要比较入栈元素和当前栈中最小值，将值较小的元素 push 到 minStack 中。\n\n\n\nprivate Stack<Integer> dataStack = new Stack<>();\nprivate Stack<Integer> minStack = new Stack<>();\n\npublic void push(int node) {\n    dataStack.push(node);\n    minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));\n}\n\npublic void pop() {\n    dataStack.pop();\n    minStack.pop();\n}\n\npublic int top() {\n    return dataStack.peek();\n}\n\npublic int min() {\n    return minStack.peek();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 31. 栈的压入、弹出序列\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。\n\n例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。\n\n\n# 解题思路\n\n使用一个栈来模拟压入弹出操作。每次入栈一个元素后，都要判断一下栈顶元素是不是当前出栈序列 popSequence 的第一个元素，如果是的话则执行出栈操作并将 popSequence 往后移一位，继续进行判断。\n\npublic boolean IsPopOrder(int[] pushSequence, int[] popSequence) {\n    int n = pushSequence.length;\n    Stack<Integer> stack = new Stack<>();\n    for (int pushIndex = 0, popIndex = 0; pushIndex < n; pushIndex++) {\n        stack.push(pushSequence[pushIndex]);\n        while (popIndex < n && !stack.isEmpty() \n                && stack.peek() == popSequence[popIndex]) {\n            stack.pop();\n            popIndex++;\n        }\n    }\n    return stack.isEmpty();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 40. 最小的 K 个数\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 解题思路\n\n# 大小为 K 的最小堆\n\n * 复杂度：O(NlogK) + O(K)\n * 特别适合处理海量数据\n\n维护一个大小为 K 的最小堆过程如下：使用大顶堆。在添加一个元素之后，如果大顶堆的大小大于 K，那么将大顶堆的堆顶元素去除，也就是将当前堆中值最大的元素去除，从而使得留在堆中的元素都比被去除的元素来得小。\n\n应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。\n\nJava 的 PriorityQueue 实现了堆的能力，PriorityQueue 默认是小顶堆，可以在在初始化时使用 Lambda 表达式 (o1, o2) -> o2 - o1 来实现大顶堆。其它语言也有类似的堆数据结构。\n\npublic ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {\n    if (k > nums.length || k <= 0)\n        return new ArrayList<>();\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);\n    for (int num : nums) {\n        maxHeap.add(num);\n        if (maxHeap.size() > k)\n            maxHeap.poll();\n    }\n    return new ArrayList<>(maxHeap);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 快速选择\n\n * 复杂度：O(N) + O(1)\n * 只有当允许修改数组元素时才可以使用\n\n快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。\n\npublic ArrayList<Integer> GetLeastNumbers_Solution(int[] nums, int k) {\n    ArrayList<Integer> ret = new ArrayList<>();\n    if (k > nums.length || k <= 0)\n        return ret;\n    findKthSmallest(nums, k - 1);\n    /* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */\n    for (int i = 0; i < k; i++)\n        ret.add(nums[i]);\n    return ret;\n}\n\npublic void findKthSmallest(int[] nums, int k) {\n    int l = 0, h = nums.length - 1;\n    while (l < h) {\n        int j = partition(nums, l, h);\n        if (j == k)\n            break;\n        if (j > k)\n            h = j - 1;\n        else\n            l = j + 1;\n    }\n}\n\nprivate int partition(int[] nums, int l, int h) {\n    int p = nums[l];     /* 切分元素 */\n    int i = l, j = h + 1;\n    while (true) {\n        while (i != h && nums[++i] < p) ;\n        while (j != l && nums[--j] > p) ;\n        if (i >= j)\n            break;\n        swap(nums, i, j);\n    }\n    swap(nums, l, j);\n    return j;\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int t = nums[i];\n    nums[i] = nums[j];\n    nums[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 41.1 数据流中的中位数\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n\n\n# 示例1\n\n输入：\n\n[5,2,3,4,1,6,7,0,8]\n\n\n1\n\n\n返回值：\n\n"5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 "\n\n\n1\n\n\n说明：\n\n数据流里面不断吐出的是5,2,3...,则得到的平均数分别为5,(5+2)/2,3...   \n\n\n1\n\n\n\n# 示例2\n\n输入：\n\n[1,1,1]\n\n\n1\n\n\n返回值：\n\n"1.00 1.00 1.00 "\n\n\n1\n\n\n\n# 解题思路\n\n/* 大顶堆，存储左半边元素 */\nprivate PriorityQueue<Integer> left = new PriorityQueue<>((o1, o2) -> o2 - o1);\n/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */\nprivate PriorityQueue<Integer> right = new PriorityQueue<>();\n/* 当前数据流读入的元素个数 */\nprivate int N = 0;\n\npublic void Insert(Integer val) {\n    /* 插入要保证两个堆存于平衡状态 */\n    if (N % 2 == 0) {\n        /* N 为偶数的情况下插入到右半边。\n         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，\n         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */\n        left.add(val);\n        right.add(left.poll());\n    } else {\n        right.add(val);\n        left.add(right.poll());\n    }\n    N++;\n}\n\npublic Double GetMedian() {\n    if (N % 2 == 0)\n        return (left.peek() + right.peek()) / 2.0;\n    else\n        return (double) right.peek();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 41.2 字符流中第一个不重复的字符\n\n\n# 题目描述\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。\n\n\n# 示例1\n\n输入：\n\n"google"\n\n\n1\n\n\n返回值：\n\n"ggg#ll"\n\n\n1\n\n\n\n# 示例2\n\n"abcdee"\n\n\n1\n\n\n返回值：\n\n"aaaaaa"\n\n\n1\n\n\n\n# 解题思路\n\n使用统计数组来统计每个字符出现的次数，本题涉及到的字符为都为 ASCII 码，因此使用一个大小为 128 的整型数组就能完成次数统计任务。\n\n使用队列来存储到达的字符，并在每次有新的字符从字符流到达时移除队列头部那些出现次数不再是一次的元素。因为队列是先进先出顺序，因此队列头部的元素为第一次只出现一次的字符。\n\nprivate int[] cnts = new int[128];\nprivate Queue<Character> queue = new LinkedList<>();\n\npublic void Insert(char ch) {\n    cnts[ch]++;\n    queue.add(ch);\n    while (!queue.isEmpty() && cnts[queue.peek()] > 1)\n        queue.poll();\n}\n\npublic char FirstAppearingOnce() {\n    return queue.isEmpty() ? \'#\' : queue.peek();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 59. 滑动窗口的最大值\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。\n\n例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。\n\n\n\n\n# 解题思路\n\n维护一个大小为窗口大小的大顶堆，顶堆元素则为当前窗口的最大值。\n\n假设窗口的大小为 M，数组的长度为 N。在窗口向右移动时，需要先在堆中删除离开窗口的元素，并将新到达的元素添加到堆中，这两个操作的时间复杂度都为 log2M，因此算法的时间复杂度为 O(Nlog2M)，空间复杂度为 O(M)。\n\npublic ArrayList<Integer> maxInWindows(int[] num, int size) {\n    ArrayList<Integer> ret = new ArrayList<>();\n    if (size > num.length || size < 1)\n        return ret;\n    PriorityQueue<Integer> heap = new PriorityQueue<>((o1, o2) -> o2 - o1);  /* 大顶堆 */\n    for (int i = 0; i < size; i++)\n        heap.add(num[i]);\n    ret.add(heap.peek());\n    for (int i = 0, j = i + size; j < num.length; i++, j++) {            /* 维护一个大小为 size 的大顶堆 */\n        heap.remove(num[i]);\n        heap.add(num[j]);\n        ret.add(heap.peek());\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# 9. 用两个栈实现队列\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n用两个栈来实现一个队列，完成队列的 push 和 pop 操作。\n\n\n# 解题思路\n\nin 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。\n\n\n\nstack<integer> in = new stack<integer>();\nstack<integer> out = new stack<integer>();\n\npublic void push(int node) {\n    in.push(node);\n}\n\npublic int pop() throws exception {\n    if (out.isempty())\n        while (!in.isempty())\n            out.push(in.pop());\n\n    if (out.isempty())\n        throw new exception("queue is empty");\n\n    return out.pop();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 30. 包含 min 函数的栈\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n实现一个包含 min() 函数的栈，该方法返回当前栈中最小的值。\n\n\n# 解题思路\n\n使用一个额外的 minstack，栈顶元素为当前栈中最小的值。在对栈进行 push 入栈和 pop 出栈操作时，同样需要对 minstack 进行入栈出栈操作，从而使 minstack 栈顶元素一直为当前栈中最小的值。在进行 push 操作时，需要比较入栈元素和当前栈中最小值，将值较小的元素 push 到 minstack 中。\n\n\n\nprivate stack<integer> datastack = new stack<>();\nprivate stack<integer> minstack = new stack<>();\n\npublic void push(int node) {\n    datastack.push(node);\n    minstack.push(minstack.isempty() ? node : math.min(minstack.peek(), node));\n}\n\npublic void pop() {\n    datastack.pop();\n    minstack.pop();\n}\n\npublic int top() {\n    return datastack.peek();\n}\n\npublic int min() {\n    return minstack.peek();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 31. 栈的压入、弹出序列\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。\n\n例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。\n\n\n# 解题思路\n\n使用一个栈来模拟压入弹出操作。每次入栈一个元素后，都要判断一下栈顶元素是不是当前出栈序列 popsequence 的第一个元素，如果是的话则执行出栈操作并将 popsequence 往后移一位，继续进行判断。\n\npublic boolean ispoporder(int[] pushsequence, int[] popsequence) {\n    int n = pushsequence.length;\n    stack<integer> stack = new stack<>();\n    for (int pushindex = 0, popindex = 0; pushindex < n; pushindex++) {\n        stack.push(pushsequence[pushindex]);\n        while (popindex < n && !stack.isempty() \n                && stack.peek() == popsequence[popindex]) {\n            stack.pop();\n            popindex++;\n        }\n    }\n    return stack.isempty();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 40. 最小的 k 个数\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 解题思路\n\n# 大小为 k 的最小堆\n\n * 复杂度：o(nlogk) + o(k)\n * 特别适合处理海量数据\n\n维护一个大小为 k 的最小堆过程如下：使用大顶堆。在添加一个元素之后，如果大顶堆的大小大于 k，那么将大顶堆的堆顶元素去除，也就是将当前堆中值最大的元素去除，从而使得留在堆中的元素都比被去除的元素来得小。\n\n应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。\n\njava 的 priorityqueue 实现了堆的能力，priorityqueue 默认是小顶堆，可以在在初始化时使用 lambda 表达式 (o1, o2) -> o2 - o1 来实现大顶堆。其它语言也有类似的堆数据结构。\n\npublic arraylist<integer> getleastnumbers_solution(int[] nums, int k) {\n    if (k > nums.length || k <= 0)\n        return new arraylist<>();\n    priorityqueue<integer> maxheap = new priorityqueue<>((o1, o2) -> o2 - o1);\n    for (int num : nums) {\n        maxheap.add(num);\n        if (maxheap.size() > k)\n            maxheap.poll();\n    }\n    return new arraylist<>(maxheap);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 快速选择\n\n * 复杂度：o(n) + o(1)\n * 只有当允许修改数组元素时才可以使用\n\n快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 k 个元素，这种找第 k 个元素的算法称为快速选择算法。\n\npublic arraylist<integer> getleastnumbers_solution(int[] nums, int k) {\n    arraylist<integer> ret = new arraylist<>();\n    if (k > nums.length || k <= 0)\n        return ret;\n    findkthsmallest(nums, k - 1);\n    /* findkthsmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */\n    for (int i = 0; i < k; i++)\n        ret.add(nums[i]);\n    return ret;\n}\n\npublic void findkthsmallest(int[] nums, int k) {\n    int l = 0, h = nums.length - 1;\n    while (l < h) {\n        int j = partition(nums, l, h);\n        if (j == k)\n            break;\n        if (j > k)\n            h = j - 1;\n        else\n            l = j + 1;\n    }\n}\n\nprivate int partition(int[] nums, int l, int h) {\n    int p = nums[l];     /* 切分元素 */\n    int i = l, j = h + 1;\n    while (true) {\n        while (i != h && nums[++i] < p) ;\n        while (j != l && nums[--j] > p) ;\n        if (i >= j)\n            break;\n        swap(nums, i, j);\n    }\n    swap(nums, l, j);\n    return j;\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int t = nums[i];\n    nums[i] = nums[j];\n    nums[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 41.1 数据流中的中位数\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n\n\n# 示例1\n\n输入：\n\n[5,2,3,4,1,6,7,0,8]\n\n\n1\n\n\n返回值：\n\n"5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 "\n\n\n1\n\n\n说明：\n\n数据流里面不断吐出的是5,2,3...,则得到的平均数分别为5,(5+2)/2,3...   \n\n\n1\n\n\n\n# 示例2\n\n输入：\n\n[1,1,1]\n\n\n1\n\n\n返回值：\n\n"1.00 1.00 1.00 "\n\n\n1\n\n\n\n# 解题思路\n\n/* 大顶堆，存储左半边元素 */\nprivate priorityqueue<integer> left = new priorityqueue<>((o1, o2) -> o2 - o1);\n/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */\nprivate priorityqueue<integer> right = new priorityqueue<>();\n/* 当前数据流读入的元素个数 */\nprivate int n = 0;\n\npublic void insert(integer val) {\n    /* 插入要保证两个堆存于平衡状态 */\n    if (n % 2 == 0) {\n        /* n 为偶数的情况下插入到右半边。\n         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，\n         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */\n        left.add(val);\n        right.add(left.poll());\n    } else {\n        right.add(val);\n        left.add(right.poll());\n    }\n    n++;\n}\n\npublic double getmedian() {\n    if (n % 2 == 0)\n        return (left.peek() + right.peek()) / 2.0;\n    else\n        return (double) right.peek();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 41.2 字符流中第一个不重复的字符\n\n\n# 题目描述\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。\n\n\n# 示例1\n\n输入：\n\n"google"\n\n\n1\n\n\n返回值：\n\n"ggg#ll"\n\n\n1\n\n\n\n# 示例2\n\n"abcdee"\n\n\n1\n\n\n返回值：\n\n"aaaaaa"\n\n\n1\n\n\n\n# 解题思路\n\n使用统计数组来统计每个字符出现的次数，本题涉及到的字符为都为 ascii 码，因此使用一个大小为 128 的整型数组就能完成次数统计任务。\n\n使用队列来存储到达的字符，并在每次有新的字符从字符流到达时移除队列头部那些出现次数不再是一次的元素。因为队列是先进先出顺序，因此队列头部的元素为第一次只出现一次的字符。\n\nprivate int[] cnts = new int[128];\nprivate queue<character> queue = new linkedlist<>();\n\npublic void insert(char ch) {\n    cnts[ch]++;\n    queue.add(ch);\n    while (!queue.isempty() && cnts[queue.peek()] > 1)\n        queue.poll();\n}\n\npublic char firstappearingonce() {\n    return queue.isempty() ? \'#\' : queue.peek();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 59. 滑动窗口的最大值\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。\n\n例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。\n\n\n\n\n# 解题思路\n\n维护一个大小为窗口大小的大顶堆，顶堆元素则为当前窗口的最大值。\n\n假设窗口的大小为 m，数组的长度为 n。在窗口向右移动时，需要先在堆中删除离开窗口的元素，并将新到达的元素添加到堆中，这两个操作的时间复杂度都为 log2m，因此算法的时间复杂度为 o(nlog2m)，空间复杂度为 o(m)。\n\npublic arraylist<integer> maxinwindows(int[] num, int size) {\n    arraylist<integer> ret = new arraylist<>();\n    if (size > num.length || size < 1)\n        return ret;\n    priorityqueue<integer> heap = new priorityqueue<>((o1, o2) -> o2 - o1);  /* 大顶堆 */\n    for (int i = 0; i < size; i++)\n        heap.add(num[i]);\n    ret.add(heap.peek());\n    for (int i = 0, j = i + size; j < num.length; i++, j++) {            /* 维护一个大小为 size 的大顶堆 */\n        heap.remove(num[i]);\n        heap.add(num[j]);\n        ret.add(heap.peek());\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"双指针",frontmatter:{title:"双指针",date:"2022-10-12T22:57:42.000Z",permalink:"/pages/4b7917/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/06.%E5%8F%8C%E6%8C%87%E9%92%88.html",relativePath:"02.计算机基础/50.剑指Offer题解/06.双指针.md",key:"v-24153295",path:"/pages/4b7917/",headers:[{level:2,title:"57.1 和为 S 的两个数字",slug:"_57-1-和为-s-的两个数字",normalizedTitle:"57.1 和为 s 的两个数字",charIndex:2},{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:22},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:54},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"57.2 和为 S 的连续正数序列",slug:"_57-2-和为-s-的连续正数序列",normalizedTitle:"57.2 和为 s 的连续正数序列",charIndex:717},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:54},{level:3,title:"题目描述",slug:"题目描述-3",normalizedTitle:"题目描述",charIndex:54},{level:3,title:"解题思路",slug:"解题思路-2",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"58.1 翻转单词顺序列",slug:"_58-1-翻转单词顺序列",normalizedTitle:"58.1 翻转单词顺序列",charIndex:1621},{level:3,title:"题目描述",slug:"题目描述-4",normalizedTitle:"题目描述",charIndex:54},{level:3,title:"题目描述",slug:"题目描述-5",normalizedTitle:"题目描述",charIndex:54},{level:3,title:"解题思路",slug:"解题思路-3",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"58.1 翻转单词顺序列",slug:"_58-1-翻转单词顺序列-2",normalizedTitle:"58.1 翻转单词顺序列",charIndex:1621},{level:3,title:"题目描述",slug:"题目描述-6",normalizedTitle:"题目描述",charIndex:54},{level:3,title:"题目描述",slug:"题目描述-7",normalizedTitle:"题目描述",charIndex:54},{level:3,title:"解题思路",slug:"解题思路-4",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"58.2 左旋转字符串",slug:"_58-2-左旋转字符串",normalizedTitle:"58.2 左旋转字符串",charIndex:3427},{level:3,title:"题目链接",slug:"题目链接-2",normalizedTitle:"题目链接",charIndex:22},{level:3,title:"题目描述",slug:"题目描述-8",normalizedTitle:"题目描述",charIndex:54},{level:3,title:"解题思路",slug:"解题思路-5",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"22. 链表中倒数第 K 个结点",slug:"_22-链表中倒数第-k-个结点",normalizedTitle:"22. 链表中倒数第 k 个结点",charIndex:4219},{level:3,title:"解题思路",slug:"解题思路-6",normalizedTitle:"解题思路",charIndex:114}],headersStr:"57.1 和为 S 的两个数字 题目链接 题目描述 解题思路 57.2 和为 S 的连续正数序列 题目描述 题目描述 解题思路 58.1 翻转单词顺序列 题目描述 题目描述 解题思路 58.1 翻转单词顺序列 题目描述 题目描述 解题思路 58.2 左旋转字符串 题目链接 题目描述 解题思路 22. 链表中倒数第 K 个结点 解题思路",content:'# 57.1 和为 S 的两个数字\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n在有序数组中找出两个数，使得和为给定的数 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。\n\n\n# 解题思路\n\n使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。\n\n * 如果两个指针指向元素的和 sum == target，那么这两个元素即为所求。\n * 如果 sum > target，移动较大的元素，使 sum 变小一些；\n * 如果 sum < target，移动较小的元素，使 sum 变大一些。\n\npublic ArrayList<Integer> FindNumbersWithSum(int[] nums, int target) {\n    int i = 0, j = nums.length - 1;\n    while (i < j) {\n        int cur = nums[i] + array[j];\n        if (cur == target)\n            return new ArrayList<>(Arrays.asList(nums[i], nums[j]));\n        if (cur < target)\n            i++;\n        else\n            j--;\n    }\n    return new ArrayList<>();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 57.2 和为 S 的连续正数序列\n\n\n# 题目描述\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n输出所有和为 S 的连续正数序列。例如和为 100 的连续序列有：\n\n[9, 10, 11, 12, 13, 14, 15, 16]\n[18, 19, 20, 21, 22]。\n\n\n1\n2\n\n\n\n# 解题思路\n\npublic ArrayList<ArrayList<Integer>> FindContinuousSequence(int sum) {\n    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();\n    int start = 1, end = 2;\n    int curSum = 3;\n    while (end < sum) {\n        if (curSum > sum) {\n            curSum -= start;\n            start++;\n        } else if (curSum < sum) {\n            end++;\n            curSum += end;\n        } else {\n            ArrayList<Integer> list = new ArrayList<>();\n            for (int i = start; i <= end; i++)\n                list.add(i);\n            ret.add(list);\n            curSum -= start;\n            start++;\n            end++;\n            curSum += end;\n        }\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 58.1 翻转单词顺序列\n\n\n# 题目描述\n\n牛客网(opens new window)\n\n\n# 题目描述\n\nInput:\n"I am a student."\n\nOutput:\n"student. a am I"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n先翻转每个单词，再翻转整个字符串。\n\n题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。\n\npublic String ReverseSentence(String str) {\n    int n = str.length();\n    char[] chars = str.toCharArray();\n    int i = 0, j = 0;\n    while (j <= n) {\n        if (j == n || chars[j] == \' \') {\n            reverse(chars, i, j - 1);\n            i = j + 1;\n        }\n        j++;\n    }\n    reverse(chars, 0, n - 1);\n    return new String(chars);\n}\n\nprivate void reverse(char[] c, int i, int j) {\n    while (i < j)\n        swap(c, i++, j--);\n}\n\nprivate void swap(char[] c, int i, int j) {\n    char t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 58.1 翻转单词顺序列\n\n\n# 题目描述\n\n牛客网(opens new window)\n\n\n# 题目描述\n\nInput:\n"I am a student."\n\nOutput:\n"student. a am I"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n先翻转每个单词，再翻转整个字符串。\n\n题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。\n\npublic String ReverseSentence(String str) {\n    int n = str.length();\n    char[] chars = str.toCharArray();\n    int i = 0, j = 0;\n    while (j <= n) {\n        if (j == n || chars[j] == \' \') {\n            reverse(chars, i, j - 1);\n            i = j + 1;\n        }\n        j++;\n    }\n    reverse(chars, 0, n - 1);\n    return new String(chars);\n}\n\nprivate void reverse(char[] c, int i, int j) {\n    while (i < j)\n        swap(c, i++, j--);\n}\n\nprivate void swap(char[] c, int i, int j) {\n    char t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 58.2 左旋转字符串\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n将字符串 S 从第 K 位置分隔成两个子字符串，并交换这两个子字符串的位置。\n\nInput:\nS="abcXYZdef"\nK=3\n\nOutput:\n"XYZdefabc"\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 解题思路\n\n先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"。\n\npublic String LeftRotateString(String str, int n) {\n    if (n >= str.length())\n        return str;\n    char[] chars = str.toCharArray();\n    reverse(chars, 0, n - 1);\n    reverse(chars, n, chars.length - 1);\n    reverse(chars, 0, chars.length - 1);\n    return new String(chars);\n}\n\nprivate void reverse(char[] chars, int i, int j) {\n    while (i < j)\n        swap(chars, i++, j--);\n}\n\nprivate void swap(char[] chars, int i, int j) {\n    char t = chars[i];\n    chars[i] = chars[j];\n    chars[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 22. 链表中倒数第 K 个结点\n\n牛客网(opens new window)\n\n\n# 解题思路\n\n设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。\n\n\n\npublic ListNode FindKthToTail(ListNode head, int k) {\n    if (head == null)\n        return null;\n    ListNode P1 = head;\n    while (P1 != null && k-- > 0)\n        P1 = P1.next;\n    if (k > 0)\n        return null;\n    ListNode P2 = head;\n    while (P1 != null) {\n        P1 = P1.next;\n        P2 = P2.next;\n    }\n    return P2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# 57.1 和为 s 的两个数字\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n在有序数组中找出两个数，使得和为给定的数 s。如果有多对数字的和等于 s，输出两个数的乘积最小的。\n\n\n# 解题思路\n\n使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。\n\n * 如果两个指针指向元素的和 sum == target，那么这两个元素即为所求。\n * 如果 sum > target，移动较大的元素，使 sum 变小一些；\n * 如果 sum < target，移动较小的元素，使 sum 变大一些。\n\npublic arraylist<integer> findnumberswithsum(int[] nums, int target) {\n    int i = 0, j = nums.length - 1;\n    while (i < j) {\n        int cur = nums[i] + array[j];\n        if (cur == target)\n            return new arraylist<>(arrays.aslist(nums[i], nums[j]));\n        if (cur < target)\n            i++;\n        else\n            j--;\n    }\n    return new arraylist<>();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 57.2 和为 s 的连续正数序列\n\n\n# 题目描述\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n输出所有和为 s 的连续正数序列。例如和为 100 的连续序列有：\n\n[9, 10, 11, 12, 13, 14, 15, 16]\n[18, 19, 20, 21, 22]。\n\n\n1\n2\n\n\n\n# 解题思路\n\npublic arraylist<arraylist<integer>> findcontinuoussequence(int sum) {\n    arraylist<arraylist<integer>> ret = new arraylist<>();\n    int start = 1, end = 2;\n    int cursum = 3;\n    while (end < sum) {\n        if (cursum > sum) {\n            cursum -= start;\n            start++;\n        } else if (cursum < sum) {\n            end++;\n            cursum += end;\n        } else {\n            arraylist<integer> list = new arraylist<>();\n            for (int i = start; i <= end; i++)\n                list.add(i);\n            ret.add(list);\n            cursum -= start;\n            start++;\n            end++;\n            cursum += end;\n        }\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 58.1 翻转单词顺序列\n\n\n# 题目描述\n\n牛客网(opens new window)\n\n\n# 题目描述\n\ninput:\n"i am a student."\n\noutput:\n"student. a am i"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n先翻转每个单词，再翻转整个字符串。\n\n题目应该有一个隐含条件，就是不能用额外的空间。虽然 java 的题目输入参数为 string 类型，需要先创建一个字符数组使得空间复杂度为 o(n)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。\n\npublic string reversesentence(string str) {\n    int n = str.length();\n    char[] chars = str.tochararray();\n    int i = 0, j = 0;\n    while (j <= n) {\n        if (j == n || chars[j] == \' \') {\n            reverse(chars, i, j - 1);\n            i = j + 1;\n        }\n        j++;\n    }\n    reverse(chars, 0, n - 1);\n    return new string(chars);\n}\n\nprivate void reverse(char[] c, int i, int j) {\n    while (i < j)\n        swap(c, i++, j--);\n}\n\nprivate void swap(char[] c, int i, int j) {\n    char t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 58.1 翻转单词顺序列\n\n\n# 题目描述\n\n牛客网(opens new window)\n\n\n# 题目描述\n\ninput:\n"i am a student."\n\noutput:\n"student. a am i"\n\n\n1\n2\n3\n4\n5\n\n\n\n# 解题思路\n\n先翻转每个单词，再翻转整个字符串。\n\n题目应该有一个隐含条件，就是不能用额外的空间。虽然 java 的题目输入参数为 string 类型，需要先创建一个字符数组使得空间复杂度为 o(n)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。\n\npublic string reversesentence(string str) {\n    int n = str.length();\n    char[] chars = str.tochararray();\n    int i = 0, j = 0;\n    while (j <= n) {\n        if (j == n || chars[j] == \' \') {\n            reverse(chars, i, j - 1);\n            i = j + 1;\n        }\n        j++;\n    }\n    reverse(chars, 0, n - 1);\n    return new string(chars);\n}\n\nprivate void reverse(char[] c, int i, int j) {\n    while (i < j)\n        swap(c, i++, j--);\n}\n\nprivate void swap(char[] c, int i, int j) {\n    char t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 58.2 左旋转字符串\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n将字符串 s 从第 k 位置分隔成两个子字符串，并交换这两个子字符串的位置。\n\ninput:\ns="abcxyzdef"\nk=3\n\noutput:\n"xyzdefabc"\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 解题思路\n\n先将 "abc" 和 "xyzdef" 分别翻转，得到 "cbafedzyx"，然后再把整个字符串翻转得到 "xyzdefabc"。\n\npublic string leftrotatestring(string str, int n) {\n    if (n >= str.length())\n        return str;\n    char[] chars = str.tochararray();\n    reverse(chars, 0, n - 1);\n    reverse(chars, n, chars.length - 1);\n    reverse(chars, 0, chars.length - 1);\n    return new string(chars);\n}\n\nprivate void reverse(char[] chars, int i, int j) {\n    while (i < j)\n        swap(chars, i++, j--);\n}\n\nprivate void swap(char[] chars, int i, int j) {\n    char t = chars[i];\n    chars[i] = chars[j];\n    chars[j] = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 22. 链表中倒数第 k 个结点\n\n牛客网(opens new window)\n\n\n# 解题思路\n\n设链表的长度为 n。设置两个指针 p1 和 p2，先让 p1 移动 k 个节点，则还有 n - k 个节点可以移动。此时让 p1 和 p2 同时移动，可以知道当 p1 移动到链表结尾时，p2 移动到第 n - k 个节点处，该位置就是倒数第 k 个节点。\n\n\n\npublic listnode findkthtotail(listnode head, int k) {\n    if (head == null)\n        return null;\n    listnode p1 = head;\n    while (p1 != null && k-- > 0)\n        p1 = p1.next;\n    if (k > 0)\n        return null;\n    listnode p2 = head;\n    while (p1 != null) {\n        p1 = p1.next;\n        p2 = p2.next;\n    }\n    return p2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"链表",frontmatter:{title:"链表",date:"2022-10-12T23:23:03.000Z",permalink:"/pages/f55bff/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/10.%E9%93%BE%E8%A1%A8.html",relativePath:"02.计算机基础/50.剑指Offer题解/10.链表.md",key:"v-ca8a5a42",path:"/pages/f55bff/",headers:[{level:2,title:"6. 从尾到头打印链表",slug:"_6-从尾到头打印链表",normalizedTitle:"6. 从尾到头打印链表",charIndex:2},{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:80},{level:4,title:"1. 使用递归",slug:"_1-使用递归",normalizedTitle:"1. 使用递归",charIndex:88},{level:4,title:"2. 使用头插法",slug:"_2-使用头插法",normalizedTitle:"2. 使用头插法",charIndex:500},{level:4,title:"3. 使用栈",slug:"_3-使用栈",normalizedTitle:"3. 使用栈",charIndex:1324},{level:2,title:"18.2 删除链表中重复的结点",slug:"_18-2-删除链表中重复的结点",normalizedTitle:"18.2 删除链表中重复的结点",charIndex:1748},{level:3,title:"题目链接",slug:"题目链接-2",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题描述",slug:"解题描述",normalizedTitle:"解题描述",charIndex:1900},{level:2,title:"24. 反转链表",slug:"_24-反转链表",normalizedTitle:"24. 反转链表",charIndex:2346},{level:3,title:"解题思路",slug:"解题思路-2",normalizedTitle:"解题思路",charIndex:80},{level:4,title:"递归",slug:"递归",normalizedTitle:"递归",charIndex:93},{level:4,title:"迭代",slug:"迭代",normalizedTitle:"迭代",charIndex:2671},{level:2,title:"25. 合并两个排序的链表",slug:"_25-合并两个排序的链表",normalizedTitle:"25. 合并两个排序的链表",charIndex:2976},{level:3,title:"题目描述",slug:"题目描述-3",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-3",normalizedTitle:"解题思路",charIndex:80},{level:4,title:"递归",slug:"递归-2",normalizedTitle:"递归",charIndex:93},{level:4,title:"迭代",slug:"迭代-2",normalizedTitle:"迭代",charIndex:2671},{level:2,title:"35. 复杂链表的复制",slug:"_35-复杂链表的复制",normalizedTitle:"35. 复杂链表的复制",charIndex:3984},{level:3,title:"题目描述",slug:"题目描述-4",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-4",normalizedTitle:"解题思路",charIndex:80},{level:2,title:"52. 两个链表的第一个公共结点",slug:"_52-两个链表的第一个公共结点",normalizedTitle:"52. 两个链表的第一个公共结点",charIndex:5223},{level:3,title:"题目描述",slug:"题目描述-5",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-5",normalizedTitle:"解题思路",charIndex:80}],headersStr:"6. 从尾到头打印链表 题目链接 题目描述 解题思路 1. 使用递归 2. 使用头插法 3. 使用栈 18.2 删除链表中重复的结点 题目链接 题目描述 解题描述 24. 反转链表 解题思路 递归 迭代 25. 合并两个排序的链表 题目描述 解题思路 递归 迭代 35. 复杂链表的复制 题目描述 解题思路 52. 两个链表的第一个公共结点 题目描述 解题思路",content:"# 6. 从尾到头打印链表\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n从尾到头反过来打印出每个结点的值。\n\n\n\n\n# 解题思路\n\n# 1. 使用递归\n\n要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。\n\npublic ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n    ArrayList<Integer> ret = new ArrayList<>();\n    if (listNode != null) {\n        ret.addAll(printListFromTailToHead(listNode.next));\n        ret.add(listNode.val);\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2. 使用头插法\n\n头插法顾名思义是将节点插入到头部：在遍历原始链表时，将当前节点插入新链表的头部，使其成为第一个节点。\n\n链表的操作需要维护后继关系，例如在某个节点 node1 之后插入一个节点 node2，我们可以通过修改后继关系来实现：\n\nnode3 = node1.next;\nnode2.next = node3;\nnode1.next = node2;\n\n\n1\n2\n3\n\n\n\n\n为了能将一个节点插入头部，我们引入了一个叫头结点的辅助节点，该节点不存储值，只是为了方便进行插入操作。不要将头结点与第一个节点混起来，第一个节点是链表中第一个真正存储值的节点。\n\n\n\npublic ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n    // 头插法构建逆序链表\n    ListNode head = new ListNode(-1);\n    while (listNode != null) {\n        ListNode memo = listNode.next;\n        listNode.next = head.next;\n        head.next = listNode;\n        listNode = memo;\n    }\n    // 构建 ArrayList\n    ArrayList<Integer> ret = new ArrayList<>();\n    head = head.next;\n    while (head != null) {\n        ret.add(head.val);\n        head = head.next;\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3. 使用栈\n\n栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。\n\n\n\npublic ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n    Stack<Integer> stack = new Stack<>();\n    while (listNode != null) {\n        stack.add(listNode.val);\n        listNode = listNode.next;\n    }\n    ArrayList<Integer> ret = new ArrayList<>();\n    while (!stack.isEmpty())\n        ret.add(stack.pop());\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 18.2 删除链表中重复的结点\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1->2->3->3->4->4->5 处理后为 1->2->5\n\n\n\n\n# 解题描述\n\npublic ListNode deleteDuplication(ListNode pHead) {\n    if (pHead == null || pHead.next == null)\n        return pHead;\n    ListNode next = pHead.next;\n    if (pHead.val == next.val) {\n        while (next != null && pHead.val == next.val)\n            next = next.next;\n        return deleteDuplication(next);\n    } else {\n        pHead.next = deleteDuplication(pHead.next);\n        return pHead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 24. 反转链表\n\nNowCoder(opens new window)\n\n\n# 解题思路\n\n# 递归\n\npublic ListNode ReverseList(ListNode head) {\n    if (head == null || head.next == null)\n        return head;\n    ListNode next = head.next;\n    head.next = null;\n    ListNode newHead = ReverseList(next);\n    next.next = head;\n    return newHead;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 迭代\n\n使用头插法。\n\npublic ListNode ReverseList(ListNode head) {\n    ListNode newList = new ListNode(-1);\n    while (head != null) {\n        ListNode next = head.next;\n        head.next = newList.next;\n        newList.next = head;\n        head = next;\n    }\n    return newList.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 25. 合并两个排序的链表\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n\n\n\n# 解题思路\n\n# 递归\n\npublic ListNode Merge(ListNode list1, ListNode list2) {\n    if (list1 == null)\n        return list2;\n    if (list2 == null)\n        return list1;\n    if (list1.val <= list2.val) {\n        list1.next = Merge(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = Merge(list1, list2.next);\n        return list2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 迭代\n\npublic ListNode Merge(ListNode list1, ListNode list2) {\n    ListNode head = new ListNode(-1);\n    ListNode cur = head;\n    while (list1 != null && list2 != null) {\n        if (list1.val <= list2.val) {\n            cur.next = list1;\n            list1 = list1.next;\n        } else {\n            cur.next = list2;\n            list2 = list2.next;\n        }\n        cur = cur.next;\n    }\n    if (list1 != null)\n        cur.next = list1;\n    if (list2 != null)\n        cur.next = list2;\n    return head.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 35. 复杂链表的复制\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。\n\npublic class RandomListNode {\n    int label;\n    RandomListNode next = null;\n    RandomListNode random = null;\n\n    RandomListNode(int label) {\n        this.label = label;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n# 解题思路\n\n第一步，在每个节点的后面插入复制的节点。\n\n\n\n第二步，对复制节点的 random 链接进行赋值。\n\n\n\n第三步，拆分。\n\n\n\npublic RandomListNode Clone(RandomListNode pHead) {\n    if (pHead == null)\n        return null;\n    // 插入新节点\n    RandomListNode cur = pHead;\n    while (cur != null) {\n        RandomListNode clone = new RandomListNode(cur.label);\n        clone.next = cur.next;\n        cur.next = clone;\n        cur = clone.next;\n    }\n    // 建立 random 链接\n    cur = pHead;\n    while (cur != null) {\n        RandomListNode clone = cur.next;\n        if (cur.random != null)\n            clone.random = cur.random.next;\n        cur = clone.next;\n    }\n    // 拆分\n    cur = pHead;\n    RandomListNode pCloneHead = pHead.next;\n    while (cur.next != null) {\n        RandomListNode next = cur.next;\n        cur.next = next.next;\n        cur = next;\n    }\n    return pCloneHead;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 52. 两个链表的第一个公共结点\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n\n\n\n# 解题思路\n\n设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。\n\n当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。\n\npublic ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {\n    ListNode l1 = pHead1, l2 = pHead2;\n    while (l1 != l2) {\n        l1 = (l1 == null) ? pHead2 : l1.next;\n        l2 = (l2 == null) ? pHead1 : l2.next;\n    }\n    return l1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# 6. 从尾到头打印链表\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n从尾到头反过来打印出每个结点的值。\n\n\n\n\n# 解题思路\n\n# 1. 使用递归\n\n要逆序打印链表 1->2->3（3,2,1)，可以先逆序打印链表 2->3(3,2)，最后再打印第一个节点 1。而链表 2->3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。\n\npublic arraylist<integer> printlistfromtailtohead(listnode listnode) {\n    arraylist<integer> ret = new arraylist<>();\n    if (listnode != null) {\n        ret.addall(printlistfromtailtohead(listnode.next));\n        ret.add(listnode.val);\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2. 使用头插法\n\n头插法顾名思义是将节点插入到头部：在遍历原始链表时，将当前节点插入新链表的头部，使其成为第一个节点。\n\n链表的操作需要维护后继关系，例如在某个节点 node1 之后插入一个节点 node2，我们可以通过修改后继关系来实现：\n\nnode3 = node1.next;\nnode2.next = node3;\nnode1.next = node2;\n\n\n1\n2\n3\n\n\n\n\n为了能将一个节点插入头部，我们引入了一个叫头结点的辅助节点，该节点不存储值，只是为了方便进行插入操作。不要将头结点与第一个节点混起来，第一个节点是链表中第一个真正存储值的节点。\n\n\n\npublic arraylist<integer> printlistfromtailtohead(listnode listnode) {\n    // 头插法构建逆序链表\n    listnode head = new listnode(-1);\n    while (listnode != null) {\n        listnode memo = listnode.next;\n        listnode.next = head.next;\n        head.next = listnode;\n        listnode = memo;\n    }\n    // 构建 arraylist\n    arraylist<integer> ret = new arraylist<>();\n    head = head.next;\n    while (head != null) {\n        ret.add(head.val);\n        head = head.next;\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3. 使用栈\n\n栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。\n\n\n\npublic arraylist<integer> printlistfromtailtohead(listnode listnode) {\n    stack<integer> stack = new stack<>();\n    while (listnode != null) {\n        stack.add(listnode.val);\n        listnode = listnode.next;\n    }\n    arraylist<integer> ret = new arraylist<>();\n    while (!stack.isempty())\n        ret.add(stack.pop());\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 18.2 删除链表中重复的结点\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1->2->3->3->4->4->5 处理后为 1->2->5\n\n\n\n\n# 解题描述\n\npublic listnode deleteduplication(listnode phead) {\n    if (phead == null || phead.next == null)\n        return phead;\n    listnode next = phead.next;\n    if (phead.val == next.val) {\n        while (next != null && phead.val == next.val)\n            next = next.next;\n        return deleteduplication(next);\n    } else {\n        phead.next = deleteduplication(phead.next);\n        return phead;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 24. 反转链表\n\nnowcoder(opens new window)\n\n\n# 解题思路\n\n# 递归\n\npublic listnode reverselist(listnode head) {\n    if (head == null || head.next == null)\n        return head;\n    listnode next = head.next;\n    head.next = null;\n    listnode newhead = reverselist(next);\n    next.next = head;\n    return newhead;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 迭代\n\n使用头插法。\n\npublic listnode reverselist(listnode head) {\n    listnode newlist = new listnode(-1);\n    while (head != null) {\n        listnode next = head.next;\n        head.next = newlist.next;\n        newlist.next = head;\n        head = next;\n    }\n    return newlist.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 25. 合并两个排序的链表\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n\n\n\n# 解题思路\n\n# 递归\n\npublic listnode merge(listnode list1, listnode list2) {\n    if (list1 == null)\n        return list2;\n    if (list2 == null)\n        return list1;\n    if (list1.val <= list2.val) {\n        list1.next = merge(list1.next, list2);\n        return list1;\n    } else {\n        list2.next = merge(list1, list2.next);\n        return list2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 迭代\n\npublic listnode merge(listnode list1, listnode list2) {\n    listnode head = new listnode(-1);\n    listnode cur = head;\n    while (list1 != null && list2 != null) {\n        if (list1.val <= list2.val) {\n            cur.next = list1;\n            list1 = list1.next;\n        } else {\n            cur.next = list2;\n            list2 = list2.next;\n        }\n        cur = cur.next;\n    }\n    if (list1 != null)\n        cur.next = list1;\n    if (list2 != null)\n        cur.next = list2;\n    return head.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 35. 复杂链表的复制\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。\n\npublic class randomlistnode {\n    int label;\n    randomlistnode next = null;\n    randomlistnode random = null;\n\n    randomlistnode(int label) {\n        this.label = label;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n# 解题思路\n\n第一步，在每个节点的后面插入复制的节点。\n\n\n\n第二步，对复制节点的 random 链接进行赋值。\n\n\n\n第三步，拆分。\n\n\n\npublic randomlistnode clone(randomlistnode phead) {\n    if (phead == null)\n        return null;\n    // 插入新节点\n    randomlistnode cur = phead;\n    while (cur != null) {\n        randomlistnode clone = new randomlistnode(cur.label);\n        clone.next = cur.next;\n        cur.next = clone;\n        cur = clone.next;\n    }\n    // 建立 random 链接\n    cur = phead;\n    while (cur != null) {\n        randomlistnode clone = cur.next;\n        if (cur.random != null)\n            clone.random = cur.random.next;\n        cur = clone.next;\n    }\n    // 拆分\n    cur = phead;\n    randomlistnode pclonehead = phead.next;\n    while (cur.next != null) {\n        randomlistnode next = cur.next;\n        cur.next = next.next;\n        cur = next;\n    }\n    return pclonehead;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 52. 两个链表的第一个公共结点\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n\n\n\n# 解题思路\n\n设 a 的长度为 a + c，b 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。\n\n当访问链表 a 的指针访问到链表尾部时，令它从链表 b 的头部重新开始访问链表 b；同样地，当访问链表 b 的指针访问到链表尾部时，令它从链表 a 的头部重新开始访问链表 a。这样就能控制访问 a 和 b 两个链表的指针能同时访问到交点。\n\npublic listnode findfirstcommonnode(listnode phead1, listnode phead2) {\n    listnode l1 = phead1, l2 = phead2;\n    while (l1 != l2) {\n        l1 = (l1 == null) ? phead2 : l1.next;\n        l2 = (l2 == null) ? phead1 : l2.next;\n    }\n    return l1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"树",frontmatter:{title:"树",date:"2022-10-12T23:46:13.000Z",permalink:"/pages/873a10/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/15.%E6%A0%91.html",relativePath:"02.计算机基础/50.剑指Offer题解/15.树.md",key:"v-ccd01cc4",path:"/pages/873a10/",headers:[{level:2,title:"7. 重建二叉树",slug:"_7-重建二叉树",normalizedTitle:"7. 重建二叉树",charIndex:2},{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:15},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:114},{level:3,title:"8. 二叉树的下一个结点",slug:"_8-二叉树的下一个结点",normalizedTitle:"8. 二叉树的下一个结点",charIndex:1008},{level:3,title:"题目链接",slug:"题目链接-2",normalizedTitle:"题目链接",charIndex:15},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-2",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"26. 树的子结构",slug:"_26-树的子结构",normalizedTitle:"26. 树的子结构",charIndex:2145},{level:3,title:"题目链接",slug:"题目链接-3",normalizedTitle:"题目链接",charIndex:15},{level:3,title:"题目描述",slug:"题目描述-3",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-3",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"27. 二叉树的镜像",slug:"_27-二叉树的镜像",normalizedTitle:"27. 二叉树的镜像",charIndex:2906},{level:3,title:"题目描述",slug:"题目描述-4",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-4",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"28. 对称的二叉树",slug:"_28-对称的二叉树",normalizedTitle:"28. 对称的二叉树",charIndex:3280},{level:3,title:"题目描述",slug:"题目描述-5",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-5",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"32.1 从上往下打印二叉树",slug:"_32-1-从上往下打印二叉树",normalizedTitle:"32.1 从上往下打印二叉树",charIndex:3868},{level:3,title:"题目描述",slug:"题目描述-6",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-6",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"32.2 把二叉树打印成多行",slug:"_32-2-把二叉树打印成多行",normalizedTitle:"32.2 把二叉树打印成多行",charIndex:4690},{level:3,title:"题目描述",slug:"题目描述-7",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-7",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"32.3 按之字形顺序打印二叉树",slug:"_32-3-按之字形顺序打印二叉树",normalizedTitle:"32.3 按之字形顺序打印二叉树",charIndex:5576},{level:3,title:"题目描述",slug:"题目描述-8",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-8",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"33. 二叉搜索树的后序遍历序列",slug:"_33-二叉搜索树的后序遍历序列",normalizedTitle:"33. 二叉搜索树的后序遍历序列",charIndex:6525},{level:3,title:"题目描述",slug:"题目描述-9",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-9",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"34. 二叉树中和为某一值的路径",slug:"_34-二叉树中和为某一值的路径",normalizedTitle:"34. 二叉树中和为某一值的路径",charIndex:7623},{level:3,title:"题目描述",slug:"题目描述-10",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-10",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"36. 二叉搜索树与双向链表",slug:"_36-二叉搜索树与双向链表",normalizedTitle:"36. 二叉搜索树与双向链表",charIndex:8618},{level:3,title:"题目描述",slug:"题目描述-11",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-11",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"37. 序列化二叉树",slug:"_37-序列化二叉树",normalizedTitle:"37. 序列化二叉树",charIndex:9193},{level:3,title:"题目描述",slug:"题目描述-12",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-12",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"54. 二叉查找树的第 K 个结点",slug:"_54-二叉查找树的第-k-个结点",normalizedTitle:"54. 二叉查找树的第 k 个结点",charIndex:10365},{level:3,title:"解题思路",slug:"解题思路-13",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"55.1 二叉树的深度",slug:"_55-1-二叉树的深度",normalizedTitle:"55.1 二叉树的深度",charIndex:10825},{level:3,title:"题目描述",slug:"题目描述-13",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-14",normalizedTitle:"解题思路",charIndex:114},{level:2,title:"55.2 判断是否是平衡二叉树",slug:"_55-2-判断是否是平衡二叉树",normalizedTitle:"55.2 判断是否是平衡二叉树",charIndex:11075},{level:3,title:"题目描述",slug:"题目描述-14",normalizedTitle:"题目描述",charIndex:47},{level:3,title:"解题思路",slug:"解题思路-15",normalizedTitle:"解题思路",charIndex:114}],headersStr:"7. 重建二叉树 题目链接 题目描述 解题思路 8. 二叉树的下一个结点 题目链接 题目描述 解题思路 26. 树的子结构 题目链接 题目描述 解题思路 27. 二叉树的镜像 题目描述 解题思路 28. 对称的二叉树 题目描述 解题思路 32.1 从上往下打印二叉树 题目描述 解题思路 32.2 把二叉树打印成多行 题目描述 解题思路 32.3 按之字形顺序打印二叉树 题目描述 解题思路 33. 二叉搜索树的后序遍历序列 题目描述 解题思路 34. 二叉树中和为某一值的路径 题目描述 解题思路 36. 二叉搜索树与双向链表 题目描述 解题思路 37. 序列化二叉树 题目描述 解题思路 54. 二叉查找树的第 K 个结点 解题思路 55.1 二叉树的深度 题目描述 解题思路 55.2 判断是否是平衡二叉树 题目描述 解题思路",content:'# 7. 重建二叉树\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n\n\n\n# 解题思路\n\n前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。\n\n\n\n// 缓存中序遍历数组每个值对应的索引\nprivate Map<Integer, Integer> indexForInOrders = new HashMap<>();\n\npublic TreeNode reConstructBinaryTree(int[] pre, int[] in) {\n    for (int i = 0; i < in.length; i++)\n        indexForInOrders.put(in[i], i);\n    return reConstructBinaryTree(pre, 0, pre.length - 1, 0);\n}\n\nprivate TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL) {\n    if (preL > preR)\n        return null;\n    TreeNode root = new TreeNode(pre[preL]);\n    int inIndex = indexForInOrders.get(root.val);\n    int leftTreeSize = inIndex - inL;\n    root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeSize, inL);\n    root.right = reConstructBinaryTree(pre, preL + leftTreeSize + 1, preR, inL + leftTreeSize + 1);\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 8. 二叉树的下一个结点\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。\n\npublic class TreeLinkNode {\n\n    int val;\n    TreeLinkNode left = null;\n    TreeLinkNode right = null;\n    TreeLinkNode next = null; // 指向父结点的指针\n\n    TreeLinkNode(int val) {\n        this.val = val;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 解题思路\n\n我们先来回顾一下中序遍历的过程：先遍历树的左子树，再遍历根节点，最后再遍历右子树。所以最左节点是中序遍历的第一个节点。\n\nvoid traverse(TreeNode root) {\n    if (root == null) return;\n    traverse(root.left);\n    visit(root);\n    traverse(root.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；\n\n\n\n② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。\n\n\n\npublic TreeLinkNode GetNext(TreeLinkNode pNode) {\n    if (pNode.right != null) {\n        TreeLinkNode node = pNode.right;\n        while (node.left != null)\n            node = node.left;\n        return node;\n    } else {\n        while (pNode.next != null) {\n            TreeLinkNode parent = pNode.next;\n            if (parent.left == pNode)\n                return parent;\n            pNode = pNode.next;\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 26. 树的子结构\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构） 假如给定A为{8,8,7,9,2,#,#,#,#,4,7}，B为{8,9,2}，2个树的结构如下，可以看出B是A的子结构\n\n\n\n\n# 解题思路\n\npublic boolean HasSubtree(TreeNode root1, TreeNode root2) {\n    if (root1 == null || root2 == null)\n        return false;\n    return isSubtreeWithRoot(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);\n}\n\nprivate boolean isSubtreeWithRoot(TreeNode root1, TreeNode root2) {\n    if (root2 == null)\n        return true;\n    if (root1 == null)\n        return false;\n    if (root1.val != root2.val)\n        return false;\n    return isSubtreeWithRoot(root1.left, root2.left) && isSubtreeWithRoot(root1.right, root2.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 27. 二叉树的镜像\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n\n\n\n# 解题思路\n\npublic TreeNode Mirror(TreeNode root) {\n    if (root == null)\n        return root;\n    swap(root);\n    Mirror(root.left);\n    Mirror(root.right);\n    return root;\n}\n\nprivate void swap(TreeNode root) {\n    TreeNode t = root.left;\n    root.left = root.right;\n    root.right = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 28. 对称的二叉树\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n给定一棵二叉树，判断其是否是自身的镜像（即：是否对称） 例如： 下面这棵二叉树是对称的 下面这棵二叉树不对称。\n\n\n# 解题思路\n\nboolean isSymmetrical(TreeNode pRoot) {\n    if (pRoot == null)\n        return true;\n    return isSymmetrical(pRoot.left, pRoot.right);\n}\n\nboolean isSymmetrical(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null)\n        return true;\n    if (t1 == null || t2 == null)\n        return false;\n    if (t1.val != t2.val)\n        return false;\n    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 32.1 从上往下打印二叉树\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如输入{8,6,10,#,#,2,1}，如以下图中的示例二叉树，则依次打印8,6,10,2,1(空节点不打印，跳过)，请你将打印的结果存放到一个数组里面，返回。\n\n\n\n\n# 解题思路\n\n使用队列来进行层次遍历。\n\n不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。\n\npublic ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    ArrayList<Integer> ret = new ArrayList<>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        int cnt = queue.size();\n        while (cnt-- > 0) {\n            TreeNode t = queue.poll();\n            if (t == null)\n                continue;\n            ret.add(t.val);\n            queue.add(t.left);\n            queue.add(t.right);\n        }\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 32.2 把二叉树打印成多行\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。\n\n例如： 给定的二叉树是{1,2,3,#,#,4,5} 该二叉树多行打印层序遍历的结果是\n\n[\n\n[1],\n\n[2,3],\n\n[4,5]\n\n]\n\n\n# 解题思路\n\nArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {\n    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(pRoot);\n    while (!queue.isEmpty()) {\n        ArrayList<Integer> list = new ArrayList<>();\n        int cnt = queue.size();\n        while (cnt-- > 0) {\n            TreeNode node = queue.poll();\n            if (node == null)\n                continue;\n            list.add(node.val);\n            queue.add(node.left);\n            queue.add(node.right);\n        }\n        if (list.size() != 0)\n            ret.add(list);\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 32.3 按之字形顺序打印二叉树\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。\n\n\n# 解题思路\n\npublic ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {\n    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(pRoot);\n    boolean reverse = false;\n    while (!queue.isEmpty()) {\n        ArrayList<Integer> list = new ArrayList<>();\n        int cnt = queue.size();\n        while (cnt-- > 0) {\n            TreeNode node = queue.poll();\n            if (node == null)\n                continue;\n            list.add(node.val);\n            queue.add(node.left);\n            queue.add(node.right);\n        }\n        if (reverse)\n            Collections.reverse(list);\n        reverse = !reverse;\n        if (list.size() != 0)\n            ret.add(list);\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 33. 二叉搜索树的后序遍历序列\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。\n\n例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。\n\n\n\n\n# 解题思路\n\n 1. 二叉树的后序遍历顺序是：左子树 -> 右子树 -> 根节点\n 2. 因此序列的最后一个数代表了根节点\n 3. 因此我们可以将一个序列划分为3段, 左子树+右子树+根, 例如[4, 8, 6, 12, 16, 14, 10]可以根据根节点的值将其划分为左子树[4, 8, 6], 右子树[12, 16, 14], 根[10], 由于我们是先确定的左子树区间, 因此当右子树区间中出现小于根节点的值时, 序列不合法, 我们再采用分治的思想, 对于每段序列代表的子树, 检查它的左子树和右子树, 当且仅当左右子树都合法时返回true\n\npublic boolean VerifySquenceOfBST(int[] sequence) {\n    if (sequence == null || sequence.length == 0)\n        return false;\n    return verify(sequence, 0, sequence.length - 1);\n}\n\nprivate boolean verify(int[] sequence, int first, int last) {\n    if (last - first <= 1)\n        return true;\n    int rootVal = sequence[last];\n    int cutIndex = first;\n    while (cutIndex < last && sequence[cutIndex] <= rootVal)\n        cutIndex++;\n    for (int i = cutIndex; i < last; i++)\n        if (sequence[i] < rootVal)\n            return false;\n    return verify(sequence, first, cutIndex - 1) && verify(sequence, cutIndex, last - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 34. 二叉树中和为某一值的路径\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n\n下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12\n\n\n\n\n# 解题思路\n\nprivate ArrayList<ArrayList<Integer>> ret = new ArrayList<>();\n\npublic ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {\n    backtracking(root, target, new ArrayList<>());\n    return ret;\n}\n\nprivate void backtracking(TreeNode node, int target, ArrayList<Integer> path) {\n    if (node == null)\n        return;\n    path.add(node.val);\n    target -= node.val;\n  //已经到达叶子节点，并且正好加出了target\n    if (target == 0 && node.left == null && node.right == null) {\n        ret.add(new ArrayList<>(path));\n    } else {\n      //递归左子树\n        backtracking(node.left, target, path);\n      //递归右子树\n        backtracking(node.right, target, path);\n    }\n  //无论当前路径是否加出了target，必须去掉最后一个，然后返回父节点，去查找另一条路径，最终的path肯定为null\n    path.remove(path.size() - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 36. 二叉搜索树与双向链表\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。\n\n\n\n\n# 解题思路\n\nprivate TreeNode pre = null;\nprivate TreeNode head = null;\n\npublic TreeNode Convert(TreeNode root) {\n    inOrder(root);\n    return head;\n}\n\nprivate void inOrder(TreeNode node) {\n    if (node == null)\n        return;\n    inOrder(node.left);\n    node.left = pre;\n    if (pre != null)\n        pre.right = node;\n    pre = node;\n    if (head == null)\n        head = node;\n    inOrder(node.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 37. 序列化二叉树\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n请实现两个函数，分别用来序列化和反序列化二叉树。\n\n\n# 解题思路\n\npublic class SerializeTree {\n\n    int index = -1;\n    /**\n     * 分别遍历左节点和右节点，空使用#代替，节点之间，隔开\n     *\n     * @param root\n     * @return\n     */\n    public String Serialize(TreeNode root) {\n        if (root == null) {\n            return "#";\n        } else {\n            return root.val + "," + Serialize(root.left) + "," + Serialize(root.right);\n        }\n    }\n    /**\n     * 使用index来设置树节点的val值，递归遍历左节点和右节点，如果值是#则表示是空节点，直接返回\n     *\n     * @param str\n     * @return\n     */\n    TreeNode Deserialize(String str) {\n        String[] s = str.split(",");//将序列化之后的序列用，分隔符转化为数组\n        index++;//索引每次加一\n        int len = s.length;\n        if (index > len) {\n            return null;\n        }\n        TreeNode treeNode = null;\n        if (!s[index].equals("#")) {//不是叶子节点 继续走 是叶子节点出递归\n            treeNode = new TreeNode(Integer.parseInt(s[index]));\n            treeNode.left = Deserialize(str);\n            treeNode.right = Deserialize(str);\n        }\n        return treeNode;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 54. 二叉查找树的第 K 个结点\n\nNowCoder(opens new window)\n\n\n# 解题思路\n\n利用二叉查找树中序遍历有序的特点。\n\nprivate TreeNode ret;\nprivate int cnt = 0;\n\npublic TreeNode KthNode(TreeNode pRoot, int k) {\n    inOrder(pRoot, k);\n    return ret;\n}\n\nprivate void inOrder(TreeNode root, int k) {\n    if (root == null || cnt >= k)\n        return;\n    inOrder(root.left, k);\n    cnt++;\n    if (cnt == k)\n        ret = root;\n    inOrder(root.right, k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 55.1 二叉树的深度\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。\n\n\n\n\n# 解题思路\n\npublic int TreeDepth(TreeNode root) {\n    return root == null ? 0 : 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));\n}\n\n\n1\n2\n3\n\n\n\n# 55.2 判断是否是平衡二叉树\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 样例解释：\n\n\n\n样例二叉树如图，为一颗平衡二叉树 注：我们约定空树是平衡二叉树。\n\n\n# 解题思路\n\nprivate boolean isBalanced = true;\n\npublic boolean IsBalanced_Solution(TreeNode root) {\n    height(root);\n    return isBalanced;\n}\n\nprivate int height(TreeNode root) {\n    if (root == null || !isBalanced)\n        return 0;\n    int left = height(root.left);\n    int right = height(root.right);\n    if (Math.abs(left - right) > 1)\n        isBalanced = false;\n    return 1 + Math.max(left, right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',normalizedContent:'# 7. 重建二叉树\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n\n\n\n# 解题思路\n\n前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。\n\n\n\n// 缓存中序遍历数组每个值对应的索引\nprivate map<integer, integer> indexforinorders = new hashmap<>();\n\npublic treenode reconstructbinarytree(int[] pre, int[] in) {\n    for (int i = 0; i < in.length; i++)\n        indexforinorders.put(in[i], i);\n    return reconstructbinarytree(pre, 0, pre.length - 1, 0);\n}\n\nprivate treenode reconstructbinarytree(int[] pre, int prel, int prer, int inl) {\n    if (prel > prer)\n        return null;\n    treenode root = new treenode(pre[prel]);\n    int inindex = indexforinorders.get(root.val);\n    int lefttreesize = inindex - inl;\n    root.left = reconstructbinarytree(pre, prel + 1, prel + lefttreesize, inl);\n    root.right = reconstructbinarytree(pre, prel + lefttreesize + 1, prer, inl + lefttreesize + 1);\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 8. 二叉树的下一个结点\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。\n\npublic class treelinknode {\n\n    int val;\n    treelinknode left = null;\n    treelinknode right = null;\n    treelinknode next = null; // 指向父结点的指针\n\n    treelinknode(int val) {\n        this.val = val;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 解题思路\n\n我们先来回顾一下中序遍历的过程：先遍历树的左子树，再遍历根节点，最后再遍历右子树。所以最左节点是中序遍历的第一个节点。\n\nvoid traverse(treenode root) {\n    if (root == null) return;\n    traverse(root.left);\n    visit(root);\n    traverse(root.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；\n\n\n\n② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。\n\n\n\npublic treelinknode getnext(treelinknode pnode) {\n    if (pnode.right != null) {\n        treelinknode node = pnode.right;\n        while (node.left != null)\n            node = node.left;\n        return node;\n    } else {\n        while (pnode.next != null) {\n            treelinknode parent = pnode.next;\n            if (parent.left == pnode)\n                return parent;\n            pnode = pnode.next;\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 26. 树的子结构\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n输入两棵二叉树a，b，判断b是不是a的子结构。（我们约定空树不是任意一个树的子结构） 假如给定a为{8,8,7,9,2,#,#,#,#,4,7}，b为{8,9,2}，2个树的结构如下，可以看出b是a的子结构\n\n\n\n\n# 解题思路\n\npublic boolean hassubtree(treenode root1, treenode root2) {\n    if (root1 == null || root2 == null)\n        return false;\n    return issubtreewithroot(root1, root2) || hassubtree(root1.left, root2) || hassubtree(root1.right, root2);\n}\n\nprivate boolean issubtreewithroot(treenode root1, treenode root2) {\n    if (root2 == null)\n        return true;\n    if (root1 == null)\n        return false;\n    if (root1.val != root2.val)\n        return false;\n    return issubtreewithroot(root1.left, root2.left) && issubtreewithroot(root1.right, root2.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 27. 二叉树的镜像\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n\n\n\n# 解题思路\n\npublic treenode mirror(treenode root) {\n    if (root == null)\n        return root;\n    swap(root);\n    mirror(root.left);\n    mirror(root.right);\n    return root;\n}\n\nprivate void swap(treenode root) {\n    treenode t = root.left;\n    root.left = root.right;\n    root.right = t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 28. 对称的二叉树\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n给定一棵二叉树，判断其是否是自身的镜像（即：是否对称） 例如： 下面这棵二叉树是对称的 下面这棵二叉树不对称。\n\n\n# 解题思路\n\nboolean issymmetrical(treenode proot) {\n    if (proot == null)\n        return true;\n    return issymmetrical(proot.left, proot.right);\n}\n\nboolean issymmetrical(treenode t1, treenode t2) {\n    if (t1 == null && t2 == null)\n        return true;\n    if (t1 == null || t2 == null)\n        return false;\n    if (t1.val != t2.val)\n        return false;\n    return issymmetrical(t1.left, t2.right) && issymmetrical(t1.right, t2.left);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 32.1 从上往下打印二叉树\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如输入{8,6,10,#,#,2,1}，如以下图中的示例二叉树，则依次打印8,6,10,2,1(空节点不打印，跳过)，请你将打印的结果存放到一个数组里面，返回。\n\n\n\n\n# 解题思路\n\n使用队列来进行层次遍历。\n\n不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。\n\npublic arraylist<integer> printfromtoptobottom(treenode root) {\n    queue<treenode> queue = new linkedlist<>();\n    arraylist<integer> ret = new arraylist<>();\n    queue.add(root);\n    while (!queue.isempty()) {\n        int cnt = queue.size();\n        while (cnt-- > 0) {\n            treenode t = queue.poll();\n            if (t == null)\n                continue;\n            ret.add(t.val);\n            queue.add(t.left);\n            queue.add(t.right);\n        }\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 32.2 把二叉树打印成多行\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n给定一个节点数为 n 二叉树，要求从上到下按层打印二叉树的 val 值，同一层结点从左至右输出，每一层输出一行，将输出的结果存放到一个二维数组中返回。\n\n例如： 给定的二叉树是{1,2,3,#,#,4,5} 该二叉树多行打印层序遍历的结果是\n\n[\n\n[1],\n\n[2,3],\n\n[4,5]\n\n]\n\n\n# 解题思路\n\narraylist<arraylist<integer>> print(treenode proot) {\n    arraylist<arraylist<integer>> ret = new arraylist<>();\n    queue<treenode> queue = new linkedlist<>();\n    queue.add(proot);\n    while (!queue.isempty()) {\n        arraylist<integer> list = new arraylist<>();\n        int cnt = queue.size();\n        while (cnt-- > 0) {\n            treenode node = queue.poll();\n            if (node == null)\n                continue;\n            list.add(node.val);\n            queue.add(node.left);\n            queue.add(node.right);\n        }\n        if (list.size() != 0)\n            ret.add(list);\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 32.3 按之字形顺序打印二叉树\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。\n\n\n# 解题思路\n\npublic arraylist<arraylist<integer>> print(treenode proot) {\n    arraylist<arraylist<integer>> ret = new arraylist<>();\n    queue<treenode> queue = new linkedlist<>();\n    queue.add(proot);\n    boolean reverse = false;\n    while (!queue.isempty()) {\n        arraylist<integer> list = new arraylist<>();\n        int cnt = queue.size();\n        while (cnt-- > 0) {\n            treenode node = queue.poll();\n            if (node == null)\n                continue;\n            list.add(node.val);\n            queue.add(node.left);\n            queue.add(node.right);\n        }\n        if (reverse)\n            collections.reverse(list);\n        reverse = !reverse;\n        if (list.size() != 0)\n            ret.add(list);\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 33. 二叉搜索树的后序遍历序列\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。\n\n例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。\n\n\n\n\n# 解题思路\n\n 1. 二叉树的后序遍历顺序是：左子树 -> 右子树 -> 根节点\n 2. 因此序列的最后一个数代表了根节点\n 3. 因此我们可以将一个序列划分为3段, 左子树+右子树+根, 例如[4, 8, 6, 12, 16, 14, 10]可以根据根节点的值将其划分为左子树[4, 8, 6], 右子树[12, 16, 14], 根[10], 由于我们是先确定的左子树区间, 因此当右子树区间中出现小于根节点的值时, 序列不合法, 我们再采用分治的思想, 对于每段序列代表的子树, 检查它的左子树和右子树, 当且仅当左右子树都合法时返回true\n\npublic boolean verifysquenceofbst(int[] sequence) {\n    if (sequence == null || sequence.length == 0)\n        return false;\n    return verify(sequence, 0, sequence.length - 1);\n}\n\nprivate boolean verify(int[] sequence, int first, int last) {\n    if (last - first <= 1)\n        return true;\n    int rootval = sequence[last];\n    int cutindex = first;\n    while (cutindex < last && sequence[cutindex] <= rootval)\n        cutindex++;\n    for (int i = cutindex; i < last; i++)\n        if (sequence[i] < rootval)\n            return false;\n    return verify(sequence, first, cutindex - 1) && verify(sequence, cutindex, last - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 34. 二叉树中和为某一值的路径\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n\n下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12\n\n\n\n\n# 解题思路\n\nprivate arraylist<arraylist<integer>> ret = new arraylist<>();\n\npublic arraylist<arraylist<integer>> findpath(treenode root, int target) {\n    backtracking(root, target, new arraylist<>());\n    return ret;\n}\n\nprivate void backtracking(treenode node, int target, arraylist<integer> path) {\n    if (node == null)\n        return;\n    path.add(node.val);\n    target -= node.val;\n  //已经到达叶子节点，并且正好加出了target\n    if (target == 0 && node.left == null && node.right == null) {\n        ret.add(new arraylist<>(path));\n    } else {\n      //递归左子树\n        backtracking(node.left, target, path);\n      //递归右子树\n        backtracking(node.right, target, path);\n    }\n  //无论当前路径是否加出了target，必须去掉最后一个，然后返回父节点，去查找另一条路径，最终的path肯定为null\n    path.remove(path.size() - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 36. 二叉搜索树与双向链表\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。\n\n\n\n\n# 解题思路\n\nprivate treenode pre = null;\nprivate treenode head = null;\n\npublic treenode convert(treenode root) {\n    inorder(root);\n    return head;\n}\n\nprivate void inorder(treenode node) {\n    if (node == null)\n        return;\n    inorder(node.left);\n    node.left = pre;\n    if (pre != null)\n        pre.right = node;\n    pre = node;\n    if (head == null)\n        head = node;\n    inorder(node.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 37. 序列化二叉树\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n请实现两个函数，分别用来序列化和反序列化二叉树。\n\n\n# 解题思路\n\npublic class serializetree {\n\n    int index = -1;\n    /**\n     * 分别遍历左节点和右节点，空使用#代替，节点之间，隔开\n     *\n     * @param root\n     * @return\n     */\n    public string serialize(treenode root) {\n        if (root == null) {\n            return "#";\n        } else {\n            return root.val + "," + serialize(root.left) + "," + serialize(root.right);\n        }\n    }\n    /**\n     * 使用index来设置树节点的val值，递归遍历左节点和右节点，如果值是#则表示是空节点，直接返回\n     *\n     * @param str\n     * @return\n     */\n    treenode deserialize(string str) {\n        string[] s = str.split(",");//将序列化之后的序列用，分隔符转化为数组\n        index++;//索引每次加一\n        int len = s.length;\n        if (index > len) {\n            return null;\n        }\n        treenode treenode = null;\n        if (!s[index].equals("#")) {//不是叶子节点 继续走 是叶子节点出递归\n            treenode = new treenode(integer.parseint(s[index]));\n            treenode.left = deserialize(str);\n            treenode.right = deserialize(str);\n        }\n        return treenode;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 54. 二叉查找树的第 k 个结点\n\nnowcoder(opens new window)\n\n\n# 解题思路\n\n利用二叉查找树中序遍历有序的特点。\n\nprivate treenode ret;\nprivate int cnt = 0;\n\npublic treenode kthnode(treenode proot, int k) {\n    inorder(proot, k);\n    return ret;\n}\n\nprivate void inorder(treenode root, int k) {\n    if (root == null || cnt >= k)\n        return;\n    inorder(root.left, k);\n    cnt++;\n    if (cnt == k)\n        ret = root;\n    inorder(root.right, k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 55.1 二叉树的深度\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。\n\n\n\n\n# 解题思路\n\npublic int treedepth(treenode root) {\n    return root == null ? 0 : 1 + math.max(treedepth(root.left), treedepth(root.right));\n}\n\n\n1\n2\n3\n\n\n\n# 55.2 判断是否是平衡二叉树\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 平衡二叉树（balanced binary tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 样例解释：\n\n\n\n样例二叉树如图，为一颗平衡二叉树 注：我们约定空树是平衡二叉树。\n\n\n# 解题思路\n\nprivate boolean isbalanced = true;\n\npublic boolean isbalanced_solution(treenode root) {\n    height(root);\n    return isbalanced;\n}\n\nprivate int height(treenode root) {\n    if (root == null || !isbalanced)\n        return 0;\n    int left = height(root.left);\n    int right = height(root.right);\n    if (math.abs(left - right) > 1)\n        isbalanced = false;\n    return 1 + math.max(left, right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"贪心",frontmatter:{title:"贪心",date:"2022-10-17T22:18:27.000Z",permalink:"/pages/b54770/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/20.%E8%B4%AA%E5%BF%83.html",relativePath:"02.计算机基础/50.剑指Offer题解/20.贪心.md",key:"v-1fc84936",path:"/pages/b54770/",headers:[{level:2,title:"63. 股票的最大利润",slug:"_63-股票的最大利润",normalizedTitle:"63. 股票的最大利润",charIndex:2},{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:93},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:132}],headersStr:"63. 股票的最大利润 题目链接 题目描述 解题思路",content:"# 63. 股票的最大利润\n\n\n# 题目链接\n\nLeetcode：121. Best Time to Buy and Sell Stock (opens new window)\n\n\n# 题目描述\n\n可以有一次买入和一次卖出，买入必须在前。求最大收益。\n\n\n\n\n# 解题思路\n\n使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。因此在遍历数组时记录当前最低的买入价格，并且尝试将每个位置都作为卖出价格，取收益最大的即可。\n\npublic int maxProfit(int[] prices) {\n    if (prices == null || prices.length == 0)\n        return 0;\n    int soFarMin = prices[0];\n    int maxProfit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        soFarMin = Math.min(soFarMin, prices[i]);\n        maxProfit = Math.max(maxProfit, prices[i] - soFarMin);\n    }\n    return maxProfit;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# 63. 股票的最大利润\n\n\n# 题目链接\n\nleetcode：121. best time to buy and sell stock (opens new window)\n\n\n# 题目描述\n\n可以有一次买入和一次卖出，买入必须在前。求最大收益。\n\n\n\n\n# 解题思路\n\n使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。因此在遍历数组时记录当前最低的买入价格，并且尝试将每个位置都作为卖出价格，取收益最大的即可。\n\npublic int maxprofit(int[] prices) {\n    if (prices == null || prices.length == 0)\n        return 0;\n    int sofarmin = prices[0];\n    int maxprofit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        sofarmin = math.min(sofarmin, prices[i]);\n        maxprofit = math.max(maxprofit, prices[i] - sofarmin);\n    }\n    return maxprofit;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"分治",frontmatter:{title:"分治",date:"2022-10-17T22:57:57.000Z",permalink:"/pages/87a843/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/25.%E5%88%86%E6%B2%BB.html",relativePath:"02.计算机基础/50.剑指Offer题解/25.分治.md",key:"v-13bddd54",path:"/pages/87a843/",headers:[{level:2,title:"16. 数值的整数次方",slug:"_16-数值的整数次方",normalizedTitle:"16. 数值的整数次方",charIndex:2},{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:106}],headersStr:"16. 数值的整数次方 题目链接 题目描述 解题思路",content:"# 16. 数值的整数次方\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n给定一个 double 类型的浮点数 x和 int 类型的整数 n，求 x 的 n 次方。\n\n\n# 解题思路\n\n最直观的解法是将 x 重复乘 n 次，xxx...x，那么时间复杂度为 O(N)。因为乘法是可交换的，所以可以将上述操作拆开成两半 (xx..x) (x*x..*x)，两半的计算是一样的，因此只需要计算一次。而且对于新拆开的计算，又可以继续拆开。这就是分治思想，将原问题的规模拆成多个规模较小的子问题，最后子问题的解合并起来。\n\n本题中子问题是 xn/2，在将子问题合并时将子问题的解乘于自身相乘即可。但如果 n 不为偶数，那么拆成两半还会剩下一个 x，在将子问题合并时还需要需要多乘于一个 x。\n\n\n\n因为 (x*x)n/2 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。\n\npublic double Power(double x, int n) {\n    boolean isNegative = false;\n    if (n < 0) {\n        n = -n;\n        isNegative = true;\n    }\n    double res = pow(x, n);\n    return isNegative ? 1 / res : res;\n}\n\nprivate double pow(double x, int n) {\n    if (n == 0) return 1;\n    if (n == 1) return x;\n    double res = pow(x, n / 2);\n    res = res * res;\n    if (n % 2 != 0) res *= x;\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# 16. 数值的整数次方\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n给定一个 double 类型的浮点数 x和 int 类型的整数 n，求 x 的 n 次方。\n\n\n# 解题思路\n\n最直观的解法是将 x 重复乘 n 次，xxx...x，那么时间复杂度为 o(n)。因为乘法是可交换的，所以可以将上述操作拆开成两半 (xx..x) (x*x..*x)，两半的计算是一样的，因此只需要计算一次。而且对于新拆开的计算，又可以继续拆开。这就是分治思想，将原问题的规模拆成多个规模较小的子问题，最后子问题的解合并起来。\n\n本题中子问题是 xn/2，在将子问题合并时将子问题的解乘于自身相乘即可。但如果 n 不为偶数，那么拆成两半还会剩下一个 x，在将子问题合并时还需要需要多乘于一个 x。\n\n\n\n因为 (x*x)n/2 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 o(logn)。\n\npublic double power(double x, int n) {\n    boolean isnegative = false;\n    if (n < 0) {\n        n = -n;\n        isnegative = true;\n    }\n    double res = pow(x, n);\n    return isnegative ? 1 / res : res;\n}\n\nprivate double pow(double x, int n) {\n    if (n == 0) return 1;\n    if (n == 1) return x;\n    double res = pow(x, n / 2);\n    res = res * res;\n    if (n % 2 != 0) res *= x;\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"排序",frontmatter:{title:"排序",date:"2022-10-31T22:45:38.000Z",permalink:"/pages/d3dd7b/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/30.%E6%8E%92%E5%BA%8F.html",relativePath:"02.计算机基础/50.剑指Offer题解/30.排序.md",key:"v-c85da526",path:"/pages/d3dd7b/",headers:[{level:2,title:"21. 调整数组顺序使奇数位于偶数前面",slug:"_21-调整数组顺序使奇数位于偶数前面",normalizedTitle:"21. 调整数组顺序使奇数位于偶数前面",charIndex:2},{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:26},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:58},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:169},{level:2,title:"45. 把数组排成最小的数",slug:"_45-把数组排成最小的数",normalizedTitle:"45. 把数组排成最小的数",charIndex:676},{level:3,title:"题目链接",slug:"题目链接-2",normalizedTitle:"题目链接",charIndex:26},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:58},{level:3,title:"解题思路",slug:"解题思路-2",normalizedTitle:"解题思路",charIndex:169}],headersStr:"21. 调整数组顺序使奇数位于偶数前面 题目链接 题目描述 解题思路 45. 把数组排成最小的数 题目链接 题目描述 解题思路",content:'# 21. 调整数组顺序使奇数位于偶数前面\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。例如对于 [1,2,3,4,5]，调整后得到 [1,3,5,2,4]，而不能是 {5,1,3,4,2} 这种相对位置改变的结果。\n\n\n\n\n# 解题思路\n\n方法一：创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。\n\npublic int[] reOrderArray (int[] nums) {\n    // 奇数个数\n    int oddCnt = 0;\n    for (int x : nums)\n        if (!isEven(x))\n            oddCnt++;\n    int[] copy = nums.clone();\n    int i = 0, j = oddCnt;\n    for (int num : copy) {\n        if (num % 2 == 1)\n            nums[i++] = num;\n        else\n            nums[j++] = num;\n    }\n    return nums;\n}\n\nprivate boolean isEven(int x) {\n    return x % 2 == 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 45. 把数组排成最小的数\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。\n\n\n# 解题思路\n\n可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。\n\npublic String PrintMinNumber(int[] numbers) {\n    if (numbers == null || numbers.length == 0)\n        return "";\n    int n = numbers.length;\n    String[] nums = new String[n];\n    for (int i = 0; i < n; i++)\n        nums[i] = numbers[i] + "";\n    Arrays.sort(nums, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));\n    String ret = "";\n    for (String str : nums)\n        ret += str;\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# 21. 调整数组顺序使奇数位于偶数前面\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。例如对于 [1,2,3,4,5]，调整后得到 [1,3,5,2,4]，而不能是 {5,1,3,4,2} 这种相对位置改变的结果。\n\n\n\n\n# 解题思路\n\n方法一：创建一个新数组，时间复杂度 o(n)，空间复杂度 o(n)。\n\npublic int[] reorderarray (int[] nums) {\n    // 奇数个数\n    int oddcnt = 0;\n    for (int x : nums)\n        if (!iseven(x))\n            oddcnt++;\n    int[] copy = nums.clone();\n    int i = 0, j = oddcnt;\n    for (int num : copy) {\n        if (num % 2 == 1)\n            nums[i++] = num;\n        else\n            nums[j++] = num;\n    }\n    return nums;\n}\n\nprivate boolean iseven(int x) {\n    return x % 2 == 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 45. 把数组排成最小的数\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。\n\n\n# 解题思路\n\n可以看成是一个排序问题，在比较两个字符串 s1 和 s2 的大小时，应该比较的是 s1+s2 和 s2+s1 的大小，如果 s1+s2 < s2+s1，那么应该把 s1 排在前面，否则应该把 s2 排在前面。\n\npublic string printminnumber(int[] numbers) {\n    if (numbers == null || numbers.length == 0)\n        return "";\n    int n = numbers.length;\n    string[] nums = new string[n];\n    for (int i = 0; i < n; i++)\n        nums[i] = numbers[i] + "";\n    arrays.sort(nums, (s1, s2) -> (s1 + s2).compareto(s2 + s1));\n    string ret = "";\n    for (string str : nums)\n        ret += str;\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"动态规划",frontmatter:{title:"动态规划",date:"2022-10-31T22:52:31.000Z",permalink:"/pages/6546a2/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/35.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html",relativePath:"02.计算机基础/50.剑指Offer题解/35.动态规划.md",key:"v-311026d5",path:"/pages/6546a2/",headers:[{level:2,title:"10.1 斐波那契数列",slug:"_10-1-斐波那契数列",normalizedTitle:"10.1 斐波那契数列",charIndex:2},{level:3,title:"题目链接",slug:"题目链接",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:85},{level:2,title:"10.2 矩形覆盖",slug:"_10-2-矩形覆盖",normalizedTitle:"10.2 矩形覆盖",charIndex:820},{level:3,title:"题目链接",slug:"题目链接-2",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-2",normalizedTitle:"解题思路",charIndex:85},{level:2,title:"10.4 变态跳台阶",slug:"_10-4-变态跳台阶",normalizedTitle:"10.4 变态跳台阶",charIndex:1399},{level:3,title:"题目链接",slug:"题目链接-3",normalizedTitle:"题目链接",charIndex:18},{level:3,title:"题目描述",slug:"题目描述-3",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-3",normalizedTitle:"解题思路",charIndex:85},{level:4,title:"动态规划",slug:"动态规划",normalizedTitle:"动态规划",charIndex:204},{level:4,title:"数学推导",slug:"数学推导",normalizedTitle:"数学推导",charIndex:1783},{level:3,title:"题目描述",slug:"题目描述-4",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-4",normalizedTitle:"解题思路",charIndex:85},{level:3,title:"题目描述",slug:"题目描述-5",normalizedTitle:"题目描述",charIndex:50},{level:3,title:"解题思路",slug:"解题思路-5",normalizedTitle:"解题思路",charIndex:85}],headersStr:"10.1 斐波那契数列 题目链接 题目描述 解题思路 10.2 矩形覆盖 题目链接 题目描述 解题思路 10.4 变态跳台阶 题目链接 题目描述 解题思路 动态规划 数学推导 题目描述 解题思路 题目描述 解题思路",content:"# 10.1 斐波那契数列\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n求斐波那契数列的第 n 项，n <= 39。\n\n\n\n\n# 解题思路\n\n如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。\n\n\n\n递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。\n\npublic int Fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    int[] fib = new int[n + 1];\n    fib[1] = 1;\n    for (int i = 2; i <= n; i++)\n        fib[i] = fib[i - 1] + fib[i - 2];\n    return fib[n];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。\n\npublic int Fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    int pre2 = 0, pre1 = 1;\n    int fib = 0;\n    for (int i = 2; i <= n; i++) {\n        fib = pre2 + pre1;\n        pre2 = pre1;\n        pre1 = fib;\n    }\n    return fib;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 10.2 矩形覆盖\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？\n\n\n\n\n# 解题思路\n\n当 n 为 1 时，只有一种覆盖方法：\n\n\n\n当 n 为 2 时，有两种覆盖方法：\n\n\n\n要覆盖 2n 的大矩形，可以先覆盖 21 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 22 的矩形，再覆盖 2(n-2) 的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：\n\n\n\npublic int rectCover(int n) {\n    if (n <= 2)\n        return n;\n    int pre2 = 1, pre1 = 2;\n    int result = 0;\n    for (int i = 3; i <= n; i++) {\n        result = pre2 + pre1;\n        pre2 = pre1;\n        pre1 = result;\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 10.4 变态跳台阶\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n\n\n\n# 解题思路\n\n# 动态规划\n\npublic int jumpFloorII(int target) {\n    int[] dp = new int[target];\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < target; i++)\n        for (int j = 0; j < i; j++)\n            dp[i] += dp[j];\n    return dp[target - 1];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 数学推导\n\n跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么\n\nf(n-1) = f(n-2) + f(n-3) + ... + f(0)\n\n\n1\n\n\n同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么\n\nf(n) = f(n-1) + f(n-2) + ... + f(0)\n\n\n1\n\n\n综上可得\n\nf(n) - f(n-1) = f(n-1)\n\n\n1\n\n\n即\n\nf(n) = 2*f(n-1)\n\n\n1\n\n\n所以 f(n) 是一个等比数列\n\npublic int JumpFloorII(int target) {\n    return (int) Math.pow(2, target - 1);\n}\n\n\n1\n2\n3\n\n\n\n# 42. 连续子数组的最大和\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。\n\n\n# 解题思路\n\npublic int FindGreatestSumOfSubArray(int[] array) {\n        int[] dp = new int[array.length];\n        int max = array[0];\n        dp[0] = array[0];\n        for(int i=1;i<array.length;i++){\n            // 动态规划，状态转移方程，确定dp[i]的最大值\n            dp[i] = Math.max(dp[i-1] + array[i], array[i]);\n            // 每次比较，保存出现的最大值\n            max = Math.max(max,dp[i]);\n        }\n        return max;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 47. 礼物的最大价值\n\nNowCoder(opens new window)\n\n\n# 题目描述\n\n在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘\n\n1    10   3    8\n12   2    9    6\n5    7    4    11\n3    7    16   5\n\n\n1\n2\n3\n4\n\n\n礼物的最大价值为 1+12+5+7+7+16+5=53。\n\n\n# 解题思路\n\n应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。\n\nimport java.util.*;\n\npublic class Bonus {\n    public int getMost(int[][] board) {\n        \n\t\tif(board == null || board.length==0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<board.length;i++){\n\t\t\tfor (int j = 0; j < board[0].length; j++) {\n\t\t\t\tif(i==0 && j==0){\n\t\t\t\t\t// 奖金就是第一个格子本身\n\t\t\t\t}else if(i==0){\n\t\t\t\t\t// 说明在第一行   第一行的奖金只能来自第一行左边的格子\n                    // 奖金等于当前格子的奖金加上左边格子的奖金\n\t\t\t\t\tboard[0][j] += board[0][j-1];\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t}else if(j==0){\n\t\t\t\t\t// 说明在第一列   第一列的奖金只能来自列的上面个格子\n                    // 奖金等于当前格子的奖金加上上面格子的奖金\n\t\t\t\t\tboard[i][0] += board[i-1][0];\t\t\t\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\t// 来自上面或者左边的格子，选取最大奖金的。\n                    // 最大奖金等于当前格子奖金加上左边或上面格子中奖金数大的那个\n\t\t\t\t\tboard[i][j] +=Math.max(board[i][j-1],board[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 增加通用型，直接用数据的长度吧\n\t\treturn board[board.length-1][board[0].length-1];\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",normalizedContent:"# 10.1 斐波那契数列\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n求斐波那契数列的第 n 项，n <= 39。\n\n\n\n\n# 解题思路\n\n如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。\n\n\n\n递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。\n\npublic int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    int[] fib = new int[n + 1];\n    fib[1] = 1;\n    for (int i = 2; i <= n; i++)\n        fib[i] = fib[i - 1] + fib[i - 2];\n    return fib[n];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 o(n) 降低为 o(1)。\n\npublic int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    int pre2 = 0, pre1 = 1;\n    int fib = 0;\n    for (int i = 2; i <= n; i++) {\n        fib = pre2 + pre1;\n        pre2 = pre1;\n        pre1 = fib;\n    }\n    return fib;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 10.2 矩形覆盖\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？\n\n\n\n\n# 解题思路\n\n当 n 为 1 时，只有一种覆盖方法：\n\n\n\n当 n 为 2 时，有两种覆盖方法：\n\n\n\n要覆盖 2n 的大矩形，可以先覆盖 21 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 22 的矩形，再覆盖 2(n-2) 的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：\n\n\n\npublic int rectcover(int n) {\n    if (n <= 2)\n        return n;\n    int pre2 = 1, pre1 = 2;\n    int result = 0;\n    for (int i = 3; i <= n; i++) {\n        result = pre2 + pre1;\n        pre2 = pre1;\n        pre1 = result;\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 10.4 变态跳台阶\n\n\n# 题目链接\n\n牛客网(opens new window)\n\n\n# 题目描述\n\n一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n\n\n\n# 解题思路\n\n# 动态规划\n\npublic int jumpfloorii(int target) {\n    int[] dp = new int[target];\n    arrays.fill(dp, 1);\n    for (int i = 1; i < target; i++)\n        for (int j = 0; j < i; j++)\n            dp[i] += dp[j];\n    return dp[target - 1];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 数学推导\n\n跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么\n\nf(n-1) = f(n-2) + f(n-3) + ... + f(0)\n\n\n1\n\n\n同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么\n\nf(n) = f(n-1) + f(n-2) + ... + f(0)\n\n\n1\n\n\n综上可得\n\nf(n) - f(n-1) = f(n-1)\n\n\n1\n\n\n即\n\nf(n) = 2*f(n-1)\n\n\n1\n\n\n所以 f(n) 是一个等比数列\n\npublic int jumpfloorii(int target) {\n    return (int) math.pow(2, target - 1);\n}\n\n\n1\n2\n3\n\n\n\n# 42. 连续子数组的最大和\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。\n\n\n# 解题思路\n\npublic int findgreatestsumofsubarray(int[] array) {\n        int[] dp = new int[array.length];\n        int max = array[0];\n        dp[0] = array[0];\n        for(int i=1;i<array.length;i++){\n            // 动态规划，状态转移方程，确定dp[i]的最大值\n            dp[i] = math.max(dp[i-1] + array[i], array[i]);\n            // 每次比较，保存出现的最大值\n            max = math.max(max,dp[i]);\n        }\n        return max;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 47. 礼物的最大价值\n\nnowcoder(opens new window)\n\n\n# 题目描述\n\n在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘\n\n1    10   3    8\n12   2    9    6\n5    7    4    11\n3    7    16   5\n\n\n1\n2\n3\n4\n\n\n礼物的最大价值为 1+12+5+7+7+16+5=53。\n\n\n# 解题思路\n\n应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。\n\nimport java.util.*;\n\npublic class bonus {\n    public int getmost(int[][] board) {\n        \n\t\tif(board == null || board.length==0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<board.length;i++){\n\t\t\tfor (int j = 0; j < board[0].length; j++) {\n\t\t\t\tif(i==0 && j==0){\n\t\t\t\t\t// 奖金就是第一个格子本身\n\t\t\t\t}else if(i==0){\n\t\t\t\t\t// 说明在第一行   第一行的奖金只能来自第一行左边的格子\n                    // 奖金等于当前格子的奖金加上左边格子的奖金\n\t\t\t\t\tboard[0][j] += board[0][j-1];\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t}else if(j==0){\n\t\t\t\t\t// 说明在第一列   第一列的奖金只能来自列的上面个格子\n                    // 奖金等于当前格子的奖金加上上面格子的奖金\n\t\t\t\t\tboard[i][0] += board[i-1][0];\t\t\t\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\t// 来自上面或者左边的格子，选取最大奖金的。\n                    // 最大奖金等于当前格子奖金加上左边或上面格子中奖金数大的那个\n\t\t\t\t\tboard[i][j] +=math.max(board[i][j-1],board[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 增加通用型，直接用数据的长度吧\n\t\treturn board[board.length-1][board[0].length-1];\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"数学",frontmatter:{title:"数学",date:"2022-11-01T23:22:36.000Z",permalink:"/pages/9c176f/",categories:["计算机基础","剑指Offer题解"],tags:[null]},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/50.%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/40.%E6%95%B0%E5%AD%A6.html",relativePath:"02.计算机基础/50.剑指Offer题解/40.数学.md",key:"v-25d809ae",path:"/pages/9c176f/",headers:[{level:2,title:"39. 数组中出现次数超过一半的数字",slug:"_39-数组中出现次数超过一半的数字",normalizedTitle:"39. 数组中出现次数超过一半的数字",charIndex:2},{level:3,title:"解题思路",slug:"解题思路",normalizedTitle:"解题思路",charIndex:53}],headersStr:"39. 数组中出现次数超过一半的数字 解题思路",content:"# 39. 数组中出现次数超过一半的数字\n\nNowCoder(opens new window)\n\n\n# 解题思路\n\n想象一下，如果把这些数字当做人种，一个数字和另外一个数字打了起来，同归于尽。最后剩下的是不是人数最多的那种人。这里要满足一个条件：某类人的数目一定要大于总人数的一半。\n\n算法步骤：我们选择输入数组中第一个元素作为候选元素candidate，并设置其出现次数为count=1。随后遍历数组。当遇到与candidate相同的元素，count+1;不同的元素，count-1。当count为0的时候，选择下一个元素为候选元素，并且置count=1。遍历到数组的最后，剩下的candidate就是要求的结果。\n\nint MoreThanHalfNum_Solution(vector<int> &numbers) {\n    int candidate = numbers[0];\n    int count = 1;\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] == candidate) {\n            count++;\n        } else {\n            count--;\n        }\n        if (count == 0) {\n            candidate = numbers[i + 1];\n            count++;\n        }\n    }\n    return candidate;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# 39. 数组中出现次数超过一半的数字\n\nnowcoder(opens new window)\n\n\n# 解题思路\n\n想象一下，如果把这些数字当做人种，一个数字和另外一个数字打了起来，同归于尽。最后剩下的是不是人数最多的那种人。这里要满足一个条件：某类人的数目一定要大于总人数的一半。\n\n算法步骤：我们选择输入数组中第一个元素作为候选元素candidate，并设置其出现次数为count=1。随后遍历数组。当遇到与candidate相同的元素，count+1;不同的元素，count-1。当count为0的时候，选择下一个元素为候选元素，并且置count=1。遍历到数组的最后，剩下的candidate就是要求的结果。\n\nint morethanhalfnum_solution(vector<int> &numbers) {\n    int candidate = numbers[0];\n    int count = 1;\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] == candidate) {\n            count++;\n        } else {\n            count--;\n        }\n        if (count == 0) {\n            candidate = numbers[i + 1];\n            count++;\n        }\n    }\n    return candidate;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"聚簇索引和非聚簇索引有什么区别？",frontmatter:{title:"聚簇索引和非聚簇索引有什么区别？",date:"2022-05-21T17:08:04.000Z",permalink:"/pages/a5adb0/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/006.%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/006.聚簇索引和非聚簇索引有什么区别？.md",key:"v-f0f711c4",path:"/pages/a5adb0/",headers:[{level:2,title:"聚簇索引",slug:"聚簇索引",normalizedTitle:"聚簇索引",charIndex:2},{level:2,title:"非聚簇索引",slug:"非聚簇索引",normalizedTitle:"非聚簇索引",charIndex:119}],headersStr:"聚簇索引 非聚簇索引",content:"# 聚簇索引\n\n * 对应Innodb引擎中的主键索引\n * 索引的叶节点就是数据节点 -正式聚簇索引的顺序就是数据的物理存储顺序，所以一个表最多只能有一个聚簇索引，因为物理存储只能有一个顺序。正因为一个表最多只能有一个聚簇索引\n\n\n# 非聚簇索引\n\n * 对应MyISAM\n * 非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n\n",normalizedContent:"# 聚簇索引\n\n * 对应innodb引擎中的主键索引\n * 索引的叶节点就是数据节点 -正式聚簇索引的顺序就是数据的物理存储顺序，所以一个表最多只能有一个聚簇索引，因为物理存储只能有一个顺序。正因为一个表最多只能有一个聚簇索引\n\n\n# 非聚簇索引\n\n * 对应myisam\n * 非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 MySQL 常见索引类型，介绍一下覆盖索引",frontmatter:{title:"简述 MySQL 常见索引类型，介绍一下覆盖索引",date:"2022-05-21T17:08:24.000Z",permalink:"/pages/17b014/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/007.%E7%AE%80%E8%BF%B0%20MySQL%20%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.html",relativePath:"03.数据库/01.MYSQL相关/007.简述 MySQL 常见索引类型，介绍一下覆盖索引.md",key:"v-824b776c",path:"/pages/17b014/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"MySQL中 InnoDB 和 MylSAM 的区别是什么？",frontmatter:{title:"MySQL中 InnoDB 和 MylSAM 的区别是什么？",date:"2022-05-21T17:07:47.000Z",permalink:"/pages/3a8659/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/001.MySQL%E4%B8%AD%20InnoDB%20%E5%92%8C%20MylSAM%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/001.MySQL中 InnoDB 和 MylSAM 的区别是什么？.md",key:"v-674454ac",path:"/pages/3a8659/",headers:[{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:37},{level:2,title:"场景选择",slug:"场景选择",normalizedTitle:"场景选择",charIndex:253}],headersStr:"区别 场景选择",content:"MySQL5.5版本开始Innodb已经成为Mysql的默认引擎\n\n\n# 区别\n\n * InnoDB 支持事务，MyISAM 不支持事务。 这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一\n * MyISAM锁的粒度是表级的，而InnoDB支持行级锁\n * MyISAM支持全文类型索引，而InnoDB不支持全文索引\n * MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM\n * MyISAM表保存成文件形式，跨平台使用更加方便\n\n\n# 场景选择\n\nMyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB",normalizedContent:"mysql5.5版本开始innodb已经成为mysql的默认引擎\n\n\n# 区别\n\n * innodb 支持事务，myisam 不支持事务。 这是 mysql 将默认存储引擎从 myisam 变成 innodb 的重要原因之一\n * myisam锁的粒度是表级的，而innodb支持行级锁\n * myisam支持全文类型索引，而innodb不支持全文索引\n * myisam相对简单，效率上要优于innodb，小型应用可以考虑使用myisam\n * myisam表保存成文件形式，跨平台使用更加方便\n\n\n# 场景选择\n\nmyisam管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择myisam innodb用于事务处理，具有acid事务支持等特性，如果在应用中执行大量insert和update操作，应该选择innodb",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么",frontmatter:{title:"MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么",date:"2022-05-21T17:05:11.000Z",permalink:"/pages/bc5538/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/020.MySQL%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20B+%20%E6%A0%91%E6%9D%A5%E4%BD%9C%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%AF%B9%E6%AF%94%20B%20%E6%A0%91%E5%AE%83%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88.html",relativePath:"03.数据库/01.MYSQL相关/020.MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么.md",key:"v-6c681639",path:"/pages/bc5538/",headers:[{level:2,title:"磁盘存取原理",slug:"磁盘存取原理",normalizedTitle:"磁盘存取原理",charIndex:59},{level:2,title:"B-/+Tree索引的性能分析",slug:"b-tree索引的性能分析",normalizedTitle:"b-/+tree索引的性能分析",charIndex:246}],headersStr:"磁盘存取原理 B-/+Tree索引的性能分析",content:"> 索引本身也是以文件的形式存储在磁盘上，索引查找过程中存在I/O消耗，采用B tree结构可以减少I/O。\n\n\n# 磁盘存取原理\n\n> 局部性原理与磁盘预读：当一个数据被用到时，其附近的数据也很快会被用到。 预读的长度一般为页的整数倍，主存和磁盘以页为单位交换数据。\n\n磁盘和磁头构成了存取物理结构。同心圆环是磁道，磁道被划分成一个个段，叫扇区，扇区是最小存储单元。 i/o读取数据的过程：磁盘旋转到指定扇区，磁头移动到指定磁道。 所以减少磁盘旋转或者减少磁头移动就能减少i/o。\n\n\n# B-/+Tree索引的性能分析\n\nB Tree利用局部性原理可减少i/o次数。 根据B Tree定义可知，检索一次最多需要访问h个节点，h-1次i/o，h是树高，mysql设计者巧妙的将一个节点大小设置为等于一个页大小，每次新建节点都申请一个页的空间，这样就保证一个节点物理上也存储在一个页，这样每个节点只需要一次i/o就可以完全载入。",normalizedContent:"> 索引本身也是以文件的形式存储在磁盘上，索引查找过程中存在i/o消耗，采用b tree结构可以减少i/o。\n\n\n# 磁盘存取原理\n\n> 局部性原理与磁盘预读：当一个数据被用到时，其附近的数据也很快会被用到。 预读的长度一般为页的整数倍，主存和磁盘以页为单位交换数据。\n\n磁盘和磁头构成了存取物理结构。同心圆环是磁道，磁道被划分成一个个段，叫扇区，扇区是最小存储单元。 i/o读取数据的过程：磁盘旋转到指定扇区，磁头移动到指定磁道。 所以减少磁盘旋转或者减少磁头移动就能减少i/o。\n\n\n# b-/+tree索引的性能分析\n\nb tree利用局部性原理可减少i/o次数。 根据b tree定义可知，检索一次最多需要访问h个节点，h-1次i/o，h是树高，mysql设计者巧妙的将一个节点大小设置为等于一个页大小，每次新建节点都申请一个页的空间，这样就保证一个节点物理上也存储在一个页，这样每个节点只需要一次i/o就可以完全载入。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述Mysql的事务隔离级别",frontmatter:{title:"简述Mysql的事务隔离级别",date:"2022-05-20T11:35:30.000Z",permalink:"/pages/9f2936/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/010.%E7%AE%80%E8%BF%B0Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html",relativePath:"03.数据库/01.MYSQL相关/010.简述Mysql的事务隔离级别.md",key:"v-7e02c4a1",path:"/pages/9f2936/",headers:[{level:2,title:"READ UNCOMMITTED (未提交读)",slug:"read-uncommitted-未提交读",normalizedTitle:"read uncommitted (未提交读)",charIndex:2},{level:2,title:"READ COMMITTED (提交读)",slug:"read-committed-提交读",normalizedTitle:"read committed (提交读)",charIndex:55},{level:2,title:"REPEATABLE READ (可重复读)",slug:"repeatable-read-可重复读",normalizedTitle:"repeatable read (可重复读)",charIndex:117},{level:2,title:"SERIALIZABLE (可串行化)",slug:"serializable-可串行化",normalizedTitle:"serializable (可串行化)",charIndex:168}],headersStr:"READ UNCOMMITTED (未提交读) READ COMMITTED (提交读) REPEATABLE READ (可重复读) SERIALIZABLE (可串行化)",content:"# READ UNCOMMITTED (未提交读)\n\n存在脏读问题 存在不可重复读问题 存在幻读问题\n\n\n# READ COMMITTED (提交读)\n\n只读已经事物提交的数据，不存在脏读。 存在不可重复读问题 存在幻读问题\n\n\n# REPEATABLE READ (可重复读)\n\n是mysql默认的隔离级别 mvcc解决幻读\n\n\n# SERIALIZABLE (可串行化)\n\n读写串行化，效率太低，没人使用。",normalizedContent:"# read uncommitted (未提交读)\n\n存在脏读问题 存在不可重复读问题 存在幻读问题\n\n\n# read committed (提交读)\n\n只读已经事物提交的数据，不存在脏读。 存在不可重复读问题 存在幻读问题\n\n\n# repeatable read (可重复读)\n\n是mysql默认的隔离级别 mvcc解决幻读\n\n\n# serializable (可串行化)\n\n读写串行化，效率太低，没人使用。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"说一下Mysql锁",frontmatter:{title:"说一下Mysql锁",date:"2022-05-21T22:59:15.000Z",permalink:"/pages/b17e88/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/015.%E8%AF%B4%E4%B8%80%E4%B8%8BMysql%E9%94%81.html",relativePath:"03.数据库/01.MYSQL相关/015.说一下Mysql锁.md",key:"v-5b0e09c6",path:"/pages/b17e88/",headers:[{level:2,title:"锁类型",slug:"锁类型",normalizedTitle:"锁类型",charIndex:2},{level:2,title:"Record lock、gap lock、next-key lock",slug:"record-lock、gap-lock、next-key-lock",normalizedTitle:"record lock、gap lock、next-key lock",charIndex:1049},{level:2,title:"锁都加在哪些资源上",slug:"锁都加在哪些资源上",normalizedTitle:"锁都加在哪些资源上",charIndex:1599},{level:2,title:"4.4 各种条件下的加锁",slug:"_4-4-各种条件下的加锁",normalizedTitle:"4.4 各种条件下的加锁",charIndex:1867}],headersStr:"锁类型 Record lock、gap lock、next-key lock 锁都加在哪些资源上 4.4 各种条件下的加锁",content:"# 锁类型\n\n * 共享锁（S）:锁住一行，阻止其他事物获得相同数据集的排他锁\n * 排他锁（X）:锁住一行，阻止其他事物获得相同数据集的共享锁和排他锁\n\n为了实现表锁和行锁共存，InnoDB内部还使用了意向锁，这两种意向锁都是表锁。\n\n * 意向共享锁（IS）:获得数据行的S锁前要先获得表的IS锁\n * 意向排他锁（IX）:获得数据行的X锁前要先获得表的IX锁\n\n兼容矩阵\n\n项目   X    IX   S    IS\nX    冲突   冲突   冲突   冲突\nIX   冲突        冲突   \nS    冲突   冲突        \nIS   冲突             \n\n为什么要使用意向锁？ 在没有意向锁情况下，事物T1申请了行排他锁，如果事物T2要申请表排他锁，就要遍历表的所有锁看有没有行排他锁，这是耗费性能的。有了意向锁，判断是否有意向排他锁就可以了。\n\n意向共享锁可以多个并存，意向排他锁只能有一个。\n\n在兼容矩阵中，为什么IX和IX是兼容的？ 因为IX存在的条件是表中有行拍他锁，IX存在的目的是阻止其他事物申请表排他锁，但是不组织其他事物申请行排他锁。 所以，当表中存在IX锁，在申请行排他锁时，会先申请IX锁并且申请成功 但是如果申请表排他锁则申请失败。\n\n什么SQL加什么锁？ 意向锁是InnoDB自动加的，无需用户干预。 update、delete、insert，InnoDB自动加排他锁。 非显式加锁的select，InnoDB不会加锁。\n\nselect加锁： 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。\n\ninsert加锁： insert会在insert所在行加排他锁，这是一个record lock。 不过，在insert之前会先加一种锁，官方称为insertion intention gap lock，也就是意向gap锁。意向gap锁可以同时存在多个，两个事物可以给相同的gap加意向gap锁，只要插入的记录唯一键不同，两个事物的insert都会成功。 为什么需要意向gap锁？ （个人理解）如果没有意向gap锁，insert时需要对比所有未提交的insert记录，看是不是唯一键冲突。有gap锁，则只需要和获得这个gap锁的事务比较唯一键。\n\n\n# Record lock、gap lock、next-key lock\n\n三种类型的排他锁，锁定数据范围不同： Record lock:只锁一行数据，按唯一键加锁 gap lock：锁住两个索引之间的间隙，但不包含记录本身 只有两种情况才有单纯的gap锁： next-key lock：Record lock+gap lock。\n\n举个例子来看这三种排他锁.如下表，id为PK。\n\nID   NAME\n10   a\n20   b\n50   c\n\nRecord Lock：select * from tab where id = 10 for update; //对id=10单行进行加锁 Gap Lock锁范围：（- ∞，10）（10，20）（20，50）（50，+∞） Next-Key Lock锁范围：（- ∞，10）[10，20）[20，50）[50，+∞）\n\n只有两种场景会有单纯的gap lock:\n\n * update t set name ='d' where id > 60; 锁定 (60,+∞),这里只有gap锁，没有索引本身的锁。\n * update t set name ='d' where id < 1; 锁定 (- ∞,1),这里只有gap锁，没有索引本身的锁。\n\n\n# 锁都加在哪些资源上\n\n * 表\n * 索引（主键索引、唯一索引、普通索引）\n * 索引之间的gap\n\n为什么任何session都insert不进去？ 可能是，表数据少，有一个事物在执行update时全表扫描，把表锁住了。\n\n这种逻辑：先select再update，有什么问题？ select是快照读，update是当前读，可能会出现幻读导致数据不一致。 解决办法：\n\n * 乐观锁 update set version=v+1 where version=v\n * 悲观锁 select * from t for update\n\n\n# 4.4 各种条件下的加锁\n\n给定SQL：delete from t1 where id = 10; 那么，当前的事物隔离级别RC、RR。id的索引情况。有如下讨论：\n\n-      RC                                                                                                                                         RR\n主键索引   [外链图片转存中...(img-vkCidSBQ-1653142673824)]只需要将主键上，id =                                                                                       [外链图片转存中...(img-IznzsLkw-1653142673825)]只需要将主键上，id =\n       10的记录加上X锁即可                                                                                                                                10的记录加上X锁即可\n唯一索引   [外链图片转存中...(img-I8ESnpgb-1653142673825)]此组合中，id是unique索引，而主键是name列。首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name   [外链图片转存中...(img-ULIYfRJG-1653142673826)]此组合中，id是unique索引，而主键是name列。首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name\n       = ‘d’ 对应的主键索引项加X锁。                                                                                                                         = ‘d’ 对应的主键索引项加X锁。\n普通索引   [外链图片转存中...(img-LMDZXlly-1653142673826)]id列索引上，满足id =                                                                                      [外链图片转存中...(img-KS9pBMEu-1653142673827)]与左图的唯一不同在于：在主键上加了gap锁。\n       10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁\n非索引    [外链图片转存中...(img-RmaEu3Nd-1653142673827)]进行全部扫描。聚簇索引上所有的记录，都被加上了X锁                                                                          [外链图片转存中...(img-cffdiN3C-1653142673827)]全表记录加X锁，聚簇索引的每个gap都加gap锁",normalizedContent:"# 锁类型\n\n * 共享锁（s）:锁住一行，阻止其他事物获得相同数据集的排他锁\n * 排他锁（x）:锁住一行，阻止其他事物获得相同数据集的共享锁和排他锁\n\n为了实现表锁和行锁共存，innodb内部还使用了意向锁，这两种意向锁都是表锁。\n\n * 意向共享锁（is）:获得数据行的s锁前要先获得表的is锁\n * 意向排他锁（ix）:获得数据行的x锁前要先获得表的ix锁\n\n兼容矩阵\n\n项目   x    ix   s    is\nx    冲突   冲突   冲突   冲突\nix   冲突        冲突   \ns    冲突   冲突        \nis   冲突             \n\n为什么要使用意向锁？ 在没有意向锁情况下，事物t1申请了行排他锁，如果事物t2要申请表排他锁，就要遍历表的所有锁看有没有行排他锁，这是耗费性能的。有了意向锁，判断是否有意向排他锁就可以了。\n\n意向共享锁可以多个并存，意向排他锁只能有一个。\n\n在兼容矩阵中，为什么ix和ix是兼容的？ 因为ix存在的条件是表中有行拍他锁，ix存在的目的是阻止其他事物申请表排他锁，但是不组织其他事物申请行排他锁。 所以，当表中存在ix锁，在申请行排他锁时，会先申请ix锁并且申请成功 但是如果申请表排他锁则申请失败。\n\n什么sql加什么锁？ 意向锁是innodb自动加的，无需用户干预。 update、delete、insert，innodb自动加排他锁。 非显式加锁的select，innodb不会加锁。\n\nselect加锁： 共享锁（s）：select * from table_name where ... lock in share mode。 排他锁（x)：select * from table_name where ... for update。\n\ninsert加锁： insert会在insert所在行加排他锁，这是一个record lock。 不过，在insert之前会先加一种锁，官方称为insertion intention gap lock，也就是意向gap锁。意向gap锁可以同时存在多个，两个事物可以给相同的gap加意向gap锁，只要插入的记录唯一键不同，两个事物的insert都会成功。 为什么需要意向gap锁？ （个人理解）如果没有意向gap锁，insert时需要对比所有未提交的insert记录，看是不是唯一键冲突。有gap锁，则只需要和获得这个gap锁的事务比较唯一键。\n\n\n# record lock、gap lock、next-key lock\n\n三种类型的排他锁，锁定数据范围不同： record lock:只锁一行数据，按唯一键加锁 gap lock：锁住两个索引之间的间隙，但不包含记录本身 只有两种情况才有单纯的gap锁： next-key lock：record lock+gap lock。\n\n举个例子来看这三种排他锁.如下表，id为pk。\n\nid   name\n10   a\n20   b\n50   c\n\nrecord lock：select * from tab where id = 10 for update; //对id=10单行进行加锁 gap lock锁范围：（- ∞，10）（10，20）（20，50）（50，+∞） next-key lock锁范围：（- ∞，10）[10，20）[20，50）[50，+∞）\n\n只有两种场景会有单纯的gap lock:\n\n * update t set name ='d' where id > 60; 锁定 (60,+∞),这里只有gap锁，没有索引本身的锁。\n * update t set name ='d' where id < 1; 锁定 (- ∞,1),这里只有gap锁，没有索引本身的锁。\n\n\n# 锁都加在哪些资源上\n\n * 表\n * 索引（主键索引、唯一索引、普通索引）\n * 索引之间的gap\n\n为什么任何session都insert不进去？ 可能是，表数据少，有一个事物在执行update时全表扫描，把表锁住了。\n\n这种逻辑：先select再update，有什么问题？ select是快照读，update是当前读，可能会出现幻读导致数据不一致。 解决办法：\n\n * 乐观锁 update set version=v+1 where version=v\n * 悲观锁 select * from t for update\n\n\n# 4.4 各种条件下的加锁\n\n给定sql：delete from t1 where id = 10; 那么，当前的事物隔离级别rc、rr。id的索引情况。有如下讨论：\n\n-      rc                                                                                                                                         rr\n主键索引   [外链图片转存中...(img-vkcidsbq-1653142673824)]只需要将主键上，id =                                                                                       [外链图片转存中...(img-iznzslkw-1653142673825)]只需要将主键上，id =\n       10的记录加上x锁即可                                                                                                                                10的记录加上x锁即可\n唯一索引   [外链图片转存中...(img-i8esnpgb-1653142673825)]此组合中，id是unique索引，而主键是name列。首先会将unique索引上的id=10索引记录加上x锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name   [外链图片转存中...(img-uliyfrjg-1653142673826)]此组合中，id是unique索引，而主键是name列。首先会将unique索引上的id=10索引记录加上x锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name\n       = ‘d’ 对应的主键索引项加x锁。                                                                                                                         = ‘d’ 对应的主键索引项加x锁。\n普通索引   [外链图片转存中...(img-lmdzxlly-1653142673826)]id列索引上，满足id =                                                                                      [外链图片转存中...(img-ks9pbmeu-1653142673827)]与左图的唯一不同在于：在主键上加了gap锁。\n       10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁\n非索引    [外链图片转存中...(img-rmaeu3nd-1653142673827)]进行全部扫描。聚簇索引上所有的记录，都被加上了x锁                                                                          [外链图片转存中...(img-cffdin3c-1653142673827)]全表记录加x锁，聚簇索引的每个gap都加gap锁",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述乐观锁以及悲观锁的区别以及使用场景",frontmatter:{title:"简述乐观锁以及悲观锁的区别以及使用场景",date:"2022-05-21T17:05:33.000Z",permalink:"/pages/57561d/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/030.%E7%AE%80%E8%BF%B0%E4%B9%90%E8%A7%82%E9%94%81%E4%BB%A5%E5%8F%8A%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"03.数据库/01.MYSQL相关/030.简述乐观锁以及悲观锁的区别以及使用场景.md",key:"v-c39c4fe2",path:"/pages/57561d/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述什么是最左匹配原则",frontmatter:{title:"简述什么是最左匹配原则",date:"2022-05-21T17:06:10.000Z",permalink:"/pages/7a1f1e/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/050.%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99.html",relativePath:"03.数据库/01.MYSQL相关/050.简述什么是最左匹配原则.md",key:"v-4ecddbec",path:"/pages/7a1f1e/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？",frontmatter:{title:"简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？",date:"2022-05-21T17:05:55.000Z",permalink:"/pages/36672c/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/040.%E7%AE%80%E8%BF%B0%E8%84%8F%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8F%91%E7%94%9F%E5%9C%BA%E6%99%AF%EF%BC%8CInnoDB%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/040.简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？.md",key:"v-689e142a",path:"/pages/36672c/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"MySQL 联合索引底层原理是什么？",frontmatter:{title:"MySQL 联合索引底层原理是什么？",date:"2022-05-21T17:06:26.000Z",permalink:"/pages/52773a/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/060.MySQL%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/060.MySQL 联合索引底层原理是什么？.md",key:"v-505fbe2e",path:"/pages/52773a/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"产生死锁的必要条件有哪些？如何解决死锁？",frontmatter:{title:"产生死锁的必要条件有哪些？如何解决死锁？",date:"2022-05-21T17:06:48.000Z",permalink:"/pages/f4cf50/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/070.%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/070.产生死锁的必要条件有哪些？如何解决死锁？.md",key:"v-0dd47f09",path:"/pages/f4cf50/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述常见的负载均衡算法",frontmatter:{title:"简述常见的负载均衡算法",date:"2022-05-21T17:07:07.000Z",permalink:"/pages/f2dbbe/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/080.%E7%AE%80%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95.html",relativePath:"03.数据库/01.MYSQL相关/080.简述常见的负载均衡算法.md",key:"v-53bcbb7a",path:"/pages/f2dbbe/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 MySQL 的主从同步机制，如果同步失败会怎么样？",frontmatter:{title:"简述 MySQL 的主从同步机制，如果同步失败会怎么样？",date:"2022-05-21T17:07:22.000Z",permalink:"/pages/1ac30e/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/090.%E7%AE%80%E8%BF%B0%20MySQL%20%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%90%8C%E6%AD%A5%E5%A4%B1%E8%B4%A5%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/090.简述 MySQL 的主从同步机制，如果同步失败会怎么样？.md",key:"v-c383b96e",path:"/pages/1ac30e/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"如何设计数据库压测方案？",frontmatter:{title:"如何设计数据库压测方案？",date:"2022-05-21T17:08:40.000Z",permalink:"/pages/a8eb47/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/100.%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%A1%88%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/100.如何设计数据库压测方案？.md",key:"v-4cef944a",path:"/pages/a8eb47/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述数据库中什么情况下进行分库，什么情况下进行分表？",frontmatter:{title:"简述数据库中什么情况下进行分库，什么情况下进行分表？",date:"2022-05-21T17:08:52.000Z",permalink:"/pages/ac0bb8/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/110.%E7%AE%80%E8%BF%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%88%86%E8%A1%A8%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/110.简述数据库中什么情况下进行分库，什么情况下进行分表？.md",key:"v-ed0c93b8",path:"/pages/ac0bb8/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 undo log 和 redo log 的作用",frontmatter:{title:"简述 undo log 和 redo log 的作用",date:"2022-05-21T17:09:29.000Z",permalink:"/pages/7bbbf6/",categories:["数据库","MYSQL相关"],tags:["binlog","redo log"]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/130.%E7%AE%80%E8%BF%B0%20undo%20log%20%E5%92%8C%20redo%20log%20%E7%9A%84%E4%BD%9C%E7%94%A8.html",relativePath:"03.数据库/01.MYSQL相关/130.简述 undo log 和 redo log 的作用.md",key:"v-f3acaa1a",path:"/pages/7bbbf6/",headers:[{level:2,title:"redo log 的写入机制",slug:"redo-log-的写入机制",normalizedTitle:"redo log 的写入机制",charIndex:456},{level:2,title:"binlog 的写入机制",slug:"binlog-的写入机制",normalizedTitle:"binlog 的写入机制",charIndex:711},{level:2,title:"组提交机制（group commit）",slug:"组提交机制-group-commit",normalizedTitle:"组提交机制（group commit）",charIndex:971}],headersStr:"redo log 的写入机制 binlog 的写入机制 组提交机制（group commit）",content:"# binlog和redo log是什么，有什么用\n\n这两个日志都可以用于数据库的备份和恢复，以及主从复制。区别在于\n\nBINLOG            REDO LOG               备注\n在sql 层产生          在innoDB存储引擎层产生         \n记录数据行修改           记录数据页修改                \n先提交事务，再产生binlog   先产生redo log再提交事务       \n用于主从复制            在在mysql崩溃时，恢复未提交事务数据   \n                                         \n\n\n# binlog和redo log写入机制\n\n先说共性，这两个log的写入都要走这个过程： 先写入mysql server的buffer，再写入os buffer，再写入磁盘。 两个buffer之间的写入是内存操作，很快的，耗费io的操作是调用fsync写入磁盘的操作。\n\n\n# redo log 的写入机制\n\ninnodb_flush_log_at_trx_commit的值有三种0、1、2。控制log写入磁盘的频率。 innodb_flush_log_at_trx_commit的值 | 写入策略\n\n-------- | ----- 1 |事务commit后马上将log buffer写入os buffer并且调用fsync写入磁盘 0 | 每秒写入os buffer并立刻调用fsync写入磁盘 2 | commit后立即写入os buffer，然后每秒调用fsync写磁盘\n\n\n# binlog 的写入机制\n\n每个线程一个binlog缓存，因为binlog写入要求事务的完整性，即一个事务完成才能把事务binlog完整的写入。\n\nSYNC_BINLOG的值   写入策略\n1               事务commit后马上将log buffer写入os buffer并且调用fsync写入磁盘\n0               每秒写入os buffer并立刻调用fsync写入磁盘\nN(N>1)          commit后立即写入os buffer，积累N个事务调用fsync写磁盘\n\n\n# 组提交机制（group commit）\n\n> 双1配置是说将sync_binlog和innodb_flush_log_at_trx_commit都设置为1.那是不是说每次commit都要两次刷盘？但是是否定的。用组提交机制来实现。\n\n如果你想提升 binlog 组提交的效果，可以通过设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count实现：\n\nBINLOG_GROUP_COMMIT_SYNC_DELAY   BINLOG_GROUP_COMMIT_SYNC_NO_DELAY_COUNT\n调用多少微妙后再调用fsync                  积累多少次后调用fsync\n\n\n# 应对IO性能瓶颈\n\n如果IO出现性能瓶颈，可以考虑以下三个解决办法\n\n * 调大binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count，后果是可能增加sql执行时间，但是数据不会丢失。\n * sync_binlog设置大于1的数，风险是，断电后悔丢掉binlog日志\n * innodb_flush_log_at_trx_commit设置为2，风险是，断电后会丢失数据。",normalizedContent:"# binlog和redo log是什么，有什么用\n\n这两个日志都可以用于数据库的备份和恢复，以及主从复制。区别在于\n\nbinlog            redo log               备注\n在sql 层产生          在innodb存储引擎层产生         \n记录数据行修改           记录数据页修改                \n先提交事务，再产生binlog   先产生redo log再提交事务       \n用于主从复制            在在mysql崩溃时，恢复未提交事务数据   \n                                         \n\n\n# binlog和redo log写入机制\n\n先说共性，这两个log的写入都要走这个过程： 先写入mysql server的buffer，再写入os buffer，再写入磁盘。 两个buffer之间的写入是内存操作，很快的，耗费io的操作是调用fsync写入磁盘的操作。\n\n\n# redo log 的写入机制\n\ninnodb_flush_log_at_trx_commit的值有三种0、1、2。控制log写入磁盘的频率。 innodb_flush_log_at_trx_commit的值 | 写入策略\n\n-------- | ----- 1 |事务commit后马上将log buffer写入os buffer并且调用fsync写入磁盘 0 | 每秒写入os buffer并立刻调用fsync写入磁盘 2 | commit后立即写入os buffer，然后每秒调用fsync写磁盘\n\n\n# binlog 的写入机制\n\n每个线程一个binlog缓存，因为binlog写入要求事务的完整性，即一个事务完成才能把事务binlog完整的写入。\n\nsync_binlog的值   写入策略\n1               事务commit后马上将log buffer写入os buffer并且调用fsync写入磁盘\n0               每秒写入os buffer并立刻调用fsync写入磁盘\nn(n>1)          commit后立即写入os buffer，积累n个事务调用fsync写磁盘\n\n\n# 组提交机制（group commit）\n\n> 双1配置是说将sync_binlog和innodb_flush_log_at_trx_commit都设置为1.那是不是说每次commit都要两次刷盘？但是是否定的。用组提交机制来实现。\n\n如果你想提升 binlog 组提交的效果，可以通过设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count实现：\n\nbinlog_group_commit_sync_delay   binlog_group_commit_sync_no_delay_count\n调用多少微妙后再调用fsync                  积累多少次后调用fsync\n\n\n# 应对io性能瓶颈\n\n如果io出现性能瓶颈，可以考虑以下三个解决办法\n\n * 调大binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count，后果是可能增加sql执行时间，但是数据不会丢失。\n * sync_binlog设置大于1的数，风险是，断电后悔丢掉binlog日志\n * innodb_flush_log_at_trx_commit设置为2，风险是，断电后会丢失数据。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"数据库的读写分离的作用是什么？如何实现？",frontmatter:{title:"数据库的读写分离的作用是什么？如何实现？",date:"2022-05-21T17:09:05.000Z",permalink:"/pages/f62359/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/120.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/120.数据库的读写分离的作用是什么？如何实现？.md",key:"v-d6bc240a",path:"/pages/f62359/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"什么是 SQL 注入攻击？如何防止这类攻击？",frontmatter:{title:"什么是 SQL 注入攻击？如何防止这类攻击？",date:"2022-05-21T17:09:41.000Z",permalink:"/pages/b4338e/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/140.%E4%BB%80%E4%B9%88%E6%98%AF%20SQL%20%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%BF%99%E7%B1%BB%E6%94%BB%E5%87%BB%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/140.什么是 SQL 注入攻击？如何防止这类攻击？.md",key:"v-ceed6ba6",path:"/pages/b4338e/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"MySQL 中 join 与 left join 的区别是什么？",frontmatter:{title:"MySQL 中 join 与 left join 的区别是什么？",date:"2022-05-21T17:09:52.000Z",permalink:"/pages/429100/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/150.MySQL%20%E4%B8%AD%20join%20%E4%B8%8E%20left%20join%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/150.MySQL 中 join 与 left join 的区别是什么？.md",key:"v-77790024",path:"/pages/429100/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 MySQL MVCC 的实现原理",frontmatter:{title:"简述 MySQL MVCC 的实现原理",date:"2022-05-21T17:10:09.000Z",permalink:"/pages/1656d8/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/160.%E7%AE%80%E8%BF%B0%20MySQL%20MVCC%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%20.html",relativePath:"03.数据库/01.MYSQL相关/160.简述 MySQL MVCC 的实现原理 .md",key:"v-76f5e79a",path:"/pages/1656d8/",headers:[{level:2,title:"什么是MVCC？",slug:"什么是mvcc",normalizedTitle:"什么是mvcc？",charIndex:2},{level:2,title:"Innodb MVCC实现的核心知识点",slug:"innodb-mvcc实现的核心知识点",normalizedTitle:"innodb mvcc实现的核心知识点",charIndex:398},{level:3,title:"事务版本号",slug:"事务版本号",normalizedTitle:"事务版本号",charIndex:422},{level:3,title:"表的隐藏列。",slug:"表的隐藏列。",normalizedTitle:"表的隐藏列。",charIndex:479},{level:3,title:"undo log",slug:"undo-log",normalizedTitle:"undo log",charIndex:644},{level:3,title:"read view",slug:"read-view",normalizedTitle:"read view",charIndex:993},{level:3,title:"Read view 的几个重要属性",slug:"read-view-的几个重要属性",normalizedTitle:"read view 的几个重要属性",charIndex:1120},{level:3,title:"Read view 匹配条件",slug:"read-view-匹配条件",normalizedTitle:"read view 匹配条件",charIndex:1303},{level:3,title:"版本链",slug:"版本链",normalizedTitle:"版本链",charIndex:215},{level:2,title:"MVCC原理",slug:"mvcc原理",normalizedTitle:"mvcc原理",charIndex:2244},{level:2,title:"举例说明",slug:"举例说明",normalizedTitle:"举例说明",charIndex:2725},{level:2,title:"MVCC不存在幻读问题（RR级别的情况下）",slug:"mvcc不存在幻读问题-rr级别的情况下",normalizedTitle:"mvcc不存在幻读问题（rr级别的情况下）",charIndex:3024}],headersStr:"什么是MVCC？ Innodb MVCC实现的核心知识点 事务版本号 表的隐藏列。 undo log read view Read view 的几个重要属性 Read view 匹配条件 版本链 MVCC原理 举例说明 MVCC不存在幻读问题（RR级别的情况下）",content:"# 什么是MVCC？\n\nMVCC是在并发访问数据库时，通过对数据做多版本管理，避免因为写锁的阻塞而造成读数据的并发阻塞问题。\n\n通俗的讲就是MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。\n\n在MySQL中，MVCC只在读取已提交（Read Committed）和可重复读（Repeatable Read）两个事务级别下有效。其是通过Undo日志中的版本链和ReadView一致性视图来实现的。\n\nMVCC就是在多个事务同时存在时，SELECT语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。\n\n * mvcc特性：读不加锁，读写不冲突。\n * MVCC只在READ COMMITTED (提交读)、REPEATABLE READ (可重复读)下工作。不兼容其他隔离级别。\n\n\n# Innodb MVCC实现的核心知识点\n\n\n# 事务版本号\n\n每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。\n\n\n# 表的隐藏列。\n\n在数据表后加三个隐藏列，事物版本（DB_TRX_ID），回滚指针（DB_ROLL_PTR）、隐藏ID（DB_ROW_ID）。每开启一个事物版本号自增1；\n\n * DB_TRX_ID: 事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID；\n * DB_ROLL_PTR：指向上一个版本数据在undo log 里的位置指针，回滚指针，通过它可以将不同的版本串联起来，形成版本链。\n * DB_ROW_ID: 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;\n\n\n# undo log\n\nUndo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。\n\nUndo log 的用途\n\n * 保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。\n\n * 用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。\n\n\n# read view\n\n在innodb 中每个事务开启后都会得到一个read_view。\n\n副本主要保存了当前数据库系统中正处于活跃（没有commit）的事务的ID号，其实简单的说这个副本中保存的是系统中当前不应该被本事务看到的其他事务id列表。\n\n\n# Read view 的几个重要属性\n\ntrx_ids: 当前系统活跃(未提交)事务版本号集合。\n\nlow_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。\n\nup_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”\n\ncreator_trx_id: 创建当前read view的事务版本号；\n\n\n# Read view 匹配条件\n\n 1. 数据事务ID <up_limit_id 则显示 如果数据事务ID小于read view中的最小活跃事务ID，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。\n 2. 数据事务ID>=low_limit_id 则不显示 如果数据事务ID大于read view 中的当前系统的最大事务ID，则说明该数据是在当前read view 创建之后才产生的，所以数据不予显示。\n 3. p_limit_id <=数据事务ID<low_limit_id 则与活跃事务集合trx_ids里匹配 如果数据的事务ID大于最小的活跃事务ID,同时又小于等于系统最大的事务ID，这种情况就说明这个数据有可能是在当前事务开始的时候还没有提交的。 所以这时候我们需要把数据的事务ID与当前read view 中的活跃事务集合trx_ids 匹配:\n    1. 如果事务ID不存在于trx_ids 集合（则说明read view产生的时候事务已经commit了），这种情况数据则可以显示。\n    2. 如果事务ID存在trx_ids则说明read view产生的时候数据还没有提交，但是如果数据的事务ID等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。\n    3. 如果事务ID既存在trx_ids而且又不等于creator_trx_id那就说明read view产生的时候数据还没有提交，又不是自己生成的，所以这种情况下此数据不能显示。\n 4. 不满足read view条件时候，从undo log里面获取数据\n\n当数据的事务ID不满足read view条件时候，从undo log里面获取数据的历史版本，然后数据历史版本事务号回头再来和read view 条件匹配 ，直到找到一条满足条件的历史数据，或者找不到则返回空结果；\n\n\n# 版本链\n\n所有版本的数据都只会存一份，然后通过回滚指针连接起来，之后就是通过一定的规则找到具体是哪个版本上的数据就行了。\n\n假设现在有一张account表，其中有id和name两个字段，那么版本链的示意图如下：\n\n\n# MVCC原理\n\n\n\n * 如果落在绿色区间（DB_TRX_ID < min_id）：这个版本比min_id还小（事务ID是从小往大顺序生成的），说明这个版本在SELECT之前就已经提交了，所以这个数据是可见的。或者（这里是短路或，前面条件不满足才会判断后面这个条件）这个版本的事务本身就是当前SELECT语句所在事务的话，也是一样可见的；\n\n * 如果落在红色区间（DB_TRX_ID > max_id）：表示这个版本是由将来启动的事务来生成的，当前还未开始，那么是不可见的；\n\n * 果落在黄色区间（min_id <= DB_TRX_ID <= max_id）：这个时候就需要再判断两种情况： 如果这个版本的事务ID在ReadView的未提交事务数组中，表示这个版本是由还未提交的事务生成的，那么就是不可见的；\n\n * 如果这个版本的事务ID不在ReadView的未提交事务数组中，表示这个版本是已经提交了的事务生成的，那么是可见的。\n\n * 如果在上述的判断中发现当前版本是不可见的，那么就继续从版本链中通过回滚指针拿取下一个版本来进行上述的判断。\n\n\n# 举例说明\n\n假设当前事物版本为current_version\n\n** select: ** 查询会自动加where条件 and current_version>=def_create_version and (DB_TRX_ID = 'undefined' or DB_TRX_ID>current_version ) delete: DB_ROW_ID = current_version update: 先执行delete再执行insert insert: 插入数据并且默认DB_TRX_ID = current_version and DB_ROW_ID = 'undefined'\n\n\n# MVCC不存在幻读问题（RR级别的情况下）\n\n首先确认一点MVCC属于快照读的，在进行快照读的情况下是不会对数据进行加锁，而是基于事务版本号和undo历史版本读取数据，其实上面的文章已经说得很清楚了，我们根据上面的MVCC流程来推导，无论如何在MVCC的情况下都是不会出现幻读的问题的，如下图。\n\n1、开启事务1，获得事务ID为1。\n\n2、事务1执行查询，得到readview。\n\n3、开始事务2。\n\n4、执行insert。\n\n5、提交事务2。\n\n6、执行事务1的第二次查询 (因为这里是RR级别，所以不会再去获得readview,还是使用第一次获得的readview)\n\n7、最后得到的结果是，插入的数据不会显示，因为插入的数据事务ID大于等于 readview里的最大活跃事务ID。",normalizedContent:"# 什么是mvcc？\n\nmvcc是在并发访问数据库时，通过对数据做多版本管理，避免因为写锁的阻塞而造成读数据的并发阻塞问题。\n\n通俗的讲就是mvcc通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。\n\n在mysql中，mvcc只在读取已提交（read committed）和可重复读（repeatable read）两个事务级别下有效。其是通过undo日志中的版本链和readview一致性视图来实现的。\n\nmvcc就是在多个事务同时存在时，select语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。\n\n * mvcc特性：读不加锁，读写不冲突。\n * mvcc只在read committed (提交读)、repeatable read (可重复读)下工作。不兼容其他隔离级别。\n\n\n# innodb mvcc实现的核心知识点\n\n\n# 事务版本号\n\n每次事务开启前都会从数据库获得一个自增长的事务id，可以从事务id判断事务的执行先后顺序。\n\n\n# 表的隐藏列。\n\n在数据表后加三个隐藏列，事物版本（db_trx_id），回滚指针（db_roll_ptr）、隐藏id（db_row_id）。每开启一个事物版本号自增1；\n\n * db_trx_id: 事务id，记录的是当前事务在做insert或update语句操作时的事务id；\n * db_roll_ptr：指向上一个版本数据在undo log 里的位置指针，回滚指针，通过它可以将不同的版本串联起来，形成版本链。\n * db_row_id: 隐藏id ，当创建表没有合适的索引作为聚集索引时，会用该隐藏id创建聚集索引;\n\n\n# undo log\n\nundo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。\n\nundo log 的用途\n\n * 保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。\n\n * 用于mvcc快照读的数据，在mvcc多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。\n\n\n# read view\n\n在innodb 中每个事务开启后都会得到一个read_view。\n\n副本主要保存了当前数据库系统中正处于活跃（没有commit）的事务的id号，其实简单的说这个副本中保存的是系统中当前不应该被本事务看到的其他事务id列表。\n\n\n# read view 的几个重要属性\n\ntrx_ids: 当前系统活跃(未提交)事务版本号集合。\n\nlow_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。\n\nup_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”\n\ncreator_trx_id: 创建当前read view的事务版本号；\n\n\n# read view 匹配条件\n\n 1. 数据事务id <up_limit_id 则显示 如果数据事务id小于read view中的最小活跃事务id，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。\n 2. 数据事务id>=low_limit_id 则不显示 如果数据事务id大于read view 中的当前系统的最大事务id，则说明该数据是在当前read view 创建之后才产生的，所以数据不予显示。\n 3. p_limit_id <=数据事务id<low_limit_id 则与活跃事务集合trx_ids里匹配 如果数据的事务id大于最小的活跃事务id,同时又小于等于系统最大的事务id，这种情况就说明这个数据有可能是在当前事务开始的时候还没有提交的。 所以这时候我们需要把数据的事务id与当前read view 中的活跃事务集合trx_ids 匹配:\n    1. 如果事务id不存在于trx_ids 集合（则说明read view产生的时候事务已经commit了），这种情况数据则可以显示。\n    2. 如果事务id存在trx_ids则说明read view产生的时候数据还没有提交，但是如果数据的事务id等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。\n    3. 如果事务id既存在trx_ids而且又不等于creator_trx_id那就说明read view产生的时候数据还没有提交，又不是自己生成的，所以这种情况下此数据不能显示。\n 4. 不满足read view条件时候，从undo log里面获取数据\n\n当数据的事务id不满足read view条件时候，从undo log里面获取数据的历史版本，然后数据历史版本事务号回头再来和read view 条件匹配 ，直到找到一条满足条件的历史数据，或者找不到则返回空结果；\n\n\n# 版本链\n\n所有版本的数据都只会存一份，然后通过回滚指针连接起来，之后就是通过一定的规则找到具体是哪个版本上的数据就行了。\n\n假设现在有一张account表，其中有id和name两个字段，那么版本链的示意图如下：\n\n\n# mvcc原理\n\n\n\n * 如果落在绿色区间（db_trx_id < min_id）：这个版本比min_id还小（事务id是从小往大顺序生成的），说明这个版本在select之前就已经提交了，所以这个数据是可见的。或者（这里是短路或，前面条件不满足才会判断后面这个条件）这个版本的事务本身就是当前select语句所在事务的话，也是一样可见的；\n\n * 如果落在红色区间（db_trx_id > max_id）：表示这个版本是由将来启动的事务来生成的，当前还未开始，那么是不可见的；\n\n * 果落在黄色区间（min_id <= db_trx_id <= max_id）：这个时候就需要再判断两种情况： 如果这个版本的事务id在readview的未提交事务数组中，表示这个版本是由还未提交的事务生成的，那么就是不可见的；\n\n * 如果这个版本的事务id不在readview的未提交事务数组中，表示这个版本是已经提交了的事务生成的，那么是可见的。\n\n * 如果在上述的判断中发现当前版本是不可见的，那么就继续从版本链中通过回滚指针拿取下一个版本来进行上述的判断。\n\n\n# 举例说明\n\n假设当前事物版本为current_version\n\n** select: ** 查询会自动加where条件 and current_version>=def_create_version and (db_trx_id = 'undefined' or db_trx_id>current_version ) delete: db_row_id = current_version update: 先执行delete再执行insert insert: 插入数据并且默认db_trx_id = current_version and db_row_id = 'undefined'\n\n\n# mvcc不存在幻读问题（rr级别的情况下）\n\n首先确认一点mvcc属于快照读的，在进行快照读的情况下是不会对数据进行加锁，而是基于事务版本号和undo历史版本读取数据，其实上面的文章已经说得很清楚了，我们根据上面的mvcc流程来推导，无论如何在mvcc的情况下都是不会出现幻读的问题的，如下图。\n\n1、开启事务1，获得事务id为1。\n\n2、事务1执行查询，得到readview。\n\n3、开始事务2。\n\n4、执行insert。\n\n5、提交事务2。\n\n6、执行事务1的第二次查询 (因为这里是rr级别，所以不会再去获得readview,还是使用第一次获得的readview)\n\n7、最后得到的结果是，插入的数据不会显示，因为插入的数据事务id大于等于 readview里的最大活跃事务id。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"MySQL 中 varchar 和 char 的区别是什么？",frontmatter:{title:"MySQL 中 varchar 和 char 的区别是什么？",date:"2022-05-21T17:10:21.000Z",permalink:"/pages/d97948/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/170.MySQL%20%E4%B8%AD%20varchar%20%E5%92%8C%20char%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/170.MySQL 中 varchar 和 char 的区别是什么？.md",key:"v-0a7e6416",path:"/pages/d97948/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"模糊查询是如何实现的？",frontmatter:{title:"模糊查询是如何实现的？",date:"2022-05-21T17:10:36.000Z",permalink:"/pages/32696d/",categories:["数据库","MYSQL相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/180.%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",relativePath:"03.数据库/01.MYSQL相关/180.模糊查询是如何实现的？.md",key:"v-6b967a6e",path:"/pages/32696d/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Redis 有几种数据结构？Zset 是如何实现的？",frontmatter:{title:"Redis 有几种数据结构？Zset 是如何实现的？",date:"2022-05-21T17:21:14.000Z",permalink:"/pages/d70c1f/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/001.Redis%20%E6%9C%89%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9FZset%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",relativePath:"03.数据库/02.REDIS相关/001.Redis 有几种数据结构？Zset 是如何实现的？.md",key:"v-d804fba0",path:"/pages/d70c1f/",headers:[{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:2},{level:2,title:"链表",slug:"链表",normalizedTitle:"链表",charIndex:396},{level:2,title:"hash",slug:"hash",normalizedTitle:"hash",charIndex:26},{level:2,title:"跳跃表",slug:"跳跃表",normalizedTitle:"跳跃表",charIndex:2338},{level:2,title:"整数集合",slug:"整数集合",normalizedTitle:"整数集合",charIndex:3010},{level:2,title:"压缩列表",slug:"压缩列表",normalizedTitle:"压缩列表",charIndex:3402},{level:2,title:"RedisObject",slug:"redisobject",normalizedTitle:"redisobject",charIndex:4119}],headersStr:"字符串 链表 hash 跳跃表 整数集合 压缩列表 RedisObject",content:"> 字符串（String）、列表（list）、字典（hash）、集合（set）、有序集合（sortSet）.\n\n\n# 字符串\n\n 1. 源码\n\n/*\n- 保存字符串对象的结构\n*/\nstruct sdshdr {\n\n   // buf 中已占用空间的长度\n   int len;\n\n   // buf 中剩余可用空间的长度\n   int free;\n\n   // 数据空间\n   char buf[];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 2. sds与c字符串的区别\n\n * sds获取字符串长度的复杂度为O(1),c的是O(n)\n * c的api是不安全的，可能造成缓冲区溢出，sds的是安全的。\n * 修改N次字符串，c需要N次内存分配。sds最多需要N次分配。sds有空间预分配和惰性回收。\n * sds可以使用部分c的字符串库。\n\n\n# 链表\n\n 1. 源码\n\n/*\n* 双端链表节点\n*/\ntypedef struct listNode {\n\n  // 前置节点\n  struct listNode *prev;\n\n  // 后置节点\n  struct listNode *next;\n\n  // 节点的值\n  void *value;\n\n} listNode;\n\n/*\n* 双端链表结构\n*/\ntypedef struct list {\n\n  // 表头节点\n  listNode *head;\n\n  // 表尾节点\n  listNode *tail;\n\n  // 节点值复制函数\n  void *(*dup)(void *ptr);\n\n  // 节点值释放函数\n  void (*free)(void *ptr);\n\n  // 节点值对比函数\n  int (*match)(void *ptr, void *key);\n\n  // 链表所包含的节点数量\n  unsigned long len;\n\n} list;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n[外链图片转存中...(img-ua4uHhOc-1653145947289)]\n\n\n# hash\n\n 1. 源码\n\n/*\n* 哈希表节点\n*/\ntypedef struct dictEntry {\n  \n  // 键\n  void *key;\n\n  // 值\n  union {\n      void *val;\n      uint64_t u64;\n      int64_t s64;\n  } v;\n\n  // 指向下个哈希表节点，形成链表\n  struct dictEntry *next;\n\n} dictEntry;\n\n/*\n* 哈希表\n*\n* 每个字典都使用两个哈希表，从而实现渐进式 rehash 。\n*/\ntypedef struct dictht {\n  \n  // 哈希表数组\n  dictEntry **table;\n\n  // 哈希表大小\n  unsigned long size;\n  \n  // 哈希表大小掩码，用于计算索引值\n  // 总是等于 size - 1\n  unsigned long sizemask;\n\n  // 该哈希表已有节点的数量\n  unsigned long used;\n\n} dictht;\n\n/*\n* 字典\n*/\ntypedef struct dict {\n\n  // 类型特定函数\n  dictType *type;\n\n  // 私有数据\n  void *privdata;\n\n  // 哈希表\n  dictht ht[2];\n\n  // rehash 索引\n  // 当 rehash 不在进行时，值为 -1\n  int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n\n  // 目前正在运行的安全迭代器的数量\n  int iterators; /* number of iterators currently running */\n\n} dict;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n[外链图片转存中...(img-3IEt2xy5-1653145947290)] 2. reHash\n\n> 扩容场景： 有BGSAVE或者BGREWRITEAOF时，负载因子超过5. 无BGSAVE或者BGREWRITEAOF时，负载因子超过1. 扩容为第一个大于等于ht[0].used*2的2的幂\n\n> 缩容场景： 负载因子小于0.1 缩容为第一个大于等于ht[0].used的2的幂\n\n> 负载因子：ht[0].used/ht[0].size\n\n> 渐进式rehash: rehashidx指向正在hash的索引。rehashidx=-1表示未进行rehash 每次访问dict结构时rehash一个索引\n\n[外链图片转存中...(img-A0e54HI9-1653145947290)]\n\n\n# 跳跃表\n\n 1. 源码\n\n/*\n* 跳跃表节点\n*/\ntypedef struct zskiplistNode {\n\n   // 成员对象\n   robj *obj;\n\n   // 分值\n   double score;\n\n   // 后退指针\n   struct zskiplistNode *backward;\n\n   // 层\n   struct zskiplistLevel {\n\n       // 前进指针\n       struct zskiplistNode *forward;\n\n       // 跨度\n       unsigned int span;\n\n   } level[];\n\n} zskiplistNode;\n\n/*\n* 跳跃表\n*/\ntypedef struct zskiplist {\n\n   // 表头节点和表尾节点\n   struct zskiplistNode *header, *tail;\n\n   // 表中节点的数量\n   unsigned long length;\n\n   // 表中层数最大的节点的层数\n   int level;\n\n} zskiplist;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n[外链图片转存中...(img-MbZS62dp-1653145947291)]\n\n\n# 整数集合\n\n 1. 源码\n\ntypedef struct intset {\n   \n   // 编码方式\n   uint32_t encoding;\n\n   // 集合包含的元素数量\n   uint32_t length;\n\n   // 保存元素的数组\n   int8_t contents[];\n\n} intset;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n[外链图片转存中...(img-hdTbZZhS-1653145947291)] 2. 编码升级 添加一个元素可能导致编码升级。编码升级需要做三件事\n\n * 扩展空间\n * 转变现有元素的类型并发至在合适的位置上。保证原有顺序防止\n * 防止新加入的元素。新加入的元素一定是最大或最小的，所以放在最前或者最后\n\n[外链图片转存中...(img-0R00I0BO-1653145947291)]\n\n\n# 压缩列表\n\n> 压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。 一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值\n\n 1. 源码\n\n/*\n* 保存 ziplist 节点信息的结构\n*/\ntypedef struct zlentry {\n\n   // prevrawlen ：前置节点的长度\n   // prevrawlensize ：编码 prevrawlen 所需的字节大小\n   unsigned int prevrawlensize, prevrawlen;\n\n   // len ：当前节点值的长度\n   // lensize ：编码 len 所需的字节大小\n   unsigned int lensize, len;\n\n   // 当前节点 header 的大小\n   // 等于 prevrawlensize + lensize\n   unsigned int headersize;\n\n   // 当前节点值所使用的编码类型\n   unsigned char encoding;\n\n   // 指向当前节点的指针\n   unsigned char *p;\n\n} zlentry;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 2. 示意图 [外链图片转存中...(img-NMDF8Bnt-1653145947292)] [外链图片转存中...(img-5KdqaS0e-1653145947292)]\n\n\n# RedisObject\n\n> Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。\n\n 1. 源码\n\ntypedef struct redisObject {\n\n   // 类型\n   unsigned type:4;\n\n   // 编码\n   unsigned encoding:4;\n\n   // 对象最后一次被访问的时间\n   unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n\n   // 引用计数\n   int refcount;\n\n   // 指向实际值的指针\n   void *ptr;\n\n} robj;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n[外链图片转存中...(img-uT4NW4Ki-1653145947292)] 2. 类型和编码的对应关系 [外链图片转存中...(img-jkooRnC4-1653145947293)] 3. 字符串对象\n\n值                           编码\n可以用long保存的整形                int\n可以用long，double保存的浮点         embstr或row\n长度太长，不可以用long，double保存的浮点   embstr或row\n小于39字节的字符串                  embstr\n大于39字节的字符串                  row\n\n> row要两次申请内存，两次释放内存。为这俩对象RedisObject、SdsStr。embstr申请一次释放一次，而且申请的是连续的内存空间，能更好的利用缓存。\n\n 4. 链表对象\n\n> inkedList和zipList的转换临界值:每个元素长度都小于64、元素个数小于512。满足以上两个条件才能用zipList\n\n 5. hash对象\n\n> hashtable和zipList的转换临界值:每个元素长度都小于64、元素个数小于512。满足以上两个条件才能用zipList\n\n 6. 集合对象\n\n> hashtable和intset的转换临界值:每个元素都是int、元素个数小于512。满足以上两个条件才能用intset\n\n 7. 内存回收\n\n> redis是用C实现的，C没有自动回收内存的机制。RedisObject中的refCount记录对象的引用个数，当refCount=0的时候自动释放内存。\n\n 8. 对象共享\n\n> 0- 9999这1w个整数是共享对象。字符串不做共享对象，因为对比匹配太复杂",normalizedContent:"> 字符串（string）、列表（list）、字典（hash）、集合（set）、有序集合（sortset）.\n\n\n# 字符串\n\n 1. 源码\n\n/*\n- 保存字符串对象的结构\n*/\nstruct sdshdr {\n\n   // buf 中已占用空间的长度\n   int len;\n\n   // buf 中剩余可用空间的长度\n   int free;\n\n   // 数据空间\n   char buf[];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 2. sds与c字符串的区别\n\n * sds获取字符串长度的复杂度为o(1),c的是o(n)\n * c的api是不安全的，可能造成缓冲区溢出，sds的是安全的。\n * 修改n次字符串，c需要n次内存分配。sds最多需要n次分配。sds有空间预分配和惰性回收。\n * sds可以使用部分c的字符串库。\n\n\n# 链表\n\n 1. 源码\n\n/*\n* 双端链表节点\n*/\ntypedef struct listnode {\n\n  // 前置节点\n  struct listnode *prev;\n\n  // 后置节点\n  struct listnode *next;\n\n  // 节点的值\n  void *value;\n\n} listnode;\n\n/*\n* 双端链表结构\n*/\ntypedef struct list {\n\n  // 表头节点\n  listnode *head;\n\n  // 表尾节点\n  listnode *tail;\n\n  // 节点值复制函数\n  void *(*dup)(void *ptr);\n\n  // 节点值释放函数\n  void (*free)(void *ptr);\n\n  // 节点值对比函数\n  int (*match)(void *ptr, void *key);\n\n  // 链表所包含的节点数量\n  unsigned long len;\n\n} list;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n[外链图片转存中...(img-ua4uhhoc-1653145947289)]\n\n\n# hash\n\n 1. 源码\n\n/*\n* 哈希表节点\n*/\ntypedef struct dictentry {\n  \n  // 键\n  void *key;\n\n  // 值\n  union {\n      void *val;\n      uint64_t u64;\n      int64_t s64;\n  } v;\n\n  // 指向下个哈希表节点，形成链表\n  struct dictentry *next;\n\n} dictentry;\n\n/*\n* 哈希表\n*\n* 每个字典都使用两个哈希表，从而实现渐进式 rehash 。\n*/\ntypedef struct dictht {\n  \n  // 哈希表数组\n  dictentry **table;\n\n  // 哈希表大小\n  unsigned long size;\n  \n  // 哈希表大小掩码，用于计算索引值\n  // 总是等于 size - 1\n  unsigned long sizemask;\n\n  // 该哈希表已有节点的数量\n  unsigned long used;\n\n} dictht;\n\n/*\n* 字典\n*/\ntypedef struct dict {\n\n  // 类型特定函数\n  dicttype *type;\n\n  // 私有数据\n  void *privdata;\n\n  // 哈希表\n  dictht ht[2];\n\n  // rehash 索引\n  // 当 rehash 不在进行时，值为 -1\n  int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n\n  // 目前正在运行的安全迭代器的数量\n  int iterators; /* number of iterators currently running */\n\n} dict;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n[外链图片转存中...(img-3iet2xy5-1653145947290)] 2. rehash\n\n> 扩容场景： 有bgsave或者bgrewriteaof时，负载因子超过5. 无bgsave或者bgrewriteaof时，负载因子超过1. 扩容为第一个大于等于ht[0].used*2的2的幂\n\n> 缩容场景： 负载因子小于0.1 缩容为第一个大于等于ht[0].used的2的幂\n\n> 负载因子：ht[0].used/ht[0].size\n\n> 渐进式rehash: rehashidx指向正在hash的索引。rehashidx=-1表示未进行rehash 每次访问dict结构时rehash一个索引\n\n[外链图片转存中...(img-a0e54hi9-1653145947290)]\n\n\n# 跳跃表\n\n 1. 源码\n\n/*\n* 跳跃表节点\n*/\ntypedef struct zskiplistnode {\n\n   // 成员对象\n   robj *obj;\n\n   // 分值\n   double score;\n\n   // 后退指针\n   struct zskiplistnode *backward;\n\n   // 层\n   struct zskiplistlevel {\n\n       // 前进指针\n       struct zskiplistnode *forward;\n\n       // 跨度\n       unsigned int span;\n\n   } level[];\n\n} zskiplistnode;\n\n/*\n* 跳跃表\n*/\ntypedef struct zskiplist {\n\n   // 表头节点和表尾节点\n   struct zskiplistnode *header, *tail;\n\n   // 表中节点的数量\n   unsigned long length;\n\n   // 表中层数最大的节点的层数\n   int level;\n\n} zskiplist;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n[外链图片转存中...(img-mbzs62dp-1653145947291)]\n\n\n# 整数集合\n\n 1. 源码\n\ntypedef struct intset {\n   \n   // 编码方式\n   uint32_t encoding;\n\n   // 集合包含的元素数量\n   uint32_t length;\n\n   // 保存元素的数组\n   int8_t contents[];\n\n} intset;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n[外链图片转存中...(img-hdtbzzhs-1653145947291)] 2. 编码升级 添加一个元素可能导致编码升级。编码升级需要做三件事\n\n * 扩展空间\n * 转变现有元素的类型并发至在合适的位置上。保证原有顺序防止\n * 防止新加入的元素。新加入的元素一定是最大或最小的，所以放在最前或者最后\n\n[外链图片转存中...(img-0r00i0bo-1653145947291)]\n\n\n# 压缩列表\n\n> 压缩列表是 redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。 一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值\n\n 1. 源码\n\n/*\n* 保存 ziplist 节点信息的结构\n*/\ntypedef struct zlentry {\n\n   // prevrawlen ：前置节点的长度\n   // prevrawlensize ：编码 prevrawlen 所需的字节大小\n   unsigned int prevrawlensize, prevrawlen;\n\n   // len ：当前节点值的长度\n   // lensize ：编码 len 所需的字节大小\n   unsigned int lensize, len;\n\n   // 当前节点 header 的大小\n   // 等于 prevrawlensize + lensize\n   unsigned int headersize;\n\n   // 当前节点值所使用的编码类型\n   unsigned char encoding;\n\n   // 指向当前节点的指针\n   unsigned char *p;\n\n} zlentry;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 2. 示意图 [外链图片转存中...(img-nmdf8bnt-1653145947292)] [外链图片转存中...(img-5kdqas0e-1653145947292)]\n\n\n# redisobject\n\n> redis 使用对象来表示数据库中的键和值， 每次当我们在 redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。\n\n 1. 源码\n\ntypedef struct redisobject {\n\n   // 类型\n   unsigned type:4;\n\n   // 编码\n   unsigned encoding:4;\n\n   // 对象最后一次被访问的时间\n   unsigned lru:redis_lru_bits; /* lru time (relative to server.lruclock) */\n\n   // 引用计数\n   int refcount;\n\n   // 指向实际值的指针\n   void *ptr;\n\n} robj;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n[外链图片转存中...(img-ut4nw4ki-1653145947292)] 2. 类型和编码的对应关系 [外链图片转存中...(img-jkoornc4-1653145947293)] 3. 字符串对象\n\n值                           编码\n可以用long保存的整形                int\n可以用long，double保存的浮点         embstr或row\n长度太长，不可以用long，double保存的浮点   embstr或row\n小于39字节的字符串                  embstr\n大于39字节的字符串                  row\n\n> row要两次申请内存，两次释放内存。为这俩对象redisobject、sdsstr。embstr申请一次释放一次，而且申请的是连续的内存空间，能更好的利用缓存。\n\n 4. 链表对象\n\n> inkedlist和ziplist的转换临界值:每个元素长度都小于64、元素个数小于512。满足以上两个条件才能用ziplist\n\n 5. hash对象\n\n> hashtable和ziplist的转换临界值:每个元素长度都小于64、元素个数小于512。满足以上两个条件才能用ziplist\n\n 6. 集合对象\n\n> hashtable和intset的转换临界值:每个元素都是int、元素个数小于512。满足以上两个条件才能用intset\n\n 7. 内存回收\n\n> redis是用c实现的，c没有自动回收内存的机制。redisobject中的refcount记录对象的引用个数，当refcount=0的时候自动释放内存。\n\n 8. 对象共享\n\n> 0- 9999这1w个整数是共享对象。字符串不做共享对象，因为对比匹配太复杂",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"为什么 Redis 在单线程下能如此快？",frontmatter:{title:"为什么 Redis 在单线程下能如此快？",date:"2022-05-21T17:20:12.000Z",permalink:"/pages/d66211/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/002.%E4%B8%BA%E4%BB%80%E4%B9%88%20Redis%20%E5%9C%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%83%BD%E5%A6%82%E6%AD%A4%E5%BF%AB%EF%BC%9F.html",relativePath:"03.数据库/02.REDIS相关/002.为什么 Redis 在单线程下能如此快？.md",key:"v-cb742458",path:"/pages/d66211/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 Redis 字符串的底层结构",frontmatter:{title:"简述 Redis 字符串的底层结构",date:"2022-05-21T17:20:49.000Z",permalink:"/pages/34aec2/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/005.%E7%AE%80%E8%BF%B0%20Redis%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.html",relativePath:"03.数据库/02.REDIS相关/005.简述 Redis 字符串的底层结构.md",key:"v-3e917471",path:"/pages/34aec2/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Redis 如何实现分布式锁？",frontmatter:{title:"Redis 如何实现分布式锁？",date:"2022-05-21T17:21:32.000Z",permalink:"/pages/656f46/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/030.Redis%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F.html",relativePath:"03.数据库/02.REDIS相关/030.Redis 如何实现分布式锁？.md",key:"v-2c6b511c",path:"/pages/656f46/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 Redis 集群配置以及基础原理",frontmatter:{title:"简述 Redis 集群配置以及基础原理",date:"2022-05-21T17:21:55.000Z",permalink:"/pages/338e30/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/040.%E7%AE%80%E8%BF%B0%20Redis%20%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86.html",relativePath:"03.数据库/02.REDIS相关/040.简述 Redis 集群配置以及基础原理.md",key:"v-3d2fdd6a",path:"/pages/338e30/",headers:[{level:2,title:"复制",slug:"复制",normalizedTitle:"复制",charIndex:39}],headersStr:"复制",content:"# 集群\n\n> 集群是redis的分布式数据库方案。通过分片实现数据共享。提供复制和故障转移功能。\n\n// 保存连接节点所需的有关信息\ntypedef struct clusterLink {\n\n    // 连接的创建时间\n    mstime_t ctime;             /* Link creation time */\n\n    // TCP 套接字描述符\n    int fd;                     /* TCP socket file descriptor */\n\n    // 输出缓冲区，保存着等待发送给其他节点的消息（message）。\n    sds sndbuf;                 /* Packet send buffer */\n\n    // 输入缓冲区，保存着从其他节点接收到的消息。\n    sds rcvbuf;                 /* Packet reception buffer */\n\n    // 与这个连接相关联的节点，如果没有的话就为 NULL\n    struct clusterNode *node;   /* Node related to this link if any, or NULL */\n\n} clusterLink;\n\n// 节点状态\nstruct clusterNode {\n\n    // 创建节点的时间\n    mstime_t ctime; /* Node object creation time. */\n\n    // 节点的名字，由 40 个十六进制字符组成\n    // 例如 68eef66df23420a5862208ef5b1a7005b806f2ff\n    char name[REDIS_CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */\n\n    // 节点标识\n    // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），\n    // 以及节点目前所处的状态（比如在线或者下线）。\n    int flags;      /* REDIS_NODE_... */\n\n    // 节点当前的配置纪元，用于实现故障转移\n    uint64_t configEpoch; /* Last configEpoch observed for this node */\n\n    // 由这个节点负责处理的槽\n    // 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长\n    // 每个字节的每个位记录了一个槽的保存状态\n    // 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理\n    // 比如 slots[0] 的第一个位保存了槽 0 的保存情况\n    // slots[0] 的第二个位保存了槽 1 的保存情况，以此类推\n    unsigned char slots[REDIS_CLUSTER_SLOTS/8]; /* slots handled by this node */\n\n    // 该节点负责处理的槽数量\n    int numslots;   /* Number of slots handled by this node */\n\n    // 如果本节点是主节点，那么用这个属性记录从节点的数量\n    int numslaves;  /* Number of slave nodes, if this is a master */\n\n    // 指针数组，指向各个从节点\n    struct clusterNode **slaves; /* pointers to slave nodes */\n\n    // 如果这是一个从节点，那么指向主节点\n    struct clusterNode *slaveof; /* pointer to the master node */\n\n    // 最后一次发送 PING 命令的时间\n    mstime_t ping_sent;      /* Unix time we sent latest ping */\n\n    // 最后一次接收 PONG 回复的时间戳\n    mstime_t pong_received;  /* Unix time we received the pong */\n\n    // 最后一次被设置为 FAIL 状态的时间\n    mstime_t fail_time;      /* Unix time when FAIL flag was set */\n\n    // 最后一次给某个从节点投票的时间\n    mstime_t voted_time;     /* Last time we voted for a slave of this master */\n\n    // 最后一次从这个节点接收到复制偏移量的时间\n    mstime_t repl_offset_time;  /* Unix time we received offset for this node */\n\n    // 这个节点的复制偏移量\n    long long repl_offset;      /* Last known repl offset for this node. */\n\n    // 节点的 IP 地址\n    char ip[REDIS_IP_STR_LEN];  /* Latest known IP address of this node */\n\n    // 节点的端口号\n    int port;                   /* Latest known port of this node */\n\n    // 保存连接节点所需的有关信息\n    clusterLink *link;          /* TCP/IP link with this node */\n\n    // 一个链表，记录了所有其他节点对该节点的下线报告\n    list *fail_reports;         /* List of nodes signaling this as failing */\n\n};\ntypedef struct clusterNode clusterNode;\n\n\n// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。\n// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，\n// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count \n// 也被放到了这个结构里面。\ntypedef struct clusterState {\n\n    // 指向当前节点的指针\n    clusterNode *myself;  /* This node */\n\n    // 集群当前的配置纪元，用于实现故障转移\n    uint64_t currentEpoch;\n\n    // 集群当前的状态：是在线还是下线\n    int state;            /* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */\n\n    // 集群中至少处理着一个槽的节点的数量。\n    int size;             /* Num of master nodes with at least one slot */\n\n    // 集群节点名单（包括 myself 节点）\n    // 字典的键为节点的名字，字典的值为 clusterNode 结构\n    dict *nodes;          /* Hash table of name -> clusterNode structures */\n\n    // 节点黑名单，用于 CLUSTER FORGET 命令\n    // 防止被 FORGET 的命令重新被添加到集群里面\n    // （不过现在似乎没有在使用的样子，已废弃？还是尚未实现？）\n    dict *nodes_black_list; /* Nodes we don't re-add for a few seconds. */\n\n    // 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点\n    // migrating_slots_to[i] = NULL 表示槽 i 未被迁移\n    // migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A\n    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];\n\n    // 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点\n    // importing_slots_from[i] = NULL 表示槽 i 未进行导入\n    // importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i\n    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];\n\n    // 负责处理各个槽的节点\n    // 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理\n    clusterNode *slots[REDIS_CLUSTER_SLOTS];\n\n    // 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序\n    // 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便\n    // 具体操作定义在 db.c 里面\n    zskiplist *slots_to_keys;\n\n    /* The following fields are used to take the slave state on elections. */\n    // 以下这些域被用于进行故障转移选举\n\n    // 上次执行选举或者下次执行选举的时间\n    mstime_t failover_auth_time; /* Time of previous or next election. */\n\n    // 节点获得的投票数量\n    int failover_auth_count;    /* Number of votes received so far. */\n\n    // 如果值为 1 ，表示本节点已经向其他节点发送了投票请求\n    int failover_auth_sent;     /* True if we already asked for votes. */\n\n    int failover_auth_rank;     /* This slave rank for current auth request. */\n\n    uint64_t failover_auth_epoch; /* Epoch of the current election. */\n\n    /* Manual failover state in common. */\n    /* 共用的手动故障转移状态 */\n\n    // 手动故障转移执行的时间限制\n    mstime_t mf_end;            /* Manual failover time limit (ms unixtime).\n                                   It is zero if there is no MF in progress. */\n    /* Manual failover state of master. */\n    /* 主服务器的手动故障转移状态 */\n    clusterNode *mf_slave;      /* Slave performing the manual failover. */\n    /* Manual failover state of slave. */\n    /* 从服务器的手动故障转移状态 */\n    long long mf_master_offset; /* Master offset the slave needs to start MF\n                                   or zero if stil not received. */\n    // 指示手动故障转移是否可以开始的标志值\n    // 值为非 0 时表示各个主服务器可以开始投票\n    int mf_can_start;           /* If non-zero signal that the manual failover\n                                   can start requesting masters vote. */\n\n    /* The followign fields are uesd by masters to take state on elections. */\n    /* 以下这些域由主服务器使用，用于记录选举时的状态 */\n\n    // 集群最后一次进行投票的纪元\n    uint64_t lastVoteEpoch;     /* Epoch of the last vote granted. */\n\n    // 在进入下个事件循环之前要做的事情，以各个 flag 来记录\n    int todo_before_sleep; /* Things to do in clusterBeforeSleep(). */\n\n    // 通过 cluster 连接发送的消息数量\n    long long stats_bus_messages_sent;  /* Num of msg sent via cluster bus. */\n\n    // 通过 cluster 接收到的消息数量\n    long long stats_bus_messages_received; /* Num of msg rcvd via cluster bus.*/\n\n} clusterState;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n\n\n[外链图片转存中...(img-pyfo5Uy7-1653145947299)]\n\n 2. cluster meet命令\n\n> 客户端向节点A发送meet命令，指定节点B的ip和端口。将B加入到A的集群。\n\n * 向A发命令cluster meet B.\n * A为B创建一个clusterNode结构并保存在dict中\n * A向B发一个meet消息\n * B为A创建一个clusterNode结构并保存在dict中\n * B返回A一个PONG消息\n * A收到PONG返回一个PING\n * B收到PING，握手结束 [外链图片转存中...(img-MJB1V7if-1653145947300)]\n\n 3. 槽指派\n\n> redis通过分片的方式保存键值对，集群的整个数据库被分成16384个槽。每个节点处理一定数量的槽，每个key一定属于其中一个槽。\n\n * 向节点指派槽的命令：cluster addslots 1 2 3 4\n * clusterNode中Slots数组保存当前节点所有槽信息。Slots是二进制数组。\n * 传播节点的槽指派信息：集群节点会相互发送自己被指派的槽，节点收到其他几点的槽信息会更新相应的dict中的clusterNode结构。\n * clusterState中Slots数组保存所有槽信息。 [外链图片转存中...(img-p5szUZKB-1653145947300)]\n * cluster addslots 1 2 3 4的实现：首先遍历clusterState的Slots判断命令中的槽还没有被指派。然后遍历命令中的槽，设置clusterState的Slots和clusterNode的slots。\n\n 4. 集群中执行命令\n\n * 接收命令的节点计算命令要处理的数据库属于哪个槽，如果是指派给自己的就直接执行；如果不是就向客户端返回一个moved错误指引客户端至正确节点执行。\n * 计算给定key的槽：任何一个key通过这个算法就可以得出一个介于0-16383之间的槽。crc16(key)&16383\n * 集群中的节点只能使用0号数据库。\n\n 5. 重新分片 集群管理软件redis-trib负责执行。\n\n * redis-trib向目标节点发送导入命令，并将slot指向目标节点\n * redis-trib向源节点发送导出命令\n * redis-trib从源节点获取导出slot的键，导入到目标节点\n * 键迁移结束。向集群中任意节点发送消息，slot已指向目标节点。 [外链图片转存中...(img-dezJf9DD-1653145947300)]\n\n 6. ask错误\n\n * ask错误：正在被转移的key被查询时，会发生查询转移\n * Cluster setslot importing命令：clusterState的Importing_lots_from记录着导入的槽\n * Cluster setslot migrating命令:clusterState的migrating_slots_to记录着正在导出的槽。ask错误的实现\n\n 7. publish的实现\n\n> 不是直接向所有节点广播，而是通过一个节点向所有节点广播。因为redis中有一个潜规则：各节点通过消息通信。\n\ntypedef struct {\n\n    // 频道名长度\n    uint32_t channel_len;\n\n    // 消息长度\n    uint32_t message_len;\n\n    // 消息内容，格式为 频道名+消息\n    // bulk_data[0:channel_len-1] 为频道名\n    // bulk_data[channel_len:channel_len+message_len-1] 为消息\n    unsigned char bulk_data[8]; /* defined as 8 just for alignment concerns. */\n\n} clusterMsgDataPublish;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 复制\n\n 1. 复制的步骤\n\n * redis的复制分为两个步骤，同步（sync）和命令传播(commond propogate)。\n * 同步：从服务器向主服务器发送sync命令，主服务器生成rdb文件，并将生成rdb期间的数据库修改命令保存在缓冲区，然后都传给从服务器。同步浪费资源体现在：a.生成rdb耗费cpu，内存，i/o;b.传输rdb耗费网络资源；c.载入rdb会阻塞服务器。\n * 命令传播：主服务器收到的修改命令也发给从服务器执行。\n * redis2.8以前的复制缺陷：缺陷场景：主从断线之后的重新复制。实现方式：断线之后，主从重新走一遍同步和命令传播。缺陷原因：同步是很浪费资源的操作，应该尽量避免。\n * redis2.8以后用psync代替sync;psync支持完全重同步和部分重同步。\n * 部分重同步的实现：偏移量（同步的字节量），复制积压缓冲区(固定长度的队列)，服务器运行id（判断是不是向同一个服务器发送的同步命令）。 [外链图片转存中...(img-PHS6g12W-1653145947297)]\n\n 2. 复制的实现\n\n * 设置主服务器地址和端口。Slaveof 127.0.0.1 6379。从服务器保存主服务器地址和端口。\n * 建立套接字。从服务器根据保存的主服务器地址和端口号，建立套接字。\n * 从服务器发送ping命令。超时或者错误则重新建立套接字重试；返回“PONG”说明网络连接正常。\n * 身份验证。主从都没有设置身份验证或者设置一致才可以通过身份验证。\n * 从服务器发送监听端口，主服务器将其保存在redisClient的slave_listening_port;\n * 同步。从服务器向主服务发送psync命令。 [外链图片转存中...(img-JbQvVK4o-1653145947297)]\n\n 3. 心跳检测\n\n> 从服务器每秒发送命令给主服务器，replconf ack offset,有三个作用\n\n * 检测链接状况\n * 辅助实现min-slaves选项。min-slaves-to-write 3，min-slaves-max-lag 10。表示从服务器少于3个，或者从服务延迟都大于等于10，主服务器将终止写命令。\n * 检测命令丢失",normalizedContent:"# 集群\n\n> 集群是redis的分布式数据库方案。通过分片实现数据共享。提供复制和故障转移功能。\n\n// 保存连接节点所需的有关信息\ntypedef struct clusterlink {\n\n    // 连接的创建时间\n    mstime_t ctime;             /* link creation time */\n\n    // tcp 套接字描述符\n    int fd;                     /* tcp socket file descriptor */\n\n    // 输出缓冲区，保存着等待发送给其他节点的消息（message）。\n    sds sndbuf;                 /* packet send buffer */\n\n    // 输入缓冲区，保存着从其他节点接收到的消息。\n    sds rcvbuf;                 /* packet reception buffer */\n\n    // 与这个连接相关联的节点，如果没有的话就为 null\n    struct clusternode *node;   /* node related to this link if any, or null */\n\n} clusterlink;\n\n// 节点状态\nstruct clusternode {\n\n    // 创建节点的时间\n    mstime_t ctime; /* node object creation time. */\n\n    // 节点的名字，由 40 个十六进制字符组成\n    // 例如 68eef66df23420a5862208ef5b1a7005b806f2ff\n    char name[redis_cluster_namelen]; /* node name, hex string, sha1-size */\n\n    // 节点标识\n    // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），\n    // 以及节点目前所处的状态（比如在线或者下线）。\n    int flags;      /* redis_node_... */\n\n    // 节点当前的配置纪元，用于实现故障转移\n    uint64_t configepoch; /* last configepoch observed for this node */\n\n    // 由这个节点负责处理的槽\n    // 一共有 redis_cluster_slots / 8 个字节长\n    // 每个字节的每个位记录了一个槽的保存状态\n    // 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理\n    // 比如 slots[0] 的第一个位保存了槽 0 的保存情况\n    // slots[0] 的第二个位保存了槽 1 的保存情况，以此类推\n    unsigned char slots[redis_cluster_slots/8]; /* slots handled by this node */\n\n    // 该节点负责处理的槽数量\n    int numslots;   /* number of slots handled by this node */\n\n    // 如果本节点是主节点，那么用这个属性记录从节点的数量\n    int numslaves;  /* number of slave nodes, if this is a master */\n\n    // 指针数组，指向各个从节点\n    struct clusternode **slaves; /* pointers to slave nodes */\n\n    // 如果这是一个从节点，那么指向主节点\n    struct clusternode *slaveof; /* pointer to the master node */\n\n    // 最后一次发送 ping 命令的时间\n    mstime_t ping_sent;      /* unix time we sent latest ping */\n\n    // 最后一次接收 pong 回复的时间戳\n    mstime_t pong_received;  /* unix time we received the pong */\n\n    // 最后一次被设置为 fail 状态的时间\n    mstime_t fail_time;      /* unix time when fail flag was set */\n\n    // 最后一次给某个从节点投票的时间\n    mstime_t voted_time;     /* last time we voted for a slave of this master */\n\n    // 最后一次从这个节点接收到复制偏移量的时间\n    mstime_t repl_offset_time;  /* unix time we received offset for this node */\n\n    // 这个节点的复制偏移量\n    long long repl_offset;      /* last known repl offset for this node. */\n\n    // 节点的 ip 地址\n    char ip[redis_ip_str_len];  /* latest known ip address of this node */\n\n    // 节点的端口号\n    int port;                   /* latest known port of this node */\n\n    // 保存连接节点所需的有关信息\n    clusterlink *link;          /* tcp/ip link with this node */\n\n    // 一个链表，记录了所有其他节点对该节点的下线报告\n    list *fail_reports;         /* list of nodes signaling this as failing */\n\n};\ntypedef struct clusternode clusternode;\n\n\n// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。\n// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，\n// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count \n// 也被放到了这个结构里面。\ntypedef struct clusterstate {\n\n    // 指向当前节点的指针\n    clusternode *myself;  /* this node */\n\n    // 集群当前的配置纪元，用于实现故障转移\n    uint64_t currentepoch;\n\n    // 集群当前的状态：是在线还是下线\n    int state;            /* redis_cluster_ok, redis_cluster_fail, ... */\n\n    // 集群中至少处理着一个槽的节点的数量。\n    int size;             /* num of master nodes with at least one slot */\n\n    // 集群节点名单（包括 myself 节点）\n    // 字典的键为节点的名字，字典的值为 clusternode 结构\n    dict *nodes;          /* hash table of name -> clusternode structures */\n\n    // 节点黑名单，用于 cluster forget 命令\n    // 防止被 forget 的命令重新被添加到集群里面\n    // （不过现在似乎没有在使用的样子，已废弃？还是尚未实现？）\n    dict *nodes_black_list; /* nodes we don't re-add for a few seconds. */\n\n    // 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点\n    // migrating_slots_to[i] = null 表示槽 i 未被迁移\n    // migrating_slots_to[i] = clusternode_a 表示槽 i 要从本节点迁移至节点 a\n    clusternode *migrating_slots_to[redis_cluster_slots];\n\n    // 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点\n    // importing_slots_from[i] = null 表示槽 i 未进行导入\n    // importing_slots_from[i] = clusternode_a 表示正从节点 a 中导入槽 i\n    clusternode *importing_slots_from[redis_cluster_slots];\n\n    // 负责处理各个槽的节点\n    // 例如 slots[i] = clusternode_a 表示槽 i 由节点 a 处理\n    clusternode *slots[redis_cluster_slots];\n\n    // 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序\n    // 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便\n    // 具体操作定义在 db.c 里面\n    zskiplist *slots_to_keys;\n\n    /* the following fields are used to take the slave state on elections. */\n    // 以下这些域被用于进行故障转移选举\n\n    // 上次执行选举或者下次执行选举的时间\n    mstime_t failover_auth_time; /* time of previous or next election. */\n\n    // 节点获得的投票数量\n    int failover_auth_count;    /* number of votes received so far. */\n\n    // 如果值为 1 ，表示本节点已经向其他节点发送了投票请求\n    int failover_auth_sent;     /* true if we already asked for votes. */\n\n    int failover_auth_rank;     /* this slave rank for current auth request. */\n\n    uint64_t failover_auth_epoch; /* epoch of the current election. */\n\n    /* manual failover state in common. */\n    /* 共用的手动故障转移状态 */\n\n    // 手动故障转移执行的时间限制\n    mstime_t mf_end;            /* manual failover time limit (ms unixtime).\n                                   it is zero if there is no mf in progress. */\n    /* manual failover state of master. */\n    /* 主服务器的手动故障转移状态 */\n    clusternode *mf_slave;      /* slave performing the manual failover. */\n    /* manual failover state of slave. */\n    /* 从服务器的手动故障转移状态 */\n    long long mf_master_offset; /* master offset the slave needs to start mf\n                                   or zero if stil not received. */\n    // 指示手动故障转移是否可以开始的标志值\n    // 值为非 0 时表示各个主服务器可以开始投票\n    int mf_can_start;           /* if non-zero signal that the manual failover\n                                   can start requesting masters vote. */\n\n    /* the followign fields are uesd by masters to take state on elections. */\n    /* 以下这些域由主服务器使用，用于记录选举时的状态 */\n\n    // 集群最后一次进行投票的纪元\n    uint64_t lastvoteepoch;     /* epoch of the last vote granted. */\n\n    // 在进入下个事件循环之前要做的事情，以各个 flag 来记录\n    int todo_before_sleep; /* things to do in clusterbeforesleep(). */\n\n    // 通过 cluster 连接发送的消息数量\n    long long stats_bus_messages_sent;  /* num of msg sent via cluster bus. */\n\n    // 通过 cluster 接收到的消息数量\n    long long stats_bus_messages_received; /* num of msg rcvd via cluster bus.*/\n\n} clusterstate;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n\n\n[外链图片转存中...(img-pyfo5uy7-1653145947299)]\n\n 2. cluster meet命令\n\n> 客户端向节点a发送meet命令，指定节点b的ip和端口。将b加入到a的集群。\n\n * 向a发命令cluster meet b.\n * a为b创建一个clusternode结构并保存在dict中\n * a向b发一个meet消息\n * b为a创建一个clusternode结构并保存在dict中\n * b返回a一个pong消息\n * a收到pong返回一个ping\n * b收到ping，握手结束 [外链图片转存中...(img-mjb1v7if-1653145947300)]\n\n 3. 槽指派\n\n> redis通过分片的方式保存键值对，集群的整个数据库被分成16384个槽。每个节点处理一定数量的槽，每个key一定属于其中一个槽。\n\n * 向节点指派槽的命令：cluster addslots 1 2 3 4\n * clusternode中slots数组保存当前节点所有槽信息。slots是二进制数组。\n * 传播节点的槽指派信息：集群节点会相互发送自己被指派的槽，节点收到其他几点的槽信息会更新相应的dict中的clusternode结构。\n * clusterstate中slots数组保存所有槽信息。 [外链图片转存中...(img-p5szuzkb-1653145947300)]\n * cluster addslots 1 2 3 4的实现：首先遍历clusterstate的slots判断命令中的槽还没有被指派。然后遍历命令中的槽，设置clusterstate的slots和clusternode的slots。\n\n 4. 集群中执行命令\n\n * 接收命令的节点计算命令要处理的数据库属于哪个槽，如果是指派给自己的就直接执行；如果不是就向客户端返回一个moved错误指引客户端至正确节点执行。\n * 计算给定key的槽：任何一个key通过这个算法就可以得出一个介于0-16383之间的槽。crc16(key)&16383\n * 集群中的节点只能使用0号数据库。\n\n 5. 重新分片 集群管理软件redis-trib负责执行。\n\n * redis-trib向目标节点发送导入命令，并将slot指向目标节点\n * redis-trib向源节点发送导出命令\n * redis-trib从源节点获取导出slot的键，导入到目标节点\n * 键迁移结束。向集群中任意节点发送消息，slot已指向目标节点。 [外链图片转存中...(img-dezjf9dd-1653145947300)]\n\n 6. ask错误\n\n * ask错误：正在被转移的key被查询时，会发生查询转移\n * cluster setslot importing命令：clusterstate的importing_lots_from记录着导入的槽\n * cluster setslot migrating命令:clusterstate的migrating_slots_to记录着正在导出的槽。ask错误的实现\n\n 7. publish的实现\n\n> 不是直接向所有节点广播，而是通过一个节点向所有节点广播。因为redis中有一个潜规则：各节点通过消息通信。\n\ntypedef struct {\n\n    // 频道名长度\n    uint32_t channel_len;\n\n    // 消息长度\n    uint32_t message_len;\n\n    // 消息内容，格式为 频道名+消息\n    // bulk_data[0:channel_len-1] 为频道名\n    // bulk_data[channel_len:channel_len+message_len-1] 为消息\n    unsigned char bulk_data[8]; /* defined as 8 just for alignment concerns. */\n\n} clustermsgdatapublish;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 复制\n\n 1. 复制的步骤\n\n * redis的复制分为两个步骤，同步（sync）和命令传播(commond propogate)。\n * 同步：从服务器向主服务器发送sync命令，主服务器生成rdb文件，并将生成rdb期间的数据库修改命令保存在缓冲区，然后都传给从服务器。同步浪费资源体现在：a.生成rdb耗费cpu，内存，i/o;b.传输rdb耗费网络资源；c.载入rdb会阻塞服务器。\n * 命令传播：主服务器收到的修改命令也发给从服务器执行。\n * redis2.8以前的复制缺陷：缺陷场景：主从断线之后的重新复制。实现方式：断线之后，主从重新走一遍同步和命令传播。缺陷原因：同步是很浪费资源的操作，应该尽量避免。\n * redis2.8以后用psync代替sync;psync支持完全重同步和部分重同步。\n * 部分重同步的实现：偏移量（同步的字节量），复制积压缓冲区(固定长度的队列)，服务器运行id（判断是不是向同一个服务器发送的同步命令）。 [外链图片转存中...(img-phs6g12w-1653145947297)]\n\n 2. 复制的实现\n\n * 设置主服务器地址和端口。slaveof 127.0.0.1 6379。从服务器保存主服务器地址和端口。\n * 建立套接字。从服务器根据保存的主服务器地址和端口号，建立套接字。\n * 从服务器发送ping命令。超时或者错误则重新建立套接字重试；返回“pong”说明网络连接正常。\n * 身份验证。主从都没有设置身份验证或者设置一致才可以通过身份验证。\n * 从服务器发送监听端口，主服务器将其保存在redisclient的slave_listening_port;\n * 同步。从服务器向主服务发送psync命令。 [外链图片转存中...(img-jbqvvk4o-1653145947297)]\n\n 3. 心跳检测\n\n> 从服务器每秒发送命令给主服务器，replconf ack offset,有三个作用\n\n * 检测链接状况\n * 辅助实现min-slaves选项。min-slaves-to-write 3，min-slaves-max-lag 10。表示从服务器少于3个，或者从服务延迟都大于等于10，主服务器将终止写命令。\n * 检测命令丢失",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 Redis 中跳表的应用以及优缺点",frontmatter:{title:"简述 Redis 中跳表的应用以及优缺点",date:"2022-05-21T17:22:09.000Z",permalink:"/pages/a42826/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/050.%E7%AE%80%E8%BF%B0%20Redis%20%E4%B8%AD%E8%B7%B3%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9.html",relativePath:"03.数据库/02.REDIS相关/050.简述 Redis 中跳表的应用以及优缺点.md",key:"v-18b427a0",path:"/pages/a42826/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Redis的缓存淘汰策略有哪些？",frontmatter:{title:"Redis的缓存淘汰策略有哪些？",date:"2022-05-21T17:20:33.000Z",permalink:"/pages/9326cc/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/010.Redis%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.html",relativePath:"03.数据库/02.REDIS相关/010.Redis的缓存淘汰策略有哪些？.md",key:"v-c0bc7b7a",path:"/pages/9326cc/",headers:[{level:2,title:"过期键",slug:"过期键",normalizedTitle:"过期键",charIndex:2},{level:2,title:"内存淘汰策略（内存不足时)",slug:"内存淘汰策略-内存不足时",normalizedTitle:"内存淘汰策略（内存不足时)",charIndex:235}],headersStr:"过期键 内存淘汰策略（内存不足时)",content:"# 过期键\n\n * 删除过期键的策略\n   \n   * 定时：对内存友好，对cpu不友好\n   * 惰性：对内存不友好，对cpu友好\n   * 定期：是定时和惰性的折中方案。执行时长和频率是衡量一个定期策略好坏的标准。\n\n * rdb再说生成和加载过程中过滤掉过期的键\n\n * aof模式下，过期的键只有真正del的时候才会记录在aof文件。重写aof文件不会包含过期的键。\n\n * 主从复制：从服务器遇到过期键不会del，接收到主服务器的del命令才会删除。\n\n\n# 内存淘汰策略（内存不足时)\n\n * noeviction：抛异常\n * allkeys-lru：在所有的key中按lru淘汰\n * allkeys-random:在所有的key中随机淘汰\n * volatile-lru：在设置了过期时间的key中lru淘汰\n * volatile-random:在设置了过期时间的key中随机淘汰\n * volatile-ttl：删除快过期的key",normalizedContent:"# 过期键\n\n * 删除过期键的策略\n   \n   * 定时：对内存友好，对cpu不友好\n   * 惰性：对内存不友好，对cpu友好\n   * 定期：是定时和惰性的折中方案。执行时长和频率是衡量一个定期策略好坏的标准。\n\n * rdb再说生成和加载过程中过滤掉过期的键\n\n * aof模式下，过期的键只有真正del的时候才会记录在aof文件。重写aof文件不会包含过期的键。\n\n * 主从复制：从服务器遇到过期键不会del，接收到主服务器的del命令才会删除。\n\n\n# 内存淘汰策略（内存不足时)\n\n * noeviction：抛异常\n * allkeys-lru：在所有的key中按lru淘汰\n * allkeys-random:在所有的key中随机淘汰\n * volatile-lru：在设置了过期时间的key中lru淘汰\n * volatile-random:在设置了过期时间的key中随机淘汰\n * volatile-ttl：删除快过期的key",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点",frontmatter:{title:"简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点",date:"2022-05-21T17:21:43.000Z",permalink:"/pages/7e708d/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/020.%E7%AE%80%E8%BF%B0%20Redis%20%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%AD%20RDB%20%E4%BB%A5%E5%8F%8A%20AOF%20%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.html",relativePath:"03.数据库/02.REDIS相关/020.简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点.md",key:"v-7c214d00",path:"/pages/7e708d/",headers:[{level:2,title:"RDB持久化",slug:"rdb持久化",normalizedTitle:"rdb持久化",charIndex:2},{level:2,title:"AOF持久化",slug:"aof持久化",normalizedTitle:"aof持久化",charIndex:1345}],headersStr:"RDB持久化 AOF持久化",content:'# RDB持久化\n\n 1. save和bgsave源码\n\nvoid saveCommand(redisClient *c) {\n\n   // BGSAVE 已经在执行中，不能再执行 SAVE\n   // 否则将产生竞争条件\n   if (server.rdb_child_pid != -1) {\n       addReplyError(c,"Background save already in progress");\n       return;\n   }\n\n   // 执行 \n   if (rdbSave(server.rdb_filename) == REDIS_OK) {\n       addReply(c,shared.ok);\n   } else {\n       addReply(c,shared.err);\n   }\n}\n\nvoid bgsaveCommand(redisClient *c) {\n\n   // 不能重复执行 BGSAVE\n   if (server.rdb_child_pid != -1) {\n       addReplyError(c,"Background save already in progress");\n\n   // 不能在 BGREWRITEAOF 正在运行时执行\n   } else if (server.aof_child_pid != -1) {\n       addReplyError(c,"Can\'t BGSAVE while AOF log rewriting is in progress");\n\n   // 执行 BGSAVE\n   } else if (rdbSaveBackground(server.rdb_filename) == REDIS_OK) {\n       addReplyStatus(c,"Background saving started");\n\n   } else {\n       addReply(c,shared.err);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n 2. 自动间隔性保存\n\n> 服务器间隔性检车saveparams中的任意一个条件是否得到满足，如果得到满足，执行bgsave.saveparams[0]表示距离上次bgsave900s内,至少有一次数据库变化。\n\n[外链图片转存中...(img-SwAqAX8z-1653145947293)]\n\n 3. rdb文件结构 [外链图片转存中...(img-Prs54pGE-1653145947294)] 其中database结构如下： [外链图片转存中...(img-rn1gUv6w-1653145947294)] 其中ksy_value_pairs结构如下 [外链图片转存中...(img-B62S2gV5-1653145947295)]\n\n> type指定了value的类型。value的编码方式不同期存储结构也不同。\n\n\n# AOF持久化\n\n 1. aof的实现 命令追加：所有客户端命令都会被存到redis_server的aof_buf缓冲区。 文件写入：操作系统在写入文件的时候，先写入缓存，缓存满了才写入文件。 文件同步：flushAppendOnlyFile()负责将aof_buf写入文件aof。\n\n> flushAppendOnlyFile中配置的appendfsync决定同步策略。appendfsync有三个取值：always(每次写入都同步)、everysec(每次事件都写入但不同步，每秒同步)、 no(每次事件都写入但不同步，操作系统决定同步)；\n\n 2. aof的载入与还原 [外链图片转存中...(img-pNMyXRLJ-1653145947295)]\n 3. AOF重写 [外链图片转存中...(img-i1nhwgNs-1653145947295)]',normalizedContent:'# rdb持久化\n\n 1. save和bgsave源码\n\nvoid savecommand(redisclient *c) {\n\n   // bgsave 已经在执行中，不能再执行 save\n   // 否则将产生竞争条件\n   if (server.rdb_child_pid != -1) {\n       addreplyerror(c,"background save already in progress");\n       return;\n   }\n\n   // 执行 \n   if (rdbsave(server.rdb_filename) == redis_ok) {\n       addreply(c,shared.ok);\n   } else {\n       addreply(c,shared.err);\n   }\n}\n\nvoid bgsavecommand(redisclient *c) {\n\n   // 不能重复执行 bgsave\n   if (server.rdb_child_pid != -1) {\n       addreplyerror(c,"background save already in progress");\n\n   // 不能在 bgrewriteaof 正在运行时执行\n   } else if (server.aof_child_pid != -1) {\n       addreplyerror(c,"can\'t bgsave while aof log rewriting is in progress");\n\n   // 执行 bgsave\n   } else if (rdbsavebackground(server.rdb_filename) == redis_ok) {\n       addreplystatus(c,"background saving started");\n\n   } else {\n       addreply(c,shared.err);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n 2. 自动间隔性保存\n\n> 服务器间隔性检车saveparams中的任意一个条件是否得到满足，如果得到满足，执行bgsave.saveparams[0]表示距离上次bgsave900s内,至少有一次数据库变化。\n\n[外链图片转存中...(img-swaqax8z-1653145947293)]\n\n 3. rdb文件结构 [外链图片转存中...(img-prs54pge-1653145947294)] 其中database结构如下： [外链图片转存中...(img-rn1guv6w-1653145947294)] 其中ksy_value_pairs结构如下 [外链图片转存中...(img-b62s2gv5-1653145947295)]\n\n> type指定了value的类型。value的编码方式不同期存储结构也不同。\n\n\n# aof持久化\n\n 1. aof的实现 命令追加：所有客户端命令都会被存到redis_server的aof_buf缓冲区。 文件写入：操作系统在写入文件的时候，先写入缓存，缓存满了才写入文件。 文件同步：flushappendonlyfile()负责将aof_buf写入文件aof。\n\n> flushappendonlyfile中配置的appendfsync决定同步策略。appendfsync有三个取值：always(每次写入都同步)、everysec(每次事件都写入但不同步，每秒同步)、 no(每次事件都写入但不同步，操作系统决定同步)；\n\n 2. aof的载入与还原 [外链图片转存中...(img-pnmyxrlj-1653145947295)]\n 3. aof重写 [外链图片转存中...(img-i1nhwgns-1653145947295)]',charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 Redis 中如何防止缓存雪崩和缓存击穿",frontmatter:{title:"简述 Redis 中如何防止缓存雪崩和缓存击穿",date:"2022-05-21T17:22:52.000Z",permalink:"/pages/03cd25/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/070.%E7%AE%80%E8%BF%B0%20Redis%20%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.html",relativePath:"03.数据库/02.REDIS相关/070.简述 Redis 中如何防止缓存雪崩和缓存击穿.md",key:"v-c2fe5e1a",path:"/pages/03cd25/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 Redis 的线程模型以及底层架构设计",frontmatter:{title:"简述 Redis 的线程模型以及底层架构设计",date:"2022-05-21T17:23:08.000Z",permalink:"/pages/9c28c9/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/080.%E7%AE%80%E8%BF%B0%20Redis%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",relativePath:"03.数据库/02.REDIS相关/080.简述 Redis 的线程模型以及底层架构设计.md",key:"v-35718f4e",path:"/pages/9c28c9/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Redis 中，sentinel 和 cluster 的区别和适用场景是什么？",frontmatter:{title:"Redis 中，sentinel 和 cluster 的区别和适用场景是什么？",date:"2022-05-21T17:22:27.000Z",permalink:"/pages/e2e910/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/060.Redis%20%E4%B8%AD%EF%BC%8Csentinel%20%E5%92%8C%20cluster%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",relativePath:"03.数据库/02.REDIS相关/060.Redis 中，sentinel 和 cluster 的区别和适用场景是什么？.md",key:"v-6a45f68d",path:"/pages/e2e910/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 Redis 的哨兵机制",frontmatter:{title:"简述 Redis 的哨兵机制",date:"2022-05-21T17:23:24.000Z",permalink:"/pages/cc8507/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/100.%E7%AE%80%E8%BF%B0%20Redis%20%E7%9A%84%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6.html",relativePath:"03.数据库/02.REDIS相关/100.简述 Redis 的哨兵机制.md",key:"v-57957421",path:"/pages/cc8507/",headers:[{level:2,title:"sentinel",slug:"sentinel",normalizedTitle:"sentinel",charIndex:2}],headersStr:"sentinel",content:"# sentinel\n\n> 负责redis高可用，检测主服务器下线，然后选举一个从服务器成为新的主服务器。\n\n 1. 源码\n\n// Sentinel 会为每个被监视的 Redis 实例创建相应的 sentinelRedisInstance 实例\n// （被监视的实例可以是主服务器、从服务器、或者其他 Sentinel ）\ntypedef struct sentinelRedisInstance {\n    \n    // 标识值，记录了实例的类型，以及该实例的当前状态\n    int flags;      /* See SRI_... defines */\n    \n    // 实例的名字\n    // 主服务器的名字由用户在配置文件中设置\n    // 从服务器以及 Sentinel 的名字由 Sentinel 自动设置\n    // 格式为 ip:port ，例如 \"127.0.0.1:26379\"\n    char *name;     /* Master name from the point of view of this sentinel. */\n\n    // 实例的运行 ID\n    char *runid;    /* run ID of this instance. */\n\n    // 配置纪元，用于实现故障转移\n    uint64_t config_epoch;  /* Configuration epoch. */\n\n    // 实例的地址\n    sentinelAddr *addr; /* Master host. */\n\n    // 用于发送命令的异步连接\n    redisAsyncContext *cc; /* Hiredis context for commands. */\n\n    // 用于执行 SUBSCRIBE 命令、接收频道信息的异步连接\n    // 仅在实例为主服务器时使用\n    redisAsyncContext *pc; /* Hiredis context for Pub / Sub. */\n\n    // 已发送但尚未回复的命令数量\n    int pending_commands;   /* Number of commands sent waiting for a reply. */\n\n    // cc 连接的创建时间\n    mstime_t cc_conn_time; /* cc connection time. */\n    \n    // pc 连接的创建时间\n    mstime_t pc_conn_time; /* pc connection time. */\n\n    // 最后一次从这个实例接收信息的时间\n    mstime_t pc_last_activity; /* Last time we received any message. */\n\n    // 实例最后一次返回正确的 PING 命令回复的时间\n    mstime_t last_avail_time; /* Last time the instance replied to ping with\n                                 a reply we consider valid. */\n    // 实例最后一次发送 PING 命令的时间\n    mstime_t last_ping_time;  /* Last time a pending ping was sent in the\n                                 context of the current command connection\n                                 with the instance. 0 if still not sent or\n                                 if pong already received. */\n    // 实例最后一次返回 PING 命令的时间，无论内容正确与否\n    mstime_t last_pong_time;  /* Last time the instance replied to ping,\n                                 whatever the reply was. That's used to check\n                                 if the link is idle and must be reconnected. */\n\n    // 最后一次向频道发送问候信息的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_pub_time;   /* Last time we sent hello via Pub/Sub. */\n\n    // 最后一次接收到这个 sentinel 发来的问候信息的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_hello_time; /* Only used if SRI_SENTINEL is set. Last time\n                                 we received a hello from this Sentinel\n                                 via Pub/Sub. */\n\n    // 最后一次回复 SENTINEL is-master-down-by-addr 命令的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_master_down_reply_time; /* Time of last reply to\n                                             SENTINEL is-master-down command. */\n\n    // 实例被判断为 SDOWN 状态的时间\n    mstime_t s_down_since_time; /* Subjectively down since time. */\n\n    // 实例被判断为 ODOWN 状态的时间\n    mstime_t o_down_since_time; /* Objectively down since time. */\n\n    // SENTINEL down-after-milliseconds 选项所设定的值\n    // 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）\n    mstime_t down_after_period; /* Consider it down after that period. */\n\n    // 从实例获取 INFO 命令的回复的时间\n    mstime_t info_refresh;  /* Time at which we received INFO output from it. */\n\n    /* Role and the first time we observed it.\n     * This is useful in order to delay replacing what the instance reports\n     * with our own configuration. We need to always wait some time in order\n     * to give a chance to the leader to report the new configuration before\n     * we do silly things. */\n    // 实例的角色\n    int role_reported;\n    // 角色的更新时间\n    mstime_t role_reported_time;\n\n    // 最后一次从服务器的主服务器地址变更的时间\n    mstime_t slave_conf_change_time; /* Last time slave master addr changed. */\n\n    /* Master specific. */\n    /* 主服务器实例特有的属性 -------------------------------------------------------------*/\n\n    // 其他同样监控这个主服务器的所有 sentinel\n    dict *sentinels;    /* Other sentinels monitoring the same master. */\n\n    // 如果这个实例代表的是一个主服务器\n    // 那么这个字典保存着主服务器属下的从服务器\n    // 字典的键是从服务器的名字，字典的值是从服务器对应的 sentinelRedisInstance 结构\n    dict *slaves;       /* Slaves for this master instance. */\n\n    // SENTINEL monitor <master-name> <IP> <port> <quorum> 选项中的 quorum 参数\n    // 判断这个实例为客观下线（objectively down）所需的支持投票数量\n    int quorum;         /* Number of sentinels that need to agree on failure. */\n\n    // SENTINEL parallel-syncs <master-name> <number> 选项的值\n    // 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量\n    int parallel_syncs; /* How many slaves to reconfigure at same time. */\n\n    // 连接主服务器和从服务器所需的密码\n    char *auth_pass;    /* Password to use for AUTH against master & slaves. */\n\n    /* Slave specific. */\n    /* 从服务器实例特有的属性 -------------------------------------------------------------*/\n\n    // 主从服务器连接断开的时间\n    mstime_t master_link_down_time; /* Slave replication link down time. */\n\n    // 从服务器优先级\n    int slave_priority; /* Slave priority according to its INFO output. */\n\n    // 执行故障转移操作时，从服务器发送 SLAVEOF <new-master> 命令的时间\n    mstime_t slave_reconf_sent_time; /* Time at which we sent SLAVE OF <new> */\n\n    // 主服务器的实例（在本实例为从服务器时使用）\n    struct sentinelRedisInstance *master; /* Master instance if it's slave. */\n\n    // INFO 命令的回复中记录的主服务器 IP\n    char *slave_master_host;    /* Master host as reported by INFO */\n    \n    // INFO 命令的回复中记录的主服务器端口号\n    int slave_master_port;      /* Master port as reported by INFO */\n\n    // INFO 命令的回复中记录的主从服务器连接状态\n    int slave_master_link_status; /* Master link status as reported by INFO */\n\n    // 从服务器的复制偏移量\n    unsigned long long slave_repl_offset; /* Slave replication offset. */\n\n    /* Failover */\n    /* 故障转移相关属性 -------------------------------------------------------------------*/\n\n\n    // 如果这是一个主服务器实例，那么 leader 将是负责进行故障转移的 Sentinel 的运行 ID 。\n    // 如果这是一个 Sentinel 实例，那么 leader 就是被选举出来的领头 Sentinel 。\n    // 这个域只在 Sentinel 实例的 flags 属性的 SRI_MASTER_DOWN 标志处于打开状态时才有效。\n    char *leader;       /* If this is a master instance, this is the runid of\n                           the Sentinel that should perform the failover. If\n                           this is a Sentinel, this is the runid of the Sentinel\n                           that this Sentinel voted as leader. */\n    // 领头的纪元\n    uint64_t leader_epoch; /* Epoch of the 'leader' field. */\n    // 当前执行中的故障转移的纪元\n    uint64_t failover_epoch; /* Epoch of the currently started failover. */\n    // 故障转移操作的当前状态\n    int failover_state; /* See SENTINEL_FAILOVER_STATE_* defines. */\n\n    // 状态改变的时间\n    mstime_t failover_state_change_time;\n\n    // 最后一次进行故障迁移的时间\n    mstime_t failover_start_time;   /* Last failover attempt start time. */\n\n    // SENTINEL failover-timeout <master-name> <ms> 选项的值\n    // 刷新故障迁移状态的最大时限\n    mstime_t failover_timeout;      /* Max time to refresh failover state. */\n\n    mstime_t failover_delay_logged; /* For what failover_start_time value we\n                                       logged the failover delay. */\n    // 指向被提升为新主服务器的从服务器的指针\n    struct sentinelRedisInstance *promoted_slave; /* Promoted slave instance. */\n\n    /* Scripts executed to notify admin or reconfigure clients: when they\n     * are set to NULL no script is executed. */\n    // 一个文件路径，保存着 WARNING 级别的事件发生时执行的，\n    // 用于通知管理员的脚本的地址\n    char *notification_script;\n\n    // 一个文件路径，保存着故障转移执行之前、之后、或者被中止时，\n    // 需要执行的脚本的地址\n    char *client_reconfig_script;\n\n} sentinelRedisInstance;\n\n/* Main state. */\n/* Sentinel 的状态结构 */\nstruct sentinelState {\n\n    // 当前纪元\n    uint64_t current_epoch;     /* Current epoch. */\n\n    // 保存了所有被这个 sentinel 监视的主服务器\n    // 字典的键是主服务器的名字\n    // 字典的值则是一个指向 sentinelRedisInstance 结构的指针\n    dict *masters;      /* Dictionary of master sentinelRedisInstances.\n                           Key is the instance name, value is the\n                           sentinelRedisInstance structure pointer. */\n\n    // 是否进入了 TILT 模式？\n    int tilt;           /* Are we in TILT mode? */\n\n    // 目前正在执行的脚本的数量\n    int running_scripts;    /* Number of scripts in execution right now. */\n\n    // 进入 TILT 模式的时间\n    mstime_t tilt_start_time;   /* When TITL started. */\n\n    // 最后一次执行时间处理器的时间\n    mstime_t previous_time;     /* Last time we ran the time handler. */\n\n    // 一个 FIFO 队列，包含了所有需要执行的用户脚本\n    list *scripts_queue;    /* Queue of user scripts to execute. */\n\n} sentinel;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n\n 2. 启动并初始化sentinel\n\n * 启动命令：Redis-sentinel /path/sentinel.conf\n * 初始化服务器\n * 使用sentinel专用代码\n * 初始化sentinel状态。sentinelState{}\n * 初始化masters属性。根据配置文件来生成。 [外链图片转存中...(img-gEx8X9Le-1653145947298)]\n * 创建两个链接主服务器的异步网络：一个命令链接；一个订阅链接。\n * 获取服务器信息。10s/次向主服务器发送info命令。获取主从信息。更新主从信息。从信息的保存结构如下： [外链图片转存中...(img-aBn6piJg-1653145947298)]\n * 获取从服务器信息。获取从服务器信息。sentinel发现主服务器有从服务器时，保存从服务器并创建两个异步链接：命令链接和订阅链接。10s/次向从服务器发送命令获取信息更新本地存储。\n * 向主从发送信息。2s/次通过命令连接发送信息。发送频道_sentinel_:hello\n * 接收信息。接收频道 sentinel:hello（用于发现新的sentinel）\n * 更新sentinel字典。sentinelResidInstance结构中的sentinels保存这个主服务器的所有sentinel。接收到_sentinel_:hello频道的消息时，更新sentinel.\n * 创建sentinel之间的连接。(不创建订阅链接)\n\n 3. 检测主观下线状态\n\n> sentinel每秒向它连接的实例发送ping命令。返回+pong、-loading、-masterdown是有效回复。其他回复或者指定时间没回复则认为无效。配置项down-after-milliseconds指定了sentinel判断主观下线时间长度。如果一个实例在down-after-milliseconds时间内连续向sentinel返回无效，则认为主观下线。\n\n * sentinelRedisInstance中的master属性有主观下线标识。\n * down-after-milliseconds是master下线的标准，也是master下slaves下线的标准，也是其他sentinel判断master下线的标准。\n * 多个sentinel设置同一个msater的down-after-milliseconds可能不同\n\n 4. 客观下线\n\n> sentinel判断一个master已经主观下线，会询问其他sentinel，如果一定数量 的都认为这个master已经主观下线，则判定这个master客观下线。然后做故障转移。\n\n * 发送sentinel is-master-down-by-addr命令询问其他sentinel\n * sentinel配置中的quorum参数决定有几个sentinel判断下线才能算是下线\n * 当一个msater被判定为客观下线时，监视这个master的各个sentinel之间会选举一个为领头sentinel，做故障转移。\n * 故障转移：选一个先master、slaves同步新的master、旧的master成为新master的slave\n\n 5. 选举领头sentinel\n\n> 当一个主服务器下线后，在监管这个主服务器的sentinel中选举一个领头sentinel。用于故障转移\n\n[外链图片转存中...(img-5XFvVtzH-1653145947298)] 6. 故障转移 领头sentinel完成故障转移需要三个步骤：\n\n * 在从服务器中选一个成为新的主服务器。sentinel在从服务器中选举一个，向其发送命令slaveof no one,使之成为主服务器。发送slaveof no one明后后每秒发送info命令观察role是不是变成了master。\n * 让从服务器同步新的主服务器. [外链图片转存中...(img-jz4GYou9-1653145947299)]\n * 让旧的主服务器成为新的主服务器的从服务器，当其上线时，成为从服务器。",normalizedContent:"# sentinel\n\n> 负责redis高可用，检测主服务器下线，然后选举一个从服务器成为新的主服务器。\n\n 1. 源码\n\n// sentinel 会为每个被监视的 redis 实例创建相应的 sentinelredisinstance 实例\n// （被监视的实例可以是主服务器、从服务器、或者其他 sentinel ）\ntypedef struct sentinelredisinstance {\n    \n    // 标识值，记录了实例的类型，以及该实例的当前状态\n    int flags;      /* see sri_... defines */\n    \n    // 实例的名字\n    // 主服务器的名字由用户在配置文件中设置\n    // 从服务器以及 sentinel 的名字由 sentinel 自动设置\n    // 格式为 ip:port ，例如 \"127.0.0.1:26379\"\n    char *name;     /* master name from the point of view of this sentinel. */\n\n    // 实例的运行 id\n    char *runid;    /* run id of this instance. */\n\n    // 配置纪元，用于实现故障转移\n    uint64_t config_epoch;  /* configuration epoch. */\n\n    // 实例的地址\n    sentineladdr *addr; /* master host. */\n\n    // 用于发送命令的异步连接\n    redisasynccontext *cc; /* hiredis context for commands. */\n\n    // 用于执行 subscribe 命令、接收频道信息的异步连接\n    // 仅在实例为主服务器时使用\n    redisasynccontext *pc; /* hiredis context for pub / sub. */\n\n    // 已发送但尚未回复的命令数量\n    int pending_commands;   /* number of commands sent waiting for a reply. */\n\n    // cc 连接的创建时间\n    mstime_t cc_conn_time; /* cc connection time. */\n    \n    // pc 连接的创建时间\n    mstime_t pc_conn_time; /* pc connection time. */\n\n    // 最后一次从这个实例接收信息的时间\n    mstime_t pc_last_activity; /* last time we received any message. */\n\n    // 实例最后一次返回正确的 ping 命令回复的时间\n    mstime_t last_avail_time; /* last time the instance replied to ping with\n                                 a reply we consider valid. */\n    // 实例最后一次发送 ping 命令的时间\n    mstime_t last_ping_time;  /* last time a pending ping was sent in the\n                                 context of the current command connection\n                                 with the instance. 0 if still not sent or\n                                 if pong already received. */\n    // 实例最后一次返回 ping 命令的时间，无论内容正确与否\n    mstime_t last_pong_time;  /* last time the instance replied to ping,\n                                 whatever the reply was. that's used to check\n                                 if the link is idle and must be reconnected. */\n\n    // 最后一次向频道发送问候信息的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_pub_time;   /* last time we sent hello via pub/sub. */\n\n    // 最后一次接收到这个 sentinel 发来的问候信息的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_hello_time; /* only used if sri_sentinel is set. last time\n                                 we received a hello from this sentinel\n                                 via pub/sub. */\n\n    // 最后一次回复 sentinel is-master-down-by-addr 命令的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_master_down_reply_time; /* time of last reply to\n                                             sentinel is-master-down command. */\n\n    // 实例被判断为 sdown 状态的时间\n    mstime_t s_down_since_time; /* subjectively down since time. */\n\n    // 实例被判断为 odown 状态的时间\n    mstime_t o_down_since_time; /* objectively down since time. */\n\n    // sentinel down-after-milliseconds 选项所设定的值\n    // 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）\n    mstime_t down_after_period; /* consider it down after that period. */\n\n    // 从实例获取 info 命令的回复的时间\n    mstime_t info_refresh;  /* time at which we received info output from it. */\n\n    /* role and the first time we observed it.\n     * this is useful in order to delay replacing what the instance reports\n     * with our own configuration. we need to always wait some time in order\n     * to give a chance to the leader to report the new configuration before\n     * we do silly things. */\n    // 实例的角色\n    int role_reported;\n    // 角色的更新时间\n    mstime_t role_reported_time;\n\n    // 最后一次从服务器的主服务器地址变更的时间\n    mstime_t slave_conf_change_time; /* last time slave master addr changed. */\n\n    /* master specific. */\n    /* 主服务器实例特有的属性 -------------------------------------------------------------*/\n\n    // 其他同样监控这个主服务器的所有 sentinel\n    dict *sentinels;    /* other sentinels monitoring the same master. */\n\n    // 如果这个实例代表的是一个主服务器\n    // 那么这个字典保存着主服务器属下的从服务器\n    // 字典的键是从服务器的名字，字典的值是从服务器对应的 sentinelredisinstance 结构\n    dict *slaves;       /* slaves for this master instance. */\n\n    // sentinel monitor <master-name> <ip> <port> <quorum> 选项中的 quorum 参数\n    // 判断这个实例为客观下线（objectively down）所需的支持投票数量\n    int quorum;         /* number of sentinels that need to agree on failure. */\n\n    // sentinel parallel-syncs <master-name> <number> 选项的值\n    // 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量\n    int parallel_syncs; /* how many slaves to reconfigure at same time. */\n\n    // 连接主服务器和从服务器所需的密码\n    char *auth_pass;    /* password to use for auth against master & slaves. */\n\n    /* slave specific. */\n    /* 从服务器实例特有的属性 -------------------------------------------------------------*/\n\n    // 主从服务器连接断开的时间\n    mstime_t master_link_down_time; /* slave replication link down time. */\n\n    // 从服务器优先级\n    int slave_priority; /* slave priority according to its info output. */\n\n    // 执行故障转移操作时，从服务器发送 slaveof <new-master> 命令的时间\n    mstime_t slave_reconf_sent_time; /* time at which we sent slave of <new> */\n\n    // 主服务器的实例（在本实例为从服务器时使用）\n    struct sentinelredisinstance *master; /* master instance if it's slave. */\n\n    // info 命令的回复中记录的主服务器 ip\n    char *slave_master_host;    /* master host as reported by info */\n    \n    // info 命令的回复中记录的主服务器端口号\n    int slave_master_port;      /* master port as reported by info */\n\n    // info 命令的回复中记录的主从服务器连接状态\n    int slave_master_link_status; /* master link status as reported by info */\n\n    // 从服务器的复制偏移量\n    unsigned long long slave_repl_offset; /* slave replication offset. */\n\n    /* failover */\n    /* 故障转移相关属性 -------------------------------------------------------------------*/\n\n\n    // 如果这是一个主服务器实例，那么 leader 将是负责进行故障转移的 sentinel 的运行 id 。\n    // 如果这是一个 sentinel 实例，那么 leader 就是被选举出来的领头 sentinel 。\n    // 这个域只在 sentinel 实例的 flags 属性的 sri_master_down 标志处于打开状态时才有效。\n    char *leader;       /* if this is a master instance, this is the runid of\n                           the sentinel that should perform the failover. if\n                           this is a sentinel, this is the runid of the sentinel\n                           that this sentinel voted as leader. */\n    // 领头的纪元\n    uint64_t leader_epoch; /* epoch of the 'leader' field. */\n    // 当前执行中的故障转移的纪元\n    uint64_t failover_epoch; /* epoch of the currently started failover. */\n    // 故障转移操作的当前状态\n    int failover_state; /* see sentinel_failover_state_* defines. */\n\n    // 状态改变的时间\n    mstime_t failover_state_change_time;\n\n    // 最后一次进行故障迁移的时间\n    mstime_t failover_start_time;   /* last failover attempt start time. */\n\n    // sentinel failover-timeout <master-name> <ms> 选项的值\n    // 刷新故障迁移状态的最大时限\n    mstime_t failover_timeout;      /* max time to refresh failover state. */\n\n    mstime_t failover_delay_logged; /* for what failover_start_time value we\n                                       logged the failover delay. */\n    // 指向被提升为新主服务器的从服务器的指针\n    struct sentinelredisinstance *promoted_slave; /* promoted slave instance. */\n\n    /* scripts executed to notify admin or reconfigure clients: when they\n     * are set to null no script is executed. */\n    // 一个文件路径，保存着 warning 级别的事件发生时执行的，\n    // 用于通知管理员的脚本的地址\n    char *notification_script;\n\n    // 一个文件路径，保存着故障转移执行之前、之后、或者被中止时，\n    // 需要执行的脚本的地址\n    char *client_reconfig_script;\n\n} sentinelredisinstance;\n\n/* main state. */\n/* sentinel 的状态结构 */\nstruct sentinelstate {\n\n    // 当前纪元\n    uint64_t current_epoch;     /* current epoch. */\n\n    // 保存了所有被这个 sentinel 监视的主服务器\n    // 字典的键是主服务器的名字\n    // 字典的值则是一个指向 sentinelredisinstance 结构的指针\n    dict *masters;      /* dictionary of master sentinelredisinstances.\n                           key is the instance name, value is the\n                           sentinelredisinstance structure pointer. */\n\n    // 是否进入了 tilt 模式？\n    int tilt;           /* are we in tilt mode? */\n\n    // 目前正在执行的脚本的数量\n    int running_scripts;    /* number of scripts in execution right now. */\n\n    // 进入 tilt 模式的时间\n    mstime_t tilt_start_time;   /* when titl started. */\n\n    // 最后一次执行时间处理器的时间\n    mstime_t previous_time;     /* last time we ran the time handler. */\n\n    // 一个 fifo 队列，包含了所有需要执行的用户脚本\n    list *scripts_queue;    /* queue of user scripts to execute. */\n\n} sentinel;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n\n 2. 启动并初始化sentinel\n\n * 启动命令：redis-sentinel /path/sentinel.conf\n * 初始化服务器\n * 使用sentinel专用代码\n * 初始化sentinel状态。sentinelstate{}\n * 初始化masters属性。根据配置文件来生成。 [外链图片转存中...(img-gex8x9le-1653145947298)]\n * 创建两个链接主服务器的异步网络：一个命令链接；一个订阅链接。\n * 获取服务器信息。10s/次向主服务器发送info命令。获取主从信息。更新主从信息。从信息的保存结构如下： [外链图片转存中...(img-abn6pijg-1653145947298)]\n * 获取从服务器信息。获取从服务器信息。sentinel发现主服务器有从服务器时，保存从服务器并创建两个异步链接：命令链接和订阅链接。10s/次向从服务器发送命令获取信息更新本地存储。\n * 向主从发送信息。2s/次通过命令连接发送信息。发送频道_sentinel_:hello\n * 接收信息。接收频道 sentinel:hello（用于发现新的sentinel）\n * 更新sentinel字典。sentinelresidinstance结构中的sentinels保存这个主服务器的所有sentinel。接收到_sentinel_:hello频道的消息时，更新sentinel.\n * 创建sentinel之间的连接。(不创建订阅链接)\n\n 3. 检测主观下线状态\n\n> sentinel每秒向它连接的实例发送ping命令。返回+pong、-loading、-masterdown是有效回复。其他回复或者指定时间没回复则认为无效。配置项down-after-milliseconds指定了sentinel判断主观下线时间长度。如果一个实例在down-after-milliseconds时间内连续向sentinel返回无效，则认为主观下线。\n\n * sentinelredisinstance中的master属性有主观下线标识。\n * down-after-milliseconds是master下线的标准，也是master下slaves下线的标准，也是其他sentinel判断master下线的标准。\n * 多个sentinel设置同一个msater的down-after-milliseconds可能不同\n\n 4. 客观下线\n\n> sentinel判断一个master已经主观下线，会询问其他sentinel，如果一定数量 的都认为这个master已经主观下线，则判定这个master客观下线。然后做故障转移。\n\n * 发送sentinel is-master-down-by-addr命令询问其他sentinel\n * sentinel配置中的quorum参数决定有几个sentinel判断下线才能算是下线\n * 当一个msater被判定为客观下线时，监视这个master的各个sentinel之间会选举一个为领头sentinel，做故障转移。\n * 故障转移：选一个先master、slaves同步新的master、旧的master成为新master的slave\n\n 5. 选举领头sentinel\n\n> 当一个主服务器下线后，在监管这个主服务器的sentinel中选举一个领头sentinel。用于故障转移\n\n[外链图片转存中...(img-5xfvvtzh-1653145947298)] 6. 故障转移 领头sentinel完成故障转移需要三个步骤：\n\n * 在从服务器中选一个成为新的主服务器。sentinel在从服务器中选举一个，向其发送命令slaveof no one,使之成为主服务器。发送slaveof no one明后后每秒发送info命令观察role是不是变成了master。\n * 让从服务器同步新的主服务器. [外链图片转存中...(img-jz4gyou9-1653145947299)]\n * 让旧的主服务器成为新的主服务器的从服务器，当其上线时，成为从服务器。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"简述 Redis 如何处理热点 key 访问",frontmatter:{title:"简述 Redis 如何处理热点 key 访问",date:"2022-05-21T17:23:43.000Z",permalink:"/pages/795c09/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/110.%E7%AE%80%E8%BF%B0%20Redis%20%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%83%AD%E7%82%B9%20key%20%E8%AE%BF%E9%97%AE.html",relativePath:"03.数据库/02.REDIS相关/110.简述 Redis 如何处理热点 key 访问.md",key:"v-37f158ba",path:"/pages/795c09/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Redis 序列化有哪些方式？",frontmatter:{title:"Redis 序列化有哪些方式？",date:"2022-05-21T17:23:58.000Z",permalink:"/pages/0d3c6b/",categories:["数据库","REDIS相关"],tags:[null]},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/120.Redis%20%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F.html",relativePath:"03.数据库/02.REDIS相关/120.Redis 序列化有哪些方式？.md",key:"v-02ea33c3",path:"/pages/0d3c6b/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Netty",frontmatter:{title:"Netty",date:"2020-05-21T21:50:26.000Z",permalink:"/pages/40f3c9/",categories:["中间件","Netty"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/001.%E4%BD%A0%E7%86%9F%E6%82%89%E5%93%AA%E4%BA%9BIO%E6%A8%A1%E5%9E%8B%EF%BC%9F.html",relativePath:"04.中间件/10.Netty/001.你熟悉哪些IO模型？.md",key:"v-be02b3c0",path:"/pages/40f3c9/",headers:[{level:2,title:"1.1 I/O基础入门",slug:"_1-1-i-o基础入门",normalizedTitle:"1.1 i/o基础入门",charIndex:2},{level:3,title:"1.1.1 linux网络I/O模型简介",slug:"_1-1-1-linux网络i-o模型简介",normalizedTitle:"1.1.1 linux网络i/o模型简介",charIndex:141},{level:3,title:"I/O多路复用技术",slug:"i-o多路复用技术",normalizedTitle:"i/o多路复用技术",charIndex:425},{level:2,title:"1.2 Java的IO演进",slug:"_1-2-java的io演进",normalizedTitle:"1.2 java的io演进",charIndex:531},{level:2,title:"2.1 传统的BIO编程",slug:"_2-1-传统的bio编程",normalizedTitle:"2.1 传统的bio编程",charIndex:595},{level:3,title:"2.1.1 BIO通信模型图",slug:"_2-1-1-bio通信模型图",normalizedTitle:"2.1.1 bio通信模型图",charIndex:692},{level:2,title:"2.2 伪异步IO模型",slug:"_2-2-伪异步io模型",normalizedTitle:"2.2 伪异步io模型",charIndex:767},{level:2,title:"2.3 NIO模型",slug:"_2-3-nio模型",normalizedTitle:"2.3 nio模型",charIndex:877},{level:2,title:"2.3.1 NIO简介",slug:"_2-3-1-nio简介",normalizedTitle:"2.3.1 nio简介",charIndex:891},{level:2,title:"2.3.2 NIO服务序列图",slug:"_2-3-2-nio服务序列图",normalizedTitle:"2.3.2 nio服务序列图",charIndex:1035},{level:2,title:"2.4 AIO",slug:"_2-4-aio",normalizedTitle:"2.4 aio",charIndex:1056}],headersStr:"1.1 I/O基础入门 1.1.1 linux网络I/O模型简介 I/O多路复用技术 1.2 Java的IO演进 2.1 传统的BIO编程 2.1.1 BIO通信模型图 2.2 伪异步IO模型 2.3 NIO模型 2.3.1 NIO简介 2.3.2 NIO服务序列图 2.4 AIO",content:"# 1.1 I/O基础入门\n\nJava1.4之前对I/O的支持并不完善，给开发带来的问题有：\n\n * 没有数据缓冲区，I/O性能存在问题\n * 没有C/C++中channel的概念，只有输入输出流\n * BIO会导致通信被长时间阻塞\n * 支持的字符集优先，硬件移植性不好\n\n\n# 1.1.1 linux网络I/O模型简介\n\nlinux中所有的外部设备都是一个文件，socket也是一个文件，有文件描述符（fd）指向它。 UNIX提供5中I/O模型：\n\n * BIO模型：在进程空间调用recvfrom,直到有数据才返回。\n * NIO模型：轮训调用recvfrom。\n * I/O复用：linux提供select/poll，其支持多个fd的NIO，但是select/poll本身是阻塞的。epoll采用事件驱动的方式代替顺序扫描，其性能更高。\n * 信号驱动I/O模型：\n * 异步I/O:通知内核某个操作，并整个操作完成的时候通知我们。\n\n\n# I/O多路复用技术\n\nepoll优点：\n\n * 支持一个进程打开的fd不受限制\n * IO效率不会随着fd数量增加而下降\n * 使用mmap加速内核和用户空间的消息传递\n * epoll API更加简单\n\n\n# 1.2 Java的IO演进\n\n2011年JDK7发布：\n\n * 提供了能批量获取文件属性的API\n * 提供AIO功能\n\n\n# 2.1 传统的BIO编程\n\nCLient/Server模型中，Server负责绑定IP,启动监听端口；Client发起链接请求，经过三次握手建立连接，通过输入输出流进行同步阻塞式通信。\n\n\n# 2.1.1 BIO通信模型图\n\n通过Acceptor处理多个client连接请求，处理完成后销毁线程。 该模型的问题就是支持的线程数量有限。\n\n\n# 2.2 伪异步IO模型\n\n伪异步是为了解决BIO一个链路需要一个线程的问题。 通过一个线程池处理多个客户端的请求接入\n\n * 线程的数量不会大量膨胀导致资源耗尽\n * 问题是：没有解决同步IO导致的线程阻塞问题\n\n\n# 2.3 NIO模型\n\n\n# 2.3.1 NIO简介\n\n缓冲区buf 本质是一个字节数组（ByteBuff），同时提供数据的结构化访问以及维护读写位置。\n\n通道 channel channel是全双工的。 流是单向的。 多路复用 selector selector简单来说就是轮训注册在其上的channel,\n\n\n# 2.3.2 NIO服务序列图\n\n\n\n\n# 2.4 AIO",normalizedContent:"# 1.1 i/o基础入门\n\njava1.4之前对i/o的支持并不完善，给开发带来的问题有：\n\n * 没有数据缓冲区，i/o性能存在问题\n * 没有c/c++中channel的概念，只有输入输出流\n * bio会导致通信被长时间阻塞\n * 支持的字符集优先，硬件移植性不好\n\n\n# 1.1.1 linux网络i/o模型简介\n\nlinux中所有的外部设备都是一个文件，socket也是一个文件，有文件描述符（fd）指向它。 unix提供5中i/o模型：\n\n * bio模型：在进程空间调用recvfrom,直到有数据才返回。\n * nio模型：轮训调用recvfrom。\n * i/o复用：linux提供select/poll，其支持多个fd的nio，但是select/poll本身是阻塞的。epoll采用事件驱动的方式代替顺序扫描，其性能更高。\n * 信号驱动i/o模型：\n * 异步i/o:通知内核某个操作，并整个操作完成的时候通知我们。\n\n\n# i/o多路复用技术\n\nepoll优点：\n\n * 支持一个进程打开的fd不受限制\n * io效率不会随着fd数量增加而下降\n * 使用mmap加速内核和用户空间的消息传递\n * epoll api更加简单\n\n\n# 1.2 java的io演进\n\n2011年jdk7发布：\n\n * 提供了能批量获取文件属性的api\n * 提供aio功能\n\n\n# 2.1 传统的bio编程\n\nclient/server模型中，server负责绑定ip,启动监听端口；client发起链接请求，经过三次握手建立连接，通过输入输出流进行同步阻塞式通信。\n\n\n# 2.1.1 bio通信模型图\n\n通过acceptor处理多个client连接请求，处理完成后销毁线程。 该模型的问题就是支持的线程数量有限。\n\n\n# 2.2 伪异步io模型\n\n伪异步是为了解决bio一个链路需要一个线程的问题。 通过一个线程池处理多个客户端的请求接入\n\n * 线程的数量不会大量膨胀导致资源耗尽\n * 问题是：没有解决同步io导致的线程阻塞问题\n\n\n# 2.3 nio模型\n\n\n# 2.3.1 nio简介\n\n缓冲区buf 本质是一个字节数组（bytebuff），同时提供数据的结构化访问以及维护读写位置。\n\n通道 channel channel是全双工的。 流是单向的。 多路复用 selector selector简单来说就是轮训注册在其上的channel,\n\n\n# 2.3.2 nio服务序列图\n\n\n\n\n# 2.4 aio",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"TCP粘包拆包问题的解决之道",frontmatter:{title:"TCP粘包拆包问题的解决之道",date:"2022-05-21T23:32:33.000Z",permalink:"/pages/3db019/",categories:["中间件","Netty"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/010.TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93.html",relativePath:"04.中间件/10.Netty/010.TCP粘包拆包问题的解决之道.md",key:"v-5acdab4d",path:"/pages/3db019/",headers:[{level:2,title:"4.1 TCP粘包/拆包",slug:"_4-1-tcp粘包-拆包",normalizedTitle:"4.1 tcp粘包/拆包",charIndex:2},{level:3,title:"4.1.1 TCP粘包/拆包问题说明",slug:"_4-1-1-tcp粘包-拆包问题说明",normalizedTitle:"4.1.1 tcp粘包/拆包问题说明",charIndex:19},{level:3,title:"4.1.2 TCP粘包/拆包发生的原因",slug:"_4-1-2-tcp粘包-拆包发生的原因",normalizedTitle:"4.1.2 tcp粘包/拆包发生的原因",charIndex:111},{level:3,title:"4.1.3 TCP粘包/拆包问题的解决策略",slug:"_4-1-3-tcp粘包-拆包问题的解决策略",normalizedTitle:"4.1.3 tcp粘包/拆包问题的解决策略",charIndex:181},{level:2,title:"4.3 Netty解决tcp粘包问题",slug:"_4-3-netty解决tcp粘包问题",normalizedTitle:"4.3 netty解决tcp粘包问题",charIndex:322}],headersStr:"4.1 TCP粘包/拆包 4.1.1 TCP粘包/拆包问题说明 4.1.2 TCP粘包/拆包发生的原因 4.1.3 TCP粘包/拆包问题的解决策略 4.3 Netty解决tcp粘包问题",content:"# 4.1 TCP粘包/拆包\n\n\n# 4.1.1 TCP粘包/拆包问题说明\n\nTCP协议是”流“协议，流是没有间隔的。tcp会根据缓存大小将业务上的大包划分成多个小包发送出去、也可能多个小包合成一个大包发送出去。\n\n\n# 4.1.2 TCP粘包/拆包发生的原因\n\n * 应用层：大于套接字接口缓冲区大小\n * TCP层：MSS\n * IP层：MTU\n\n\n\n\n# 4.1.3 TCP粘包/拆包问题的解决策略\n\n * 消息定长len，例如每个报文固定200字节。那么读取到定长len后就重置计数器开始读取下一个包。\n * 包尾加换行符分割，如ftp。\n * 消息头+消息体。消息头包含消息长度信息。\n * 更复杂的应用协议，如netty.\n\n\n# 4.3 Netty解决tcp粘包问题\n\n * LineBasedFrameDecoder：原理是遍历ByteBuf中字节，以换行符分割\n * StringDecoder:将接收的byte对象转换为字符串，然后调用后面的handler 如果发送的消息不是以换行符结束的，netty也有其他解码器支持。",normalizedContent:"# 4.1 tcp粘包/拆包\n\n\n# 4.1.1 tcp粘包/拆包问题说明\n\ntcp协议是”流“协议，流是没有间隔的。tcp会根据缓存大小将业务上的大包划分成多个小包发送出去、也可能多个小包合成一个大包发送出去。\n\n\n# 4.1.2 tcp粘包/拆包发生的原因\n\n * 应用层：大于套接字接口缓冲区大小\n * tcp层：mss\n * ip层：mtu\n\n\n\n\n# 4.1.3 tcp粘包/拆包问题的解决策略\n\n * 消息定长len，例如每个报文固定200字节。那么读取到定长len后就重置计数器开始读取下一个包。\n * 包尾加换行符分割，如ftp。\n * 消息头+消息体。消息头包含消息长度信息。\n * 更复杂的应用协议，如netty.\n\n\n# 4.3 netty解决tcp粘包问题\n\n * linebasedframedecoder：原理是遍历bytebuf中字节，以换行符分割\n * stringdecoder:将接收的byte对象转换为字符串，然后调用后面的handler 如果发送的消息不是以换行符结束的，netty也有其他解码器支持。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Netty中有哪些解码器？",frontmatter:{title:"Netty中有哪些解码器？",date:"2022-05-21T23:33:34.000Z",permalink:"/pages/59089d/",categories:["中间件","Netty"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/015.Netty%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E7%A0%81%E5%99%A8%EF%BC%9F.html",relativePath:"04.中间件/10.Netty/015.Netty中有哪些解码器？.md",key:"v-073f22cd",path:"/pages/59089d/",headers:[{level:2,title:"5.1 DelimiterBasedFrameDecoder",slug:"_5-1-delimiterbasedframedecoder",normalizedTitle:"5.1 delimiterbasedframedecoder",charIndex:2},{level:2,title:"5.2 FixedLengthFrameDecoder",slug:"_5-2-fixedlengthframedecoder",normalizedTitle:"5.2 fixedlengthframedecoder",charIndex:83}],headersStr:"5.1 DelimiterBasedFrameDecoder 5.2 FixedLengthFrameDecoder",content:"# 5.1 DelimiterBasedFrameDecoder\n\n支持任意字符为分隔符 支持设置单条消息最大长度，如果找了最大长度还没找到分隔符就抛出异常\n\n\n# 5.2 FixedLengthFrameDecoder\n\n使用简单，指定包长渡就ok。",normalizedContent:"# 5.1 delimiterbasedframedecoder\n\n支持任意字符为分隔符 支持设置单条消息最大长度，如果找了最大长度还没找到分隔符就抛出异常\n\n\n# 5.2 fixedlengthframedecoder\n\n使用简单，指定包长渡就ok。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"ChannelPipeline和ChannelHandler",frontmatter:{title:"ChannelPipeline和ChannelHandler",date:"2022-05-21T23:36:46.000Z",permalink:"/pages/f851b6/",categories:["中间件","Netty"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/030.ChannelPipeline%E5%92%8CChannelHandler.html",relativePath:"04.中间件/10.Netty/030.ChannelPipeline和ChannelHandler.md",key:"v-5157927c",path:"/pages/f851b6/",headers:[{level:2,title:"ChannelPipeline和ChannelHandler",slug:"channelpipeline和channelhandler",normalizedTitle:"channelpipeline和channelhandler",charIndex:2},{level:2,title:"17.1 ChannelPipeline的功能说明",slug:"_17-1-channelpipeline的功能说明",normalizedTitle:"17.1 channelpipeline的功能说明",charIndex:170},{level:2,title:"17.1 ChannelPipeline源码",slug:"_17-1-channelpipeline源码",normalizedTitle:"17.1 channelpipeline源码",charIndex:641}],headersStr:"ChannelPipeline和ChannelHandler 17.1 ChannelPipeline的功能说明 17.1 ChannelPipeline源码",content:"# ChannelPipeline和ChannelHandler\n\nChannelPipeline是对Channel的封装，ChannelPipeline持有时间拦截器ChannelHandler的链表，由ChannelHandler对I/O事件拦截和处理，可以通过新增和删除ChannelHandler来实现不同业务的逻辑定制。\n\n\n# 17.1 ChannelPipeline的功能说明\n\nChannelPipeline是ChannelHandler的容器，负责ChannelHandler的管理和事件拦截 17.1.1 ChannelPipeline的事件处理 Netty中的事件分为inbound和outbound事件 inbound事件通常由IO线程触发，如tcp连接建立、断开、异常通知等 outbound事件通常是由用户主动发起的网络IO操作，如用户发起的绑定本地地址，发送消息等 17.1.2 自定义拦截器 通常ChannelHandler只需要继承ChannelHandlerAdapter类覆盖自己关心的方法即可。 17.1.3 ChannelPipeline的主要特性 ChannelPipeline支持动态添加或者删除ChannelHandler。使用场景（业务高峰期加入拥塞保护ChannelHandler，高峰过后删掉ChannelHandler）。 ChannelPipeline是线程安全的，但是ChannelHandler不是线程安全的。\n\n\n# 17.1 ChannelPipeline源码\n\n实际上是ChannelHandler 的容器，内部维护了一个ChannelHandler链表和迭代器。",normalizedContent:"# channelpipeline和channelhandler\n\nchannelpipeline是对channel的封装，channelpipeline持有时间拦截器channelhandler的链表，由channelhandler对i/o事件拦截和处理，可以通过新增和删除channelhandler来实现不同业务的逻辑定制。\n\n\n# 17.1 channelpipeline的功能说明\n\nchannelpipeline是channelhandler的容器，负责channelhandler的管理和事件拦截 17.1.1 channelpipeline的事件处理 netty中的事件分为inbound和outbound事件 inbound事件通常由io线程触发，如tcp连接建立、断开、异常通知等 outbound事件通常是由用户主动发起的网络io操作，如用户发起的绑定本地地址，发送消息等 17.1.2 自定义拦截器 通常channelhandler只需要继承channelhandleradapter类覆盖自己关心的方法即可。 17.1.3 channelpipeline的主要特性 channelpipeline支持动态添加或者删除channelhandler。使用场景（业务高峰期加入拥塞保护channelhandler，高峰过后删掉channelhandler）。 channelpipeline是线程安全的，但是channelhandler不是线程安全的。\n\n\n# 17.1 channelpipeline源码\n\n实际上是channelhandler 的容器，内部维护了一个channelhandler链表和迭代器。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"EventLoop和EventLoopGroup",frontmatter:{title:"EventLoop和EventLoopGroup",date:"2022-05-21T23:37:23.000Z",permalink:"/pages/e7aa60/",categories:["中间件","Netty"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/040.EventLoop%E5%92%8CEventLoopGroup.html",relativePath:"04.中间件/10.Netty/040.EventLoop和EventLoopGroup.md",key:"v-62f3fa3e",path:"/pages/e7aa60/",headers:[{level:2,title:"EventLoop和EventLoopGroup",slug:"eventloop和eventloopgroup",normalizedTitle:"eventloop和eventloopgroup",charIndex:2}],headersStr:"EventLoop和EventLoopGroup",content:"# EventLoop和EventLoopGroup\n\nEventLoop负责处理连接中的事件， 和EvenvLoop有关的几个概念是：Channel, EventLoopGroup。\n\n * 一个EventLoopGroup包含一个或多个EventLoop。\n * 一个EventLoop对应于一个线程，所有EventLoop处理的I/O事件都在这个线程中完成。\n * 一个Channel对应唯一个一个EventLoop。\n * 一个EventLoop可以对应多个Channel。\n\n对于基于Netty的网络服务，Client端启动需要一个EventLoopGroup， Server端启动需要两个EventLoopGroup, 因为Server端需要两种Channel, 一种是ServerChannel, 只有一个，负责接受连接，另一种是用于处理连接的一组Channel。\n\nEventLoop继承了concurrent包里的 ScheduledExecutorService，这使得它可以接受Callable或者Runnable并执行。EventLoop中的parent()方法返回包含这个EventLoop的EventLoopGroup",normalizedContent:"# eventloop和eventloopgroup\n\neventloop负责处理连接中的事件， 和evenvloop有关的几个概念是：channel, eventloopgroup。\n\n * 一个eventloopgroup包含一个或多个eventloop。\n * 一个eventloop对应于一个线程，所有eventloop处理的i/o事件都在这个线程中完成。\n * 一个channel对应唯一个一个eventloop。\n * 一个eventloop可以对应多个channel。\n\n对于基于netty的网络服务，client端启动需要一个eventloopgroup， server端启动需要两个eventloopgroup, 因为server端需要两种channel, 一种是serverchannel, 只有一个，负责接受连接，另一种是用于处理连接的一组channel。\n\neventloop继承了concurrent包里的 scheduledexecutorservice，这使得它可以接受callable或者runnable并执行。eventloop中的parent()方法返回包含这个eventloop的eventloopgroup",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"为什么Netty要自己写一个ByteBuf",frontmatter:{title:"为什么Netty要自己写一个ByteBuf",date:"2022-05-21T23:35:32.000Z",permalink:"/pages/ef17ee/",categories:["中间件","Netty"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/020.%E4%B8%BA%E4%BB%80%E4%B9%88Netty%E8%A6%81%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAByteBuf.html",relativePath:"04.中间件/10.Netty/020.为什么Netty要自己写一个ByteBuf.md",key:"v-bbcf6e5a",path:"/pages/ef17ee/",headers:[{level:2,title:"15.2 ByteBuf源码分析",slug:"_15-2-bytebuf源码分析",normalizedTitle:"15.2 bytebuf源码分析",charIndex:2},{level:2,title:"15.3 ByteBuffer相关辅助类",slug:"_15-3-bytebuffer相关辅助类",normalizedTitle:"15.3 bytebuffer相关辅助类",charIndex:8055}],headersStr:"15.2 ByteBuf源码分析 15.3 ByteBuffer相关辅助类",content:'# 15.2 ByteBuf源码分析\n\n继承关系 从内存分配的角度看，byteBuf分为两类：\n\n * 堆内存缓冲区：优点是内存的分配和回收快。缺点是进行IO读写时需要一次内存复制，用户空间和内核空间的复制。\n * 直接内存缓冲区：优缺点和堆内存缓冲区整好相反。 经验表明ByteBuf的最佳实践是在IO通信线程的读写缓冲区使用DirectByteBuf,后端业务的编解码模块使用HeapByteBuf，这样的组合可以达到性能最优。 从内存回收的角度看、ByteBuf分两类，基于对象池的ByteBuf和普通ByteBuf。使用内存池后的Netty在高并发和高负载环境下内存和GC更加平稳。 15.2.1 AbstractByteBuf源码分析 实现ByteBuf的一些公共属性和功能。 主要成员变量\n\n    static final ResourceLeakDetector<ByteBuf> leakDetector =\n            ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);//用于对象是否泄漏，定义为static，意味着所有byteBuf共享\n\n    int readerIndex;//读索引\n    int writerIndex;//写索引\n    private int markedReaderIndex;//读mark\n    private int markedWriterIndex;//写mark\n    private int maxCapacity;//最大容量\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nByte数组不在这里，因为AbstractByteBuf无法确定使用直接内存还是堆内存。 readBytes(ByteBuf dst, int dstIndex, int length)\n\npublic ByteBuf readBytes(ByteBuf dst, int dstIndex, int length) {\n       checkReadableBytes(length);//校验可读性\n       getBytes(readerIndex, dst, dstIndex, length);//读取。从readerIndex开始读取length个字节到目标数组中\n       readerIndex += length;//移动读指针\n       return this;\n   }\n\n\n1\n2\n3\n4\n5\n6\n\n\n再看一下checkReadableBytes():\n\n/**\n     * Throws an {@link IndexOutOfBoundsException} if the current\n     * {@linkplain #readableBytes() readable bytes} of this buffer is less\n     * than the specified value.\n     */\n    protected final void checkReadableBytes(int minimumReadableBytes) {\n        if (minimumReadableBytes < 0) {\n            throw new IllegalArgumentException("minimumReadableBytes: " + minimumReadableBytes + " (expected: >= 0)");\n        }\n        checkReadableBytes0(minimumReadableBytes);\n    }\n    \nprivate void checkReadableBytes0(int minimumReadableBytes) {\n        ensureAccessible();\n        if (readerIndex > writerIndex - minimumReadableBytes) {\n            throw new IndexOutOfBoundsException(String.format(\n                    "readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s",\n                    readerIndex, minimumReadableBytes, writerIndex, this));\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nwriteBytes(byte[] src, int srcIndex, int length)\n\npublic ByteBuf writeBytes(byte[] src, int srcIndex, int length) {\n        ensureWritable(length);//可写校验和扩容\n        setBytes(writerIndex, src, srcIndex, length);//从writerIndex开始写length长度\n        writerIndex += length;//移动写指针\n        return this;\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\nensureWritable(int minWritableBytes)\n\npublic ByteBuf ensureWritable(int minWritableBytes) {\n        if (minWritableBytes < 0) {\n            throw new IllegalArgumentException(String.format(\n                    "minWritableBytes: %d (expected: >= 0)", minWritableBytes));\n        }\n        ensureWritable0(minWritableBytes);\n        return this;\n    }\n    \nfinal void ensureWritable0(int minWritableBytes) {\n        ensureAccessible();//检查这个buf是否还有引用（如果已经没有引用那就没必要在写了）\n        if (minWritableBytes <= writableBytes()) {//写入的字节小于可写字节，校验通过\n            return;\n        }\n\n        if (minWritableBytes > maxCapacity - writerIndex) {//写入的字节大于最大可写入字节，抛异常\n            throw new IndexOutOfBoundsException(String.format(\n                    "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s",\n                    writerIndex, minWritableBytes, maxCapacity, this));\n        }\n\n        // Normalize the current capacity to the power of 2.\n        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);\n\n        // Adjust to the new capacity.\n        capacity(newCapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n重用缓冲区\n\npublic ByteBuf discardReadBytes() {\n        ensureAccessible();\n        if (readerIndex == 0) {\n            return this;\n        }\n\n        if (readerIndex != writerIndex) {\n            setBytes(0, this, readerIndex, writerIndex - readerIndex);//复制缓冲区\n            writerIndex -= readerIndex;//重置写指针\n            adjustMarkers(readerIndex);//调整mark指针\n            readerIndex = 0;//重置读指针\n        } else {\n            adjustMarkers(readerIndex);\n            writerIndex = readerIndex = 0;\n        }\n        return this;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n15.2.2 AbstractReferenceCountedByteBuf源码分析\n\npublic abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {\n\n    private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater =\n            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");//通过原子的方式对成员变量进行更新，消除锁\n\n    private volatile int refCnt;//跟踪对象的引用次数，采用CAS对其自增1，默认值为1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n15.2.2 UnPooledHeapByteBuf源码分析 非池化的基于堆内存，频繁的大块内存分配和回收会对性能造成影响，但是相比对外内存的申请和释放，成本还是低一些。 相比HeapByteBuf， UnPooledHeapByteBuf的实现更加加单，也不容易出现内存管理方面的问题，因此在满足性能的条件下，推荐使用UnPooledHeapByteBuf。\n\npublic class UnpooledHeapByteBuf extends AbstractReferenceCountedByteBuf {\nprivate final ByteBufAllocator alloc;\n    byte[] array;//这里直接使用JDK的ByteBuffer也可以，之所以使用Byte数组是因为性能和便捷的位操作\n    private ByteBuffer tmpNioBuf;//用于实现将netty的byteBuf转换为JDK的ByteBuffer\n }\n\n\n1\n2\n3\n4\n5\n\n\n转换JDK Buffer netty基于byte数组实现 jdk的nio buf提供wrap方法，可直接实现 转换 看下转换方法\n\npublic ByteBuffer nioBuffer(int index, int length) {\n        ensureAccessible();\n        return ByteBuffer.wrap(array, index, length).slice();\n    }\npublic ByteBuffer slice() {\n        return new HeapByteBuffer(hb,//仍然使用的是原buffer的全局数组，只是改变了position和limit的位置，所以新buf和原buf内容是相互影响的\n                                        -1,\n                                        0,\n                                        this.remaining(),\n                                        this.remaining(),\n                                        this.position() + offset);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nslice方法的作用：copy position到limit之间的内容， 15.2.3 pooledByteBuf内存池原理分析 PoolArena是netty的内存池显现类。 为了集中管理内存，提供内存申请是释放的效率，很多框架会申请一大块内存，提供相应的接口分配和释放内存，这样就不再频繁的使用系统调用来使用内存，可以提高性能。预先申请的那块内存就叫Memory Arena。PoolArena是netty对Memory Arena的实现。 Netty的PoolArena由多个chunk组成，每个chunk由多个Page组成。 PoolArena源码：\n\nabstract class PoolArena<T> implements PoolArenaMetric {\n    static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();\n\n    enum SizeClass {\n        Tiny,\n        Small,\n        Normal\n    }\n\n    static final int numTinySubpagePools = 512 >>> 4;\n\n    final PooledByteBufAllocator parent;\n\n    private final int maxOrder;\n    final int pageSize;\n    final int pageShifts;\n    final int chunkSize;\n    final int subpageOverflowMask;\n    final int numSmallSubpagePools;\n    final int directMemoryCacheAlignment;\n    final int directMemoryCacheAlignmentMask;\n    private final PoolSubpage<T>[] tinySubpagePools;\n    private final PoolSubpage<T>[] smallSubpagePools;\n\n    private final PoolChunkList<T> q050;\n    private final PoolChunkList<T> q025;\n    private final PoolChunkList<T> q000;\n    private final PoolChunkList<T> qInit;\n    private final PoolChunkList<T> q075;\n    private final PoolChunkList<T> q100;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nPoolChunk的实现 PoolChunk负责多个Page的内存管理，PoolChunk将其负责的多个Page构建成一棵二叉树。 假设一个chunk由16个page组成，则其组织形式： Page大小是4字节，chunk大小是64字节。 每个节点都记录自己在整个Memory Arena中的偏移地址，一旦被分配，则该节点及其子节点在接下来的内存分配过程中会被忽略。 举例来说，我们申请16个字节空间，则第三层的某个节点会被标记为已分配，则再次分配内存的时候会从其他三个节点中分配。 分配内存时对树采用深度优先算法，但是从哪棵子树开始深度遍历是随机的。 PoolSubPage的实现 申请内存小于一个page，则内存分配在page中完成，每个page会被分为大小相等的多个块。 被分的单位块大小等于第一次申请的内存大小，例如一个Page8字节，第一次申请2字节，则该page被切分成4块，每块2字节。而且这个page以后只能用于分配2字节的内存申请，如果再来一个4字节的内存申请，只能在另一个Page中申请。 Page使用标识位来表示内存块是否可用。维护一个long数组，每个位表示一个块的使用情况。 例如page为128字节，第一次申请内存为1字节，则该page被分为128块，则long数组中有2个元素，（每个long64位，两个long可以表示128位）。0、1表示该块是否可用。 15.2.4 PooledDirectByteBuf内存池原理分析 创建字节缓冲区 由于采用内存池实现，所以创建PooledDirectByteBuf对象不能new一个实例，而是从内存池获取。然后设置引用计数器。\n\nstatic PooledDirectByteBuf newInstance(int maxCapacity) {\n        PooledDirectByteBuf buf = RECYCLER.get();\n        buf.reuse(maxCapacity);\n        return buf;\n    }\nfinal void reuse(int maxCapacity) {\n        maxCapacity(maxCapacity);\n        setRefCnt(1);\n        setIndex0(0, 0);\n        discardMarks();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复制字节缓冲区 会从内存池中获取一个新的buffer而不是new一个。\n\n\n# 15.3 ByteBuffer相关辅助类\n\n15.3.1 ByteBufHolder 对消息体进行包装和抽象，不同的子类有不同的实现。 实现ByteBufHolder的子类可以自己实现一些实用的方法。 Netty也有一些子类继承自ByteBufHolder。 15.3.2 ByteBufAllocator 字节缓冲区分配器，其实现类有两种：基于池的和普通的。 其API: 15.3.3 CompositeByteBuf 允许将多个ByteBuf组装到一起。 使用场景：如某协议包含消息头和消息体，当对消息进行编码的时候需要进行整合。 这种场景有两种实现方式：\n\n * 将一个buf复制到另一个buf。或者创建一个新的buf将两个buf都放到新的buf。\n * 通过List或其他集合容器，将两个buf都放入容器统一维护和处理。\n\n看下源码：\n\npublic class CompositeByteBuf extends AbstractReferenceCountedByteBuf implements Iterable<ByteBuf> {\n\n   private static final ByteBuffer EMPTY_NIO_BUFFER = Unpooled.EMPTY_BUFFER.nioBuffer();\n   private static final Iterator<ByteBuf> EMPTY_ITERATOR = Collections.<ByteBuf>emptyList().iterator();\n\n   private final ByteBufAllocator alloc;\n   private final boolean direct;\n   private final ComponentList components;//维护buf的容器\n   private final int maxNumComponents;\n\n   private boolean freed;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n再看下ComponentList：\n\nprivate static final class ComponentList extends ArrayList<Component> {\n\n        ComponentList(int initialCapacity) {\n            super(initialCapacity);\n        }\n\n        // Expose this methods so we not need to create a new subList just to remove a range of elements.\n        @Override\n        public void removeRange(int fromIndex, int toIndex) {\n            super.removeRange(fromIndex, toIndex);\n        }\n    }\n\nprivate static final class Component {\n        final ByteBuf buf;\n        final int length;\n        int offset;//在集合中的位置偏移\n        int endOffset;\n\n        Component(ByteBuf buf) {\n            this.buf = buf;\n            length = buf.readableBytes();\n        }\n\n        void freeIfNecessary() {\n            buf.release(); // We should not get a NPE here. If so, it must be a bug.\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n15.3.4 ByteBufUtil 几个常用的工具方法：\n\n * encodeString\n * decodeString\n * hexDump',normalizedContent:'# 15.2 bytebuf源码分析\n\n继承关系 从内存分配的角度看，bytebuf分为两类：\n\n * 堆内存缓冲区：优点是内存的分配和回收快。缺点是进行io读写时需要一次内存复制，用户空间和内核空间的复制。\n * 直接内存缓冲区：优缺点和堆内存缓冲区整好相反。 经验表明bytebuf的最佳实践是在io通信线程的读写缓冲区使用directbytebuf,后端业务的编解码模块使用heapbytebuf，这样的组合可以达到性能最优。 从内存回收的角度看、bytebuf分两类，基于对象池的bytebuf和普通bytebuf。使用内存池后的netty在高并发和高负载环境下内存和gc更加平稳。 15.2.1 abstractbytebuf源码分析 实现bytebuf的一些公共属性和功能。 主要成员变量\n\n    static final resourceleakdetector<bytebuf> leakdetector =\n            resourceleakdetectorfactory.instance().newresourceleakdetector(bytebuf.class);//用于对象是否泄漏，定义为static，意味着所有bytebuf共享\n\n    int readerindex;//读索引\n    int writerindex;//写索引\n    private int markedreaderindex;//读mark\n    private int markedwriterindex;//写mark\n    private int maxcapacity;//最大容量\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nbyte数组不在这里，因为abstractbytebuf无法确定使用直接内存还是堆内存。 readbytes(bytebuf dst, int dstindex, int length)\n\npublic bytebuf readbytes(bytebuf dst, int dstindex, int length) {\n       checkreadablebytes(length);//校验可读性\n       getbytes(readerindex, dst, dstindex, length);//读取。从readerindex开始读取length个字节到目标数组中\n       readerindex += length;//移动读指针\n       return this;\n   }\n\n\n1\n2\n3\n4\n5\n6\n\n\n再看一下checkreadablebytes():\n\n/**\n     * throws an {@link indexoutofboundsexception} if the current\n     * {@linkplain #readablebytes() readable bytes} of this buffer is less\n     * than the specified value.\n     */\n    protected final void checkreadablebytes(int minimumreadablebytes) {\n        if (minimumreadablebytes < 0) {\n            throw new illegalargumentexception("minimumreadablebytes: " + minimumreadablebytes + " (expected: >= 0)");\n        }\n        checkreadablebytes0(minimumreadablebytes);\n    }\n    \nprivate void checkreadablebytes0(int minimumreadablebytes) {\n        ensureaccessible();\n        if (readerindex > writerindex - minimumreadablebytes) {\n            throw new indexoutofboundsexception(string.format(\n                    "readerindex(%d) + length(%d) exceeds writerindex(%d): %s",\n                    readerindex, minimumreadablebytes, writerindex, this));\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nwritebytes(byte[] src, int srcindex, int length)\n\npublic bytebuf writebytes(byte[] src, int srcindex, int length) {\n        ensurewritable(length);//可写校验和扩容\n        setbytes(writerindex, src, srcindex, length);//从writerindex开始写length长度\n        writerindex += length;//移动写指针\n        return this;\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\nensurewritable(int minwritablebytes)\n\npublic bytebuf ensurewritable(int minwritablebytes) {\n        if (minwritablebytes < 0) {\n            throw new illegalargumentexception(string.format(\n                    "minwritablebytes: %d (expected: >= 0)", minwritablebytes));\n        }\n        ensurewritable0(minwritablebytes);\n        return this;\n    }\n    \nfinal void ensurewritable0(int minwritablebytes) {\n        ensureaccessible();//检查这个buf是否还有引用（如果已经没有引用那就没必要在写了）\n        if (minwritablebytes <= writablebytes()) {//写入的字节小于可写字节，校验通过\n            return;\n        }\n\n        if (minwritablebytes > maxcapacity - writerindex) {//写入的字节大于最大可写入字节，抛异常\n            throw new indexoutofboundsexception(string.format(\n                    "writerindex(%d) + minwritablebytes(%d) exceeds maxcapacity(%d): %s",\n                    writerindex, minwritablebytes, maxcapacity, this));\n        }\n\n        // normalize the current capacity to the power of 2.\n        int newcapacity = alloc().calculatenewcapacity(writerindex + minwritablebytes, maxcapacity);\n\n        // adjust to the new capacity.\n        capacity(newcapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n重用缓冲区\n\npublic bytebuf discardreadbytes() {\n        ensureaccessible();\n        if (readerindex == 0) {\n            return this;\n        }\n\n        if (readerindex != writerindex) {\n            setbytes(0, this, readerindex, writerindex - readerindex);//复制缓冲区\n            writerindex -= readerindex;//重置写指针\n            adjustmarkers(readerindex);//调整mark指针\n            readerindex = 0;//重置读指针\n        } else {\n            adjustmarkers(readerindex);\n            writerindex = readerindex = 0;\n        }\n        return this;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n15.2.2 abstractreferencecountedbytebuf源码分析\n\npublic abstract class abstractreferencecountedbytebuf extends abstractbytebuf {\n\n    private static final atomicintegerfieldupdater<abstractreferencecountedbytebuf> refcntupdater =\n            atomicintegerfieldupdater.newupdater(abstractreferencecountedbytebuf.class, "refcnt");//通过原子的方式对成员变量进行更新，消除锁\n\n    private volatile int refcnt;//跟踪对象的引用次数，采用cas对其自增1，默认值为1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n15.2.2 unpooledheapbytebuf源码分析 非池化的基于堆内存，频繁的大块内存分配和回收会对性能造成影响，但是相比对外内存的申请和释放，成本还是低一些。 相比heapbytebuf， unpooledheapbytebuf的实现更加加单，也不容易出现内存管理方面的问题，因此在满足性能的条件下，推荐使用unpooledheapbytebuf。\n\npublic class unpooledheapbytebuf extends abstractreferencecountedbytebuf {\nprivate final bytebufallocator alloc;\n    byte[] array;//这里直接使用jdk的bytebuffer也可以，之所以使用byte数组是因为性能和便捷的位操作\n    private bytebuffer tmpniobuf;//用于实现将netty的bytebuf转换为jdk的bytebuffer\n }\n\n\n1\n2\n3\n4\n5\n\n\n转换jdk buffer netty基于byte数组实现 jdk的nio buf提供wrap方法，可直接实现 转换 看下转换方法\n\npublic bytebuffer niobuffer(int index, int length) {\n        ensureaccessible();\n        return bytebuffer.wrap(array, index, length).slice();\n    }\npublic bytebuffer slice() {\n        return new heapbytebuffer(hb,//仍然使用的是原buffer的全局数组，只是改变了position和limit的位置，所以新buf和原buf内容是相互影响的\n                                        -1,\n                                        0,\n                                        this.remaining(),\n                                        this.remaining(),\n                                        this.position() + offset);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nslice方法的作用：copy position到limit之间的内容， 15.2.3 pooledbytebuf内存池原理分析 poolarena是netty的内存池显现类。 为了集中管理内存，提供内存申请是释放的效率，很多框架会申请一大块内存，提供相应的接口分配和释放内存，这样就不再频繁的使用系统调用来使用内存，可以提高性能。预先申请的那块内存就叫memory arena。poolarena是netty对memory arena的实现。 netty的poolarena由多个chunk组成，每个chunk由多个page组成。 poolarena源码：\n\nabstract class poolarena<t> implements poolarenametric {\n    static final boolean has_unsafe = platformdependent.hasunsafe();\n\n    enum sizeclass {\n        tiny,\n        small,\n        normal\n    }\n\n    static final int numtinysubpagepools = 512 >>> 4;\n\n    final pooledbytebufallocator parent;\n\n    private final int maxorder;\n    final int pagesize;\n    final int pageshifts;\n    final int chunksize;\n    final int subpageoverflowmask;\n    final int numsmallsubpagepools;\n    final int directmemorycachealignment;\n    final int directmemorycachealignmentmask;\n    private final poolsubpage<t>[] tinysubpagepools;\n    private final poolsubpage<t>[] smallsubpagepools;\n\n    private final poolchunklist<t> q050;\n    private final poolchunklist<t> q025;\n    private final poolchunklist<t> q000;\n    private final poolchunklist<t> qinit;\n    private final poolchunklist<t> q075;\n    private final poolchunklist<t> q100;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\npoolchunk的实现 poolchunk负责多个page的内存管理，poolchunk将其负责的多个page构建成一棵二叉树。 假设一个chunk由16个page组成，则其组织形式： page大小是4字节，chunk大小是64字节。 每个节点都记录自己在整个memory arena中的偏移地址，一旦被分配，则该节点及其子节点在接下来的内存分配过程中会被忽略。 举例来说，我们申请16个字节空间，则第三层的某个节点会被标记为已分配，则再次分配内存的时候会从其他三个节点中分配。 分配内存时对树采用深度优先算法，但是从哪棵子树开始深度遍历是随机的。 poolsubpage的实现 申请内存小于一个page，则内存分配在page中完成，每个page会被分为大小相等的多个块。 被分的单位块大小等于第一次申请的内存大小，例如一个page8字节，第一次申请2字节，则该page被切分成4块，每块2字节。而且这个page以后只能用于分配2字节的内存申请，如果再来一个4字节的内存申请，只能在另一个page中申请。 page使用标识位来表示内存块是否可用。维护一个long数组，每个位表示一个块的使用情况。 例如page为128字节，第一次申请内存为1字节，则该page被分为128块，则long数组中有2个元素，（每个long64位，两个long可以表示128位）。0、1表示该块是否可用。 15.2.4 pooleddirectbytebuf内存池原理分析 创建字节缓冲区 由于采用内存池实现，所以创建pooleddirectbytebuf对象不能new一个实例，而是从内存池获取。然后设置引用计数器。\n\nstatic pooleddirectbytebuf newinstance(int maxcapacity) {\n        pooleddirectbytebuf buf = recycler.get();\n        buf.reuse(maxcapacity);\n        return buf;\n    }\nfinal void reuse(int maxcapacity) {\n        maxcapacity(maxcapacity);\n        setrefcnt(1);\n        setindex0(0, 0);\n        discardmarks();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复制字节缓冲区 会从内存池中获取一个新的buffer而不是new一个。\n\n\n# 15.3 bytebuffer相关辅助类\n\n15.3.1 bytebufholder 对消息体进行包装和抽象，不同的子类有不同的实现。 实现bytebufholder的子类可以自己实现一些实用的方法。 netty也有一些子类继承自bytebufholder。 15.3.2 bytebufallocator 字节缓冲区分配器，其实现类有两种：基于池的和普通的。 其api: 15.3.3 compositebytebuf 允许将多个bytebuf组装到一起。 使用场景：如某协议包含消息头和消息体，当对消息进行编码的时候需要进行整合。 这种场景有两种实现方式：\n\n * 将一个buf复制到另一个buf。或者创建一个新的buf将两个buf都放到新的buf。\n * 通过list或其他集合容器，将两个buf都放入容器统一维护和处理。\n\n看下源码：\n\npublic class compositebytebuf extends abstractreferencecountedbytebuf implements iterable<bytebuf> {\n\n   private static final bytebuffer empty_nio_buffer = unpooled.empty_buffer.niobuffer();\n   private static final iterator<bytebuf> empty_iterator = collections.<bytebuf>emptylist().iterator();\n\n   private final bytebufallocator alloc;\n   private final boolean direct;\n   private final componentlist components;//维护buf的容器\n   private final int maxnumcomponents;\n\n   private boolean freed;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n再看下componentlist：\n\nprivate static final class componentlist extends arraylist<component> {\n\n        componentlist(int initialcapacity) {\n            super(initialcapacity);\n        }\n\n        // expose this methods so we not need to create a new sublist just to remove a range of elements.\n        @override\n        public void removerange(int fromindex, int toindex) {\n            super.removerange(fromindex, toindex);\n        }\n    }\n\nprivate static final class component {\n        final bytebuf buf;\n        final int length;\n        int offset;//在集合中的位置偏移\n        int endoffset;\n\n        component(bytebuf buf) {\n            this.buf = buf;\n            length = buf.readablebytes();\n        }\n\n        void freeifnecessary() {\n            buf.release(); // we should not get a npe here. if so, it must be a bug.\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n15.3.4 bytebufutil 几个常用的工具方法：\n\n * encodestring\n * decodestring\n * hexdump',charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Java NIO了解吗？",frontmatter:{title:"Java NIO了解吗？",date:"2022-05-21T23:39:27.000Z",permalink:"/pages/bfdcc8/",categories:["中间件","Netty"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/050.Java%20NIO%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F.html",relativePath:"04.中间件/10.Netty/050.Java NIO了解吗？.md",key:"v-6b32ada0",path:"/pages/bfdcc8/",headers:[{level:2,title:"1.1 IO概念",slug:"_1-1-io概念",normalizedTitle:"1.1 io概念",charIndex:22},{level:3,title:"1.1.1 Buffer Handler",slug:"_1-1-1-buffer-handler",normalizedTitle:"1.1.1 buffer handler",charIndex:35},{level:3,title:"1.1.1 scatter/gather",slug:"_1-1-1-scatter-gather",normalizedTitle:"1.1.1 scatter/gather",charIndex:537},{level:3,title:"1.1.2 虚拟内存",slug:"_1-1-2-虚拟内存",normalizedTitle:"1.1.2 虚拟内存",charIndex:1452},{level:3,title:"1.1.3 内存页",slug:"_1-1-3-内存页",normalizedTitle:"1.1.3 内存页",charIndex:1664},{level:3,title:"1.1.4 文件IO",slug:"_1-1-4-文件io",normalizedTitle:"1.1.4 文件io",charIndex:1791},{level:3,title:"1.1.5 IO流",slug:"_1-1-5-io流",normalizedTitle:"1.1.5 io流",charIndex:1900},{level:2,title:"2.1 Buffer Basic",slug:"_2-1-buffer-basic",normalizedTitle:"2.1 buffer basic",charIndex:2130},{level:3,title:"2.1.1 Buffer的几个属性",slug:"_2-1-1-buffer的几个属性",normalizedTitle:"2.1.1 buffer的几个属性",charIndex:2151},{level:3,title:"2.1.2 Buffer API",slug:"_2-1-2-buffer-api",normalizedTitle:"2.1.2 buffer api",charIndex:2215},{level:3,title:"2.1.3 访问Buffer",slug:"_2-1-3-访问buffer",normalizedTitle:"2.1.3 访问buffer",charIndex:2740},{level:3,title:"2.1.4 write",slug:"_2-1-4-write",normalizedTitle:"2.1.4 write",charIndex:3055},{level:3,title:"2.1.5 Flipping",slug:"_2-1-5-flipping",normalizedTitle:"2.1.5 flipping",charIndex:3270},{level:3,title:"2.1.6 Draining",slug:"_2-1-6-draining",normalizedTitle:"2.1.6 draining",charIndex:3522},{level:3,title:"2.1.7 Compacting",slug:"_2-1-7-compacting",normalizedTitle:"2.1.7 compacting",charIndex:3872},{level:3,title:"2.1.9 Mark",slug:"_2-1-9-mark",normalizedTitle:"2.1.9 mark",charIndex:3998},{level:3,title:"2.1.9 Comparing",slug:"_2-1-9-comparing",normalizedTitle:"2.1.9 comparing",charIndex:4147},{level:3,title:"2.2 创建Buffer",slug:"_2-2-创建buffer",normalizedTitle:"2.2 创建buffer",charIndex:4476},{level:2,title:"2.3 Duplicating Buffers",slug:"_2-3-duplicating-buffers",normalizedTitle:"2.3 duplicating buffers",charIndex:5030},{level:2,title:"2.4 Byte Buffers",slug:"_2-4-byte-buffers",normalizedTitle:"2.4 byte buffers",charIndex:5966},{level:3,title:"2.4.1 Byte Ordering",slug:"_2-4-1-byte-ordering",normalizedTitle:"2.4.1 byte ordering",charIndex:5987},{level:3,title:"2.4.2 Direct Buffers",slug:"_2-4-2-direct-buffers",normalizedTitle:"2.4.2 direct buffers",charIndex:6473},{level:3,title:"2.4.3 View Buffers",slug:"_2-4-3-view-buffers",normalizedTitle:"2.4.3 view buffers",charIndex:6835},{level:3,title:"2.4.4 Data Element Views",slug:"_2-4-4-data-element-views",normalizedTitle:"2.4.4 data element views",charIndex:7400},{level:2,title:"3.1 basic",slug:"_3-1-basic",normalizedTitle:"3.1 basic",charIndex:7698},{level:3,title:"3.1.1 Open channel",slug:"_3-1-1-open-channel",normalizedTitle:"3.1.1 open channel",charIndex:8270},{level:3,title:"3.1.2 Using Channels",slug:"_3-1-2-using-channels",normalizedTitle:"3.1.2 using channels",charIndex:8725},{level:3,title:"3.1.3 close Channels",slug:"_3-1-3-close-channels",normalizedTitle:"3.1.3 close channels",charIndex:9090},{level:2,title:"3.2 Scatter/Gather",slug:"_3-2-scatter-gather",normalizedTitle:"3.2 scatter/gather",charIndex:9115},{level:2,title:"3.3 File Channels",slug:"_3-3-file-channels",normalizedTitle:"3.3 file channels",charIndex:9200},{level:2,title:"3.3.1 Accessing Files",slug:"_3-3-1-accessing-files",normalizedTitle:"3.3.1 accessing files",charIndex:9248},{level:3,title:"3.3.2 File Locking",slug:"_3-3-2-file-locking",normalizedTitle:"3.3.2 file locking",charIndex:10039},{level:2,title:"3.4 Memory-Mapped Files",slug:"_3-4-memory-mapped-files",normalizedTitle:"3.4 memory-mapped files",charIndex:10062},{level:2,title:"3.5 Socket Channels",slug:"_3-5-socket-channels",normalizedTitle:"3.5 socket channels",charIndex:10090},{level:3,title:"3.5.1 Nonblocking Mode",slug:"_3-5-1-nonblocking-mode",normalizedTitle:"3.5.1 nonblocking mode",charIndex:10562},{level:3,title:"3.5.2 ServerSocketChannel",slug:"_3-5-2-serversocketchannel",normalizedTitle:"3.5.2 serversocketchannel",charIndex:11237},{level:3,title:"3.5.4 DatagramChannel",slug:"_3-5-4-datagramchannel",normalizedTitle:"3.5.4 datagramchannel",charIndex:12348},{level:3,title:"3.5.5 Pipes",slug:"_3-5-5-pipes",normalizedTitle:"3.5.5 pipes",charIndex:12444},{level:2,title:"4.1 基础",slug:"_4-1-基础",normalizedTitle:"4.1 基础",charIndex:13917},{level:2,title:"4.2 示例",slug:"_4-2-示例",normalizedTitle:"4.2 示例",charIndex:14101}],headersStr:"1.1 IO概念 1.1.1 Buffer Handler 1.1.1 scatter/gather 1.1.2 虚拟内存 1.1.3 内存页 1.1.4 文件IO 1.1.5 IO流 2.1 Buffer Basic 2.1.1 Buffer的几个属性 2.1.2 Buffer API 2.1.3 访问Buffer 2.1.4 write 2.1.5 Flipping 2.1.6 Draining 2.1.7 Compacting 2.1.9 Mark 2.1.9 Comparing 2.2 创建Buffer 2.3 Duplicating Buffers 2.4 Byte Buffers 2.4.1 Byte Ordering 2.4.2 Direct Buffers 2.4.3 View Buffers 2.4.4 Data Element Views 3.1 basic 3.1.1 Open channel 3.1.2 Using Channels 3.1.3 close Channels 3.2 Scatter/Gather 3.3 File Channels 3.3.1 Accessing Files 3.3.2 File Locking 3.4 Memory-Mapped Files 3.5 Socket Channels 3.5.1 Nonblocking Mode 3.5.2 ServerSocketChannel 3.5.4 DatagramChannel 3.5.5 Pipes 4.1 基础 4.2 示例",content:"@TOC\n\n\n# 第一章 IO介绍\n\n\n# 1.1 IO概念\n\n\n# 1.1.1 Buffer Handler\n\n内存分为用户空间（User space），内核空间（Kernel space）。 用户空间的数据读写需要通过内存空间传递。 如下图所示，用户需要读数据，则向cpu发送一个读请求，cpu相应这个请求控制disk controller从disk读取数据到内核buffer，然后再把内核buffer的数据推送给用户空间的buffer。 为什么要区分用户空间和内核空间呢？ 每个进程有独立的内存空间好处在于多个进程的内存分配互不影响。如果多个进程共享一块内存，那么内存分配的时候就得排队。\n\n为什么用户空间不能直接从disk读数据呢？\n\n * 硬件控制器只能处理固定大小的数据，用户空间需要的可能是数据块大小异常或者不对齐的数据，内核空间起作到数拆分、重组的作用。\n * 硬件设备通常不允许直接操作虚拟内存，即用户空间\n\nDMA是什么？ DMA(Direct Memory Access,直接存储器访问)。 在DMA之前通过中断CPU来传输数据。CPU响应中断，控制总线传输数据。 DMA不需要CPU参与数据传输。DMA可以和CPU交互请求控制总线传输数据。\n\n\n# 1.1.1 scatter/gather\n\n分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。 聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。\n\n比如某个协议的消息固定消息头128字节，消息体1024字节，消息尾128字节。我们想要分别处理消息头，消息体，消息尾。 使用scatter示例代码:\n\nByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body   = ByteBuffer.allocate(1024);\nByteBuffer tail   = ByteBuffer.allocate(128);\n\nByteBuffer[] bufferArray = { header, body,tail };\nchannel.read(bufferArray);\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。 所以。\n\nscatter不适合处理动态消息，相反，gather适合处理动态消息。 buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。\n\n\n# 1.1.2 虚拟内存\n\n虚拟内存是指使用虚拟内存地址代替物理内存地址。\n\n * 会有多个虚拟内存指向同一个物理内存\n * 虚拟内存可能会大于物理内存 上面说disk controller不可以直接把数据读到用户空间。虚拟内存可以通过虚拟地址映射内核空间的方式做到这一点。 如下图，内核空间的buffer对用户空间也是可见的。这就是netty零拷贝的原理，这减少了buffer在用户空间和内核空间的拷贝，非常有意义。\n\n\n# 1.1.3 内存页\n\n操作系统将内存按固定字节分页。 内存读取的基本单位是页。\n\nMMU(Memory Management Unit):内存管理单元，保存虚拟内存和物理内存的映射关系，处在CPU和内存之间，起到将虚拟内存转换为物理内存的作用。\n\n\n# 1.1.4 文件IO\n\n文件系统：文件IO发生在文件系统。文件保存在磁盘，磁盘扇区类似内存分页的概念。内存文件读取通过文件系统间接操作磁盘文件。 文件零拷贝如下图。避免了文件系统内存页和用户内存页之间的拷贝。\n\n\n# 1.1.5 IO流\n\n上面说的IO都是面向块的IO。还有面向流的IO。 大多数操作系统支持将流置为非阻塞模式，额外设置一个进程用于检查流上是否有输入，因此流本身是不被阻塞的。 网络IO一般都是流IO。 多路复用：用一个进程管理多个非阻塞IO流的状态。\n\n\n# 第二章 Buffer\n\n标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。\n\n\n# 2.1 Buffer Basic\n\n\n# 2.1.1 Buffer的几个属性\n\n * capacity\n * limit\n * position\n * mark\n\n\n# 2.1.2 Buffer API\n\npackage java.nio;\npublic abstract class Buffer {\npublic final int capacity()\npublic final int position()\npublic final Buffer position (int newPosition) public final int limit()\n  }\npublic final Buffer limit (int newLimit)\npublic final Buffer mark()\npublic final Buffer reset()\npublic final Buffer clear()\npublic final Buffer flip()\npublic final Buffer rewind()\npublic final int remaining()\npublic final boolean hasRemaining()\npublic abstract boolean isReadOnly();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.1.3 访问Buffer\n\npublic abstract class ByteBuffer\n       extends Buffer implements Comparable\n {\n// This is a partial API listing\npublic abstract byte get();\npublic abstract byte get (int index);\npublic abstract ByteBuffer put (byte b);\npublic abstract ByteBuffer put (int index, byte b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.1.4 write\n\nFigure 2-2的buffer经过下面这个代码会变成Figure 2-3的样子：\n\nbuffer.put((byte)'H').put((byte)'e').put((byte)'l')\n.put((byte)'l').put( (byte)'o');\n\n\n1\n2\n\n\n也可以按绝对位置写入：\n\nbuffer.put(0, (byte)'M').put((byte)'w');\n\n\n1\n\n\n\n\n\n# 2.1.5 Flipping\n\n当我们想要写出buffer的内容时，我们需要用position和limit指针指向时机内容的起始位置。类似这样：\n\nbuffer.limit(buffer.position()).position(0);\n\n\n1\n\n\n这等同于buffer.flip(); 调用flip()后2-4会变成2-5 说白了，flip()改变position和limit两个指针。 rewind()只改变position指针，等同于：\n\nbuffer.position(0);\n\n\n1\n\n\n\n# 2.1.6 Draining\n\nhasRemaining()可以判断是否到达limit指针 下面是一个实现，将buffer内容读到一个数组中\n\nfor (int i = 0; buffer.hasRemaining(), i++) {\n       myByteArray [i] = buffer.get();\n}\n\n\n1\n2\n3\n\n\nremaining()会返回position到limit的数量。 将buffer内容读到一个数组中另一种实现方式：\n\nint count = buffer.remaining();\nfor (int i = 0; i < count, i++) {\n       myByteArray [i] = buffer.get();\n}\n\n\n1\n2\n3\n4\n\n\n\n# 2.1.7 Compacting\n\n当你drain一部分数据想要继续fill数据的时候，你需要把还未drain的数据整体前移。 buffer.compact()；可以完成这个工作。 调用buffer.compact()的效果就是2-6到2-7\n\n\n# 2.1.9 Mark\n\nmark()方法会用mark指针指向position的位置。\n\nbuffer.position(2).mark().position(4);\n\n\n1\n\n\nreset()方法会把position指针指向mark的位置。\n\nbuffer.reset();\n\n\n1\n\n\n\n\n\n# 2.1.9 Comparing\n\npublic abstract class ByteBuffer\n       extends Buffer implements Comparable\n  {\n  // This is a partial API listing\npublic boolean equals (Object ob)\npublic int compareTo (Object ob)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nequals()返回true需要满足三个条件：\n\n * Buffer包含相同类型的元素\n * 两个Buffer的remaining()返回值相同\n * remaining data的序列相同 下面是两个例子：\n\n\n# 2.2 创建Buffer\n\n创建新buffer的两种方式：allocation or wrapping\n\npublic abstract class CharBuffer\nextends Buffer implements CharSequence, Comparable\n{\n}\n// This is a partial API listing\npublic static CharBuffer allocate (int capacity)\npublic static CharBuffer wrap (char [] array)\npublic static CharBuffer wrap (char [] array, int offset, int length)\npublic final boolean hasArray()\npublic final char [] array()\npublic final int arrayOffset()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过allocation创建的buffer是分配一块固定大小的堆内存作为buffer存储空间。 wrapping创建的buffer是创建一个buffer对象指向一个array空间。\n\n\n# 2.3 Duplicating Buffers\n\npublic abstract class CharBuffer\nextends Buffer implements CharSequence, Comparable\n   {\n}\n// This is a partial API listing\npublic abstract CharBuffer duplicate();\npublic abstract CharBuffer asReadOnlyBuffer(); \npublic abstract CharBuffer slice();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nduplicate()创建一个新的buffer,和原buffer一样。 两个buffer共享数据元素 但是他们有独立的position, limit, and mark 一个buffer更改了数据元素对另一个buffer可见 只读、直接内存这两个属性也可以通过duplicate()继承 举个例子：\n\nCharBuffer buffer = CharBuffer.allocate (8); \nbuffer.position (3).limit (6).mark().position (5); \nCharBuffer dupeBuffer = buffer.duplicate(); buffer.clear();\n\n\n1\n2\n3\n\n\nasReadOnlyBuffer()和duplicate()功能类似，只是asReadOnlyBuffer()返回一个只读的视图。 slice() 返回一个新的buffer视图，不过 new_position = original_position new_capacity = original_limit - original_position 举个例子来看slice():\n\nCharBuffer buffer = CharBuffer.allocate (8); \nbuffer.position (3).limit (5);\nCharBuffer sliceBuffer = buffer.slice();\n\n\n1\n2\n3\n\n\n\n\n\n# 2.4 Byte Buffers\n\n\n# 2.4.1 Byte Ordering\n\n原始数据类型在内存中的存储方式是多个字节的连续序列。 举个例子一个32-bit int 值为 0x037FB4C7的内存存储序列可能为2-14也可能为2-15: 这就是所谓的大端设计和小端设计。 采用大端还是小端通常由硬件的设计者决定而不是小端的设计者。 IP协议定义的字节顺序是大端。所有使用IP协议的多字节数值必须在网络字节序和本地主机字节序做转换。\n\npackage java.nio;\npublic final class ByteOrder\n{\npublic static final ByteOrder BIG_ENDIAN public static final ByteOrder LITTLE_ENDIAN\npublic static ByteOrder nativeOrder()\npublic String toString()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n除了ByteBuffer之外，其他buffer的order()适中返回同一个值，ByteOrder.nativeOrder()。\n\n\n# 2.4.2 Direct Buffers\n\npublic abstract class ByteBuffer extends Buffer implements Comparable {\n// This is a partial API listing\npublic static ByteBuffer allocate (int capacity) ;\npublic static ByteBuffer allocateDirect (int capacity) ;\npublic abstract boolean isDirect();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nallocateDirect可以直接在堆外开辟一个buffer。 堆外buffer节省了用户空间和系统空间的buffer拷贝，提升效率。\n\n\n# 2.4.3 View Buffers\n\n收到数据的时候你可能要先看一下数据再决定做什么操作，这就需要用到ByteBuffer的视图API。\n\npublic abstract class ByteBuffer extends Buffer implements Comparable {\n// This is a partial API listing\npublic abstract CharBuffer asCharBuffer(); \npublic abstract ShortBuffer asShortBuffer(); \npublic abstract IntBuffer asIntBuffer();\n public abstract LongBuffer asLongBuffer();\n  public abstract FloatBuffer asFloatBuffer();\n   public abstract DoubleBuffer asDoubleBuffer();\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n视图在直接内存buffer上操作更高效。 当本地硬件的字节顺序和buffer中的字节顺序一致时，通过低级代码就可以操作buffer中的数据，而不需要经过字节码的编码解码。\n\n\n# 2.4.4 Data Element Views\n\n当getInt() 被调用时，那么从当前位置开始的4个字节将被打包成一个int返回。 int value = buffer.getInt();将返回buffer中的1-4位，具体返回的数据值与字节序有关系。 int value = buffer.order (ByteOrder.BIG_ENDIAN).getInt(); 返回0x3BC5315E。 int value = buffer.order (ByteOrder.LITTLE_ENDIAN).getInt(); 返回0x5E31C53B。\n\n\n# 第三章 Channels\n\n\n# 3.1 basic\n\n在NIO接口中我们需要使用Channel和Buffer进行IO操作，Channel模拟了流的概念，但是又有不同。数据总是从一个Channel读到一个buffer中，或者从一个buffer中写到channel中。 channel接口的主要实现类如下：\n\n * FileChannel\n * DatagramChannel\n * SocketChannel\n * ServerSocketChannel\n\nJavaNIO Channels和流有一些相似，但是又有些不同：\n\n你可以同时读和写Channels，流Stream只支持单向的读或写（InputStream/OutputStream）\n\n * Channels可以异步的读和写，流Stream是同步的\n * Channels总是读取到buffer或者从buffer中写入\n\n下面分别介绍一下Channel最重要的一些实现类：\n\n * FileChannel : 可以读写文件中的数据\n * DatagramChannel：可以通过UDP协议读写数据\n * SocketChannel：可以通过TCP协议读写数据\n * ServerSocketChannel：允许我们像一个web服务器那样监听TCP链接请求，为每一个链接请求创建一个SocketChannel\n\n\n# 3.1.1 Open channel\n\nFileChannel只能通过getChannel()得到。 SocketChannel有工厂方法可以得到。\n\nSocketChannel sc = SocketChannel.open();\nsc.connect (new InetSocketAddress (\"somehost\", someport));\n\nServerSocketChannel ssc = ServerSocketChannel.open(); ssc.socket().bind (new InetSocketAddress (somelocalport));\nDatagramChannel dc = DatagramChannel.open();\n\nRandomAccessFile raf = new RandomAccessFile (\"somefile\", \"r\"); FileChannel fc = raf.getChannel();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.1.2 Using Channels\n\npublic interface ReadableByteChannel extends Channel {\npublic int read (ByteBuffer dst) throws IOException;\n}\n\npublic interface WritableByteChannel extends Channel {\npublic int write (ByteBuffer src) throws IOException;\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nChannels 可以是单向或者双向的。 如果一个class实现了上面两个接口，就是双向的。 Channels可以在阻塞模式和非阻塞模式工作。 只有socket和pipes可以工作在非阻塞模式。\n\n\n# 3.1.3 close Channels\n\n\n# 3.2 Scatter/Gather\n\nScatter：将多个buffer按照顺序合成一个 Gather：将一个字符串按照顺序拆分成多个。逐个填满buffer。\n\n\n# 3.3 File Channels\n\nFile channels 只能以阻塞模式工作。\n\n\n# 3.3.1 Accessing Files\n\npublic abstract class FileChannel extends AbstractChannel \nimplements ByteChannel, GatheringByteChannel, ScatteringByteChannel{\n// This is a partial API listing\n//获取position位置\npublic abstract long position()\n//设置position\npublic abstract void position (long newPosition)\n//从position位置开始读\npublic abstract int read (ByteBuffer dst)\n//从position位置开始读\npublic abstract int read (ByteBuffer dst, long position)\n//从position位置开始写\n public abstract int write (ByteBuffer src)\n//从position位置开始写\npublic abstract int write (ByteBuffer src, long position)\npublic abstract long size()\n//截取文件保留size大小，并移动position到size的位置\npublic abstract void truncate (long size) \n//强制刷新缓存到磁盘文件\npublic abstract void force (boolean metaData)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.3.2 File Locking\n\n\n# 3.4 Memory-Mapped Files\n\n\n# 3.5 Socket Channels\n\nThe new socket channels can operate in nonblocking mode and are selectable. These two capabilities enable tremendous scalability and flexibility in large applications. ServerSocketChannel没有实现read和write接口，说明它不需要转发数据。它只负责家庭socket连接，创建SocketChannel。\n\na channel is a conduit to an I/O service and provides methods for interacting with that service\n\n每个socket channels都有一个socket与之对应，调用socket()可以获得。 但并不是所有的sockets都有channels。socket的getChannel()可能但会null;\n\n\n# 3.5.1 Nonblocking Mode\n\n调用configureBlocking (false);设置channel为非阻塞模式。 但是只有持有blockingLock() 返回的对象锁的线程才能修改阻塞模式。\n\nSocket socket = null;\nObject lockObj = serverChannel.blockingLock();\n// have a handle to the lock object, but haven't locked it yet\n// may block here until lock is acquired\nsynchronize (lockObj){\n// This thread now owns the lock; mode can't be changed boolean prevState = serverChannel.isBlocking();\nserverChannel.configureBlocking (false); socket = serverChannel.accept(); serverChannel.configureBlocking (prevState);\n}\n// lock is now released, mode is allowed to change\nif (socket != null) {\ndoSomethingWithTheSocket (socket);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.5.2 ServerSocketChannel\n\nThe ServerSocketChannel class is a channel-based socket listener. 它负责处理socket任务并添加channel。\n\npublic abstract class SocketChannel\n    extends AbstractSelectableChannel\n    implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel\n{\n//SocketChannel被创建但是并没有连接，open（）只是创建一个SocketChannel，还需要调用connect()连接到一个地址\npublic static SocketChannel open() throws IOException\n//创建并连接\npublic static SocketChannel open(SocketAddress remote) throws IOException\n//支持的操作（读、写、连接）\npublic final int validOps()\n、、\npublic abstract Socket socket();\n//是否连接到远程\npublic abstract boolean isConnected();\n//Connect（）方法是耗时的，因为需要数据包对话（TCP握手）。如果SocketChannel身上有并发、connect(),isConnectionPending返回true\npublic abstract boolean isConnectionPending();\n//建立连接\npublic abstract boolean connect(SocketAddress remote) throws IOException;\n//任何时候都可以安全的调用\npublic abstract boolean finishConnect() throws IOException;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nSocket channels是线程安全的。 Socket是面向流的而不是面向数据包的，它能保证到达的顺序是发送的顺序，不能保证维护分组。发送方发送20个字节，接收方read可能直接受到7个字节，其余字节在传输中。所以，多个线程共享一个socket的一端不是好的设计。\n\n\n# 3.5.4 DatagramChannel\n\nsocketchannel为面向连接的流协议（如tcp/ip） datagramchannel为面向无连接的数据包协议（如udp/ip）\n\n\n# 3.5.5 Pipes\n\nPipe用于同一个JVM内不同线程之间的数据交换问题 不同JVM之间的数据交换问题应该使用SocketChannel Pipe类创建了一对channel对象，它们提供了一种回送机制。 Pipe实现两个进程之间的单向数据连接。 Pipe有一个SinkChannel和一个SourceChannel 数据会从SourceChannel读取、被写到SinkChannel\n\npublic abstract class Pipe {\n    public static abstract class SourceChannel\n        extends AbstractSelectableChannel\n        implements ReadableByteChannel, ScatteringByteChannel\n    {\n        protected SourceChannel(SelectorProvider provider) {\n            super(provider);\n        }\n        public final int validOps() {\n            return SelectionKey.OP_READ;\n        }\n    }\n\n    public static abstract class SinkChannel\n        extends AbstractSelectableChannel\n        implements WritableByteChannel, GatheringByteChannel\n    {\n        protected SinkChannel(SelectorProvider provider) {\n            super(provider);\n        }\n        public final int validOps() {\n            return SelectionKey.OP_WRITE;\n        }\n\n    }\n    protected Pipe() { }\n    //从管道读取数据，要访问source通道\n    public abstract SourceChannel source();\n    //向管道写入数据，要访问Sink通道\n    public abstract SinkChannel sink();\n    //管道创建\n    public static Pipe open() throws IOException {\n        return SelectorProvider.provider().openPipe();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 第四章 Selectors\n\nSelector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接,仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。\n\n\n# 4.1 基础\n\n * Selector：一个selector可以注册多个channel，一个线程通过管理Selector实现管理多个channel。\n * SelectableChannel：提供channle selectability的通用方法。\n * SelectionKey：封装了channle和selector的注册关系，包含注册的感兴趣的事件。\n\n\n# 4.2 示例\n\n//创建Selector\nSelector selector = Selector.open();\nchannel.configureBlocking(false);\n//注册Selector\nSelectionKey key = channel.register(selector, SelectionKey.OP_READ);\nwhile(true) {\n//单线程阻塞检查Selector中就绪的事件\n  int readyChannels = selector.select();\n  if(readyChannels == 0) continue;\n  Set selectedKeys = selector.selectedKeys();\n  Iterator keyIterator = selectedKeys.iterator();\n  //循环处理就绪的事件\n  while(keyIterator.hasNext()) {\n    SelectionKey key = keyIterator.next();\n    if(key.isAcceptable()) {\n        // a connection was accepted by a ServerSocketChannel.\n    } else if (key.isConnectable()) {\n        // a connection was established with a remote server.\n    } else if (key.isReadable()) {\n        // a channel is ready for reading\n    } else if (key.isWritable()) {\n        // a channel is ready for writing\n    }\n    keyIterator.remove();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"@toc\n\n\n# 第一章 io介绍\n\n\n# 1.1 io概念\n\n\n# 1.1.1 buffer handler\n\n内存分为用户空间（user space），内核空间（kernel space）。 用户空间的数据读写需要通过内存空间传递。 如下图所示，用户需要读数据，则向cpu发送一个读请求，cpu相应这个请求控制disk controller从disk读取数据到内核buffer，然后再把内核buffer的数据推送给用户空间的buffer。 为什么要区分用户空间和内核空间呢？ 每个进程有独立的内存空间好处在于多个进程的内存分配互不影响。如果多个进程共享一块内存，那么内存分配的时候就得排队。\n\n为什么用户空间不能直接从disk读数据呢？\n\n * 硬件控制器只能处理固定大小的数据，用户空间需要的可能是数据块大小异常或者不对齐的数据，内核空间起作到数拆分、重组的作用。\n * 硬件设备通常不允许直接操作虚拟内存，即用户空间\n\ndma是什么？ dma(direct memory access,直接存储器访问)。 在dma之前通过中断cpu来传输数据。cpu响应中断，控制总线传输数据。 dma不需要cpu参与数据传输。dma可以和cpu交互请求控制总线传输数据。\n\n\n# 1.1.1 scatter/gather\n\n分散（scatter）从channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，channel将从channel中读取的数据“分散（scatter）”到多个buffer中。 聚集（gather）写入channel是指在写操作时将多个buffer的数据写入同一个channel，因此，channel 将多个buffer中的数据“聚集（gather）”后发送到channel。\n\n比如某个协议的消息固定消息头128字节，消息体1024字节，消息尾128字节。我们想要分别处理消息头，消息体，消息尾。 使用scatter示例代码:\n\nbytebuffer header = bytebuffer.allocate(128);\nbytebuffer body   = bytebuffer.allocate(1024);\nbytebuffer tail   = bytebuffer.allocate(128);\n\nbytebuffer[] bufferarray = { header, body,tail };\nchannel.read(bufferarray);\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。 所以。\n\nscatter不适合处理动态消息，相反，gather适合处理动态消息。 buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与scattering reads相反，gathering writes能较好的处理动态消息。\n\n\n# 1.1.2 虚拟内存\n\n虚拟内存是指使用虚拟内存地址代替物理内存地址。\n\n * 会有多个虚拟内存指向同一个物理内存\n * 虚拟内存可能会大于物理内存 上面说disk controller不可以直接把数据读到用户空间。虚拟内存可以通过虚拟地址映射内核空间的方式做到这一点。 如下图，内核空间的buffer对用户空间也是可见的。这就是netty零拷贝的原理，这减少了buffer在用户空间和内核空间的拷贝，非常有意义。\n\n\n# 1.1.3 内存页\n\n操作系统将内存按固定字节分页。 内存读取的基本单位是页。\n\nmmu(memory management unit):内存管理单元，保存虚拟内存和物理内存的映射关系，处在cpu和内存之间，起到将虚拟内存转换为物理内存的作用。\n\n\n# 1.1.4 文件io\n\n文件系统：文件io发生在文件系统。文件保存在磁盘，磁盘扇区类似内存分页的概念。内存文件读取通过文件系统间接操作磁盘文件。 文件零拷贝如下图。避免了文件系统内存页和用户内存页之间的拷贝。\n\n\n# 1.1.5 io流\n\n上面说的io都是面向块的io。还有面向流的io。 大多数操作系统支持将流置为非阻塞模式，额外设置一个进程用于检查流上是否有输入，因此流本身是不被阻塞的。 网络io一般都是流io。 多路复用：用一个进程管理多个非阻塞io流的状态。\n\n\n# 第二章 buffer\n\n标准的io基于字节流和字符流进行操作的，而nio是基于通道（channel）和缓冲区（buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。\n\n\n# 2.1 buffer basic\n\n\n# 2.1.1 buffer的几个属性\n\n * capacity\n * limit\n * position\n * mark\n\n\n# 2.1.2 buffer api\n\npackage java.nio;\npublic abstract class buffer {\npublic final int capacity()\npublic final int position()\npublic final buffer position (int newposition) public final int limit()\n  }\npublic final buffer limit (int newlimit)\npublic final buffer mark()\npublic final buffer reset()\npublic final buffer clear()\npublic final buffer flip()\npublic final buffer rewind()\npublic final int remaining()\npublic final boolean hasremaining()\npublic abstract boolean isreadonly();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.1.3 访问buffer\n\npublic abstract class bytebuffer\n       extends buffer implements comparable\n {\n// this is a partial api listing\npublic abstract byte get();\npublic abstract byte get (int index);\npublic abstract bytebuffer put (byte b);\npublic abstract bytebuffer put (int index, byte b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.1.4 write\n\nfigure 2-2的buffer经过下面这个代码会变成figure 2-3的样子：\n\nbuffer.put((byte)'h').put((byte)'e').put((byte)'l')\n.put((byte)'l').put( (byte)'o');\n\n\n1\n2\n\n\n也可以按绝对位置写入：\n\nbuffer.put(0, (byte)'m').put((byte)'w');\n\n\n1\n\n\n\n\n\n# 2.1.5 flipping\n\n当我们想要写出buffer的内容时，我们需要用position和limit指针指向时机内容的起始位置。类似这样：\n\nbuffer.limit(buffer.position()).position(0);\n\n\n1\n\n\n这等同于buffer.flip(); 调用flip()后2-4会变成2-5 说白了，flip()改变position和limit两个指针。 rewind()只改变position指针，等同于：\n\nbuffer.position(0);\n\n\n1\n\n\n\n# 2.1.6 draining\n\nhasremaining()可以判断是否到达limit指针 下面是一个实现，将buffer内容读到一个数组中\n\nfor (int i = 0; buffer.hasremaining(), i++) {\n       mybytearray [i] = buffer.get();\n}\n\n\n1\n2\n3\n\n\nremaining()会返回position到limit的数量。 将buffer内容读到一个数组中另一种实现方式：\n\nint count = buffer.remaining();\nfor (int i = 0; i < count, i++) {\n       mybytearray [i] = buffer.get();\n}\n\n\n1\n2\n3\n4\n\n\n\n# 2.1.7 compacting\n\n当你drain一部分数据想要继续fill数据的时候，你需要把还未drain的数据整体前移。 buffer.compact()；可以完成这个工作。 调用buffer.compact()的效果就是2-6到2-7\n\n\n# 2.1.9 mark\n\nmark()方法会用mark指针指向position的位置。\n\nbuffer.position(2).mark().position(4);\n\n\n1\n\n\nreset()方法会把position指针指向mark的位置。\n\nbuffer.reset();\n\n\n1\n\n\n\n\n\n# 2.1.9 comparing\n\npublic abstract class bytebuffer\n       extends buffer implements comparable\n  {\n  // this is a partial api listing\npublic boolean equals (object ob)\npublic int compareto (object ob)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nequals()返回true需要满足三个条件：\n\n * buffer包含相同类型的元素\n * 两个buffer的remaining()返回值相同\n * remaining data的序列相同 下面是两个例子：\n\n\n# 2.2 创建buffer\n\n创建新buffer的两种方式：allocation or wrapping\n\npublic abstract class charbuffer\nextends buffer implements charsequence, comparable\n{\n}\n// this is a partial api listing\npublic static charbuffer allocate (int capacity)\npublic static charbuffer wrap (char [] array)\npublic static charbuffer wrap (char [] array, int offset, int length)\npublic final boolean hasarray()\npublic final char [] array()\npublic final int arrayoffset()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过allocation创建的buffer是分配一块固定大小的堆内存作为buffer存储空间。 wrapping创建的buffer是创建一个buffer对象指向一个array空间。\n\n\n# 2.3 duplicating buffers\n\npublic abstract class charbuffer\nextends buffer implements charsequence, comparable\n   {\n}\n// this is a partial api listing\npublic abstract charbuffer duplicate();\npublic abstract charbuffer asreadonlybuffer(); \npublic abstract charbuffer slice();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nduplicate()创建一个新的buffer,和原buffer一样。 两个buffer共享数据元素 但是他们有独立的position, limit, and mark 一个buffer更改了数据元素对另一个buffer可见 只读、直接内存这两个属性也可以通过duplicate()继承 举个例子：\n\ncharbuffer buffer = charbuffer.allocate (8); \nbuffer.position (3).limit (6).mark().position (5); \ncharbuffer dupebuffer = buffer.duplicate(); buffer.clear();\n\n\n1\n2\n3\n\n\nasreadonlybuffer()和duplicate()功能类似，只是asreadonlybuffer()返回一个只读的视图。 slice() 返回一个新的buffer视图，不过 new_position = original_position new_capacity = original_limit - original_position 举个例子来看slice():\n\ncharbuffer buffer = charbuffer.allocate (8); \nbuffer.position (3).limit (5);\ncharbuffer slicebuffer = buffer.slice();\n\n\n1\n2\n3\n\n\n\n\n\n# 2.4 byte buffers\n\n\n# 2.4.1 byte ordering\n\n原始数据类型在内存中的存储方式是多个字节的连续序列。 举个例子一个32-bit int 值为 0x037fb4c7的内存存储序列可能为2-14也可能为2-15: 这就是所谓的大端设计和小端设计。 采用大端还是小端通常由硬件的设计者决定而不是小端的设计者。 ip协议定义的字节顺序是大端。所有使用ip协议的多字节数值必须在网络字节序和本地主机字节序做转换。\n\npackage java.nio;\npublic final class byteorder\n{\npublic static final byteorder big_endian public static final byteorder little_endian\npublic static byteorder nativeorder()\npublic string tostring()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n除了bytebuffer之外，其他buffer的order()适中返回同一个值，byteorder.nativeorder()。\n\n\n# 2.4.2 direct buffers\n\npublic abstract class bytebuffer extends buffer implements comparable {\n// this is a partial api listing\npublic static bytebuffer allocate (int capacity) ;\npublic static bytebuffer allocatedirect (int capacity) ;\npublic abstract boolean isdirect();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nallocatedirect可以直接在堆外开辟一个buffer。 堆外buffer节省了用户空间和系统空间的buffer拷贝，提升效率。\n\n\n# 2.4.3 view buffers\n\n收到数据的时候你可能要先看一下数据再决定做什么操作，这就需要用到bytebuffer的视图api。\n\npublic abstract class bytebuffer extends buffer implements comparable {\n// this is a partial api listing\npublic abstract charbuffer ascharbuffer(); \npublic abstract shortbuffer asshortbuffer(); \npublic abstract intbuffer asintbuffer();\n public abstract longbuffer aslongbuffer();\n  public abstract floatbuffer asfloatbuffer();\n   public abstract doublebuffer asdoublebuffer();\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n视图在直接内存buffer上操作更高效。 当本地硬件的字节顺序和buffer中的字节顺序一致时，通过低级代码就可以操作buffer中的数据，而不需要经过字节码的编码解码。\n\n\n# 2.4.4 data element views\n\n当getint() 被调用时，那么从当前位置开始的4个字节将被打包成一个int返回。 int value = buffer.getint();将返回buffer中的1-4位，具体返回的数据值与字节序有关系。 int value = buffer.order (byteorder.big_endian).getint(); 返回0x3bc5315e。 int value = buffer.order (byteorder.little_endian).getint(); 返回0x5e31c53b。\n\n\n# 第三章 channels\n\n\n# 3.1 basic\n\n在nio接口中我们需要使用channel和buffer进行io操作，channel模拟了流的概念，但是又有不同。数据总是从一个channel读到一个buffer中，或者从一个buffer中写到channel中。 channel接口的主要实现类如下：\n\n * filechannel\n * datagramchannel\n * socketchannel\n * serversocketchannel\n\njavanio channels和流有一些相似，但是又有些不同：\n\n你可以同时读和写channels，流stream只支持单向的读或写（inputstream/outputstream）\n\n * channels可以异步的读和写，流stream是同步的\n * channels总是读取到buffer或者从buffer中写入\n\n下面分别介绍一下channel最重要的一些实现类：\n\n * filechannel : 可以读写文件中的数据\n * datagramchannel：可以通过udp协议读写数据\n * socketchannel：可以通过tcp协议读写数据\n * serversocketchannel：允许我们像一个web服务器那样监听tcp链接请求，为每一个链接请求创建一个socketchannel\n\n\n# 3.1.1 open channel\n\nfilechannel只能通过getchannel()得到。 socketchannel有工厂方法可以得到。\n\nsocketchannel sc = socketchannel.open();\nsc.connect (new inetsocketaddress (\"somehost\", someport));\n\nserversocketchannel ssc = serversocketchannel.open(); ssc.socket().bind (new inetsocketaddress (somelocalport));\ndatagramchannel dc = datagramchannel.open();\n\nrandomaccessfile raf = new randomaccessfile (\"somefile\", \"r\"); filechannel fc = raf.getchannel();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.1.2 using channels\n\npublic interface readablebytechannel extends channel {\npublic int read (bytebuffer dst) throws ioexception;\n}\n\npublic interface writablebytechannel extends channel {\npublic int write (bytebuffer src) throws ioexception;\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nchannels 可以是单向或者双向的。 如果一个class实现了上面两个接口，就是双向的。 channels可以在阻塞模式和非阻塞模式工作。 只有socket和pipes可以工作在非阻塞模式。\n\n\n# 3.1.3 close channels\n\n\n# 3.2 scatter/gather\n\nscatter：将多个buffer按照顺序合成一个 gather：将一个字符串按照顺序拆分成多个。逐个填满buffer。\n\n\n# 3.3 file channels\n\nfile channels 只能以阻塞模式工作。\n\n\n# 3.3.1 accessing files\n\npublic abstract class filechannel extends abstractchannel \nimplements bytechannel, gatheringbytechannel, scatteringbytechannel{\n// this is a partial api listing\n//获取position位置\npublic abstract long position()\n//设置position\npublic abstract void position (long newposition)\n//从position位置开始读\npublic abstract int read (bytebuffer dst)\n//从position位置开始读\npublic abstract int read (bytebuffer dst, long position)\n//从position位置开始写\n public abstract int write (bytebuffer src)\n//从position位置开始写\npublic abstract int write (bytebuffer src, long position)\npublic abstract long size()\n//截取文件保留size大小，并移动position到size的位置\npublic abstract void truncate (long size) \n//强制刷新缓存到磁盘文件\npublic abstract void force (boolean metadata)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.3.2 file locking\n\n\n# 3.4 memory-mapped files\n\n\n# 3.5 socket channels\n\nthe new socket channels can operate in nonblocking mode and are selectable. these two capabilities enable tremendous scalability and flexibility in large applications. serversocketchannel没有实现read和write接口，说明它不需要转发数据。它只负责家庭socket连接，创建socketchannel。\n\na channel is a conduit to an i/o service and provides methods for interacting with that service\n\n每个socket channels都有一个socket与之对应，调用socket()可以获得。 但并不是所有的sockets都有channels。socket的getchannel()可能但会null;\n\n\n# 3.5.1 nonblocking mode\n\n调用configureblocking (false);设置channel为非阻塞模式。 但是只有持有blockinglock() 返回的对象锁的线程才能修改阻塞模式。\n\nsocket socket = null;\nobject lockobj = serverchannel.blockinglock();\n// have a handle to the lock object, but haven't locked it yet\n// may block here until lock is acquired\nsynchronize (lockobj){\n// this thread now owns the lock; mode can't be changed boolean prevstate = serverchannel.isblocking();\nserverchannel.configureblocking (false); socket = serverchannel.accept(); serverchannel.configureblocking (prevstate);\n}\n// lock is now released, mode is allowed to change\nif (socket != null) {\ndosomethingwiththesocket (socket);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.5.2 serversocketchannel\n\nthe serversocketchannel class is a channel-based socket listener. 它负责处理socket任务并添加channel。\n\npublic abstract class socketchannel\n    extends abstractselectablechannel\n    implements bytechannel, scatteringbytechannel, gatheringbytechannel, networkchannel\n{\n//socketchannel被创建但是并没有连接，open（）只是创建一个socketchannel，还需要调用connect()连接到一个地址\npublic static socketchannel open() throws ioexception\n//创建并连接\npublic static socketchannel open(socketaddress remote) throws ioexception\n//支持的操作（读、写、连接）\npublic final int validops()\n、、\npublic abstract socket socket();\n//是否连接到远程\npublic abstract boolean isconnected();\n//connect（）方法是耗时的，因为需要数据包对话（tcp握手）。如果socketchannel身上有并发、connect(),isconnectionpending返回true\npublic abstract boolean isconnectionpending();\n//建立连接\npublic abstract boolean connect(socketaddress remote) throws ioexception;\n//任何时候都可以安全的调用\npublic abstract boolean finishconnect() throws ioexception;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nsocket channels是线程安全的。 socket是面向流的而不是面向数据包的，它能保证到达的顺序是发送的顺序，不能保证维护分组。发送方发送20个字节，接收方read可能直接受到7个字节，其余字节在传输中。所以，多个线程共享一个socket的一端不是好的设计。\n\n\n# 3.5.4 datagramchannel\n\nsocketchannel为面向连接的流协议（如tcp/ip） datagramchannel为面向无连接的数据包协议（如udp/ip）\n\n\n# 3.5.5 pipes\n\npipe用于同一个jvm内不同线程之间的数据交换问题 不同jvm之间的数据交换问题应该使用socketchannel pipe类创建了一对channel对象，它们提供了一种回送机制。 pipe实现两个进程之间的单向数据连接。 pipe有一个sinkchannel和一个sourcechannel 数据会从sourcechannel读取、被写到sinkchannel\n\npublic abstract class pipe {\n    public static abstract class sourcechannel\n        extends abstractselectablechannel\n        implements readablebytechannel, scatteringbytechannel\n    {\n        protected sourcechannel(selectorprovider provider) {\n            super(provider);\n        }\n        public final int validops() {\n            return selectionkey.op_read;\n        }\n    }\n\n    public static abstract class sinkchannel\n        extends abstractselectablechannel\n        implements writablebytechannel, gatheringbytechannel\n    {\n        protected sinkchannel(selectorprovider provider) {\n            super(provider);\n        }\n        public final int validops() {\n            return selectionkey.op_write;\n        }\n\n    }\n    protected pipe() { }\n    //从管道读取数据，要访问source通道\n    public abstract sourcechannel source();\n    //向管道写入数据，要访问sink通道\n    public abstract sinkchannel sink();\n    //管道创建\n    public static pipe open() throws ioexception {\n        return selectorprovider.provider().openpipe();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 第四章 selectors\n\nselector（选择器）是java nio中能够检测一到多个nio通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接,仅用单个线程来处理多个channels的好处是，只需要更少的线程来处理通道。\n\n\n# 4.1 基础\n\n * selector：一个selector可以注册多个channel，一个线程通过管理selector实现管理多个channel。\n * selectablechannel：提供channle selectability的通用方法。\n * selectionkey：封装了channle和selector的注册关系，包含注册的感兴趣的事件。\n\n\n# 4.2 示例\n\n//创建selector\nselector selector = selector.open();\nchannel.configureblocking(false);\n//注册selector\nselectionkey key = channel.register(selector, selectionkey.op_read);\nwhile(true) {\n//单线程阻塞检查selector中就绪的事件\n  int readychannels = selector.select();\n  if(readychannels == 0) continue;\n  set selectedkeys = selector.selectedkeys();\n  iterator keyiterator = selectedkeys.iterator();\n  //循环处理就绪的事件\n  while(keyiterator.hasnext()) {\n    selectionkey key = keyiterator.next();\n    if(key.isacceptable()) {\n        // a connection was accepted by a serversocketchannel.\n    } else if (key.isconnectable()) {\n        // a connection was established with a remote server.\n    } else if (key.isreadable()) {\n        // a channel is ready for reading\n    } else if (key.iswritable()) {\n        // a channel is ready for writing\n    }\n    keyiterator.remove();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"生产者",frontmatter:{title:"生产者",date:"2022-05-21T23:43:06.000Z",permalink:"/pages/fe7ca2/",categories:["中间件","Kafka"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/010.%E7%94%9F%E4%BA%A7%E8%80%85.html",relativePath:"04.中间件/40.Kafka/010.生产者.md",key:"v-7c0136cf",path:"/pages/fe7ca2/",headersStr:null,content:'# 创建生产者\n\n创建生产者有三个属性是必选的 bootstrap.servers 指定broker集群的地址，格式为host:port key.serializer kafka broker希望收到消息的键和值都是字节数组，但是为了代码的可读性，允许producer把java对象发送给broker，但是需要指定一个实现了org.apache.kafka.common.serialization.Serializer接口的序列化器。 value.serializer 与key.serializer一样的道理。\n\n\t\tProperties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "172.16.1.1,172.16.1.2");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer");\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer");\n        producer = new KafkaProducer<>(props);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 发送消息\n\n发送消息有三种方式：\n\n * 发送并忘记（fire-and-forget）\n * 同步发送\n * 异步发送\n\n发送并忘记 不关心消息是否到达\n\nProducerRecord<String, String> record = new ProducerRecord<>(topicName, key,value);\nproducer.send(record);\n\n\n1\n2\n\n\n同步发送\n\nProducerRecord<String, String> record = new ProducerRecord<>(topicName, key,value);\ntry{\n\tproducer.send(record).get();//producer.send(record)返回一个Future对象，调用get()阻塞等待返回结果\n} catch (Exception e){\n\te.printStackTrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nkafkaProducer会发送两类错误\n\n * 可重试的：比如连接错误、无主（no leader）错误\n * 不可重试的：比如消息太大 异步发送 异步发送的异常需要记录下拉，producer支持回调。\n\nProducerRecord<String, String> record = new ProducerRecord<>(topicNameTrade, key,value);\n            producer.send(record, new Callback() {\n                @Override\n                public void onCompletion(RecordMetadata metadata, Exception exception) {\n                    exception.printStackTrace();\n                }\n            });\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 生产者的配置\n\nacks 指定要多少个分区副本收到消息，生产者才认为消息写入是成功的。其值有0、1、all.\n\n * 0：不等待任何服务器的相应\n * 1： 只要集群的首领节点收到\n * all: 等待所有副本都收到\n\nbuffer.memory 设置生产者内存缓冲区大小。 程序发送消息的速度 > 发送到broker的速度会导致这个缓冲区空间不足。 空间不足时程序阻塞还是抛异常取决于配置max.block.ms compression.type 默认，消息是不会被压缩的。 producer向broker发送消息不是逐条发送的，是一批一批发送的。 发送批次有可选的压缩方式，有三种：\n\n * snappy\n * gzip\n * lz4\n\nretries 重试次数 默认重试之间会等待100ms retry.backoff.ms可设置这个等待时间 batch.size 有多个消息要发送到一个分区的时候，producer会把他们放到一个批次。 该配置指定是批次大小（字节）。 批次装满的时候会被发送出去，\n\n\n# 序列化器\n\n\n# 分区\n\nkafka消息的recode包含topic、key、value。 broker用key分配分区。key相同的一定会分配到同一个分区。 如果key为null,那么将使用默认分区，默认的分区器是使用Round Robin算法。 也可以实现partitioner实现自定义分区器。',normalizedContent:'# 创建生产者\n\n创建生产者有三个属性是必选的 bootstrap.servers 指定broker集群的地址，格式为host:port key.serializer kafka broker希望收到消息的键和值都是字节数组，但是为了代码的可读性，允许producer把java对象发送给broker，但是需要指定一个实现了org.apache.kafka.common.serialization.serializer接口的序列化器。 value.serializer 与key.serializer一样的道理。\n\n\t\tproperties props = new properties();\n        props.put(producerconfig.bootstrap_servers_config, "172.16.1.1,172.16.1.2");\n        props.put(producerconfig.key_serializer_class_config, "org.apache.kafka.common.serialization.stringserializer");\n        props.put(producerconfig.value_serializer_class_config, "org.apache.kafka.common.serialization.stringserializer");\n        producer = new kafkaproducer<>(props);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 发送消息\n\n发送消息有三种方式：\n\n * 发送并忘记（fire-and-forget）\n * 同步发送\n * 异步发送\n\n发送并忘记 不关心消息是否到达\n\nproducerrecord<string, string> record = new producerrecord<>(topicname, key,value);\nproducer.send(record);\n\n\n1\n2\n\n\n同步发送\n\nproducerrecord<string, string> record = new producerrecord<>(topicname, key,value);\ntry{\n\tproducer.send(record).get();//producer.send(record)返回一个future对象，调用get()阻塞等待返回结果\n} catch (exception e){\n\te.printstacktrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nkafkaproducer会发送两类错误\n\n * 可重试的：比如连接错误、无主（no leader）错误\n * 不可重试的：比如消息太大 异步发送 异步发送的异常需要记录下拉，producer支持回调。\n\nproducerrecord<string, string> record = new producerrecord<>(topicnametrade, key,value);\n            producer.send(record, new callback() {\n                @override\n                public void oncompletion(recordmetadata metadata, exception exception) {\n                    exception.printstacktrace();\n                }\n            });\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 生产者的配置\n\nacks 指定要多少个分区副本收到消息，生产者才认为消息写入是成功的。其值有0、1、all.\n\n * 0：不等待任何服务器的相应\n * 1： 只要集群的首领节点收到\n * all: 等待所有副本都收到\n\nbuffer.memory 设置生产者内存缓冲区大小。 程序发送消息的速度 > 发送到broker的速度会导致这个缓冲区空间不足。 空间不足时程序阻塞还是抛异常取决于配置max.block.ms compression.type 默认，消息是不会被压缩的。 producer向broker发送消息不是逐条发送的，是一批一批发送的。 发送批次有可选的压缩方式，有三种：\n\n * snappy\n * gzip\n * lz4\n\nretries 重试次数 默认重试之间会等待100ms retry.backoff.ms可设置这个等待时间 batch.size 有多个消息要发送到一个分区的时候，producer会把他们放到一个批次。 该配置指定是批次大小（字节）。 批次装满的时候会被发送出去，\n\n\n# 序列化器\n\n\n# 分区\n\nkafka消息的recode包含topic、key、value。 broker用key分配分区。key相同的一定会分配到同一个分区。 如果key为null,那么将使用默认分区，默认的分区器是使用round robin算法。 也可以实现partitioner实现自定义分区器。',charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"Kafka",frontmatter:{title:"Kafka",date:"2020-05-21T21:50:26.000Z",permalink:"/pages/561f34/",categories:["中间件","Kafka"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/001.Kafka%E5%8C%85%E5%90%AB%E9%82%A3%E5%87%A0%E9%83%A8%E5%88%86.html",relativePath:"04.中间件/40.Kafka/001.Kafka包含那几部分.md",key:"v-0df39df8",path:"/pages/561f34/",headersStr:null,content:"# 主题和分区\n\nkafka通过主题对消息分类。 kafka通过分区实现数据冗余和伸缩性。 一个主题包含多个分区，所以在topic内消息可能是无需的，但是在单个partition内部是有序的。\n\n\n# 生产者和消费者\n\n生产者创建消息，发布到一个特定的主题上，消息会均衡在所有分区上。 消费者订阅一个或者多个主题，按照生产顺序消费消息。 偏移量是一种元数据，是一个不断递增的整数值，消费者通过偏移量来区分已经消费的消息。每个分区有唯一的偏移量，消费者把最后消费的消息的偏移量发送到broker或者zookeeper保存。 消费者群组多个消费者共同读取一个主题，有唯一的groupId,群组保证，每个分区只能被一个消费者使用。\n\n\n# broker和集群\n\nbroker是一个独立的kafka 服务器。负责接收生产者的消息，为消息设置偏移量，提交消息到磁盘保存。是集群的组成部分。 集群控制器是集群中的一个broker。负责分区分配和broker监控。 分区首领。一个分区会分配给多个broker，这种复制机制是为了提供消息冗余。在这多个broker中需要有一个分区首领，消费者只消费分区首领的消息，分区首领负责把消费的offset同步到冗余分区中。",normalizedContent:"# 主题和分区\n\nkafka通过主题对消息分类。 kafka通过分区实现数据冗余和伸缩性。 一个主题包含多个分区，所以在topic内消息可能是无需的，但是在单个partition内部是有序的。\n\n\n# 生产者和消费者\n\n生产者创建消息，发布到一个特定的主题上，消息会均衡在所有分区上。 消费者订阅一个或者多个主题，按照生产顺序消费消息。 偏移量是一种元数据，是一个不断递增的整数值，消费者通过偏移量来区分已经消费的消息。每个分区有唯一的偏移量，消费者把最后消费的消息的偏移量发送到broker或者zookeeper保存。 消费者群组多个消费者共同读取一个主题，有唯一的groupid,群组保证，每个分区只能被一个消费者使用。\n\n\n# broker和集群\n\nbroker是一个独立的kafka 服务器。负责接收生产者的消息，为消息设置偏移量，提交消息到磁盘保存。是集群的组成部分。 集群控制器是集群中的一个broker。负责分区分配和broker监控。 分区首领。一个分区会分配给多个broker，这种复制机制是为了提供消息冗余。在这多个broker中需要有一个分区首领，消费者只消费分区首领的消息，分区首领负责把消费的offset同步到冗余分区中。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"消费者",frontmatter:{title:"消费者",date:"2022-05-21T23:43:44.000Z",permalink:"/pages/fed167/",categories:["中间件","Kafka"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/020.%E6%B6%88%E8%B4%B9%E8%80%85.html",relativePath:"04.中间件/40.Kafka/020.消费者.md",key:"v-04af9e42",path:"/pages/fed167/",headers:[{level:2,title:"几个概念",slug:"几个概念",normalizedTitle:"几个概念",charIndex:2},{level:2,title:"配置项",slug:"配置项",normalizedTitle:"配置项",charIndex:1024}],headersStr:"几个概念 配置项",content:'# 几个概念\n\n消费者组 多个消费实例共享一个GroupId,多个消费实例组织在一起协调消费订阅的主题和分区。 消费实例可以是一个进程也可以是一个线程 GroupId是一个字符串，唯一标识一个消费组 GroupId.consumerInstance:GroupId.partition = 1:N，也就是说同一个消费者实例和partition的对应关系是1：N offset 位移（offset）:consumer记录消费消息的位置 kafka的位移机制：\n\n * consumer实例保存自己的offset,通过checkPoint机制定期持久化\n * 新版本的kafka通过topic定期持久化到broker\n * 老版本的kafka是持久化到zk的，但是zk并不适合频繁的写\n\nrebalance 一个groupId内有多个consumer，其订阅topic有多个partition，那么那个消费者消费那个partition呢？rebalance就是做consumer和partition的匹配。\n\n什么时候rebalance\n\n * 组成员的变更（consumer的加入或者离开、崩溃）\n * 订阅的partition发生变更\n * 订阅的topic发生变更（按照正则方式订阅时是可能发生的）\n\n如何rebalance consumerClient有两种策略可选，通过partition.assignment.strategy配置；默认是Range策略\n\n * Range strategy：按照topic维度均分partition,问题是可能出现分配不均的问题\n * RoundRobin：所有partition均分，分配的更均匀\n\n谁来执行rebalance和consumer group管理 每个consumer group都会被分配一个coordinator用于组管理和位移管理。 当新版本consumer group的第一个consumer启动的时候，它会去和kafka server确定谁是它们组的coordinator，之后该group内的所有成员都会和该coordinator进行协调通信。\n\n谁是coordinator consumer group位移信息写入__consumers_offsets的分区为partition,该partition的leader所在的broker就是该组的coordinator。\n\n\n# 配置项\n\n\t//组唯一id\n\tpublic static final String GROUP_ID_CONFIG = "group.id";\n\n\n    //控制单次调用call()返回的记录数量\n    public static final String MAX_POLL_RECORDS_CONFIG = "max.poll.records";\n\n    /** 使用组管理的时候生效 如果consumer两次poll()调用时间超过这个阈值 组管理器会进行rebalance */\n    public static final String MAX_POLL_INTERVAL_MS_CONFIG = "max.poll.interval.ms";\n\n    /** consumer的心跳时间*/\n    public static final String SESSION_TIMEOUT_MS_CONFIG = "session.timeout.ms";\n    /**\n     * 自动提交offset 默认是true\n     * 可关闭，然后自己控制提交offset,通过auto.commit.interval.ms控制提交频次\n     */\n    public static final String ENABLE_AUTO_COMMIT_CONFIG = "enable.auto.commit";\n\n    /**\n     * 自动提交offset的频次\n     */\n    public static final String AUTO_COMMIT_INTERVAL_MS_CONFIG = "auto.commit.interval.ms";\n    /**\n     * 自定义分区策略的class全路径\n     */\n    public static final String PARTITION_ASSIGNMENT_STRATEGY_CONFIG = "partition.assignment.strategy";\n\n    /**\n     * 当offset不存在或者失效的情况下，指定消费策略\n     * 有两次消费策略earliest、latest\n     * 分别表示从最新的消息开始消费还是从最早的开始消费\n     */\n    public static final String AUTO_OFFSET_RESET_CONFIG = "auto.offset.reset";\n\n    /**\n     * 指定从broker获取的最小的数据量字节数\n     * 如果broker的数据量小于该配置那么会等一会再返回consumer\n     * 可降低broker和consumer之间的交互次数\n     */\n    public static final String FETCH_MIN_BYTES_CONFIG = "fetch.min.bytes";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n',normalizedContent:'# 几个概念\n\n消费者组 多个消费实例共享一个groupid,多个消费实例组织在一起协调消费订阅的主题和分区。 消费实例可以是一个进程也可以是一个线程 groupid是一个字符串，唯一标识一个消费组 groupid.consumerinstance:groupid.partition = 1:n，也就是说同一个消费者实例和partition的对应关系是1：n offset 位移（offset）:consumer记录消费消息的位置 kafka的位移机制：\n\n * consumer实例保存自己的offset,通过checkpoint机制定期持久化\n * 新版本的kafka通过topic定期持久化到broker\n * 老版本的kafka是持久化到zk的，但是zk并不适合频繁的写\n\nrebalance 一个groupid内有多个consumer，其订阅topic有多个partition，那么那个消费者消费那个partition呢？rebalance就是做consumer和partition的匹配。\n\n什么时候rebalance\n\n * 组成员的变更（consumer的加入或者离开、崩溃）\n * 订阅的partition发生变更\n * 订阅的topic发生变更（按照正则方式订阅时是可能发生的）\n\n如何rebalance consumerclient有两种策略可选，通过partition.assignment.strategy配置；默认是range策略\n\n * range strategy：按照topic维度均分partition,问题是可能出现分配不均的问题\n * roundrobin：所有partition均分，分配的更均匀\n\n谁来执行rebalance和consumer group管理 每个consumer group都会被分配一个coordinator用于组管理和位移管理。 当新版本consumer group的第一个consumer启动的时候，它会去和kafka server确定谁是它们组的coordinator，之后该group内的所有成员都会和该coordinator进行协调通信。\n\n谁是coordinator consumer group位移信息写入__consumers_offsets的分区为partition,该partition的leader所在的broker就是该组的coordinator。\n\n\n# 配置项\n\n\t//组唯一id\n\tpublic static final string group_id_config = "group.id";\n\n\n    //控制单次调用call()返回的记录数量\n    public static final string max_poll_records_config = "max.poll.records";\n\n    /** 使用组管理的时候生效 如果consumer两次poll()调用时间超过这个阈值 组管理器会进行rebalance */\n    public static final string max_poll_interval_ms_config = "max.poll.interval.ms";\n\n    /** consumer的心跳时间*/\n    public static final string session_timeout_ms_config = "session.timeout.ms";\n    /**\n     * 自动提交offset 默认是true\n     * 可关闭，然后自己控制提交offset,通过auto.commit.interval.ms控制提交频次\n     */\n    public static final string enable_auto_commit_config = "enable.auto.commit";\n\n    /**\n     * 自动提交offset的频次\n     */\n    public static final string auto_commit_interval_ms_config = "auto.commit.interval.ms";\n    /**\n     * 自定义分区策略的class全路径\n     */\n    public static final string partition_assignment_strategy_config = "partition.assignment.strategy";\n\n    /**\n     * 当offset不存在或者失效的情况下，指定消费策略\n     * 有两次消费策略earliest、latest\n     * 分别表示从最新的消息开始消费还是从最早的开始消费\n     */\n    public static final string auto_offset_reset_config = "auto.offset.reset";\n\n    /**\n     * 指定从broker获取的最小的数据量字节数\n     * 如果broker的数据量小于该配置那么会等一会再返回consumer\n     * 可降低broker和consumer之间的交互次数\n     */\n    public static final string fetch_min_bytes_config = "fetch.min.bytes";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n',charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"集群下的Kafka要考虑哪些事情",frontmatter:{title:"集群下的Kafka要考虑哪些事情",date:"2022-05-21T23:46:20.000Z",permalink:"/pages/8d1d04/",categories:["中间件","Kafka"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/030.%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84Kafka%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85.html",relativePath:"04.中间件/40.Kafka/030.集群下的Kafka要考虑哪些事情.md",key:"v-0c440466",path:"/pages/8d1d04/",headersStr:null,content:"# 集群成员关系\n\nKafka使用 Zookeeper来维护集群成员的信息. 每个broker都有唯一的标识符，可以配置指定，也可以自动生成。 在broker启动时，他通过创建临时节点把自己注册到zk。 broker订阅zk的/brokers/ids路径，当有broker加入或者退出集群时，这些组件可以获得通知。\n\n在关闭 broker时，它对应的节点也会消失，不过它的 ID会继续存在于其他数据结构中。例如，主题的副本列表(下面会介绍)里就可能包含这些ID。 在完全关闭一个 broker之 后，如果使用相同的 ID 启动另一个全新的 broker，它会立即加入集群，井拥有与旧 broker 相同的分区和主题。\n\n\n# 控制器\n\n控制器其实就是 一 个 broker，只不过它除了具有一般 broker 的功能之外，还负责分区 首领的选举。 哪个broker可以成为控制器？ 在集群启动时，所有broker都会尝试在zk创建节点/controller，但是只有一个broker可以创建成功，它就是控制器。 非控制器的broker节点会在控制器节点创建zk watch对象，用于接收这个节点的变更通知。 通过watch对象得知控制器节点消失，那么其他broker节点会进入下一轮的首领选举，选举成功会有一个新的递增的ID产生。 新broker加入集群会发生什么？ 控制器会检查新broker是否包含现有分区的副本，如果有，则通知其他broker，允许新的broker同步分区副本。 broker退出集群会发生什么？ 控制器监听到broker离开集群的消息，check哪些分区首领在该broker上。然后再其他broker上选举新的分区首领，并通知所有broker新的分区首领。\n\n\n# 复制\n\nkafka是一个分布式的、可分区的、可复制的提交日志服务。 复制什么？ 每个topic由对个partition、每个partition有多个副本，其中一个是首领副本，其他是跟随者副本。 该partition的生产者和消费者请求都会经过首领副本。 复制就发生在首领副本和跟随者副本之间。 当首领副本崩溃时，其中一个跟随者副本可以提升为首领副本。 当首领副本崩溃时，哪个跟随者副本可以提升为首领副本 不同步的跟随者是不能成为首领的 什么标准判断一个跟随者是不同步的？ 跟随者请求同步时总是按照offset递增的顺序请求同步的消息，而且总是在收到上一个请求的影响之后才会发出下一个请求。所以当首领收不到follower的请求最新的offset时或者一定时间内收不到follower的同步请求时，认为这个follower是不同步的。这个一定时间可以通过replica.lg.time.max.ms配置。 首选首领是可以优先称为下一届首领的。 首选首领是在创建分区时，为了在broker之间均衡首领选举的分区首领。\n\n\n# 处理请求\n\nbroker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求。 producer的生产请求和consumer的获取请求都必须发送给分区的首领副本。 那么客户端怎么知道谁是首领副本呢? 客户端使用了另一 种请求类型，也就是元数据请求。请求到元数据后缓存在本地。 通过配置matedata.max.age.ms设置定时刷新元数据。\n\n生产者请求 包含首领副本的 broker在收到生产请求时，会对请求做一些验证\n\n * 发送数据的用户是否有主题的写权限\n * 请求里的acks值是否是有效值（只允许0、1、all）\n * 如果acks=all，是否有足够的读本保证消息已经被安全写入？ 以上都做完给客户端相应。\n\n消费者请求 客户端可以指定broker最多从一个分区里返回多少数据，这是有必要的，因为broker返回大量的数据有可能撑爆客户端的buffer broke会check请求是否有效，比如请求的偏移量是否存在，如果存在，则用零拷贝的方式返回数据。 客户端也可以指定broker积攒一定的数据再返回，避免频繁的网络IO。 并不是首领副本上的消息都可以返回给客户端，只有被所有follower同步了的消息才可以返回给客户端。\n\n\n# 物理存储\n\nkafka的基本存储单元是分区。 log.dirs配置用于指定存储分区的目录。 如何做分区和broker之间的分配 加入要在6个broker的kafka集群上创建分区数为10复制系数为3的主题，那么这30个分区副本如何分配给6个broker? 做分区和broker之间的分配要遵循以下原则：\n\n * 在broker间平均的分布分区副本\n * 每个分区的副本尽可能的分布在不同的broker上\n * 如果制定了broker的机架信息，尽可能的把每个分区的副本分配到不同的机架上\n\n依照这个规则，分配方式可以如下：\n\n 1. 先均匀分配首领分区。随机选一个broker，轮训的方式给每个broker分配分区来确定首领分区的位置。\n 2. 再均匀分配分区副本。以首领分区为起点，了轮训分配分区副本。\n 3. 指定机架信息的时候，均匀分配分区的方式。假设 broker0、 broker1和 broker2放置在同一个机架上， broker3、 broker4 和 broker5分别放置在其他不同的机架上，那么在轮训分配的时候，我们不是按照从 0到 5的顺序来选择 broker，而 是按照 0, 3, 1, 4, 2, 5 的顺序来选择。\n\n如何做文件管理 因为在一个大文件中查找和删除是非常耗时的，所以我们把分区分成若干个片段。默认每个片段包含1G或者1周的数据。 当前正在写入数据的片段叫做活跃片段。活跃片段永远不会被删除。 broker会为分区的每个片段打开一个文件句柄，这会导致打开过多的文件句柄，所以操作系统必须根据实际情况做一些调优。 broker如何在一个分区的众多文件中定位指定的offset位置？ kakfa为每个分区文件建立索引，根据索引可以快速定位offset在文件中的位置。\n\n如果有必要，管理员可以删除索引，kafka会重新生成这些索引。",normalizedContent:"# 集群成员关系\n\nkafka使用 zookeeper来维护集群成员的信息. 每个broker都有唯一的标识符，可以配置指定，也可以自动生成。 在broker启动时，他通过创建临时节点把自己注册到zk。 broker订阅zk的/brokers/ids路径，当有broker加入或者退出集群时，这些组件可以获得通知。\n\n在关闭 broker时，它对应的节点也会消失，不过它的 id会继续存在于其他数据结构中。例如，主题的副本列表(下面会介绍)里就可能包含这些id。 在完全关闭一个 broker之 后，如果使用相同的 id 启动另一个全新的 broker，它会立即加入集群，井拥有与旧 broker 相同的分区和主题。\n\n\n# 控制器\n\n控制器其实就是 一 个 broker，只不过它除了具有一般 broker 的功能之外，还负责分区 首领的选举。 哪个broker可以成为控制器？ 在集群启动时，所有broker都会尝试在zk创建节点/controller，但是只有一个broker可以创建成功，它就是控制器。 非控制器的broker节点会在控制器节点创建zk watch对象，用于接收这个节点的变更通知。 通过watch对象得知控制器节点消失，那么其他broker节点会进入下一轮的首领选举，选举成功会有一个新的递增的id产生。 新broker加入集群会发生什么？ 控制器会检查新broker是否包含现有分区的副本，如果有，则通知其他broker，允许新的broker同步分区副本。 broker退出集群会发生什么？ 控制器监听到broker离开集群的消息，check哪些分区首领在该broker上。然后再其他broker上选举新的分区首领，并通知所有broker新的分区首领。\n\n\n# 复制\n\nkafka是一个分布式的、可分区的、可复制的提交日志服务。 复制什么？ 每个topic由对个partition、每个partition有多个副本，其中一个是首领副本，其他是跟随者副本。 该partition的生产者和消费者请求都会经过首领副本。 复制就发生在首领副本和跟随者副本之间。 当首领副本崩溃时，其中一个跟随者副本可以提升为首领副本。 当首领副本崩溃时，哪个跟随者副本可以提升为首领副本 不同步的跟随者是不能成为首领的 什么标准判断一个跟随者是不同步的？ 跟随者请求同步时总是按照offset递增的顺序请求同步的消息，而且总是在收到上一个请求的影响之后才会发出下一个请求。所以当首领收不到follower的请求最新的offset时或者一定时间内收不到follower的同步请求时，认为这个follower是不同步的。这个一定时间可以通过replica.lg.time.max.ms配置。 首选首领是可以优先称为下一届首领的。 首选首领是在创建分区时，为了在broker之间均衡首领选举的分区首领。\n\n\n# 处理请求\n\nbroker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求。 producer的生产请求和consumer的获取请求都必须发送给分区的首领副本。 那么客户端怎么知道谁是首领副本呢? 客户端使用了另一 种请求类型，也就是元数据请求。请求到元数据后缓存在本地。 通过配置matedata.max.age.ms设置定时刷新元数据。\n\n生产者请求 包含首领副本的 broker在收到生产请求时，会对请求做一些验证\n\n * 发送数据的用户是否有主题的写权限\n * 请求里的acks值是否是有效值（只允许0、1、all）\n * 如果acks=all，是否有足够的读本保证消息已经被安全写入？ 以上都做完给客户端相应。\n\n消费者请求 客户端可以指定broker最多从一个分区里返回多少数据，这是有必要的，因为broker返回大量的数据有可能撑爆客户端的buffer broke会check请求是否有效，比如请求的偏移量是否存在，如果存在，则用零拷贝的方式返回数据。 客户端也可以指定broker积攒一定的数据再返回，避免频繁的网络io。 并不是首领副本上的消息都可以返回给客户端，只有被所有follower同步了的消息才可以返回给客户端。\n\n\n# 物理存储\n\nkafka的基本存储单元是分区。 log.dirs配置用于指定存储分区的目录。 如何做分区和broker之间的分配 加入要在6个broker的kafka集群上创建分区数为10复制系数为3的主题，那么这30个分区副本如何分配给6个broker? 做分区和broker之间的分配要遵循以下原则：\n\n * 在broker间平均的分布分区副本\n * 每个分区的副本尽可能的分布在不同的broker上\n * 如果制定了broker的机架信息，尽可能的把每个分区的副本分配到不同的机架上\n\n依照这个规则，分配方式可以如下：\n\n 1. 先均匀分配首领分区。随机选一个broker，轮训的方式给每个broker分配分区来确定首领分区的位置。\n 2. 再均匀分配分区副本。以首领分区为起点，了轮训分配分区副本。\n 3. 指定机架信息的时候，均匀分配分区的方式。假设 broker0、 broker1和 broker2放置在同一个机架上， broker3、 broker4 和 broker5分别放置在其他不同的机架上，那么在轮训分配的时候，我们不是按照从 0到 5的顺序来选择 broker，而 是按照 0, 3, 1, 4, 2, 5 的顺序来选择。\n\n如何做文件管理 因为在一个大文件中查找和删除是非常耗时的，所以我们把分区分成若干个片段。默认每个片段包含1g或者1周的数据。 当前正在写入数据的片段叫做活跃片段。活跃片段永远不会被删除。 broker会为分区的每个片段打开一个文件句柄，这会导致打开过多的文件句柄，所以操作系统必须根据实际情况做一些调优。 broker如何在一个分区的众多文件中定位指定的offset位置？ kakfa为每个分区文件建立索引，根据索引可以快速定位offset在文件中的位置。\n\n如果有必要，管理员可以删除索引，kafka会重新生成这些索引。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"系统设计",frontmatter:{title:"系统设计",date:"2022-03-11T00:56:07.000Z",permalink:"/pages/01b9b2/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/001.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html",relativePath:"08.系统设计/001.系统设计.md",key:"v-a9558ec0",path:"/pages/01b9b2/",headers:[{level:2,title:"电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？",slug:"电商系统中-如何实现秒杀功能-如何解决商品的超卖问题",normalizedTitle:"电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？",charIndex:2},{level:2,title:"如何解决缓存与数据库不一致的问题？",slug:"如何解决缓存与数据库不一致的问题",normalizedTitle:"如何解决缓存与数据库不一致的问题？",charIndex:34},{level:2,title:"简述中间件削峰和限流的使用场景",slug:"简述中间件削峰和限流的使用场景",normalizedTitle:"简述中间件削峰和限流的使用场景",charIndex:56},{level:2,title:"项目上有什么技术难点？",slug:"项目上有什么技术难点",normalizedTitle:"项目上有什么技术难点？",charIndex:76},{level:2,title:"简述 Zookeeper 基础原理以及使用场景",slug:"简述-zookeeper-基础原理以及使用场景",normalizedTitle:"简述 zookeeper 基础原理以及使用场景",charIndex:92},{level:2,title:"如何实现百度搜索功能？",slug:"如何实现百度搜索功能",normalizedTitle:"如何实现百度搜索功能？",charIndex:120},{level:2,title:"高并发情景下，核心线程池该如何设置参数？",slug:"高并发情景下-核心线程池该如何设置参数",normalizedTitle:"高并发情景下，核心线程池该如何设置参数？",charIndex:136},{level:2,title:"设计一个阻塞队列",slug:"设计一个阻塞队列",normalizedTitle:"设计一个阻塞队列",charIndex:161},{level:2,title:"容器化了解吗？它的基本原理是什么？",slug:"容器化了解吗-它的基本原理是什么",normalizedTitle:"容器化了解吗？它的基本原理是什么？",charIndex:174},{level:2,title:"简述中间件削峰和限流的使用场景",slug:"简述中间件削峰和限流的使用场景-2",normalizedTitle:"简述中间件削峰和限流的使用场景",charIndex:56},{level:2,title:"简述一致性哈希算法的实现方式及原理",slug:"简述一致性哈希算法的实现方式及原理",normalizedTitle:"简述一致性哈希算法的实现方式及原理",charIndex:216},{level:2,title:"简述常见的负载均衡算法",slug:"简述常见的负载均衡算法",normalizedTitle:"简述常见的负载均衡算法",charIndex:238},{level:2,title:"简述 MapReduce 的原理",slug:"简述-mapreduce-的原理",normalizedTitle:"简述 mapreduce 的原理",charIndex:254},{level:2,title:"设计 Tiny URL 系统",slug:"设计-tiny-url-系统",normalizedTitle:"设计 tiny url 系统",charIndex:275},{level:2,title:"如何设计一个无锁队列",slug:"如何设计一个无锁队列",normalizedTitle:"如何设计一个无锁队列",charIndex:294},{level:2,title:"RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？",slug:"restful-与-rpc-的区别是什么-restful-的优点在哪里",normalizedTitle:"restful 与 rpc 的区别是什么？restful 的优点在哪里？",charIndex:309},{level:2,title:"假如明天是活动高峰？QPS 预计会翻10倍，你要怎么做？",slug:"假如明天是活动高峰-qps-预计会翻10倍-你要怎么做",normalizedTitle:"假如明天是活动高峰？qps 预计会翻10倍，你要怎么做？",charIndex:350}],headersStr:"电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？ 如何解决缓存与数据库不一致的问题？ 简述中间件削峰和限流的使用场景 项目上有什么技术难点？ 简述 Zookeeper 基础原理以及使用场景 如何实现百度搜索功能？ 高并发情景下，核心线程池该如何设置参数？ 设计一个阻塞队列 容器化了解吗？它的基本原理是什么？ 简述中间件削峰和限流的使用场景 简述一致性哈希算法的实现方式及原理 简述常见的负载均衡算法 简述 MapReduce 的原理 设计 Tiny URL 系统 如何设计一个无锁队列 RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？ 假如明天是活动高峰？QPS 预计会翻10倍，你要怎么做？",content:"# 电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？\n\n\n# 如何解决缓存与数据库不一致的问题？\n\n\n# 简述中间件削峰和限流的使用场景\n\n\n# 项目上有什么技术难点？\n\n\n# 简述 Zookeeper 基础原理以及使用场景\n\n\n# 如何实现百度搜索功能？\n\n\n# 高并发情景下，核心线程池该如何设置参数？\n\n\n# 设计一个阻塞队列\n\n\n# 容器化了解吗？它的基本原理是什么？\n\n\n# 简述中间件削峰和限流的使用场景\n\n\n# 简述一致性哈希算法的实现方式及原理\n\n\n# 简述常见的负载均衡算法\n\n\n# 简述 MapReduce 的原理\n\n\n# 设计 Tiny URL 系统\n\n\n# 如何设计一个无锁队列\n\n\n# RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？\n\n\n# 假如明天是活动高峰？QPS 预计会翻10倍，你要怎么做？\n\n秒杀系统\n\n设计rpc\n\n短连接\n\n排行榜\n\n微信抢红包\n\n设计点赞功能\n\n微博feed流或微信朋友圈\n\n定时任务\n\n分布式id锁事务\n\n海量数据",normalizedContent:"# 电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？\n\n\n# 如何解决缓存与数据库不一致的问题？\n\n\n# 简述中间件削峰和限流的使用场景\n\n\n# 项目上有什么技术难点？\n\n\n# 简述 zookeeper 基础原理以及使用场景\n\n\n# 如何实现百度搜索功能？\n\n\n# 高并发情景下，核心线程池该如何设置参数？\n\n\n# 设计一个阻塞队列\n\n\n# 容器化了解吗？它的基本原理是什么？\n\n\n# 简述中间件削峰和限流的使用场景\n\n\n# 简述一致性哈希算法的实现方式及原理\n\n\n# 简述常见的负载均衡算法\n\n\n# 简述 mapreduce 的原理\n\n\n# 设计 tiny url 系统\n\n\n# 如何设计一个无锁队列\n\n\n# restful 与 rpc 的区别是什么？restful 的优点在哪里？\n\n\n# 假如明天是活动高峰？qps 预计会翻10倍，你要怎么做？\n\n秒杀系统\n\n设计rpc\n\n短连接\n\n排行榜\n\n微信抢红包\n\n设计点赞功能\n\n微博feed流或微信朋友圈\n\n定时任务\n\n分布式id锁事务\n\n海量数据",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"如何保证Kafka的可靠性",frontmatter:{title:"如何保证Kafka的可靠性",date:"2022-05-21T23:47:03.000Z",permalink:"/pages/76a94c/",categories:["中间件","Kafka"],tags:[null]},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/040.%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Kafka%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7.html",relativePath:"04.中间件/40.Kafka/040.如何保证Kafka的可靠性.md",key:"v-684c4815",path:"/pages/76a94c/",headersStr:null,content:"# 可靠性保证\n\nkafka在哪些方面做出保证呢？\n\n * 单生产者，kafka可以保证顺序消费\n * 只有当写入的消息被写入所有的副本时，才认为是“已提交”的\n * 只要有一个活跃的分区副本，那么，已提交的数据就不会丢失。\n * 消费者只能读取已经提交的消息\n\n如何保证topic元数据信息安全 replication.factor配置topic的复制系数\n\n所有的分区副本都没有正常同步，分区首领又挂掉了，如何做选举？ 方案有两个\n\n * 在未正常同步的副中选举一个作为首领，缺点是存在丢失数据的风险。\n * 等待旧的首领恢复。缺点是可用性低。\n\n配置unclean.leader.election.enable=true表示允许不同步的副本称为首领，这也将面临丢失消息的风险。\n\n\n# producer如何做可靠性保证\n\n如何保证可靠投递消息？\n\n 1. ack=all表示broker要等待所有分区副本同步完消息才返回给producer response，是最可靠的投递。\n 2. 设置重试次数，注意要做业务幂等。\n 3. 有些小时不可重试错误，比如消息太大、认证错误等。根据业务来特殊处理这类消息。\n\n\n# consumer如何做可靠性保证\n\nconsumer请求的offset在broker上不存在时怎么处理？ 配置auto.offset.reset指定了两种策略：\n\n * earliest:从分区的开始读取\n * latest：从分区的末尾读取",normalizedContent:"# 可靠性保证\n\nkafka在哪些方面做出保证呢？\n\n * 单生产者，kafka可以保证顺序消费\n * 只有当写入的消息被写入所有的副本时，才认为是“已提交”的\n * 只要有一个活跃的分区副本，那么，已提交的数据就不会丢失。\n * 消费者只能读取已经提交的消息\n\n如何保证topic元数据信息安全 replication.factor配置topic的复制系数\n\n所有的分区副本都没有正常同步，分区首领又挂掉了，如何做选举？ 方案有两个\n\n * 在未正常同步的副中选举一个作为首领，缺点是存在丢失数据的风险。\n * 等待旧的首领恢复。缺点是可用性低。\n\n配置unclean.leader.election.enable=true表示允许不同步的副本称为首领，这也将面临丢失消息的风险。\n\n\n# producer如何做可靠性保证\n\n如何保证可靠投递消息？\n\n 1. ack=all表示broker要等待所有分区副本同步完消息才返回给producer response，是最可靠的投递。\n 2. 设置重试次数，注意要做业务幂等。\n 3. 有些小时不可重试错误，比如消息太大、认证错误等。根据业务来特殊处理这类消息。\n\n\n# consumer如何做可靠性保证\n\nconsumer请求的offset在broker上不存在时怎么处理？ 配置auto.offset.reset指定了两种策略：\n\n * earliest:从分区的开始读取\n * latest：从分区的末尾读取",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？",frontmatter:{title:"电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？",date:"2022-10-20T22:29:23.000Z",permalink:"/pages/379160/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/005.%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E5%8A%9F%E8%83%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81%E7%9A%84%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%EF%BC%9F.html",relativePath:"08.系统设计/005.电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？.md",key:"v-164d9a94",path:"/pages/379160/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"1 瞬时高并发",slug:"_1-瞬时高并发",normalizedTitle:"1 瞬时高并发",charIndex:242},{level:2,title:"2. 页面静态化",slug:"_2-页面静态化",normalizedTitle:"2. 页面静态化",charIndex:599},{level:2,title:"3 秒杀按钮",slug:"_3-秒杀按钮",normalizedTitle:"3 秒杀按钮",charIndex:986},{level:2,title:"4 读多写少",slug:"_4-读多写少",normalizedTitle:"4 读多写少",charIndex:1486},{level:2,title:"5 缓存问题",slug:"_5-缓存问题",normalizedTitle:"5 缓存问题",charIndex:1758},{level:3,title:"5.1 缓存击穿",slug:"_5-1-缓存击穿",normalizedTitle:"5.1 缓存击穿",charIndex:2037},{level:3,title:"5.2 缓存穿透",slug:"_5-2-缓存穿透",normalizedTitle:"5.2 缓存穿透",charIndex:2406},{level:2,title:"6 库存问题",slug:"_6-库存问题",normalizedTitle:"6 库存问题",charIndex:2907},{level:3,title:"6.1 数据库扣减库存",slug:"_6-1-数据库扣减库存",normalizedTitle:"6.1 数据库扣减库存",charIndex:3080},{level:3,title:"6.2 redis扣减库存",slug:"_6-2-redis扣减库存",normalizedTitle:"6.2 redis扣减库存",charIndex:3803},{level:3,title:"6.3 lua脚本扣减库存",slug:"_6-3-lua脚本扣减库存",normalizedTitle:"6.3 lua脚本扣减库存",charIndex:5353},{level:2,title:"7 分布式锁",slug:"_7-分布式锁",normalizedTitle:"7 分布式锁",charIndex:6127},{level:3,title:"7.1 setNx加锁",slug:"_7-1-setnx加锁",normalizedTitle:"7.1 setnx加锁",charIndex:6328},{level:3,title:"7.2 set加锁",slug:"_7-2-set加锁",normalizedTitle:"7.2 set加锁",charIndex:6576},{level:3,title:"7.3 释放锁",slug:"_7-3-释放锁",normalizedTitle:"7.3 释放锁",charIndex:6898},{level:3,title:"7.4 自旋锁",slug:"_7-4-自旋锁",normalizedTitle:"7.4 自旋锁",charIndex:7429},{level:3,title:"7.5 redisson",slug:"_7-5-redisson",normalizedTitle:"7.5 redisson",charIndex:8272},{level:2,title:"8 mq异步处理",slug:"_8-mq异步处理",normalizedTitle:"8 mq异步处理",charIndex:8416},{level:3,title:"8.1 消息丢失问题",slug:"_8-1-消息丢失问题",normalizedTitle:"8.1 消息丢失问题",charIndex:8611},{level:3,title:"8.2 重复消费问题",slug:"_8-2-重复消费问题",normalizedTitle:"8.2 重复消费问题",charIndex:8943},{level:3,title:"8.3 垃圾消息问题",slug:"_8-3-垃圾消息问题",normalizedTitle:"8.3 垃圾消息问题",charIndex:9186},{level:3,title:"8.4 延迟消费问题",slug:"_8-4-延迟消费问题",normalizedTitle:"8.4 延迟消费问题",charIndex:9420},{level:2,title:"9 如何限流？",slug:"_9-如何限流",normalizedTitle:"9 如何限流？",charIndex:9787},{level:3,title:"9.1 对同一用户限流",slug:"_9-1-对同一用户限流",normalizedTitle:"9.1 对同一用户限流",charIndex:10121},{level:3,title:"9.2 对同一ip限流",slug:"_9-2-对同一ip限流",normalizedTitle:"9.2 对同一ip限流",charIndex:10195},{level:3,title:"9.3 对接口限流",slug:"_9-3-对接口限流",normalizedTitle:"9.3 对接口限流",charIndex:10365},{level:3,title:"9.4 加验证码",slug:"_9-4-加验证码",normalizedTitle:"9.4 加验证码",charIndex:10522},{level:3,title:"9.5 提高业务门槛",slug:"_9-5-提高业务门槛",normalizedTitle:"9.5 提高业务门槛",charIndex:10806},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:11158}],headersStr:"前言 1 瞬时高并发 2. 页面静态化 3 秒杀按钮 4 读多写少 5 缓存问题 5.1 缓存击穿 5.2 缓存穿透 6 库存问题 6.1 数据库扣减库存 6.2 redis扣减库存 6.3 lua脚本扣减库存 7 分布式锁 7.1 setNx加锁 7.2 set加锁 7.3 释放锁 7.4 自旋锁 7.5 redisson 8 mq异步处理 8.1 消息丢失问题 8.2 重复消费问题 8.3 垃圾消息问题 8.4 延迟消费问题 9 如何限流？ 9.1 对同一用户限流 9.2 对同一ip限流 9.3 对接口限流 9.4 加验证码 9.5 提高业务门槛 参考",content:'# 前言\n\n高并发下如何设计秒杀系统？这是一个高频面试题。这个问题看似简单，但是里面的水很深，它考查的是高并发场景下，从前端到后端多方面的知识。\n\n秒杀一般出现在商城的促销活动中，指定了一定数量（比如：10个）的商品（比如：手机），以极低的价格（比如：0.1元），让大量用户参与活动，但只有极少数用户能够购买成功。这类活动商家绝大部分是不赚钱的，说白了是找个噱头宣传自己。\n\n虽说秒杀只是一个促销活动，但对技术要求不低。下面给大家总结一下设计秒杀系统需要注意的9个细节。\n\n\n\n\n# 1 瞬时高并发\n\n一般在秒杀时间点（比如：12点）前几分钟，用户并发量才真正突增，达到秒杀时间点时，并发量会达到顶峰。\n\n但由于这类活动是大量用户抢少量商品的场景，必定会出现狼多肉少的情况，所以其实绝大部分用户秒杀会失败，只有极少部分用户能够成功。\n\n正常情况下，大部分用户会收到商品已经抢完的提醒，收到该提醒后，他们大概率不会在那个活动页面停留了，如此一来，用户并发量又会急剧下降。所以这个峰值持续的时间其实是非常短的，这样就会出现瞬时高并发的情况，下面用一张图直观的感受一下流量的变化：\n\n\n\n像这种瞬时高并发的场景，传统的系统很难应对，我们需要设计一套全新的系统。可以从以下几个方面入手：\n\n 1. 页面静态化\n 2. CDN加速\n 3. 缓存\n 4. mq异步处理\n 5. 限流\n 6. 分布式锁\n\n\n# 2. 页面静态化\n\n活动页面是用户流量的第一入口，所以是并发量最大的地方。\n\n如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。\n\n活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做静态化处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。\n\n这样能过滤大部分无效请求。\n\n但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。\n\n如何才能让用户最快访问到活动页面呢？\n\n这就需要使用CDN，它的全称是Content Delivery Network，即内容分发网络。\n\n使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\n\n\n# 3 秒杀按钮\n\n大部分用户怕错过秒杀时间点，一般会提前进入活动页面。此时看到的秒杀按钮是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。\n\n但此时很多用户已经迫不及待了，通过不停刷新页面，争取在第一时间看到秒杀按钮的点亮。\n\n从前面得知，该活动页面是静态的。那么我们在静态页面中如何控制秒杀按钮，只在秒杀时间点时才点亮呢？\n\n没错，使用js文件控制。\n\n为了性能考虑，一般会将css、js和图片等静态资源文件提前缓存到CDN上，让用户能够就近访问秒杀页面。\n\n看到这里，有些聪明的小伙伴，可能会问：CDN上的js文件是如何更新的？\n\n秒杀开始之前，js标志为false，还有另外一个随机参数。当秒杀开始的时候系统会生成一个新的js文件，此时标志为true，并且随机参数生成一个新值，然后同步给CDN。由于有了这个随机参数，CDN不会缓存数据，每次都能从CDN中获取最新的js代码。此外，前端还可以加一个定时器，控制比如：10秒之内，只允许发起一次请求。如果用户点击了一次秒杀按钮，则在10秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。\n\n\n# 4 读多写少\n\n在秒杀的过程中，系统一般会先查一下库存是否足够，如果足够才允许下单，写数据库。如果不够，则直接返回该商品已经抢完。\n\n由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。\n\n这是非常典型的：读多写少 的场景。\n\n如果有数十万的请求过来，同时通过数据库查缓存是否足够，此时数据库可能会挂掉。因为数据库的连接资源非常有限，比如：mysql，无法同时支持这么多的连接。\n\n而应该改用缓存，比如：redis。\n\n即便用了redis，也需要部署多个节点。\n\n\n# 5 缓存问题\n\n通常情况下，我们需要在redis中保存商品信息，里面包含：商品id、商品名称、规格属性、库存等信息，同时数据库中也要有相关信息，毕竟缓存并不完全可靠。\n\n用户在点击秒杀按钮，请求秒杀接口的过程中，需要传入的商品id参数，然后服务端需要校验该商品是否合法。\n\n大致流程如下图所示：\n\n\n\n根据商品id，先从缓存中查询商品，如果商品存在，则参与秒杀。如果不存在，则需要从数据库中查询商品，如果存在，则将商品信息放入缓存，然后参与秒杀。如果商品不存在，则直接提示失败。\n\n这个过程表面上看起来是OK的，但是如果深入分析一下会发现一些问题。\n\n\n# 5.1 缓存击穿\n\n比如商品A第一次秒杀时，缓存中是没有数据的，但数据库中有。虽说上面有如果从数据库中查到数据，则放入缓存的逻辑。\n\n然而，在高并发下，同一时刻会有大量的请求，都在秒杀同一件商品，这些请求同时去查缓存中没有数据，然后又同时访问数据库。结果悲剧了，数据库可能扛不住压力，直接挂掉。\n\n如何解决这个问题呢？\n\n这就需要加锁，最好使用分布式锁。\n\n当然，针对这种情况，最好在项目启动之前，先把缓存进行预热。即事先把所有的商品，同步到缓存中，这样商品基本都能直接从缓存中获取到，就不会出现缓存击穿的问题了。\n\n是不是上面加锁这一步可以不需要了？\n\n表面上看起来，确实可以不需要。但如果缓存中设置的过期时间不对，缓存提前过期了，或者缓存被不小心删除了，如果不加锁同样可能出现缓存击穿。\n\n其实这里加锁，相当于买了一份保险。\n\n\n# 5.2 缓存穿透\n\n如果有大量的请求传入的商品id，在缓存中和数据库中都不存在，这些请求不就每次都会穿透过缓存，而直接访问数据库了。\n\n由于前面已经加了锁，所以即使这里的并发量很大，也不会导致数据库直接挂掉。\n\n但很显然这些请求的处理性能并不好，有没有更好的解决方案？\n\n这时可以想到布隆过滤器。\n\n系统根据商品id，先从布隆过滤器中查询该id是否存在，如果存在则允许从缓存中查询数据，如果不存在，则直接返回失败。\n\n虽说该方案可以解决缓存穿透问题，但是又会引出另外一个问题：布隆过滤器中的数据如何更缓存中的数据保持一致？\n\n这就要求，如果缓存中数据有更新，则要及时同步到布隆过滤器中。如果数据同步失败了，还需要增加重试机制，而且跨数据源，能保证数据的实时一致性吗？\n\n显然是不行的。\n\n所以布隆过滤器绝大部分使用在缓存数据更新很少的场景中。\n\n如果缓存数据更新非常频繁，又该如何处理呢？\n\n这时，就需要把不存在的商品id也缓存起来。\n\n下次，再有该商品id的请求过来，则也能从缓存中查到数据，只不过该数据比较特殊，表示商品不存在。需要特别注意的是，这种特殊缓存设置的超时时间应该尽量短一点。\n\n\n# 6 库存问题\n\n对于库存问题看似简单，实则里面还是有些东西。\n\n真正的秒杀商品的场景，不是说扣完库存，就完事了，如果用户在一段时间内，还没完成支付，扣减的库存是要加回去的。\n\n所以，在这里引出了一个预扣库存的概念，预扣库存的主要流程如下：\n\n\n\n扣减库存中除了上面说到的预扣库存和回退库存之外，还需要特别注意的是库存不足和库存超卖问题。\n\n\n# 6.1 数据库扣减库存\n\n使用数据库扣减库存，是最简单的实现方案了，假设扣减库存的sql如下：\n\nupdate product set stock=stock-1 where id=123;\n\n\n1\n\n\n这种写法对于扣减库存是没有问题的，但如何控制库存不足的情况下，不让用户操作呢？\n\n这就需要在update之前，先查一下库存是否足够了。\n\n伪代码如下：\n\nint stock = mapper.getStockById(123);\nif(stock > 0) {\n  int count = mapper.updateStock(123);\n  if(count > 0) {\n    addOrder(123);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n大家有没有发现这段代码的问题？\n\n没错，查询操作和更新操作不是原子性的，会导致在并发的场景下，出现库存超卖的情况。\n\n有人可能会说，这样好办，加把锁，不就搞定了，比如使用synchronized关键字。\n\n确实，可以，但是性能不够好。\n\n还有更优雅的处理方案，即基于数据库的乐观锁，这样会少一次数据库查询，而且能够天然的保证数据操作的原子性。\n\n只需将上面的sql稍微调整一下：\n\nupdate product set stock=stock-1 where id=product and stock > 0;\n\n\n1\n\n\n在sql最后加上：stock > 0，就能保证不会出现超卖的情况。\n\n但需要频繁访问数据库，我们都知道数据库连接是非常昂贵的资源。在高并发的场景下，可能会造成系统雪崩。而且，容易出现多个请求，同时竞争行锁的情况，造成相互等待，从而出现死锁的问题。\n\n\n# 6.2 redis扣减库存\n\nredis的incr方法是原子性的，可以用该方法扣减库存。伪代码如下：\n\n boolean exist = redisClient.query(productId,userId);\n  if(exist) {\n    return -1;\n  }\n  int stock = redisClient.queryStock(productId);\n  if(stock <=0) {\n    return 0;\n  }\n  redisClient.incrby(productId, -1);\n  redisClient.add(productId,userId);\nreturn 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n代码流程如下：\n\n 1. 先判断该用户有没有秒杀过该商品，如果已经秒杀过，则直接返回-1。\n 2. 查询库存，如果库存小于等于0，则直接返回0，表示库存不足。\n 3. 如果库存充足，则扣减库存，然后将本次秒杀记录保存起来。然后返回1，表示成功。\n\n估计很多小伙伴，一开始都会按这样的思路写代码。但如果仔细想想会发现，这段代码有问题。\n\n有什么问题呢？\n\n如果在高并发下，有多个请求同时查询库存，当时都大于0。由于查询库存和更新库存非原则操作，则会出现库存为负数的情况，即库存超卖。\n\n当然有人可能会说，加个synchronized不就解决问题？\n\n调整后代码如下：\n\n   boolean exist = redisClient.query(productId,userId);\n   if(exist) {\n    return -1;\n   }\n   synchronized(this) {\n       int stock = redisClient.queryStock(productId);\n       if(stock <=0) {\n         return 0;\n       }\n       redisClient.incrby(productId, -1);\n       redisClient.add(productId,userId);\n   }\n\nreturn 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n加synchronized确实能解决库存为负数问题，但是这样会导致接口性能急剧下降，每次查询都需要竞争同一把锁，显然不太合理。\n\n为了解决上面的问题，代码优化如下：\n\nboolean exist = redisClient.query(productId,userId);\nif(exist) {\n  return -1;\n}\nif(redisClient.incrby(productId, -1)<0) {\n  return 0;\n}\nredisClient.add(productId,userId);\nreturn 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n该代码主要流程如下：\n\n 1. 先判断该用户有没有秒杀过该商品，如果已经秒杀过，则直接返回-1。\n 2. 扣减库存，判断返回值是否小于0，如果小于0，则直接返回0，表示库存不足。\n 3. 如果扣减库存后，返回值大于或等于0，则将本次秒杀记录保存起来。然后返回1，表示成功。\n\n该方案咋一看，好像没问题。\n\n但如果在高并发场景中，有多个请求同时扣减库存，大多数请求的incrby操作之后，结果都会小于0。\n\n虽说，库存出现负数，不会出现超卖的问题。但由于这里是预减库存，如果负数值负的太多的话，后面万一要回退库存时，就会导致库存不准。\n\n那么，有没有更好的方案呢？\n\n\n# 6.3 lua脚本扣减库存\n\n我们都知道lua脚本，是能够保证原子性的，它跟redis一起配合使用，能够完美解决上面的问题。\n\nlua脚本有段非常经典的代码：\n\n  StringBuilder lua = new StringBuilder();\n  lua.append("if (redis.call(\'exists\', KEYS[1]) == 1) then");\n  lua.append("    local stock = tonumber(redis.call(\'get\', KEYS[1]));");\n  lua.append("    if (stock == -1) then");\n  lua.append("        return 1;");\n  lua.append("    end;");\n  lua.append("    if (stock > 0) then");\n  lua.append("        redis.call(\'incrby\', KEYS[1], -1);");\n  lua.append("        return stock;");\n  lua.append("    end;");\n  lua.append("    return 0;");\n  lua.append("end;");\n  lua.append("return -1;");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n该代码的主要流程如下：\n\n 1. 先判断商品id是否存在，如果不存在则直接返回。\n 2. 获取该商品id的库存，判断库存如果是-1，则直接返回，表示不限制库存。\n 3. 如果库存大于0，则扣减库存。\n 4. 如果库存等于0，是直接返回，表示库存不足。\n\n\n# 7 分布式锁\n\n之前我提到过，在秒杀的时候，需要先从缓存中查商品是否存在，如果不存在，则会从数据库中查商品。如果数据库中，则将该商品放入缓存中，然后返回。如果数据库中没有，则直接返回失败。\n\n大家试想一下，如果在高并发下，有大量的请求都去查一个缓存中不存在的商品，这些请求都会直接打到数据库。数据库由于承受不住压力，而直接挂掉。\n\n那么如何解决这个问题呢？\n\n这就需要用redis分布式锁了。\n\n\n# 7.1 setNx加锁\n\n使用redis的分布式锁，首先想到的是setNx命令。\n\nif (jedis.setnx(lockKey, val) == 1) {\n   jedis.expire(lockKey, timeout);\n}\n\n\n1\n2\n3\n\n\n用该命令其实可以加锁，但和后面的设置超时时间是分开的，并非原子操作。\n\n假如加锁成功了，但是设置超时时间失败了，该lockKey就变成永不失效的了。在高并发场景中，该问题会导致非常严重的后果。\n\n那么，有没有保证原子性的加锁命令呢？\n\n\n# 7.2 set加锁\n\n使用redis的set命令，它可以指定多个参数。\n\nString result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);\nif ("OK".equals(result)) {\n    return true;\n}\nreturn false;\n\n\n1\n2\n3\n4\n5\n\n\n其中：\n\n * lockKey：锁的标识\n * requestId：请求id\n * NX：只在键不存在时，才对键进行设置操作。\n * PX：设置键的过期时间为 millisecond 毫秒。\n * expireTime：过期时间\n\n由于该命令只有一步，所以它是原子操作。\n\n\n# 7.3 释放锁\n\n接下来，有些朋友可能会问：在加锁时，既然已经有了lockKey锁标识，为什么要需要记录requestId呢？\n\n答：requestId是在释放锁的时候用的。\n\nif (jedis.get(lockKey).equals(requestId)) {\n    jedis.del(lockKey);\n    return true;\n}\nreturn false;\n\n\n1\n2\n3\n4\n5\n\n\n在释放锁的时候，只能释放自己加的锁，不允许释放别人加的锁。\n\n这里为什么要用requestId，用userId不行吗？\n\n答：如果用userId的话，假设本次请求流程走完了，准备删除锁。此时，巧合锁到了过期时间失效了。而另外一个请求，巧合使用的相同userId加锁，会成功。而本次请求删除锁的时候，删除的其实是别人的锁了。\n\n当然使用lua脚本也能避免该问题：\n\nif redis.call(\'get\', KEYS[1]) == ARGV[1] then \n return redis.call(\'del\', KEYS[1]) \nelse \n  return 0 \nend\n\n\n1\n2\n3\n4\n5\n\n\n它能保证查询锁是否存在和删除锁是原子操作。\n\n\n# 7.4 自旋锁\n\n上面的加锁方法看起来好像没有问题，但如果你仔细想想，如果有1万的请求同时去竞争那把锁，可能只有一个请求是成功的，其余的9999个请求都会失败。\n\n在秒杀场景下，会有什么问题？\n\n答：每1万个请求，有1个成功。再1万个请求，有1个成功。如此下去，直到库存不足。这就变成均匀分布的秒杀了，跟我们想象中的不一样。\n\n如何解决这个问题呢？\n\n答：使用自旋锁。\n\ntry {\n  Long start = System.currentTimeMillis();\n  while(true) {\n      String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);\n     if ("OK".equals(result)) {\n        return true;\n     }\n     \n     long time = System.currentTimeMillis() - start;\n      if (time>=timeout) {\n          return false;\n      }\n      try {\n          Thread.sleep(50);\n      } catch (InterruptedException e) {\n          e.printStackTrace();\n      }\n  }\n \n} finally{\n    unlock(lockKey,requestId);\n}  \nreturn false;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在规定的时间，比如500毫秒内，自旋不断尝试加锁，如果成功则直接返回。如果失败，则休眠50毫秒，再发起新一轮的尝试。如果到了超时时间，还未加锁成功，则直接返回失败。\n\n\n# 7.5 redisson\n\n除了上面的问题之外，使用redis分布式锁，还有锁竞争问题、续期问题、锁重入问题、多个redis实例加锁问题等。\n\n这些问题使用redisson可以解决，由于篇幅的原因，在这里先保留一点悬念，有疑问的私聊给我。后面会出一个专题介绍分布式锁，敬请期待。\n\n\n# 8 mq异步处理\n\n我们都知道在真实的秒杀场景中，有三个核心流程：而这三个核心流程中，真正并发量大的是秒杀功能，下单和支付功能实际并发量很小。所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成mq异步处理的。而支付功能，比如支付宝支付，是业务场景本身保证的异步。\n\n于是，秒杀后下单的流程变成如下：如果使用mq，需要关注以下几个问题：\n\n\n# 8.1 消息丢失问题\n\n秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。\n\n那么，如何防止消息丢失呢？\n\n答：加一张消息发送表。\n\n在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。\n\n如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。\n\n这时候，要如何处理呢？\n\n答：使用job，增加重试机制。\n\n用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。\n\n\n# 8.2 重复消费问题\n\n本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。\n\n那么，如何解决重复消息问题呢？\n\n答：加一张消息处理表。\n\n消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。\n\n有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。\n\n\n# 8.3 垃圾消息问题\n\n这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。\n\n那么，如何解决这个问题呢？每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。\n\n这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。\n\n\n# 8.4 延迟消费问题\n\n通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。\n\n那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？\n\n我们首先想到的可能是job，因为它比较简单。\n\n但job有个问题，需要每隔一段时间处理一次，实时性不太好。\n\n还有更好的方案？\n\n答：使用延迟队列。\n\n我们都知道rocketmq，自带了延迟队列的功能。\n\n下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。\n\n还有个关键点，用户完成支付之后，会修改订单状态为已支付。\n\n\n\n\n# 9 如何限流？\n\n通过秒杀活动，如果我们运气爆棚，可能会用非常低的价格买到不错的商品（这种概率堪比买福利彩票中大奖）。\n\n但有些高手，并不会像我们一样老老实实，通过秒杀页面点击秒杀按钮，抢购商品。他们可能在自己的服务器上，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。\n\n如果是我们手动操作，一般情况下，一秒钟只能点击一次秒杀按钮。但是如果是服务器，一秒钟可以请求成上千接口。这种差距实在太明显了，如果不做任何限制，绝大部分商品可能是被机器抢到，而非正常的用户，有点不太公平。\n\n所以，我们有必要识别这些非法请求，做一些限制。那么，我们该如何现在这些非法请求呢？\n\n目前有两种常用的限流方式：\n\n 1. 基于nginx限流\n 2. 基于redis限流\n\n\n# 9.1 对同一用户限流\n\n为了防止某个用户，请求接口次数过于频繁，可以只针对该用户做限制。限制同一个用户id，比如每分钟只能请求5次接口。\n\n\n# 9.2 对同一ip限流\n\n有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这种nginx就没法识别了。\n\n这时需要加同一ip限流功能。限制同一个ip，比如每分钟只能请求5次接口。\n\n但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。\n\n\n# 9.3 对接口限流\n\n别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。\n\n这时可以限制请求的接口总次数。在高并发场景下，这种限制对于系统的稳定性是非常有必要的。但可能由于有些非法请求次数太多，达到了该接口的请求上限，而影响其他的正常用户访问该接口。看起来有点得不偿失。\n\n\n# 9.4 加验证码\n\n相对于上面三种方式，加验证码的方式可能更精准一些，同样能限制用户的访问频次，但好处是不会存在误杀的情况。\n\n通常情况下，用户在请求之前，需要先输入验证码。用户发起请求之后，服务端会去校验该验证码是否正确。只有正确才允许进行下一步操作，否则直接返回，并且提示验证码错误。\n\n此外，验证码一般是一次性的，同一个验证码只允许使用一次，不允许重复使用。\n\n普通验证码，由于生成的数字或者图案比较简单，可能会被破解。优点是生成速度比较快，缺点是有安全隐患。\n\n还有一个验证码叫做：移动滑块，它生成速度比较慢，但比较安全，是目前各大互联网公司的首选。\n\n\n# 9.5 提高业务门槛\n\n上面说的加验证码虽然可以限制非法用户请求，但是有些影响用户体验。用户点击秒杀按钮前，还要先输入验证码，流程显得有点繁琐，秒杀功能的流程不是应该越简单越好吗？\n\n其实，有时候达到某个目的，不一定非要通过技术手段，通过业务手段也一样。\n\n12306刚开始的时候，全国人民都在同一时刻抢火车票，由于并发量太大，系统经常挂。后来，重构优化之后，将购买周期放长了，可以提前20天购买火车票，并且可以在9点、10、11点、12点等整点购买火车票。调整业务之后（当然技术也有很多调整），将之前集中的请求，分散开了，一下子降低了用户并发量。\n\n回到这里，我们通过提高业务门槛，比如只有会员才能参与秒杀活动，普通注册用户没有权限。或者，只有等级到达3级以上的普通用户，才有资格参加该活动。\n\n\n# 参考\n\n面试官：聊聊秒杀系统如何设计？ 敖丙带你设计-秒杀系统',normalizedContent:'# 前言\n\n高并发下如何设计秒杀系统？这是一个高频面试题。这个问题看似简单，但是里面的水很深，它考查的是高并发场景下，从前端到后端多方面的知识。\n\n秒杀一般出现在商城的促销活动中，指定了一定数量（比如：10个）的商品（比如：手机），以极低的价格（比如：0.1元），让大量用户参与活动，但只有极少数用户能够购买成功。这类活动商家绝大部分是不赚钱的，说白了是找个噱头宣传自己。\n\n虽说秒杀只是一个促销活动，但对技术要求不低。下面给大家总结一下设计秒杀系统需要注意的9个细节。\n\n\n\n\n# 1 瞬时高并发\n\n一般在秒杀时间点（比如：12点）前几分钟，用户并发量才真正突增，达到秒杀时间点时，并发量会达到顶峰。\n\n但由于这类活动是大量用户抢少量商品的场景，必定会出现狼多肉少的情况，所以其实绝大部分用户秒杀会失败，只有极少部分用户能够成功。\n\n正常情况下，大部分用户会收到商品已经抢完的提醒，收到该提醒后，他们大概率不会在那个活动页面停留了，如此一来，用户并发量又会急剧下降。所以这个峰值持续的时间其实是非常短的，这样就会出现瞬时高并发的情况，下面用一张图直观的感受一下流量的变化：\n\n\n\n像这种瞬时高并发的场景，传统的系统很难应对，我们需要设计一套全新的系统。可以从以下几个方面入手：\n\n 1. 页面静态化\n 2. cdn加速\n 3. 缓存\n 4. mq异步处理\n 5. 限流\n 6. 分布式锁\n\n\n# 2. 页面静态化\n\n活动页面是用户流量的第一入口，所以是并发量最大的地方。\n\n如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。\n\n活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做静态化处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。\n\n这样能过滤大部分无效请求。\n\n但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。\n\n如何才能让用户最快访问到活动页面呢？\n\n这就需要使用cdn，它的全称是content delivery network，即内容分发网络。\n\n使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\n\n\n# 3 秒杀按钮\n\n大部分用户怕错过秒杀时间点，一般会提前进入活动页面。此时看到的秒杀按钮是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。\n\n但此时很多用户已经迫不及待了，通过不停刷新页面，争取在第一时间看到秒杀按钮的点亮。\n\n从前面得知，该活动页面是静态的。那么我们在静态页面中如何控制秒杀按钮，只在秒杀时间点时才点亮呢？\n\n没错，使用js文件控制。\n\n为了性能考虑，一般会将css、js和图片等静态资源文件提前缓存到cdn上，让用户能够就近访问秒杀页面。\n\n看到这里，有些聪明的小伙伴，可能会问：cdn上的js文件是如何更新的？\n\n秒杀开始之前，js标志为false，还有另外一个随机参数。当秒杀开始的时候系统会生成一个新的js文件，此时标志为true，并且随机参数生成一个新值，然后同步给cdn。由于有了这个随机参数，cdn不会缓存数据，每次都能从cdn中获取最新的js代码。此外，前端还可以加一个定时器，控制比如：10秒之内，只允许发起一次请求。如果用户点击了一次秒杀按钮，则在10秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。\n\n\n# 4 读多写少\n\n在秒杀的过程中，系统一般会先查一下库存是否足够，如果足够才允许下单，写数据库。如果不够，则直接返回该商品已经抢完。\n\n由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。\n\n这是非常典型的：读多写少 的场景。\n\n如果有数十万的请求过来，同时通过数据库查缓存是否足够，此时数据库可能会挂掉。因为数据库的连接资源非常有限，比如：mysql，无法同时支持这么多的连接。\n\n而应该改用缓存，比如：redis。\n\n即便用了redis，也需要部署多个节点。\n\n\n# 5 缓存问题\n\n通常情况下，我们需要在redis中保存商品信息，里面包含：商品id、商品名称、规格属性、库存等信息，同时数据库中也要有相关信息，毕竟缓存并不完全可靠。\n\n用户在点击秒杀按钮，请求秒杀接口的过程中，需要传入的商品id参数，然后服务端需要校验该商品是否合法。\n\n大致流程如下图所示：\n\n\n\n根据商品id，先从缓存中查询商品，如果商品存在，则参与秒杀。如果不存在，则需要从数据库中查询商品，如果存在，则将商品信息放入缓存，然后参与秒杀。如果商品不存在，则直接提示失败。\n\n这个过程表面上看起来是ok的，但是如果深入分析一下会发现一些问题。\n\n\n# 5.1 缓存击穿\n\n比如商品a第一次秒杀时，缓存中是没有数据的，但数据库中有。虽说上面有如果从数据库中查到数据，则放入缓存的逻辑。\n\n然而，在高并发下，同一时刻会有大量的请求，都在秒杀同一件商品，这些请求同时去查缓存中没有数据，然后又同时访问数据库。结果悲剧了，数据库可能扛不住压力，直接挂掉。\n\n如何解决这个问题呢？\n\n这就需要加锁，最好使用分布式锁。\n\n当然，针对这种情况，最好在项目启动之前，先把缓存进行预热。即事先把所有的商品，同步到缓存中，这样商品基本都能直接从缓存中获取到，就不会出现缓存击穿的问题了。\n\n是不是上面加锁这一步可以不需要了？\n\n表面上看起来，确实可以不需要。但如果缓存中设置的过期时间不对，缓存提前过期了，或者缓存被不小心删除了，如果不加锁同样可能出现缓存击穿。\n\n其实这里加锁，相当于买了一份保险。\n\n\n# 5.2 缓存穿透\n\n如果有大量的请求传入的商品id，在缓存中和数据库中都不存在，这些请求不就每次都会穿透过缓存，而直接访问数据库了。\n\n由于前面已经加了锁，所以即使这里的并发量很大，也不会导致数据库直接挂掉。\n\n但很显然这些请求的处理性能并不好，有没有更好的解决方案？\n\n这时可以想到布隆过滤器。\n\n系统根据商品id，先从布隆过滤器中查询该id是否存在，如果存在则允许从缓存中查询数据，如果不存在，则直接返回失败。\n\n虽说该方案可以解决缓存穿透问题，但是又会引出另外一个问题：布隆过滤器中的数据如何更缓存中的数据保持一致？\n\n这就要求，如果缓存中数据有更新，则要及时同步到布隆过滤器中。如果数据同步失败了，还需要增加重试机制，而且跨数据源，能保证数据的实时一致性吗？\n\n显然是不行的。\n\n所以布隆过滤器绝大部分使用在缓存数据更新很少的场景中。\n\n如果缓存数据更新非常频繁，又该如何处理呢？\n\n这时，就需要把不存在的商品id也缓存起来。\n\n下次，再有该商品id的请求过来，则也能从缓存中查到数据，只不过该数据比较特殊，表示商品不存在。需要特别注意的是，这种特殊缓存设置的超时时间应该尽量短一点。\n\n\n# 6 库存问题\n\n对于库存问题看似简单，实则里面还是有些东西。\n\n真正的秒杀商品的场景，不是说扣完库存，就完事了，如果用户在一段时间内，还没完成支付，扣减的库存是要加回去的。\n\n所以，在这里引出了一个预扣库存的概念，预扣库存的主要流程如下：\n\n\n\n扣减库存中除了上面说到的预扣库存和回退库存之外，还需要特别注意的是库存不足和库存超卖问题。\n\n\n# 6.1 数据库扣减库存\n\n使用数据库扣减库存，是最简单的实现方案了，假设扣减库存的sql如下：\n\nupdate product set stock=stock-1 where id=123;\n\n\n1\n\n\n这种写法对于扣减库存是没有问题的，但如何控制库存不足的情况下，不让用户操作呢？\n\n这就需要在update之前，先查一下库存是否足够了。\n\n伪代码如下：\n\nint stock = mapper.getstockbyid(123);\nif(stock > 0) {\n  int count = mapper.updatestock(123);\n  if(count > 0) {\n    addorder(123);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n大家有没有发现这段代码的问题？\n\n没错，查询操作和更新操作不是原子性的，会导致在并发的场景下，出现库存超卖的情况。\n\n有人可能会说，这样好办，加把锁，不就搞定了，比如使用synchronized关键字。\n\n确实，可以，但是性能不够好。\n\n还有更优雅的处理方案，即基于数据库的乐观锁，这样会少一次数据库查询，而且能够天然的保证数据操作的原子性。\n\n只需将上面的sql稍微调整一下：\n\nupdate product set stock=stock-1 where id=product and stock > 0;\n\n\n1\n\n\n在sql最后加上：stock > 0，就能保证不会出现超卖的情况。\n\n但需要频繁访问数据库，我们都知道数据库连接是非常昂贵的资源。在高并发的场景下，可能会造成系统雪崩。而且，容易出现多个请求，同时竞争行锁的情况，造成相互等待，从而出现死锁的问题。\n\n\n# 6.2 redis扣减库存\n\nredis的incr方法是原子性的，可以用该方法扣减库存。伪代码如下：\n\n boolean exist = redisclient.query(productid,userid);\n  if(exist) {\n    return -1;\n  }\n  int stock = redisclient.querystock(productid);\n  if(stock <=0) {\n    return 0;\n  }\n  redisclient.incrby(productid, -1);\n  redisclient.add(productid,userid);\nreturn 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n代码流程如下：\n\n 1. 先判断该用户有没有秒杀过该商品，如果已经秒杀过，则直接返回-1。\n 2. 查询库存，如果库存小于等于0，则直接返回0，表示库存不足。\n 3. 如果库存充足，则扣减库存，然后将本次秒杀记录保存起来。然后返回1，表示成功。\n\n估计很多小伙伴，一开始都会按这样的思路写代码。但如果仔细想想会发现，这段代码有问题。\n\n有什么问题呢？\n\n如果在高并发下，有多个请求同时查询库存，当时都大于0。由于查询库存和更新库存非原则操作，则会出现库存为负数的情况，即库存超卖。\n\n当然有人可能会说，加个synchronized不就解决问题？\n\n调整后代码如下：\n\n   boolean exist = redisclient.query(productid,userid);\n   if(exist) {\n    return -1;\n   }\n   synchronized(this) {\n       int stock = redisclient.querystock(productid);\n       if(stock <=0) {\n         return 0;\n       }\n       redisclient.incrby(productid, -1);\n       redisclient.add(productid,userid);\n   }\n\nreturn 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n加synchronized确实能解决库存为负数问题，但是这样会导致接口性能急剧下降，每次查询都需要竞争同一把锁，显然不太合理。\n\n为了解决上面的问题，代码优化如下：\n\nboolean exist = redisclient.query(productid,userid);\nif(exist) {\n  return -1;\n}\nif(redisclient.incrby(productid, -1)<0) {\n  return 0;\n}\nredisclient.add(productid,userid);\nreturn 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n该代码主要流程如下：\n\n 1. 先判断该用户有没有秒杀过该商品，如果已经秒杀过，则直接返回-1。\n 2. 扣减库存，判断返回值是否小于0，如果小于0，则直接返回0，表示库存不足。\n 3. 如果扣减库存后，返回值大于或等于0，则将本次秒杀记录保存起来。然后返回1，表示成功。\n\n该方案咋一看，好像没问题。\n\n但如果在高并发场景中，有多个请求同时扣减库存，大多数请求的incrby操作之后，结果都会小于0。\n\n虽说，库存出现负数，不会出现超卖的问题。但由于这里是预减库存，如果负数值负的太多的话，后面万一要回退库存时，就会导致库存不准。\n\n那么，有没有更好的方案呢？\n\n\n# 6.3 lua脚本扣减库存\n\n我们都知道lua脚本，是能够保证原子性的，它跟redis一起配合使用，能够完美解决上面的问题。\n\nlua脚本有段非常经典的代码：\n\n  stringbuilder lua = new stringbuilder();\n  lua.append("if (redis.call(\'exists\', keys[1]) == 1) then");\n  lua.append("    local stock = tonumber(redis.call(\'get\', keys[1]));");\n  lua.append("    if (stock == -1) then");\n  lua.append("        return 1;");\n  lua.append("    end;");\n  lua.append("    if (stock > 0) then");\n  lua.append("        redis.call(\'incrby\', keys[1], -1);");\n  lua.append("        return stock;");\n  lua.append("    end;");\n  lua.append("    return 0;");\n  lua.append("end;");\n  lua.append("return -1;");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n该代码的主要流程如下：\n\n 1. 先判断商品id是否存在，如果不存在则直接返回。\n 2. 获取该商品id的库存，判断库存如果是-1，则直接返回，表示不限制库存。\n 3. 如果库存大于0，则扣减库存。\n 4. 如果库存等于0，是直接返回，表示库存不足。\n\n\n# 7 分布式锁\n\n之前我提到过，在秒杀的时候，需要先从缓存中查商品是否存在，如果不存在，则会从数据库中查商品。如果数据库中，则将该商品放入缓存中，然后返回。如果数据库中没有，则直接返回失败。\n\n大家试想一下，如果在高并发下，有大量的请求都去查一个缓存中不存在的商品，这些请求都会直接打到数据库。数据库由于承受不住压力，而直接挂掉。\n\n那么如何解决这个问题呢？\n\n这就需要用redis分布式锁了。\n\n\n# 7.1 setnx加锁\n\n使用redis的分布式锁，首先想到的是setnx命令。\n\nif (jedis.setnx(lockkey, val) == 1) {\n   jedis.expire(lockkey, timeout);\n}\n\n\n1\n2\n3\n\n\n用该命令其实可以加锁，但和后面的设置超时时间是分开的，并非原子操作。\n\n假如加锁成功了，但是设置超时时间失败了，该lockkey就变成永不失效的了。在高并发场景中，该问题会导致非常严重的后果。\n\n那么，有没有保证原子性的加锁命令呢？\n\n\n# 7.2 set加锁\n\n使用redis的set命令，它可以指定多个参数。\n\nstring result = jedis.set(lockkey, requestid, "nx", "px", expiretime);\nif ("ok".equals(result)) {\n    return true;\n}\nreturn false;\n\n\n1\n2\n3\n4\n5\n\n\n其中：\n\n * lockkey：锁的标识\n * requestid：请求id\n * nx：只在键不存在时，才对键进行设置操作。\n * px：设置键的过期时间为 millisecond 毫秒。\n * expiretime：过期时间\n\n由于该命令只有一步，所以它是原子操作。\n\n\n# 7.3 释放锁\n\n接下来，有些朋友可能会问：在加锁时，既然已经有了lockkey锁标识，为什么要需要记录requestid呢？\n\n答：requestid是在释放锁的时候用的。\n\nif (jedis.get(lockkey).equals(requestid)) {\n    jedis.del(lockkey);\n    return true;\n}\nreturn false;\n\n\n1\n2\n3\n4\n5\n\n\n在释放锁的时候，只能释放自己加的锁，不允许释放别人加的锁。\n\n这里为什么要用requestid，用userid不行吗？\n\n答：如果用userid的话，假设本次请求流程走完了，准备删除锁。此时，巧合锁到了过期时间失效了。而另外一个请求，巧合使用的相同userid加锁，会成功。而本次请求删除锁的时候，删除的其实是别人的锁了。\n\n当然使用lua脚本也能避免该问题：\n\nif redis.call(\'get\', keys[1]) == argv[1] then \n return redis.call(\'del\', keys[1]) \nelse \n  return 0 \nend\n\n\n1\n2\n3\n4\n5\n\n\n它能保证查询锁是否存在和删除锁是原子操作。\n\n\n# 7.4 自旋锁\n\n上面的加锁方法看起来好像没有问题，但如果你仔细想想，如果有1万的请求同时去竞争那把锁，可能只有一个请求是成功的，其余的9999个请求都会失败。\n\n在秒杀场景下，会有什么问题？\n\n答：每1万个请求，有1个成功。再1万个请求，有1个成功。如此下去，直到库存不足。这就变成均匀分布的秒杀了，跟我们想象中的不一样。\n\n如何解决这个问题呢？\n\n答：使用自旋锁。\n\ntry {\n  long start = system.currenttimemillis();\n  while(true) {\n      string result = jedis.set(lockkey, requestid, "nx", "px", expiretime);\n     if ("ok".equals(result)) {\n        return true;\n     }\n     \n     long time = system.currenttimemillis() - start;\n      if (time>=timeout) {\n          return false;\n      }\n      try {\n          thread.sleep(50);\n      } catch (interruptedexception e) {\n          e.printstacktrace();\n      }\n  }\n \n} finally{\n    unlock(lockkey,requestid);\n}  \nreturn false;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在规定的时间，比如500毫秒内，自旋不断尝试加锁，如果成功则直接返回。如果失败，则休眠50毫秒，再发起新一轮的尝试。如果到了超时时间，还未加锁成功，则直接返回失败。\n\n\n# 7.5 redisson\n\n除了上面的问题之外，使用redis分布式锁，还有锁竞争问题、续期问题、锁重入问题、多个redis实例加锁问题等。\n\n这些问题使用redisson可以解决，由于篇幅的原因，在这里先保留一点悬念，有疑问的私聊给我。后面会出一个专题介绍分布式锁，敬请期待。\n\n\n# 8 mq异步处理\n\n我们都知道在真实的秒杀场景中，有三个核心流程：而这三个核心流程中，真正并发量大的是秒杀功能，下单和支付功能实际并发量很小。所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成mq异步处理的。而支付功能，比如支付宝支付，是业务场景本身保证的异步。\n\n于是，秒杀后下单的流程变成如下：如果使用mq，需要关注以下几个问题：\n\n\n# 8.1 消息丢失问题\n\n秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。\n\n那么，如何防止消息丢失呢？\n\n答：加一张消息发送表。\n\n在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。\n\n如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。\n\n这时候，要如何处理呢？\n\n答：使用job，增加重试机制。\n\n用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。\n\n\n# 8.2 重复消费问题\n\n本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。\n\n那么，如何解决重复消息问题呢？\n\n答：加一张消息处理表。\n\n消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。\n\n有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。\n\n\n# 8.3 垃圾消息问题\n\n这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。\n\n那么，如何解决这个问题呢？每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。\n\n这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。\n\n\n# 8.4 延迟消费问题\n\n通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。\n\n那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？\n\n我们首先想到的可能是job，因为它比较简单。\n\n但job有个问题，需要每隔一段时间处理一次，实时性不太好。\n\n还有更好的方案？\n\n答：使用延迟队列。\n\n我们都知道rocketmq，自带了延迟队列的功能。\n\n下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。\n\n还有个关键点，用户完成支付之后，会修改订单状态为已支付。\n\n\n\n\n# 9 如何限流？\n\n通过秒杀活动，如果我们运气爆棚，可能会用非常低的价格买到不错的商品（这种概率堪比买福利彩票中大奖）。\n\n但有些高手，并不会像我们一样老老实实，通过秒杀页面点击秒杀按钮，抢购商品。他们可能在自己的服务器上，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。\n\n如果是我们手动操作，一般情况下，一秒钟只能点击一次秒杀按钮。但是如果是服务器，一秒钟可以请求成上千接口。这种差距实在太明显了，如果不做任何限制，绝大部分商品可能是被机器抢到，而非正常的用户，有点不太公平。\n\n所以，我们有必要识别这些非法请求，做一些限制。那么，我们该如何现在这些非法请求呢？\n\n目前有两种常用的限流方式：\n\n 1. 基于nginx限流\n 2. 基于redis限流\n\n\n# 9.1 对同一用户限流\n\n为了防止某个用户，请求接口次数过于频繁，可以只针对该用户做限制。限制同一个用户id，比如每分钟只能请求5次接口。\n\n\n# 9.2 对同一ip限流\n\n有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这种nginx就没法识别了。\n\n这时需要加同一ip限流功能。限制同一个ip，比如每分钟只能请求5次接口。\n\n但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。\n\n\n# 9.3 对接口限流\n\n别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。\n\n这时可以限制请求的接口总次数。在高并发场景下，这种限制对于系统的稳定性是非常有必要的。但可能由于有些非法请求次数太多，达到了该接口的请求上限，而影响其他的正常用户访问该接口。看起来有点得不偿失。\n\n\n# 9.4 加验证码\n\n相对于上面三种方式，加验证码的方式可能更精准一些，同样能限制用户的访问频次，但好处是不会存在误杀的情况。\n\n通常情况下，用户在请求之前，需要先输入验证码。用户发起请求之后，服务端会去校验该验证码是否正确。只有正确才允许进行下一步操作，否则直接返回，并且提示验证码错误。\n\n此外，验证码一般是一次性的，同一个验证码只允许使用一次，不允许重复使用。\n\n普通验证码，由于生成的数字或者图案比较简单，可能会被破解。优点是生成速度比较快，缺点是有安全隐患。\n\n还有一个验证码叫做：移动滑块，它生成速度比较慢，但比较安全，是目前各大互联网公司的首选。\n\n\n# 9.5 提高业务门槛\n\n上面说的加验证码虽然可以限制非法用户请求，但是有些影响用户体验。用户点击秒杀按钮前，还要先输入验证码，流程显得有点繁琐，秒杀功能的流程不是应该越简单越好吗？\n\n其实，有时候达到某个目的，不一定非要通过技术手段，通过业务手段也一样。\n\n12306刚开始的时候，全国人民都在同一时刻抢火车票，由于并发量太大，系统经常挂。后来，重构优化之后，将购买周期放长了，可以提前20天购买火车票，并且可以在9点、10、11点、12点等整点购买火车票。调整业务之后（当然技术也有很多调整），将之前集中的请求，分散开了，一下子降低了用户并发量。\n\n回到这里，我们通过提高业务门槛，比如只有会员才能参与秒杀活动，普通注册用户没有权限。或者，只有等级到达3级以上的普通用户，才有资格参加该活动。\n\n\n# 参考\n\n面试官：聊聊秒杀系统如何设计？ 敖丙带你设计-秒杀系统',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"如何解决缓存与数据库不一致的问题？",frontmatter:{title:"如何解决缓存与数据库不一致的问题？",date:"2022-10-20T23:06:43.000Z",permalink:"/pages/ac945d/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/006.%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F.html",relativePath:"08.系统设计/006.如何解决缓存与数据库不一致的问题？.md",key:"v-00fb6429",path:"/pages/ac945d/",headers:[{level:2,title:"引入缓存提高性能",slug:"引入缓存提高性能",normalizedTitle:"引入缓存提高性能",charIndex:198},{level:2,title:"缓存利用率和一致性问题",slug:"缓存利用率和一致性问题",normalizedTitle:"缓存利用率和一致性问题",charIndex:795},{level:2,title:"并发引发的一致性问题",slug:"并发引发的一致性问题",normalizedTitle:"并发引发的一致性问题",charIndex:1773},{level:2,title:"删除缓存可以保证一致性吗？",slug:"删除缓存可以保证一致性吗",normalizedTitle:"删除缓存可以保证一致性吗？",charIndex:2381},{level:2,title:"如何保证两步都执行成功？",slug:"如何保证两步都执行成功",normalizedTitle:"如何保证两步都执行成功？",charIndex:3323},{level:2,title:"主从库延迟和延迟双删问题",slug:"主从库延迟和延迟双删问题",normalizedTitle:"主从库延迟和延迟双删问题",charIndex:4874},{level:2,title:"可以做到强一致吗？",slug:"可以做到强一致吗",normalizedTitle:"可以做到强一致吗？",charIndex:6009},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6510},{level:2,title:"后记",slug:"后记",normalizedTitle:"后记",charIndex:6981},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:7335}],headersStr:"引入缓存提高性能 缓存利用率和一致性问题 并发引发的一致性问题 删除缓存可以保证一致性吗？ 如何保证两步都执行成功？ 主从库延迟和延迟双删问题 可以做到强一致吗？ 总结 后记 参考",content:"如何保证缓存和数据库一致性，这是一个老生常谈的话题了。\n\n但很多人对这个问题，依旧有很多疑惑：\n\n * 到底是更新缓存还是删缓存？\n * 到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？\n * 为什么要引入消息队列保证一致性？\n * 延迟双删会有什么问题？到底要不要用？\n * ...\n\n这篇文章，我们就来把这些问题讲清楚。\n\n这篇文章干货很多，希望你可以耐心读完。\n\n\n\n\n# 引入缓存提高性能\n\n我们从最简单的场景开始讲起。\n\n如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时你的架构模型是这样的：\n\n\n\n但随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。\n\n这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：\n\n\n\n当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。\n\n但引入缓存之后，你就会面临一个问题：之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？\n\n最简单直接的方案是「全量数据刷到缓存中」：\n\n * 数据库的数据，全量刷入缓存（不设置失效时间）\n * 写请求只更新数据库，不更新缓存\n * 启动一个定时任务，定时把数据库的数据，更新到缓存中\n\n\n\n这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。\n\n但缺点也很明显，有 2 个问题：\n\n 1. 缓存利用率低：不经常访问的数据，还一直留在缓存中\n 2. 数据不一致：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）\n\n所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。\n\n那如果我们的业务体量很大，怎么解决这 2 个问题呢？\n\n\n# 缓存利用率和一致性问题\n\n先来看第一个问题，如何提高缓存利用率？\n\n想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？\n\n我们可以这样优化：\n\n * 写请求依旧只写数据库\n * 读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存\n * 同时，写入缓存中的数据，都设置失效时间\n\n\n\n这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。\n\n再来看数据一致性问题。\n\n要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。\n\n所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。\n\n但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：\n\n 1. 先更新缓存，后更新数据库\n 2. 先更新数据库，后更新缓存\n\n哪个方案更好呢？\n\n先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。\n\n因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生。\n\n这 2 种方案我们一个个来分析。\n\n1) 先更新缓存，后更新数据库\n\n如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。\n\n虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。\n\n这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。\n\n2) 先更新数据库，后更新缓存\n\n如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。\n\n之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。\n\n这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。\n\n可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？\n\n别急，后面我会详细给出对应的解决方案。\n\n我们继续分析，除了操作失败问题，还有什么场景会影响数据一致性？\n\n这里我们还需要重点关注：并发问题。\n\n\n# 并发引发的一致性问题\n\n假设我们采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？\n\n有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：\n\n 1. 线程 A 更新数据库（X = 1）\n 2. 线程 B 更新数据库（X = 2）\n 3. 线程 B 更新缓存（X = 2）\n 4. 线程 A 更新缓存（X = 1）\n\n最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。\n\n也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。\n\n> 同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。\n\n除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。\n\n这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。\n\n而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。\n\n由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。\n\n所以此时我们需要考虑另外一种方案：删除缓存。\n\n\n# 删除缓存可以保证一致性吗？\n\n删除缓存对应的方案也有 2 种：\n\n 1. 先删除缓存，后更新数据库\n 2. 先更新数据库，后删除缓存\n\n经过前面的分析我们已经得知，但凡「第二步」操作失败，都会导致数据不一致。\n\n这里我不再详述具体场景，你可以按照前面的思路推演一下，就可以看到依旧存在数据不一致的情况。\n\n这里我们重点来看「并发」问题。\n\n1) 先删除缓存，后更新数据库\n\n如果有 2 个线程要并发「读写」数据，可能会发生以下场景：\n\n 1. 线程 A 要更新 X = 2（原值 X = 1）\n 2. 线程 A 先删除缓存\n 3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）\n 4. 线程 A 将新值写入数据库（X = 2）\n 5. 线程 B 将旧值写入缓存（X = 1）\n\n最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。\n\n可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。\n\n2) 先更新数据库，后删除缓存\n\n依旧是 2 个线程并发「读写」数据：\n\n 1. 缓存中 X 不存在（数据库 X = 1）\n 2. 线程 A 读取数据库，得到旧值（X = 1）\n 3. 线程 B 更新数据库（X = 2)\n 4. 线程 B 删除缓存\n 5. 线程 A 将旧值写入缓存（X = 1）\n\n最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。\n\n这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？\n\n其实概率「很低」，这是因为它必须满足 3 个条件：\n\n 1. 缓存刚好已失效\n 2. 读请求 + 写请求并发\n 3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）\n\n仔细想一下，条件 3 发生的概率其实是非常低的。\n\n因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。\n\n这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。\n\n所以，我们应该采用这种方案，来操作数据库和缓存。\n\n好，解决了并发问题，我们继续来看前面遗留的，第二步执行「失败」导致数据不一致的问题。\n\n\n# 如何保证两步都执行成功？\n\n前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。\n\n保证第二步成功执行，就是解决问题的关键。\n\n想一下，程序在执行过程中发生异常，最简单的解决办法是什么？\n\n答案是：重试。\n\n是的，其实这里我们也可以这样做。\n\n无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。\n\n那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？\n\n答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：\n\n * 立即重试很大概率「还会失败」\n * 「重试次数」设置多少才合理？\n * 重试会一直「占用」这个线程资源，无法服务其它客户端请求\n\n看到了么，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。\n\n那更好的方案应该怎么做？\n\n答案是：异步重试。什么是异步重试？\n\n其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。\n\n或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。\n\n到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？\n\n这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。\n\n所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：\n\n * 消息队列保证可靠性：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）\n * 消息队列保证消息成功投递：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）\n\n至于写队列失败和消息队列的维护成本问题：\n\n * 写队列失败：操作缓存和写消息队列，「同时失败」的概率其实是很小的\n * 维护成本：我们项目中一般都会用到消息队列，维护成本并没有新增很多\n\n所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：\n\n\n\n那如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？\n\n方案还是有的，这就是近几年比较流行的解决方案：订阅数据库变更日志，再操作缓存。\n\n具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。\n\n那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。\n\n拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。\n\n\n\n订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：\n\n * 无需考虑写消息队列失败情况：只要写 MySQL 成功，Binlog 肯定会有\n * 自动投递到下游队列：canal 自动把数据库变更日志「投递」给下游的消息队列\n\n当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。\n\n> 如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。\n\n至此，我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。\n\n\n# 主从库延迟和延迟双删问题\n\n到这里，还有 2 个问题，是我们没有重点分析过的。\n\n第一个问题，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？\n\n这里我再把例子拿过来让你复习一下：\n\n2 个线程要并发「读写」数据，可能会发生以下场景：\n\n 1. 线程 A 要更新 X = 2（原值 X = 1）\n 2. 线程 A 先删除缓存\n 3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）\n 4. 线程 A 将新值写入数据库（X = 2）\n 5. 线程 B 将旧值写入缓存（X = 1）\n\n最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。\n\n第二个问题：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。\n\n在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：\n\n 1. 线程 A 更新主库 X = 2（原值 X = 1）\n 2. 线程 A 删除缓存\n 3. 线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）\n 4. 从库「同步」完成（主从库 X = 2）\n 5. 线程 B 将「旧值」写入缓存（X = 1）\n\n最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。\n\n看到了么？这 2 个问题的核心在于：缓存都被回种了「旧值」。\n\n那怎么解决这类问题呢？\n\n最有效的办法就是，把缓存删掉。\n\n但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：缓存延迟双删策略。\n\n按照延时双删策略，这 2 个问题的解决方案是这样的：\n\n解决第一个问题：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。\n\n解决第二个问题：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。\n\n这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。\n\n但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？\n\n * 问题1：延迟时间要大于「主从复制」的延迟时间\n * 问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间\n\n但是，这个时间在分布式和高并发场景下，其实是很难评估的**。**\n\n很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。\n\n所以你看，采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。\n\n所以实际使用中，我还是建议你采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。\n\n\n# 可以做到强一致吗？\n\n看到这里你可能会想，这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？\n\n其实很难。\n\n要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。\n\n相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？\n\n没错，性能。\n\n一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。\n\n而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。\n\n所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。\n\n虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。\n\n所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。\n\n同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。\n\n\n# 总结\n\n好了，总结一下这篇文章的重点。\n\n1、想要提高应用的性能，可以引入「缓存」来解决\n\n2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」\n\n3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生\n\n4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案\n\n5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性\n\n6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率\n\n\n# 后记\n\n本以为这个老生常谈的话题，写起来很好写，没想到在写的过程中，还是挖到了很多之前没有深度思考过的细节。\n\n在这里我也分享 4 点心得给你：\n\n1、性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案\n\n2、掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题\n\n3、失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案\n\n4、订阅变更日志的思想，本质是把权威数据源（例如 MySQL）当做 leader 副本，让其它异质系统（例如 Redis / Elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致\n\n\n# 参考\n\n缓存和数据库一致性问题，看这篇就够了",normalizedContent:"如何保证缓存和数据库一致性，这是一个老生常谈的话题了。\n\n但很多人对这个问题，依旧有很多疑惑：\n\n * 到底是更新缓存还是删缓存？\n * 到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？\n * 为什么要引入消息队列保证一致性？\n * 延迟双删会有什么问题？到底要不要用？\n * ...\n\n这篇文章，我们就来把这些问题讲清楚。\n\n这篇文章干货很多，希望你可以耐心读完。\n\n\n\n\n# 引入缓存提高性能\n\n我们从最简单的场景开始讲起。\n\n如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时你的架构模型是这样的：\n\n\n\n但随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。\n\n这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：\n\n\n\n当下优秀的缓存中间件，当属 redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。\n\n但引入缓存之后，你就会面临一个问题：之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？\n\n最简单直接的方案是「全量数据刷到缓存中」：\n\n * 数据库的数据，全量刷入缓存（不设置失效时间）\n * 写请求只更新数据库，不更新缓存\n * 启动一个定时任务，定时把数据库的数据，更新到缓存中\n\n\n\n这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。\n\n但缺点也很明显，有 2 个问题：\n\n 1. 缓存利用率低：不经常访问的数据，还一直留在缓存中\n 2. 数据不一致：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）\n\n所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。\n\n那如果我们的业务体量很大，怎么解决这 2 个问题呢？\n\n\n# 缓存利用率和一致性问题\n\n先来看第一个问题，如何提高缓存利用率？\n\n想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？\n\n我们可以这样优化：\n\n * 写请求依旧只写数据库\n * 读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存\n * 同时，写入缓存中的数据，都设置失效时间\n\n\n\n这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。\n\n再来看数据一致性问题。\n\n要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。\n\n所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。\n\n但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：\n\n 1. 先更新缓存，后更新数据库\n 2. 先更新数据库，后更新缓存\n\n哪个方案更好呢？\n\n先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。\n\n因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生。\n\n这 2 种方案我们一个个来分析。\n\n1) 先更新缓存，后更新数据库\n\n如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。\n\n虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。\n\n这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。\n\n2) 先更新数据库，后更新缓存\n\n如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。\n\n之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。\n\n这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。\n\n可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？\n\n别急，后面我会详细给出对应的解决方案。\n\n我们继续分析，除了操作失败问题，还有什么场景会影响数据一致性？\n\n这里我们还需要重点关注：并发问题。\n\n\n# 并发引发的一致性问题\n\n假设我们采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？\n\n有线程 a 和线程 b 两个线程，需要更新「同一条」数据，会发生这样的场景：\n\n 1. 线程 a 更新数据库（x = 1）\n 2. 线程 b 更新数据库（x = 2）\n 3. 线程 b 更新缓存（x = 2）\n 4. 线程 a 更新缓存（x = 1）\n\n最终 x 的值在缓存中是 1，在数据库中是 2，发生不一致。\n\n也就是说，a 虽然先于 b 发生，但 b 操作数据库和缓存的时间，却要比 a 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。\n\n> 同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。\n\n除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。\n\n这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。\n\n而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。\n\n由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。\n\n所以此时我们需要考虑另外一种方案：删除缓存。\n\n\n# 删除缓存可以保证一致性吗？\n\n删除缓存对应的方案也有 2 种：\n\n 1. 先删除缓存，后更新数据库\n 2. 先更新数据库，后删除缓存\n\n经过前面的分析我们已经得知，但凡「第二步」操作失败，都会导致数据不一致。\n\n这里我不再详述具体场景，你可以按照前面的思路推演一下，就可以看到依旧存在数据不一致的情况。\n\n这里我们重点来看「并发」问题。\n\n1) 先删除缓存，后更新数据库\n\n如果有 2 个线程要并发「读写」数据，可能会发生以下场景：\n\n 1. 线程 a 要更新 x = 2（原值 x = 1）\n 2. 线程 a 先删除缓存\n 3. 线程 b 读缓存，发现不存在，从数据库中读取到旧值（x = 1）\n 4. 线程 a 将新值写入数据库（x = 2）\n 5. 线程 b 将旧值写入缓存（x = 1）\n\n最终 x 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。\n\n可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。\n\n2) 先更新数据库，后删除缓存\n\n依旧是 2 个线程并发「读写」数据：\n\n 1. 缓存中 x 不存在（数据库 x = 1）\n 2. 线程 a 读取数据库，得到旧值（x = 1）\n 3. 线程 b 更新数据库（x = 2)\n 4. 线程 b 删除缓存\n 5. 线程 a 将旧值写入缓存（x = 1）\n\n最终 x 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。\n\n这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？\n\n其实概率「很低」，这是因为它必须满足 3 个条件：\n\n 1. 缓存刚好已失效\n 2. 读请求 + 写请求并发\n 3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）\n\n仔细想一下，条件 3 发生的概率其实是非常低的。\n\n因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。\n\n这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。\n\n所以，我们应该采用这种方案，来操作数据库和缓存。\n\n好，解决了并发问题，我们继续来看前面遗留的，第二步执行「失败」导致数据不一致的问题。\n\n\n# 如何保证两步都执行成功？\n\n前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。\n\n保证第二步成功执行，就是解决问题的关键。\n\n想一下，程序在执行过程中发生异常，最简单的解决办法是什么？\n\n答案是：重试。\n\n是的，其实这里我们也可以这样做。\n\n无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。\n\n那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？\n\n答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：\n\n * 立即重试很大概率「还会失败」\n * 「重试次数」设置多少才合理？\n * 重试会一直「占用」这个线程资源，无法服务其它客户端请求\n\n看到了么，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。\n\n那更好的方案应该怎么做？\n\n答案是：异步重试。什么是异步重试？\n\n其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。\n\n或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。\n\n到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？\n\n这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。\n\n所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：\n\n * 消息队列保证可靠性：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）\n * 消息队列保证消息成功投递：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）\n\n至于写队列失败和消息队列的维护成本问题：\n\n * 写队列失败：操作缓存和写消息队列，「同时失败」的概率其实是很小的\n * 维护成本：我们项目中一般都会用到消息队列，维护成本并没有新增很多\n\n所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：\n\n\n\n那如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？\n\n方案还是有的，这就是近几年比较流行的解决方案：订阅数据库变更日志，再操作缓存。\n\n具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。\n\n那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。\n\n拿 mysql 举例，当一条数据发生修改时，mysql 就会产生一条变更日志（binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。\n\n\n\n订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：\n\n * 无需考虑写消息队列失败情况：只要写 mysql 成功，binlog 肯定会有\n * 自动投递到下游队列：canal 自动把数据库变更日志「投递」给下游的消息队列\n\n当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。\n\n> 如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。\n\n至此，我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。\n\n\n# 主从库延迟和延迟双删问题\n\n到这里，还有 2 个问题，是我们没有重点分析过的。\n\n第一个问题，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？\n\n这里我再把例子拿过来让你复习一下：\n\n2 个线程要并发「读写」数据，可能会发生以下场景：\n\n 1. 线程 a 要更新 x = 2（原值 x = 1）\n 2. 线程 a 先删除缓存\n 3. 线程 b 读缓存，发现不存在，从数据库中读取到旧值（x = 1）\n 4. 线程 a 将新值写入数据库（x = 2）\n 5. 线程 b 将旧值写入缓存（x = 1）\n\n最终 x 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。\n\n第二个问题：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。\n\n在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：\n\n 1. 线程 a 更新主库 x = 2（原值 x = 1）\n 2. 线程 a 删除缓存\n 3. 线程 b 查询缓存，没有命中，查询「从库」得到旧值（从库 x = 1）\n 4. 从库「同步」完成（主从库 x = 2）\n 5. 线程 b 将「旧值」写入缓存（x = 1）\n\n最终 x 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。\n\n看到了么？这 2 个问题的核心在于：缓存都被回种了「旧值」。\n\n那怎么解决这类问题呢？\n\n最有效的办法就是，把缓存删掉。\n\n但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：缓存延迟双删策略。\n\n按照延时双删策略，这 2 个问题的解决方案是这样的：\n\n解决第一个问题：在线程 a 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。\n\n解决第二个问题：线程 a 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。\n\n这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。\n\n但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？\n\n * 问题1：延迟时间要大于「主从复制」的延迟时间\n * 问题2：延迟时间要大于线程 b 读取数据库 + 写入缓存的时间\n\n但是，这个时间在分布式和高并发场景下，其实是很难评估的**。**\n\n很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。\n\n所以你看，采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。\n\n所以实际使用中，我还是建议你采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。\n\n\n# 可以做到强一致吗？\n\n看到这里你可能会想，这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？\n\n其实很难。\n\n要想做到强一致，最常见的方案是 2pc、3pc、paxos、raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。\n\n相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？\n\n没错，性能。\n\n一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。\n\n而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。\n\n所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。\n\n虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。\n\n所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。\n\n同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。\n\n\n# 总结\n\n好了，总结一下这篇文章的重点。\n\n1、想要提高应用的性能，可以引入「缓存」来解决\n\n2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」\n\n3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生\n\n4、在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案\n\n5、在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性\n\n6、在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率\n\n\n# 后记\n\n本以为这个老生常谈的话题，写起来很好写，没想到在写的过程中，还是挖到了很多之前没有深度思考过的细节。\n\n在这里我也分享 4 点心得给你：\n\n1、性能和一致性不能同时满足，为了性能考虑，通常会采用「最终一致性」的方案\n\n2、掌握缓存和数据库一致性问题，核心问题有 3 点：缓存利用率、并发、缓存 + 数据库一起成功问题\n\n3、失败场景下要保证一致性，常见手段就是「重试」，同步重试会影响吞吐量，所以通常会采用异步重试的方案\n\n4、订阅变更日志的思想，本质是把权威数据源（例如 mysql）当做 leader 副本，让其它异质系统（例如 redis / elasticsearch）成为它的 follower 副本，通过同步变更日志的方式，保证 leader 和 follower 之间保持一致\n\n\n# 参考\n\n缓存和数据库一致性问题，看这篇就够了",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"什么是 CAP ？什么是最终一致性？什么是幂等操作？",frontmatter:{title:"什么是 CAP ？什么是最终一致性？什么是幂等操作？",date:"2022-05-21T17:11:49.000Z",permalink:"/pages/20c647/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/010.%E4%BB%80%E4%B9%88%E6%98%AF%20CAP%20%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%E6%93%8D%E4%BD%9C%EF%BC%9F.html",relativePath:"08.系统设计/010.什么是 CAP ？什么是最终一致性？什么是幂等操作？.md",key:"v-5675b06b",path:"/pages/20c647/",headers:[{level:3,title:"CAP理论",slug:"cap理论",normalizedTitle:"cap理论",charIndex:2},{level:3,title:"为什么这三者如此重要？",slug:"为什么这三者如此重要",normalizedTitle:"为什么这三者如此重要？",charIndex:261},{level:3,title:"CAP权衡",slug:"cap权衡",normalizedTitle:"cap权衡",charIndex:577},{level:3,title:"三种组合",slug:"三种组合",normalizedTitle:"三种组合",charIndex:784},{level:3,title:"一致性的妥协——最终一致性和Base原则",slug:"一致性的妥协-最终一致性和base原则",normalizedTitle:"一致性的妥协——最终一致性和base原则",charIndex:1070},{level:3,title:"幂等性",slug:"幂等性",normalizedTitle:"幂等性",charIndex:1420},{level:3,title:"如何解决幂等性问题",slug:"如何解决幂等性问题",normalizedTitle:"如何解决幂等性问题",charIndex:1560}],headersStr:"CAP理论 为什么这三者如此重要？ CAP权衡 三种组合 一致性的妥协——最终一致性和Base原则 幂等性 如何解决幂等性问题",content:"# CAP理论\n\nCAP的结论非常简单：在分布式系统里，有3个属性非常重要，但只能同时满足其中的2个。\n\nConsistency：all nodes在任何时刻看到的data都是一样的（或说client的read操作总是返回最新写入的那个value） Availability：系统时刻都允许操作，并且操作总会快速被Coordinator响应，最终client很快就得到返回的结果 Partition-tolerance：尽管网路有时候会因为故障导致被分隔开，但是系统依然在正常工作（或者说在满足前述的条件下工作）\n\n\n# 为什么这三者如此重要？\n\nFor Availability：\n\n经统计，对于Google、Amazon这样的数据公司，系统增加500ms的延迟就会损失公司20%的收益，所以必须快速且可靠地进行 Read/Write。\n\nFor Consistency：\n\n比如在银行系统，任何client都必须查看到最新的updated data item，不然就会给交易造成致命的影响。\n\nFor Partition-tolerance：\n\n因为Internet可能因为某些原因随时断开（Router故障、海地线缆断开、DNS故障）；即使在同一个data center里，故障都会随时随地地发生，比如 Rack switcher 宕机。\n\n\n# CAP权衡\n\n * 如今的云计算环境里，因为网络随时都会被隔离开来，这是无法避免的，P是必须满足的，那么CAP暗示一个system要在C和A中做出抉择。\n * A和C并不是一个硬币的两面,只能选择其中一个;A和C应该看成天平,系统可以选择向哪边倾斜,但另一边也应该一定程度的保留。\n * 对于A和C之间的选择,不应该粗粒度的整个系统级别进行选取,而应该针对系统中的不同子系统,针对性的采取不同的取舍策略。\n\n\n# 三种组合\n\n * CA: 保证可用性和一致性,放弃分区:除非不是分布式架构,或者应用在一个永不会通信故障的网络中(理想),只有个别场景符合,当前的互联网架构显然不符合使用\n * CP: 保证一致性和分区容忍性,放弃可用性:当节点间不可通信时,进行阻塞,直到通信恢复,期间无法再对外提供服务,用户体验不好,如A转账给B,只有A扣款成功并B收款成功,整个事务才算完成,显然耗费资源\n * AP: 保证可用性和分区容忍性,放弃强一致性(使用最终一致性):给出一个用户可以忍受的时间,时间内达成数据的最终一致性,比如跨行转账,并不是立刻到账,可能是明天,或者2小时内到账\n\n\n# 一致性的妥协——最终一致性和Base原则\n\n * BA(Basically Available)基本可用:系统在绝大部分时间应处于可用状态,允许出现故障损失部分可用性,但保证核心可用。\n * S(Soft State)软状态:数据状态不要求在任何时刻都保持一致,允许存在中间状态,而该状态不影响系统可用性。对于多副本的存储系统而言,就是允许副本之间的同步存在延时,并且在这个过程中系统依旧可以响应客户端请求。\n * E(Eventual Consistency)最终一致性:尽管软状态不要求分布式数据在任何时刻都保持一致,但经过一定时间后,这些数据最终能达到一致性状态。 BASE理论的核心思想是:把分布式系统的可用性放在首位,放弃CAP中对数据强一致性的追求,只要系统能保证数据最终一致。\n\n\n# 幂等性\n\n在微服务架构下,不同微服务间会有大量的基于http,rpc或者mq消息的网络通信,接口的重复调用以及消息的重复消费可能会经常发生。\n\n微服务架构应该具有幂等性,当接口被重复调用时,消息被重复消费时,对系统的产生的影响应该和接口被调用一次,消息被消费一次时一样。\n\n\n# 如何解决幂等性问题\n\n * 全局唯一ID。根据业务生成一个全局唯一ID,在调用接口时会传入该ID,接口提供方会从相应的存储系统比如Redis中去检索这个全局ID是否存在,如果存在则说明该操作已经执行过了,将拒绝本次服务请求;否则将相应该服务请求并将全局ID存入存储系统中,之后包含相同业务ID参数的请求将被拒绝。\n\n * 数据库表唯一键。这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中,一个订单只会支付一次,可以建立一张去重表,将订单ID作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中,这样当出现重复支付时,数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。\n\n * 多版本并发控制适合对更新请求作幂等性控制,比如要更新商品的名字,这是就可以在更新的接口中增加一个版本号来做幂等性控制",normalizedContent:"# cap理论\n\ncap的结论非常简单：在分布式系统里，有3个属性非常重要，但只能同时满足其中的2个。\n\nconsistency：all nodes在任何时刻看到的data都是一样的（或说client的read操作总是返回最新写入的那个value） availability：系统时刻都允许操作，并且操作总会快速被coordinator响应，最终client很快就得到返回的结果 partition-tolerance：尽管网路有时候会因为故障导致被分隔开，但是系统依然在正常工作（或者说在满足前述的条件下工作）\n\n\n# 为什么这三者如此重要？\n\nfor availability：\n\n经统计，对于google、amazon这样的数据公司，系统增加500ms的延迟就会损失公司20%的收益，所以必须快速且可靠地进行 read/write。\n\nfor consistency：\n\n比如在银行系统，任何client都必须查看到最新的updated data item，不然就会给交易造成致命的影响。\n\nfor partition-tolerance：\n\n因为internet可能因为某些原因随时断开（router故障、海地线缆断开、dns故障）；即使在同一个data center里，故障都会随时随地地发生，比如 rack switcher 宕机。\n\n\n# cap权衡\n\n * 如今的云计算环境里，因为网络随时都会被隔离开来，这是无法避免的，p是必须满足的，那么cap暗示一个system要在c和a中做出抉择。\n * a和c并不是一个硬币的两面,只能选择其中一个;a和c应该看成天平,系统可以选择向哪边倾斜,但另一边也应该一定程度的保留。\n * 对于a和c之间的选择,不应该粗粒度的整个系统级别进行选取,而应该针对系统中的不同子系统,针对性的采取不同的取舍策略。\n\n\n# 三种组合\n\n * ca: 保证可用性和一致性,放弃分区:除非不是分布式架构,或者应用在一个永不会通信故障的网络中(理想),只有个别场景符合,当前的互联网架构显然不符合使用\n * cp: 保证一致性和分区容忍性,放弃可用性:当节点间不可通信时,进行阻塞,直到通信恢复,期间无法再对外提供服务,用户体验不好,如a转账给b,只有a扣款成功并b收款成功,整个事务才算完成,显然耗费资源\n * ap: 保证可用性和分区容忍性,放弃强一致性(使用最终一致性):给出一个用户可以忍受的时间,时间内达成数据的最终一致性,比如跨行转账,并不是立刻到账,可能是明天,或者2小时内到账\n\n\n# 一致性的妥协——最终一致性和base原则\n\n * ba(basically available)基本可用:系统在绝大部分时间应处于可用状态,允许出现故障损失部分可用性,但保证核心可用。\n * s(soft state)软状态:数据状态不要求在任何时刻都保持一致,允许存在中间状态,而该状态不影响系统可用性。对于多副本的存储系统而言,就是允许副本之间的同步存在延时,并且在这个过程中系统依旧可以响应客户端请求。\n * e(eventual consistency)最终一致性:尽管软状态不要求分布式数据在任何时刻都保持一致,但经过一定时间后,这些数据最终能达到一致性状态。 base理论的核心思想是:把分布式系统的可用性放在首位,放弃cap中对数据强一致性的追求,只要系统能保证数据最终一致。\n\n\n# 幂等性\n\n在微服务架构下,不同微服务间会有大量的基于http,rpc或者mq消息的网络通信,接口的重复调用以及消息的重复消费可能会经常发生。\n\n微服务架构应该具有幂等性,当接口被重复调用时,消息被重复消费时,对系统的产生的影响应该和接口被调用一次,消息被消费一次时一样。\n\n\n# 如何解决幂等性问题\n\n * 全局唯一id。根据业务生成一个全局唯一id,在调用接口时会传入该id,接口提供方会从相应的存储系统比如redis中去检索这个全局id是否存在,如果存在则说明该操作已经执行过了,将拒绝本次服务请求;否则将相应该服务请求并将全局id存入存储系统中,之后包含相同业务id参数的请求将被拒绝。\n\n * 数据库表唯一键。这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中,一个订单只会支付一次,可以建立一张去重表,将订单id作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中,这样当出现重复支付时,数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。\n\n * 多版本并发控制适合对更新请求作幂等性控制,比如要更新商品的名字,这是就可以在更新的接口中增加一个版本号来做幂等性控制",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"设计 Tiny URL 系统",frontmatter:{title:"设计 Tiny URL 系统",date:"2022-11-09T22:40:00.000Z",permalink:"/pages/7c8753/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/021.%E8%AE%BE%E8%AE%A1%20Tiny%20URL%20%E7%B3%BB%E7%BB%9F.html",relativePath:"08.系统设计/021.设计 Tiny URL 系统.md",key:"v-1d6b51b7",path:"/pages/7c8753/",headers:[{level:2,title:"使用场景(Scenario)",slug:"使用场景-scenario",normalizedTitle:"使用场景(scenario)",charIndex:2},{level:2,title:"需求(Needs)",slug:"需求-needs",normalizedTitle:"需求(needs)",charIndex:98},{level:2,title:"短网址的长度",slug:"短网址的长度",normalizedTitle:"短网址的长度",charIndex:137},{level:2,title:"一对一还是一对多映射？",slug:"一对一还是一对多映射",normalizedTitle:"一对一还是一对多映射？",charIndex:686},{level:2,title:"如何计算短网址",slug:"如何计算短网址",normalizedTitle:"如何计算短网址",charIndex:991},{level:2,title:"如何存储",slug:"如何存储",normalizedTitle:"如何存储",charIndex:1175},{level:2,title:"301还是302重定向",slug:"_301还是302重定向",normalizedTitle:"301还是302重定向",charIndex:1386},{level:2,title:"预防攻击",slug:"预防攻击",normalizedTitle:"预防攻击",charIndex:1765},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:164}],headersStr:"使用场景(Scenario) 需求(Needs) 短网址的长度 一对一还是一对多映射？ 如何计算短网址 如何存储 301还是302重定向 预防攻击 参考",content:"# 使用场景(Scenario)\n\n微博和Twitter都有140字数的限制，如果分享一个长网址，很容易就超出限制，发布出去。短网址服务可以把一个长网址变成短网址，方便在社交网络上传播。\n\n\n# 需求(Needs)\n\n很显然，要尽可能的短。长度设计为多少才合适呢？\n\n\n# 短网址的长度\n\n当前互联网上的网页总数大概是 45亿(参考 http://www.worldwidewebsize.com)，45亿超过了 2^{32}=4294967296232=4294967296，但远远小于64位整数的上限值，那么用一个64位整数足够了。\n\n微博的短网址服务用的是长度为7的字符串，这个字符串可以看做是62进制的数，那么最大能表示{62}^7=3521614606208627=3521614606208个网址，远远大于45亿。所以长度为7就足够了。\n\n一个64位整数如何转化为字符串呢？，假设我们只是用大小写字母加数字，那么可以看做是62进制数，log_{62} {(2^{64}-1)}=10.7log62(264−1)=10.7，即字符串最长11就足够了。\n\n实际生产中，还可以再短一点，比如新浪微博采用的长度就是7，因为 62^7=3521614606208627=3521614606208，这个量级远远超过互联网上的URL总数了，绝对够用了。\n\n现代的web服务器（例如Apache, Nginx）大部分都区分URL里的大小写了，所以用大小写字母来区分不同的URL是没问题的。\n\n因此，正确答案：长度不超过7的字符串，由大小写字母加数字共62个字母组成\n\n\n# 一对一还是一对多映射？\n\n一个长网址，对应一个短网址，还是可以对应多个短网址？ 这也是个重大选择问题\n\n一般而言，一个长网址，在不同的地点，不同的用户等情况下，生成的短网址应该不一样，这样，在后端数据库中，可以更好的进行数据分析。如果一个长网址与一个短网址一一对应，那么在数据库中，仅有一行数据，无法区分不同的来源，就无法做数据分析了。\n\n以这个7位长度的短网址作为唯一ID，这个ID下可以挂各种信息，比如生成该网址的用户名，所在网站，HTTP头部的 User Agent等信息，收集了这些信息，才有可能在后面做大数据分析，挖掘数据的价值。短网址服务商的一大盈利来源就是这些数据。\n\n正确答案：一对多\n\n\n# 如何计算短网址\n\n现在我们设定了短网址是一个长度为7的字符串，如何计算得到这个短网址呢？\n\n最容易想到的办法是哈希，先hash得到一个64位整数，将它转化为62进制整，截取低7位即可。但是哈希算法会有冲突，如何处理冲突呢，又是一个麻烦。这个方法只是转移了矛盾，没有解决矛盾，抛弃。\n\n正确答案：分布式发号器(Distributed ID Generator)\n\n\n# 如何存储\n\n如果存储短网址和长网址的对应关系？以短网址为 primary key, 长网址为value, 可以用传统的关系数据库存起来，例如MySQL, PostgreSQL，也可以用任意一个分布式KV数据库，例如Redis, LevelDB。\n\n如果你手痒想要手工设计这个存储，那就是另一个话题了，你需要完整地造一个KV存储引擎轮子。当前流行的KV存储引擎有LevelDB何RockDB，去读它们的源码吧 😄\n\n\n# 301还是302重定向\n\n这也是一个有意思的问题。这个问题主要是考察你对301和302的理解，以及浏览器缓存机制的理解。\n\n301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。但是如果用了301， Google，百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的Cookie, User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。\n\n所以，正确答案是302重定向。\n\n可以抓包看看新浪微博的短网址是怎么做的，使用 Chrome 浏览器，访问这个URL http://t.cn/RX2VxjI，是我事先发微博自动生成的短网址。来抓包看看返回的结果是啥，\n\n\n\n可见新浪微博用的就是302临时重定向。\n\n\n# 预防攻击\n\n如果一些别有用心的黑客，短时间内向TinyURL服务器发送大量的请求，会迅速耗光ID，怎么办呢？\n\n首先，限制IP的单日请求总数，超过阈值则直接拒绝服务。\n\n光限制IP的请求数还不够，因为黑客一般手里有上百万台肉鸡的，IP地址大大的有，所以光限制IP作用不大。\n\n可以用一台Redis作为缓存服务器，存储的不是 ID->长网址，而是 长网址->ID，仅存储一天以内的数据，用LRU机制进行淘汰。这样，如果黑客大量发同一个长网址过来，直接从缓存服务器里返回短网址即可，他就无法耗光我们的ID了。\n\n\n# 参考\n\n短链接设计",normalizedContent:"# 使用场景(scenario)\n\n微博和twitter都有140字数的限制，如果分享一个长网址，很容易就超出限制，发布出去。短网址服务可以把一个长网址变成短网址，方便在社交网络上传播。\n\n\n# 需求(needs)\n\n很显然，要尽可能的短。长度设计为多少才合适呢？\n\n\n# 短网址的长度\n\n当前互联网上的网页总数大概是 45亿(参考 http://www.worldwidewebsize.com)，45亿超过了 2^{32}=4294967296232=4294967296，但远远小于64位整数的上限值，那么用一个64位整数足够了。\n\n微博的短网址服务用的是长度为7的字符串，这个字符串可以看做是62进制的数，那么最大能表示{62}^7=3521614606208627=3521614606208个网址，远远大于45亿。所以长度为7就足够了。\n\n一个64位整数如何转化为字符串呢？，假设我们只是用大小写字母加数字，那么可以看做是62进制数，log_{62} {(2^{64}-1)}=10.7log62(264−1)=10.7，即字符串最长11就足够了。\n\n实际生产中，还可以再短一点，比如新浪微博采用的长度就是7，因为 62^7=3521614606208627=3521614606208，这个量级远远超过互联网上的url总数了，绝对够用了。\n\n现代的web服务器（例如apache, nginx）大部分都区分url里的大小写了，所以用大小写字母来区分不同的url是没问题的。\n\n因此，正确答案：长度不超过7的字符串，由大小写字母加数字共62个字母组成\n\n\n# 一对一还是一对多映射？\n\n一个长网址，对应一个短网址，还是可以对应多个短网址？ 这也是个重大选择问题\n\n一般而言，一个长网址，在不同的地点，不同的用户等情况下，生成的短网址应该不一样，这样，在后端数据库中，可以更好的进行数据分析。如果一个长网址与一个短网址一一对应，那么在数据库中，仅有一行数据，无法区分不同的来源，就无法做数据分析了。\n\n以这个7位长度的短网址作为唯一id，这个id下可以挂各种信息，比如生成该网址的用户名，所在网站，http头部的 user agent等信息，收集了这些信息，才有可能在后面做大数据分析，挖掘数据的价值。短网址服务商的一大盈利来源就是这些数据。\n\n正确答案：一对多\n\n\n# 如何计算短网址\n\n现在我们设定了短网址是一个长度为7的字符串，如何计算得到这个短网址呢？\n\n最容易想到的办法是哈希，先hash得到一个64位整数，将它转化为62进制整，截取低7位即可。但是哈希算法会有冲突，如何处理冲突呢，又是一个麻烦。这个方法只是转移了矛盾，没有解决矛盾，抛弃。\n\n正确答案：分布式发号器(distributed id generator)\n\n\n# 如何存储\n\n如果存储短网址和长网址的对应关系？以短网址为 primary key, 长网址为value, 可以用传统的关系数据库存起来，例如mysql, postgresql，也可以用任意一个分布式kv数据库，例如redis, leveldb。\n\n如果你手痒想要手工设计这个存储，那就是另一个话题了，你需要完整地造一个kv存储引擎轮子。当前流行的kv存储引擎有leveldb何rockdb，去读它们的源码吧 😄\n\n\n# 301还是302重定向\n\n这也是一个有意思的问题。这个问题主要是考察你对301和302的理解，以及浏览器缓存机制的理解。\n\n301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。但是如果用了301， google，百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的cookie, user agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。\n\n所以，正确答案是302重定向。\n\n可以抓包看看新浪微博的短网址是怎么做的，使用 chrome 浏览器，访问这个url http://t.cn/rx2vxji，是我事先发微博自动生成的短网址。来抓包看看返回的结果是啥，\n\n\n\n可见新浪微博用的就是302临时重定向。\n\n\n# 预防攻击\n\n如果一些别有用心的黑客，短时间内向tinyurl服务器发送大量的请求，会迅速耗光id，怎么办呢？\n\n首先，限制ip的单日请求总数，超过阈值则直接拒绝服务。\n\n光限制ip的请求数还不够，因为黑客一般手里有上百万台肉鸡的，ip地址大大的有，所以光限制ip作用不大。\n\n可以用一台redis作为缓存服务器，存储的不是 id->长网址，而是 长网址->id，仅存储一天以内的数据，用lru机制进行淘汰。这样，如果黑客大量发同一个长网址过来，直接从缓存服务器里返回短网址即可，他就无法耗光我们的id了。\n\n\n# 参考\n\n短链接设计",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"简述什么是两阶段提交？",frontmatter:{title:"简述什么是两阶段提交？",date:"2022-05-21T17:12:23.000Z",permalink:"/pages/4eae5b/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/020.%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%9F.html",relativePath:"08.系统设计/020.简述什么是两阶段提交？.md",key:"v-f88544f4",path:"/pages/4eae5b/",headersStr:null,content:"TCC/Try Confirm Cancel模式TCC模式只有在所有的服务的第一阶段（try）都成功的时候才进行第二阶段确认（Confirm）操作，否则进行补偿(Cancel)操作，而在try阶段是不会进行真正的业务处理的。\n\n\nTCC模式TCC模式的具体流程为两个阶段：Try，业务服务完成所有的业务检查，预留必需的业务资源如果Try在所有服务中都成功，那么执行Confirm操作，Confirm操作不做任何的业务检查（因为try中已经做过），只是用Try阶段预留的业务资源进行业务处理；否则进行Cancel操作，Cancel操作释放Try阶段预留的业务资源。\n\n\n这么说可能比较模糊，下面我举一个具体的例子，小明在线从招商银行转账100元到广发银行。\n\n\n这个操作可看作两个服务，服务a从小明的招行账户转出100元，服务b从小明的广发银行帐户汇入100元。\n\n\n服务a（小明从招行转出100元）:try: update cmb_account set balance=balance-100, freeze=freeze+100 where\nacc_id=1 and balance>100;\n\nconfirm: update cmb_account set freeze=freeze-100 where acc_id=1;\n\ncancel: update cmb_account set balance=balance+100, freeze=freeze-100 where\nacc_id=1;\n\n\n服务b（小明往广发银行汇入100元）:try: update cgb_account set freeze=freeze+100 where acc_id=1;\n\nconfirm: update cgb_account set balance=balance+100, freeze=freeze-100 where acc_id=1;\n\ncancel: update cgb_account set freeze=freeze-100 where acc_id=1;\n\n\n具体说明：a的try阶段，服务做了两件事，1：业务检查，这里是检查小明的帐户里的钱是否多余100元；2:预留资源，将100元从余额中划入冻结资金。\na的confirm阶段，这里不再进行业务检查，因为try阶段已经做过了，同时由于转账已经成功，将冻结资金扣除。a的cancel阶段，释放预留资源，既100元冻结资金，并恢复到余额。\n\n\nb的try阶段进行，预留资源，将100元冻结。b的confirm阶段，使用try阶段预留的资源，将100元冻结资金划入余额。\nb的cancel阶段，释放try阶段的预留资源，将100元从冻结资金中减去。从上面的简单例子可以看出，TCC模式比纯业务补偿模式更加复杂，所以在实现上每个服务都需要实现Cofirm和Cancel两个接口。",normalizedContent:"tcc/try confirm cancel模式tcc模式只有在所有的服务的第一阶段（try）都成功的时候才进行第二阶段确认（confirm）操作，否则进行补偿(cancel)操作，而在try阶段是不会进行真正的业务处理的。\n\n\ntcc模式tcc模式的具体流程为两个阶段：try，业务服务完成所有的业务检查，预留必需的业务资源如果try在所有服务中都成功，那么执行confirm操作，confirm操作不做任何的业务检查（因为try中已经做过），只是用try阶段预留的业务资源进行业务处理；否则进行cancel操作，cancel操作释放try阶段预留的业务资源。\n\n\n这么说可能比较模糊，下面我举一个具体的例子，小明在线从招商银行转账100元到广发银行。\n\n\n这个操作可看作两个服务，服务a从小明的招行账户转出100元，服务b从小明的广发银行帐户汇入100元。\n\n\n服务a（小明从招行转出100元）:try: update cmb_account set balance=balance-100, freeze=freeze+100 where\nacc_id=1 and balance>100;\n\nconfirm: update cmb_account set freeze=freeze-100 where acc_id=1;\n\ncancel: update cmb_account set balance=balance+100, freeze=freeze-100 where\nacc_id=1;\n\n\n服务b（小明往广发银行汇入100元）:try: update cgb_account set freeze=freeze+100 where acc_id=1;\n\nconfirm: update cgb_account set balance=balance+100, freeze=freeze-100 where acc_id=1;\n\ncancel: update cgb_account set freeze=freeze-100 where acc_id=1;\n\n\n具体说明：a的try阶段，服务做了两件事，1：业务检查，这里是检查小明的帐户里的钱是否多余100元；2:预留资源，将100元从余额中划入冻结资金。\na的confirm阶段，这里不再进行业务检查，因为try阶段已经做过了，同时由于转账已经成功，将冻结资金扣除。a的cancel阶段，释放预留资源，既100元冻结资金，并恢复到余额。\n\n\nb的try阶段进行，预留资源，将100元冻结。b的confirm阶段，使用try阶段预留的资源，将100元冻结资金划入余额。\nb的cancel阶段，释放try阶段的预留资源，将100元从冻结资金中减去。从上面的简单例子可以看出，tcc模式比纯业务补偿模式更加复杂，所以在实现上每个服务都需要实现cofirm和cancel两个接口。",charsets:{cjk:!0},lastUpdated:"2022/05/22, 00:01:01",lastUpdatedTimestamp:1653148861e3},{title:"如何实现唯一的分布式 ID",frontmatter:{title:"如何实现唯一的分布式 ID",date:"2022-11-09T22:58:29.000Z",permalink:"/pages/e5252b/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/022.%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%94%AF%E4%B8%80%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%20ID.html",relativePath:"08.系统设计/022.如何实现唯一的分布式 ID.md",key:"v-dca272ea",path:"/pages/e5252b/",headers:[{level:2,title:"1.UUID",slug:"_1-uuid",normalizedTitle:"1.uuid",charIndex:2},{level:2,title:"2.UUID转Long的方式",slug:"_2-uuid转long的方式",normalizedTitle:"2.uuid转long的方式",charIndex:215},{level:2,title:"3.数据库自增ID",slug:"_3-数据库自增id",normalizedTitle:"3.数据库自增id",charIndex:743},{level:2,title:"4.Redis的incr自增",slug:"_4-redis的incr自增",normalizedTitle:"4.redis的incr自增",charIndex:1108},{level:2,title:"5.数据库号段模式",slug:"_5-数据库号段模式",normalizedTitle:"5.数据库号段模式",charIndex:1474},{level:3,title:"6.Snowflake",slug:"_6-snowflake",normalizedTitle:"6.snowflake",charIndex:1687},{level:3,title:"6.Leaf-snowflake（美团）",slug:"_6-leaf-snowflake-美团",normalizedTitle:"6.leaf-snowflake（美团）",charIndex:1912},{level:3,title:"7.uid-generator（百度）",slug:"_7-uid-generator-百度",normalizedTitle:"7.uid-generator（百度）",charIndex:10634},{level:3,title:"8.Tinyid（滴滴）",slug:"_8-tinyid-滴滴",normalizedTitle:"8.tinyid（滴滴）",charIndex:11004},{level:3,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:11195}],headersStr:"1.UUID 2.UUID转Long的方式 3.数据库自增ID 4.Redis的incr自增 5.数据库号段模式 6.Snowflake 6.Leaf-snowflake（美团） 7.uid-generator（百度） 8.Tinyid（滴滴） 结语",content:'# 1.UUID\n\nUUID.randomUUID().toString()\n\n\n1\n\n\n【优点】\n\n 1. 本地生成无网络消耗，并具有唯一性。\n\n【缺点】\n\n 1. 长度较长且无序，也没有实际意义；\n 2. 不适用于实际的业务需求。像用作订单号UUID这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；\n 3. 如果做mysql表主键的话，由于mysql的底层存储结构是B+树，节点在排序等操作时，性能差于整型。\n\n\n# 2.UUID转Long的方式\n\nUUID.randomUUID().getMostSignificantBits() & Long.MAX_VALUE\n\n\n1\n\n\n查看UUID类的toString()方法，会发现UUID是由高64位和低64位组合而成：\n\npublic String toString() {\n        return (digits(mostSigBits >> 32, 8) + "-" +\n                digits(mostSigBits >> 16, 4) + "-" +\n                digits(mostSigBits, 4) + "-" +\n                digits(leastSigBits >> 48, 4) + "-" +\n                digits(leastSigBits, 12));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nUUID的高64位与0111111111111111111111111111111111111111111111111111111111111111做按位运算，可保证生成的id始终为正数。\n\n\n# 3.数据库自增ID\n\n基于数据库的auto_increment自增ID。\n\nCREATE DATABASE `SEQ_ID`;\nCREATE TABLE SEQID.SEQUENCE_ID (\n    id bigint(20) unsigned NOT NULL auto_increment, \n    value char(10) NOT NULL default \'\',\n    PRIMARY KEY (id),\n) ENGINE=MyISAM;\n\ninsert into SEQUENCE_ID(value) VALUES (\'values\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【优点】\n\n 1. ID自增，数值类型存取性能好；\n\n【缺点】 1.单点要防止宕机风险； 2.集群模式难扩展，比如步长。\n\n\n# 4.Redis的incr自增\n\n【优点】\n\n 1. Redis的优点是单线程、免去了线程间切换的开销，存取速度快。\n\n【缺点】\n\n 1. Redis满足分布式CAP原则中的A（Availability可用性）、P（Partition tolerance分区容错性），不能满足C（Consistency一致性），也就是说Redis无法保证在主节点宕机时自动完成数据一致性的同步操作。那么在极端情况下，主节点挂掉后可能产生重复的id。\n 2. 即使考虑用持久化的方式来规避上面的问题，仍存在以下缺陷： RDB方式：定时备份，可能存在数据丢失。假如连续自增但redis没及时持久化，而此时Redis挂掉了，重启Redis后可能会出现ID重复的情况。 AOF方式：每条写命令都备份，不会出现ID重复的情况，但文件过大，恢复数据慢。\n\n\n# 5.数据库号段模式\n\n用表记录当前最大id，和自增步长。每次机器通过乐观锁的方式修改当前最大id字段：\n\nupdate id_generator set max_id = #{max_id+step}, version = version + 1 where version = #{version} and biz_type = XXX\n\n\n1\n\n\n【优点】 不会频繁的访问数据库，对数据库的压力小很多。 【图示】\n\n\n# 6.Snowflake\n\n【组成】 符号位：1bit：符号位，固定是0，表示全部ID都是正整数 时间戳：与指定日期的时间差（毫秒级），41位，够用69年 集群ID、机器ID：10位，最多支持1024台机器 自增序列：12位，每台机器每毫秒内最多产生2^12即4096个序列号 【优点】\n\n 1. 本地生成无网络消耗。\n\n【缺点】\n\n 1. 依赖系统时间，如果系统时间被回调，或者改变，可能会造成id冲突或者重复，也能出现不是全局递增的情况。\n\n\n# 6.Leaf-snowflake（美团）\n\n美团对号段模式和雪花算法的实现方式均有改进。 【文档】 https://tech.meituan.com/2017/04/21/mt-leaf.html 【得名】 德国哲学家、数学家莱布尼茨的一句话： >There are no two identical leaves in the world > “世界上没有两片相同的树叶”。 【号段模式改进】 基于数据库号段模式，但取号段的时机不在号段消耗完的时候进行，而是当号段消费到某个点时就异步的把下一个号段加载到内存中，好处是不阻塞临界点的ID下发。\n\n【雪花算法改进——解决时钟回退方案】\n\n 1. 启动时： a. 弱依赖ZooKeeper，由Zookeepp的持久化顺序节点来存储wokerId。若写过，则用自身系统时间与leaf_forever/${self}节点记录时间做比较，若小于leaf_forever/${self}时间则认为机器时间发生了大步长回拨，服务启动失败并报警。 b. 若未写过，证明是新服务节点，直接创建持久节点leaf_forever/${self}并写入自身系统时间，接下来综合对比其余Leaf节点的系统时间来判断自身系统时间是否准确，具体做法是取leaf_temporary下的所有临时节点(所有运行中的Leaf-snowflake节点)的服务IP：Port，然后通过RPC请求得到所有节点的系统时间，计算sum(time)/nodeSize。 c. 若abs( 系统时间-sum(time)/nodeSize ) < 阈值，认为当前系统时间准确，正常启动服务，同时写临时节点leaf_temporary/${self} 维持租约。 d. 否则认为本机系统时间发生大步长偏移，启动失败并报警。 e. 每隔一段时间(3s)上报自身系统时间写入leaf_forever/${self}。\n 2. 运行时： a. 建议可以直接关闭NTP同步；【Network Time Protocol（NTP）】 b. 做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警；\n\n【主要代码】 号段模式：\n\n//LeafController.class\n@RequestMapping(value = "/api/segment/get/{key}")\npublic String getSegmentId(@PathVariable("key") String key) {\n        return get(key, segmentService.getId(key));\n}\n\n//SegmentIDGenImpl.class\n@Override\npublic Result get(final String key) {\n        // 将初始值和步长初始化\n        if (!initOK) {\n                return new Result(EXCEPTION_ID_IDCACHE_INIT_FALSE, Status.EXCEPTION);\n        }\n        // key为业务标识\n        if (cache.containsKey(key)) {\n                SegmentBuffer buffer = cache.get(key);\n                // 如果当前还没有初始化号段\n                if (!buffer.isInitOk()) {\n                        synchronized (buffer) {\n                                if (!buffer.isInitOk()) {\n                                        try {\n                                                updateSegmentFromDb(key, buffer.getCurrent());\n                                                logger.info("Init buffer. Update leafkey {} {} from db", key, buffer.getCurrent());\n                                                buffer.setInitOk(true);\n                                        } catch (Exception e) {\n                                                logger.warn("Init buffer {} exception", buffer.getCurrent(), e);\n                                        }\n                                }\n                        }\n                }\n                // 从缓存中取值\n                return getIdFromSegmentBuffer(cache.get(key));\n        }\n        return new Result(EXCEPTION_ID_KEY_NOT_EXISTS, Status.EXCEPTION);\n}\n\nprivate ExecutorService service = new ThreadPoolExecutor(5, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new UpdateThreadFactory());\n\npublic Result getIdFromSegmentBuffer(final SegmentBuffer buffer) {\n            while (true) {\n                    buffer.rLock().lock();\n                    try {\n                            final Segment segment = buffer.getCurrent();\n                            // 当号段消费到某个点时就异步的把下一个号段加载到内存中\n                            if (!buffer.isNextReady() && (segment.getIdle() < 0.9 * segment.getStep()) && buffer.getThreadRunning().compareAndSet(false, true)) {\n                                    service.execute(new Runnable() {\n                                            @Override\n                                            public void run() {\n                                                    Segment next = buffer.getSegments()[buffer.nextPos()];\n                                                    boolean updateOk = false;\n                                                    try {\n                                                            updateSegmentFromDb(buffer.getKey(), next);\n                                                            updateOk = true;\n                                                            logger.info("update segment {} from db {}", buffer.getKey(), next);\n                                                    } catch (Exception e) {\n                                                            logger.warn(buffer.getKey() + " updateSegmentFromDb exception", e);\n                                                    } finally {\n                                                            if (updateOk) {\n                                                                    buffer.wLock().lock();\n                                                                    buffer.setNextReady(true);\n                                                                    buffer.getThreadRunning().set(false);\n                                                                    buffer.wLock().unlock();\n                                                            } else {\n                                                                    buffer.getThreadRunning().set(false);\n                                                            }\n                                                    }\n                                            }\n                                    });\n                            }\n                            long value = segment.getValue().getAndIncrement();\n                            if (value < segment.getMax()) {\n                                    return new Result(value, Status.SUCCESS);\n                            }\n                    } finally {\n                            buffer.rLock().unlock();\n                    }\n                    waitAndSleep(buffer);\n                    buffer.wLock().lock();\n                    try {\n                            final Segment segment = buffer.getCurrent();\n                            long value = segment.getValue().getAndIncrement();\n                            if (value < segment.getMax()) {\n                                    return new Result(value, Status.SUCCESS);\n                            }\n                            if (buffer.isNextReady()) {\n                                    buffer.switchPos();\n                                    buffer.setNextReady(false);\n                            } else {\n                                    logger.error("Both two segments in {} are not ready!", buffer);\n                                    return new Result(EXCEPTION_ID_TWO_SEGMENTS_ARE_NULL, Status.EXCEPTION);\n                            }\n                    } finally {\n                            buffer.wLock().unlock();\n                    }\n            }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n雪花算法：\n\n//LeafController.class\n@RequestMapping(value = "/api/snowflake/get/{key}")\npublic String getSnowflakeId(@PathVariable("key") String key) {\n        return get(key, snowflakeService.getId(key));\n}\n\n//SnowflakeIDGenImpl.class\npublic synchronized Result get(String key) {\n        long timestamp = timeGen();\n        // 当前时间小于上次用的时间戳\n        if (timestamp < lastTimestamp) {\n            long offset = lastTimestamp - timestamp;\n            if (offset <= 5) {\n                try {\n                    // 时间偏差大小如果小于5ms，则等待两倍时间\n                    wait(offset << 1);\n                    // 重新获取时间戳\n                    timestamp = timeGen();\n                    if (timestamp < lastTimestamp) {\n                        return new Result(-1, Status.EXCEPTION);\n                    }\n                } catch (InterruptedException e) {\n                    LOGGER.error("wait interrupted");\n                    return new Result(-2, Status.EXCEPTION);\n                }\n            } else {\n                return new Result(-3, Status.EXCEPTION);\n            }\n        }\n        // 当前时间 = 上次的时间戳\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) & sequenceMask;\n            if (sequence == 0) {\n                //seq 为0的时候表示是下一毫秒时间开始对seq做随机\n                sequence = RANDOM.nextInt(100);\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {\n            //如果是新的ms开始\n            sequence = RANDOM.nextInt(100);\n        }\n        lastTimestamp = timestamp;\n        long id = ((timestamp - twepoch) << timestampLeftShift) | (workerId << workerIdShift) | sequence;\n        return new Result(id, Status.SUCCESS);\n\n    }\n\n    protected long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp <= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    protected long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 7.uid-generator（百度）\n\n【文档】 https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md 【组成】 ● sign(1bit) ● 固定1bit符号标识，即生成的UID为正数。 ● delta seconds (28 bits) ● 当前时间，相对于时间基点"2016-05-20"的增量值，单位：秒，最多可支持约8.7年 ● worker id (22 bits) ● 机器id，最多可支持约420w次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。 ● sequence (13 bits) ● 每秒下的并发序列，13 bits可支持每秒8192个并发。 以上参数均可通过Spring进行自定义\n\n\n# 8.Tinyid（滴滴）\n\nTinyid扩展了leaf-segment算法，支持了多db(master)，同时提供了java-client(sdk)使id生成本地化。 【优点】\n\n 1. 提供http和java client方式接入\n 2. 支持批量获取id\n 3. 支持生成1,3,5,7,9...序列的id（其实就是for循环获取）\n 4. 支持多个db的配置，无单点\n\n\n# 结语\n\n对比了几种分布式id的方案，个人认为美团的实现方案是比较完善的，它对业界比较流行的两种方案（号段模式和雪花算法）均有改进，且百度、滴滴的方案均基于它来实现。\n\n如果想要更简便的方式，UUID、UUID转Long、Redis自增方案是不错的选择，可以按各自的优缺点去选择方案。因为没有最优，只有最合适业务的方案。\n\n参考： Leaf——美团点评分布式ID生成系统',normalizedContent:'# 1.uuid\n\nuuid.randomuuid().tostring()\n\n\n1\n\n\n【优点】\n\n 1. 本地生成无网络消耗，并具有唯一性。\n\n【缺点】\n\n 1. 长度较长且无序，也没有实际意义；\n 2. 不适用于实际的业务需求。像用作订单号uuid这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；\n 3. 如果做mysql表主键的话，由于mysql的底层存储结构是b+树，节点在排序等操作时，性能差于整型。\n\n\n# 2.uuid转long的方式\n\nuuid.randomuuid().getmostsignificantbits() & long.max_value\n\n\n1\n\n\n查看uuid类的tostring()方法，会发现uuid是由高64位和低64位组合而成：\n\npublic string tostring() {\n        return (digits(mostsigbits >> 32, 8) + "-" +\n                digits(mostsigbits >> 16, 4) + "-" +\n                digits(mostsigbits, 4) + "-" +\n                digits(leastsigbits >> 48, 4) + "-" +\n                digits(leastsigbits, 12));\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nuuid的高64位与0111111111111111111111111111111111111111111111111111111111111111做按位运算，可保证生成的id始终为正数。\n\n\n# 3.数据库自增id\n\n基于数据库的auto_increment自增id。\n\ncreate database `seq_id`;\ncreate table seqid.sequence_id (\n    id bigint(20) unsigned not null auto_increment, \n    value char(10) not null default \'\',\n    primary key (id),\n) engine=myisam;\n\ninsert into sequence_id(value) values (\'values\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【优点】\n\n 1. id自增，数值类型存取性能好；\n\n【缺点】 1.单点要防止宕机风险； 2.集群模式难扩展，比如步长。\n\n\n# 4.redis的incr自增\n\n【优点】\n\n 1. redis的优点是单线程、免去了线程间切换的开销，存取速度快。\n\n【缺点】\n\n 1. redis满足分布式cap原则中的a（availability可用性）、p（partition tolerance分区容错性），不能满足c（consistency一致性），也就是说redis无法保证在主节点宕机时自动完成数据一致性的同步操作。那么在极端情况下，主节点挂掉后可能产生重复的id。\n 2. 即使考虑用持久化的方式来规避上面的问题，仍存在以下缺陷： rdb方式：定时备份，可能存在数据丢失。假如连续自增但redis没及时持久化，而此时redis挂掉了，重启redis后可能会出现id重复的情况。 aof方式：每条写命令都备份，不会出现id重复的情况，但文件过大，恢复数据慢。\n\n\n# 5.数据库号段模式\n\n用表记录当前最大id，和自增步长。每次机器通过乐观锁的方式修改当前最大id字段：\n\nupdate id_generator set max_id = #{max_id+step}, version = version + 1 where version = #{version} and biz_type = xxx\n\n\n1\n\n\n【优点】 不会频繁的访问数据库，对数据库的压力小很多。 【图示】\n\n\n# 6.snowflake\n\n【组成】 符号位：1bit：符号位，固定是0，表示全部id都是正整数 时间戳：与指定日期的时间差（毫秒级），41位，够用69年 集群id、机器id：10位，最多支持1024台机器 自增序列：12位，每台机器每毫秒内最多产生2^12即4096个序列号 【优点】\n\n 1. 本地生成无网络消耗。\n\n【缺点】\n\n 1. 依赖系统时间，如果系统时间被回调，或者改变，可能会造成id冲突或者重复，也能出现不是全局递增的情况。\n\n\n# 6.leaf-snowflake（美团）\n\n美团对号段模式和雪花算法的实现方式均有改进。 【文档】 https://tech.meituan.com/2017/04/21/mt-leaf.html 【得名】 德国哲学家、数学家莱布尼茨的一句话： >there are no two identical leaves in the world > “世界上没有两片相同的树叶”。 【号段模式改进】 基于数据库号段模式，但取号段的时机不在号段消耗完的时候进行，而是当号段消费到某个点时就异步的把下一个号段加载到内存中，好处是不阻塞临界点的id下发。\n\n【雪花算法改进——解决时钟回退方案】\n\n 1. 启动时： a. 弱依赖zookeeper，由zookeepp的持久化顺序节点来存储wokerid。若写过，则用自身系统时间与leaf_forever/${self}节点记录时间做比较，若小于leaf_forever/${self}时间则认为机器时间发生了大步长回拨，服务启动失败并报警。 b. 若未写过，证明是新服务节点，直接创建持久节点leaf_forever/${self}并写入自身系统时间，接下来综合对比其余leaf节点的系统时间来判断自身系统时间是否准确，具体做法是取leaf_temporary下的所有临时节点(所有运行中的leaf-snowflake节点)的服务ip：port，然后通过rpc请求得到所有节点的系统时间，计算sum(time)/nodesize。 c. 若abs( 系统时间-sum(time)/nodesize ) < 阈值，认为当前系统时间准确，正常启动服务，同时写临时节点leaf_temporary/${self} 维持租约。 d. 否则认为本机系统时间发生大步长偏移，启动失败并报警。 e. 每隔一段时间(3s)上报自身系统时间写入leaf_forever/${self}。\n 2. 运行时： a. 建议可以直接关闭ntp同步；【network time protocol（ntp）】 b. 做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警；\n\n【主要代码】 号段模式：\n\n//leafcontroller.class\n@requestmapping(value = "/api/segment/get/{key}")\npublic string getsegmentid(@pathvariable("key") string key) {\n        return get(key, segmentservice.getid(key));\n}\n\n//segmentidgenimpl.class\n@override\npublic result get(final string key) {\n        // 将初始值和步长初始化\n        if (!initok) {\n                return new result(exception_id_idcache_init_false, status.exception);\n        }\n        // key为业务标识\n        if (cache.containskey(key)) {\n                segmentbuffer buffer = cache.get(key);\n                // 如果当前还没有初始化号段\n                if (!buffer.isinitok()) {\n                        synchronized (buffer) {\n                                if (!buffer.isinitok()) {\n                                        try {\n                                                updatesegmentfromdb(key, buffer.getcurrent());\n                                                logger.info("init buffer. update leafkey {} {} from db", key, buffer.getcurrent());\n                                                buffer.setinitok(true);\n                                        } catch (exception e) {\n                                                logger.warn("init buffer {} exception", buffer.getcurrent(), e);\n                                        }\n                                }\n                        }\n                }\n                // 从缓存中取值\n                return getidfromsegmentbuffer(cache.get(key));\n        }\n        return new result(exception_id_key_not_exists, status.exception);\n}\n\nprivate executorservice service = new threadpoolexecutor(5, integer.max_value, 60l, timeunit.seconds, new synchronousqueue<runnable>(), new updatethreadfactory());\n\npublic result getidfromsegmentbuffer(final segmentbuffer buffer) {\n            while (true) {\n                    buffer.rlock().lock();\n                    try {\n                            final segment segment = buffer.getcurrent();\n                            // 当号段消费到某个点时就异步的把下一个号段加载到内存中\n                            if (!buffer.isnextready() && (segment.getidle() < 0.9 * segment.getstep()) && buffer.getthreadrunning().compareandset(false, true)) {\n                                    service.execute(new runnable() {\n                                            @override\n                                            public void run() {\n                                                    segment next = buffer.getsegments()[buffer.nextpos()];\n                                                    boolean updateok = false;\n                                                    try {\n                                                            updatesegmentfromdb(buffer.getkey(), next);\n                                                            updateok = true;\n                                                            logger.info("update segment {} from db {}", buffer.getkey(), next);\n                                                    } catch (exception e) {\n                                                            logger.warn(buffer.getkey() + " updatesegmentfromdb exception", e);\n                                                    } finally {\n                                                            if (updateok) {\n                                                                    buffer.wlock().lock();\n                                                                    buffer.setnextready(true);\n                                                                    buffer.getthreadrunning().set(false);\n                                                                    buffer.wlock().unlock();\n                                                            } else {\n                                                                    buffer.getthreadrunning().set(false);\n                                                            }\n                                                    }\n                                            }\n                                    });\n                            }\n                            long value = segment.getvalue().getandincrement();\n                            if (value < segment.getmax()) {\n                                    return new result(value, status.success);\n                            }\n                    } finally {\n                            buffer.rlock().unlock();\n                    }\n                    waitandsleep(buffer);\n                    buffer.wlock().lock();\n                    try {\n                            final segment segment = buffer.getcurrent();\n                            long value = segment.getvalue().getandincrement();\n                            if (value < segment.getmax()) {\n                                    return new result(value, status.success);\n                            }\n                            if (buffer.isnextready()) {\n                                    buffer.switchpos();\n                                    buffer.setnextready(false);\n                            } else {\n                                    logger.error("both two segments in {} are not ready!", buffer);\n                                    return new result(exception_id_two_segments_are_null, status.exception);\n                            }\n                    } finally {\n                            buffer.wlock().unlock();\n                    }\n            }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n雪花算法：\n\n//leafcontroller.class\n@requestmapping(value = "/api/snowflake/get/{key}")\npublic string getsnowflakeid(@pathvariable("key") string key) {\n        return get(key, snowflakeservice.getid(key));\n}\n\n//snowflakeidgenimpl.class\npublic synchronized result get(string key) {\n        long timestamp = timegen();\n        // 当前时间小于上次用的时间戳\n        if (timestamp < lasttimestamp) {\n            long offset = lasttimestamp - timestamp;\n            if (offset <= 5) {\n                try {\n                    // 时间偏差大小如果小于5ms，则等待两倍时间\n                    wait(offset << 1);\n                    // 重新获取时间戳\n                    timestamp = timegen();\n                    if (timestamp < lasttimestamp) {\n                        return new result(-1, status.exception);\n                    }\n                } catch (interruptedexception e) {\n                    logger.error("wait interrupted");\n                    return new result(-2, status.exception);\n                }\n            } else {\n                return new result(-3, status.exception);\n            }\n        }\n        // 当前时间 = 上次的时间戳\n        if (lasttimestamp == timestamp) {\n            sequence = (sequence + 1) & sequencemask;\n            if (sequence == 0) {\n                //seq 为0的时候表示是下一毫秒时间开始对seq做随机\n                sequence = random.nextint(100);\n                timestamp = tilnextmillis(lasttimestamp);\n            }\n        } else {\n            //如果是新的ms开始\n            sequence = random.nextint(100);\n        }\n        lasttimestamp = timestamp;\n        long id = ((timestamp - twepoch) << timestampleftshift) | (workerid << workeridshift) | sequence;\n        return new result(id, status.success);\n\n    }\n\n    protected long tilnextmillis(long lasttimestamp) {\n        long timestamp = timegen();\n        while (timestamp <= lasttimestamp) {\n            timestamp = timegen();\n        }\n        return timestamp;\n    }\n\n    protected long timegen() {\n        return system.currenttimemillis();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 7.uid-generator（百度）\n\n【文档】 https://github.com/baidu/uid-generator/blob/master/readme.zh_cn.md 【组成】 ● sign(1bit) ● 固定1bit符号标识，即生成的uid为正数。 ● delta seconds (28 bits) ● 当前时间，相对于时间基点"2016-05-20"的增量值，单位：秒，最多可支持约8.7年 ● worker id (22 bits) ● 机器id，最多可支持约420w次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。 ● sequence (13 bits) ● 每秒下的并发序列，13 bits可支持每秒8192个并发。 以上参数均可通过spring进行自定义\n\n\n# 8.tinyid（滴滴）\n\ntinyid扩展了leaf-segment算法，支持了多db(master)，同时提供了java-client(sdk)使id生成本地化。 【优点】\n\n 1. 提供http和java client方式接入\n 2. 支持批量获取id\n 3. 支持生成1,3,5,7,9...序列的id（其实就是for循环获取）\n 4. 支持多个db的配置，无单点\n\n\n# 结语\n\n对比了几种分布式id的方案，个人认为美团的实现方案是比较完善的，它对业界比较流行的两种方案（号段模式和雪花算法）均有改进，且百度、滴滴的方案均基于它来实现。\n\n如果想要更简便的方式，uuid、uuid转long、redis自增方案是不错的选择，可以按各自的优缺点去选择方案。因为没有最优，只有最合适业务的方案。\n\n参考： leaf——美团点评分布式id生成系统',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"电商-商品系统设计",frontmatter:{title:"电商-商品系统设计",date:"2022-12-17T12:22:21.000Z",permalink:"/pages/bb7e83/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/024.%E7%94%B5%E5%95%86-%E5%95%86%E5%93%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html",relativePath:"08.系统设计/024.电商-商品系统设计.md",key:"v-5afa53ed",path:"/pages/bb7e83/",headers:[{level:2,title:"品类管理",slug:"品类管理",normalizedTitle:"品类管理",charIndex:2},{level:3,title:"前端品类管理",slug:"前端品类管理",normalizedTitle:"前端品类管理",charIndex:23},{level:4,title:"层级结构",slug:"层级结构",normalizedTitle:"层级结构",charIndex:485},{level:4,title:"命名规则",slug:"命名规则",normalizedTitle:"命名规则",charIndex:597},{level:4,title:"个性化跳转",slug:"个性化跳转",normalizedTitle:"个性化跳转",charIndex:748},{level:4,title:"关联后端品类",slug:"关联后端品类",normalizedTitle:"关联后端品类",charIndex:908},{level:4,title:"其它功能",slug:"其它功能",normalizedTitle:"其它功能",charIndex:1026},{level:4,title:"前后台类目映射",slug:"前后台类目映射",normalizedTitle:"前后台类目映射",charIndex:1236},{level:3,title:"后端品类管理",slug:"后端品类管理",normalizedTitle:"后端品类管理",charIndex:30},{level:2,title:"类目属性管理",slug:"类目属性管理",normalizedTitle:"类目属性管理",charIndex:3184},{level:2,title:"店铺分类",slug:"店铺分类",normalizedTitle:"店铺分类",charIndex:295},{level:2,title:"商品维护",slug:"商品维护",normalizedTitle:"商品维护",charIndex:3792},{level:2,title:"搜索",slug:"搜索",normalizedTitle:"搜索",charIndex:437}],headersStr:"品类管理 前端品类管理 层级结构 命名规则 个性化跳转 关联后端品类 其它功能 前后台类目映射 后端品类管理 类目属性管理 店铺分类 商品维护 搜索",content:"# 品类管理\n\n电商平台中品类管理通常分两种：前端品类管理和后端品类管理，为什么会有两套品类管理呢？\n\n * 当平台发展壮大的时候，平台上的商品非常的多，后端系统需要创建比较细致的品类对商品归类以方便精细化管理和数据统计。\n * 前端为了活动促销，运营人员会根据当前热度或根据用户喜好不断的对品类做个性化调整，以满足推广活动，如果直接修改后台的品类，势必导致后端品类混乱，维护人员(通常由采购部的人来维护)无法识别商品品类。\n\n基于上面两点，通常就会开发两套品类分别由运营人员和采购人员各自进行维护，即不会相互影响，又实现了各自的业务功能。\n\n电商系统有哪几种商品类目：前台类目、后台类目、店铺分类。\n\n * 前台类目：对于用户来说，通过类目可以为帮助他们快速地筛选商品，从而找到心仪的物品；\n * 后台类目：对于平台来说，可以高效地管理商品体系，为运营人员多样化类目运营提供基础支撑；\n * 店铺分类：对于商家来说，有利于商家对商品归类及制定规则，方便用户更准确地找到或者搜索宝贝。\n\n\n# 前端品类管理\n\n下图是JD官网首页的分类展示，我接下来分析一下功能：\n\n# 层级结构\n\n电商品类大大小小几百种，一个好的组织方式无疑能够让用户更快速、更直观的了解网站的业务内容，最常规的方式就是层级分明的树形结构。\n\n综合考虑到商品的细分程度和用户的体验效果，前端展示的品类一般都是三级结构。\n\n# 命名规则\n\n由于页面高度限制和用户视觉效果影响，网站首页默认只显示一级品类，二、三级品类通常被隐藏，需要通过用户移动鼠标来进行触发显示。\n\n由于默认只显示一级品类，但是又需要让用户对网站业务能有一个直观的了解，所以一级品类通常都是根据相似功能聚合多个品类一同进行展示，到二三级则为具体类目信息。\n\n# 个性化跳转\n\n活动运营是电商平台的核心业务，而品类作为电商的一个重要搜索入口，前端品类会加入个性化的链接跳转，通过点击品类跳转到指定的专题页或活动页，以增加活动流量。\n\n大家可以在JD官网上试试，将鼠标放在品类上，屏幕左下方会出现跳转链接地址，大体有两种形式：一种是跳转到相应的专题页中；另一种是跳转到搜索页中。\n\n# 关联后端品类\n\n上面我们讲了系统需要设计两套品类管理，它们又是如何关联在一起的呢？这个问题其实也比较简单，在创建前端品类的时候，会有一个关联设置功能，运营人员可以个性化设置关联多个后台品类。\n\n如：办公 -> 笔、本子、册子\n\n\n\n# 其它功能\n\n * ICON:为了美化品类的展示样式，前端UI通常会设计一些ICON图标进行优化，该功能手机端使用的比较多\n\n * 排序功能：运营会根据活动热度动态来调整个别品类显示的顺序，通过后台排序数字可以自由进行维护\n\n * 状态：控制品类是否展示在前端\n   \n   \n\n列表页原型图：\n\n\n\n表单页原型图：\n\n\n\n关联品类页原型图：\n\n\n\n前端品类关联后端品类时，可以关联到任意一级，无须精确到最后一级。\n\n# 前后台类目映射\n\n1）一对一映射\n\n后台类目与前台类目是一对一的关系，前台类目直接将后台类目映射过来。例如：后台类目叫连衣裙，前台类目也叫连衣裙或者其他名字。\n\n\n\n2）多对一映射\n\n多个具有相同属性的后台类目，前台类目通过聚合的方式，将其具有相同属性的类目聚合映射成一个类目。如下图展示的“流行女裙”前台类目。\n\n\n\n多个毫无关联的后台类目，通过某个场景将他们聚合起来，将其映射成一个前台类目。如下图展示的主打情人节活动的“情人倾城“前台类目。\n\n\n\n\n# 后端品类管理\n\n对于后来系统来说，主要用于数据分类，功能相对较少一些，对于页面优化并没有那么高要求，所以跳转路径、ICON设置就不需要进行维护。\n\n但是它有一个非常重要的关联属性功能，用于维护商品展示属性的基础设置，由于涉及内容比较多，我在下一篇文章中介绍。\n\n功能整理图：\n\n\n\n列表页原型图：\n\n\n\n表单页原型图：\n\n\n\n小提示：在展示树形结构数据时，当数据量比较少的时候(如系统菜单列表)通常会采用带有上下级折叠功能的样式进行展示，但是数据量比较大的时候，通常采用分页展示，不然单页面数据太大，经常出现卡顿现象。\n\nCREATE TABLE `item_category` (\n  `category_id` bigint(32) unsigned NOT NULL AUTO_INCREMENT COMMENT '类目id，唯一标识类目',\n  `category_pid` bigint(32) unsigned NOT NULL COMMENT '类目父id',\n  `category_name` varchar(255) NOT NULL DEFAULT '' COMMENT '类目名称',\n  `category_short_name` varchar(255) NOT NULL DEFAULT '' COMMENT '类目简称',\n  `picture_key` varchar(255) NOT NULL DEFAULT '' COMMENT '图片',\n  `category_level` int(4) unsigned NOT NULL DEFAULT '0' COMMENT '类目层级',\n  `leaf_flag` tinyint(1) unsigned NOT NULL COMMENT '是否是叶子结点 0:否,1:是',\n  `category_type` tinyint(1) unsigned NOT NULL COMMENT '前台、后台 0:前台,1:后台',\n  `link_url` varchar(255) NOT NULL DEFAULT '' COMMENT '跳转链接',\n  `back_categories` tinyint(1) unsigned NOT NULL COMMENT '后台类目',\n  `sort_num` tinyint(4) unsigned NOT NULL DEFAULT '0' COMMENT '同级类目展示顺序递增排序',\n  `language` tinyint(1) unsigned NOT NULL COMMENT '语言',\n  `country` tinyint(4) unsigned NOT NULL DEFAULT '0' COMMENT '国家',\n  `category_attr_ext` json NOT NULL DEFAULT '' COMMENT '分类拓展信息',\n  `valid_status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '有效性状态:0无效,1:有效',\n  `create_time` bigint(32) NOT NULL DEFAULT '0' COMMENT '创建时间',\n  `update_time` bigint(32) NOT NULL DEFAULT '0' COMMENT '修改时间',\n  PRIMARY KEY (`category_id`),\n  KEY `idx_categorypid` (`category_pid`)\n) ENGINE=InnoDB AUTO_INCREMENT=12201 DEFAULT CHARSET=utf8mb4 COMMENT='类目表';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n后端类目约定：\n\n非叶子类目不允许挂类目属性\n\n商品发布只能发布在叶子类目上\n\n参考：电商后台设计：品类管理\n\n\n# 类目属性管理\n\n电商平台中商品数量庞大，各商品的属性又千差万别，所以设计一套可复用的属性管理功能就很重要。\n\n不同商品的属性差异化还是很大，系统设计时为了方便管理，根据用途我们将它们分类：\n\n * 基础属性：所有的商品都有的通用属性，如标题、品牌、品类等。\n * 关键属性：用来唯一确定一个SPU.\n * 销售属性：影响商品销售价格/库存的属性，不同类型的的商品销售各不相同，如手机的颜色、内存等。\n * 搜索属性：参与到商品搜索中的属性，如标题、品牌、品类等\n * 特有属性：不同商品各自所独有的属性，如鞋子的使用人群、鞋面材质，手表的机芯等\n\n是否必选\n\n是否多选\n\n是否可输入\n\n是否枚举\n\n参考：电商后台设计：属性管理\n\n\n# 店铺分类\n\n最后来讲讲店铺分类。\n\n该分类由商家自己创建，有利于商家对商品归类及制定规则，方便用户更准确的找到或者搜索宝贝。一般有以下两种展示方式供大家参考。\n\n商品管理之后台类目、前台类目、店铺分类详解\n\n前台类目和店铺分类有一定的相似点，都可以按照不同业务场景将商品分门别类归纳起来，满足运营需求。\n\n但是两则差异也很明显，店铺分类最多支持两级分类，同时只支持按照商品维度进行分类。\n\n下图创建店铺分类是采用上图右侧的布局方式。先创建分类的名字，再绑定商品，商品支持同时绑定多个店铺分类。\n\n当商家发布商品的时候，选择后台分类的同时，也可以选择自己设置好的店铺分类。\n\n\n# 商品维护\n\n\n# 搜索",normalizedContent:"# 品类管理\n\n电商平台中品类管理通常分两种：前端品类管理和后端品类管理，为什么会有两套品类管理呢？\n\n * 当平台发展壮大的时候，平台上的商品非常的多，后端系统需要创建比较细致的品类对商品归类以方便精细化管理和数据统计。\n * 前端为了活动促销，运营人员会根据当前热度或根据用户喜好不断的对品类做个性化调整，以满足推广活动，如果直接修改后台的品类，势必导致后端品类混乱，维护人员(通常由采购部的人来维护)无法识别商品品类。\n\n基于上面两点，通常就会开发两套品类分别由运营人员和采购人员各自进行维护，即不会相互影响，又实现了各自的业务功能。\n\n电商系统有哪几种商品类目：前台类目、后台类目、店铺分类。\n\n * 前台类目：对于用户来说，通过类目可以为帮助他们快速地筛选商品，从而找到心仪的物品；\n * 后台类目：对于平台来说，可以高效地管理商品体系，为运营人员多样化类目运营提供基础支撑；\n * 店铺分类：对于商家来说，有利于商家对商品归类及制定规则，方便用户更准确地找到或者搜索宝贝。\n\n\n# 前端品类管理\n\n下图是jd官网首页的分类展示，我接下来分析一下功能：\n\n# 层级结构\n\n电商品类大大小小几百种，一个好的组织方式无疑能够让用户更快速、更直观的了解网站的业务内容，最常规的方式就是层级分明的树形结构。\n\n综合考虑到商品的细分程度和用户的体验效果，前端展示的品类一般都是三级结构。\n\n# 命名规则\n\n由于页面高度限制和用户视觉效果影响，网站首页默认只显示一级品类，二、三级品类通常被隐藏，需要通过用户移动鼠标来进行触发显示。\n\n由于默认只显示一级品类，但是又需要让用户对网站业务能有一个直观的了解，所以一级品类通常都是根据相似功能聚合多个品类一同进行展示，到二三级则为具体类目信息。\n\n# 个性化跳转\n\n活动运营是电商平台的核心业务，而品类作为电商的一个重要搜索入口，前端品类会加入个性化的链接跳转，通过点击品类跳转到指定的专题页或活动页，以增加活动流量。\n\n大家可以在jd官网上试试，将鼠标放在品类上，屏幕左下方会出现跳转链接地址，大体有两种形式：一种是跳转到相应的专题页中；另一种是跳转到搜索页中。\n\n# 关联后端品类\n\n上面我们讲了系统需要设计两套品类管理，它们又是如何关联在一起的呢？这个问题其实也比较简单，在创建前端品类的时候，会有一个关联设置功能，运营人员可以个性化设置关联多个后台品类。\n\n如：办公 -> 笔、本子、册子\n\n\n\n# 其它功能\n\n * icon:为了美化品类的展示样式，前端ui通常会设计一些icon图标进行优化，该功能手机端使用的比较多\n\n * 排序功能：运营会根据活动热度动态来调整个别品类显示的顺序，通过后台排序数字可以自由进行维护\n\n * 状态：控制品类是否展示在前端\n   \n   \n\n列表页原型图：\n\n\n\n表单页原型图：\n\n\n\n关联品类页原型图：\n\n\n\n前端品类关联后端品类时，可以关联到任意一级，无须精确到最后一级。\n\n# 前后台类目映射\n\n1）一对一映射\n\n后台类目与前台类目是一对一的关系，前台类目直接将后台类目映射过来。例如：后台类目叫连衣裙，前台类目也叫连衣裙或者其他名字。\n\n\n\n2）多对一映射\n\n多个具有相同属性的后台类目，前台类目通过聚合的方式，将其具有相同属性的类目聚合映射成一个类目。如下图展示的“流行女裙”前台类目。\n\n\n\n多个毫无关联的后台类目，通过某个场景将他们聚合起来，将其映射成一个前台类目。如下图展示的主打情人节活动的“情人倾城“前台类目。\n\n\n\n\n# 后端品类管理\n\n对于后来系统来说，主要用于数据分类，功能相对较少一些，对于页面优化并没有那么高要求，所以跳转路径、icon设置就不需要进行维护。\n\n但是它有一个非常重要的关联属性功能，用于维护商品展示属性的基础设置，由于涉及内容比较多，我在下一篇文章中介绍。\n\n功能整理图：\n\n\n\n列表页原型图：\n\n\n\n表单页原型图：\n\n\n\n小提示：在展示树形结构数据时，当数据量比较少的时候(如系统菜单列表)通常会采用带有上下级折叠功能的样式进行展示，但是数据量比较大的时候，通常采用分页展示，不然单页面数据太大，经常出现卡顿现象。\n\ncreate table `item_category` (\n  `category_id` bigint(32) unsigned not null auto_increment comment '类目id，唯一标识类目',\n  `category_pid` bigint(32) unsigned not null comment '类目父id',\n  `category_name` varchar(255) not null default '' comment '类目名称',\n  `category_short_name` varchar(255) not null default '' comment '类目简称',\n  `picture_key` varchar(255) not null default '' comment '图片',\n  `category_level` int(4) unsigned not null default '0' comment '类目层级',\n  `leaf_flag` tinyint(1) unsigned not null comment '是否是叶子结点 0:否,1:是',\n  `category_type` tinyint(1) unsigned not null comment '前台、后台 0:前台,1:后台',\n  `link_url` varchar(255) not null default '' comment '跳转链接',\n  `back_categories` tinyint(1) unsigned not null comment '后台类目',\n  `sort_num` tinyint(4) unsigned not null default '0' comment '同级类目展示顺序递增排序',\n  `language` tinyint(1) unsigned not null comment '语言',\n  `country` tinyint(4) unsigned not null default '0' comment '国家',\n  `category_attr_ext` json not null default '' comment '分类拓展信息',\n  `valid_status` tinyint(1) not null default '1' comment '有效性状态:0无效,1:有效',\n  `create_time` bigint(32) not null default '0' comment '创建时间',\n  `update_time` bigint(32) not null default '0' comment '修改时间',\n  primary key (`category_id`),\n  key `idx_categorypid` (`category_pid`)\n) engine=innodb auto_increment=12201 default charset=utf8mb4 comment='类目表';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n后端类目约定：\n\n非叶子类目不允许挂类目属性\n\n商品发布只能发布在叶子类目上\n\n参考：电商后台设计：品类管理\n\n\n# 类目属性管理\n\n电商平台中商品数量庞大，各商品的属性又千差万别，所以设计一套可复用的属性管理功能就很重要。\n\n不同商品的属性差异化还是很大，系统设计时为了方便管理，根据用途我们将它们分类：\n\n * 基础属性：所有的商品都有的通用属性，如标题、品牌、品类等。\n * 关键属性：用来唯一确定一个spu.\n * 销售属性：影响商品销售价格/库存的属性，不同类型的的商品销售各不相同，如手机的颜色、内存等。\n * 搜索属性：参与到商品搜索中的属性，如标题、品牌、品类等\n * 特有属性：不同商品各自所独有的属性，如鞋子的使用人群、鞋面材质，手表的机芯等\n\n是否必选\n\n是否多选\n\n是否可输入\n\n是否枚举\n\n参考：电商后台设计：属性管理\n\n\n# 店铺分类\n\n最后来讲讲店铺分类。\n\n该分类由商家自己创建，有利于商家对商品归类及制定规则，方便用户更准确的找到或者搜索宝贝。一般有以下两种展示方式供大家参考。\n\n商品管理之后台类目、前台类目、店铺分类详解\n\n前台类目和店铺分类有一定的相似点，都可以按照不同业务场景将商品分门别类归纳起来，满足运营需求。\n\n但是两则差异也很明显，店铺分类最多支持两级分类，同时只支持按照商品维度进行分类。\n\n下图创建店铺分类是采用上图右侧的布局方式。先创建分类的名字，再绑定商品，商品支持同时绑定多个店铺分类。\n\n当商家发布商品的时候，选择后台分类的同时，也可以选择自己设置好的店铺分类。\n\n\n# 商品维护\n\n\n# 搜索",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"非技术问题",frontmatter:{title:"非技术问题",date:"2022-03-27T13:53:27.000Z",permalink:"/pages/5e507a/",categories:["非技术"],tags:[null]},regularPath:"/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/01.%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98.html",relativePath:"10.非技术/01.非技术问题.md",key:"v-2a52a762",path:"/pages/5e507a/",headers:[{level:2,title:"最有技术难度的项目是什么？遇到技术难点怎么解决？",slug:"最有技术难度的项目是什么-遇到技术难点怎么解决",normalizedTitle:"最有技术难度的项目是什么？遇到技术难点怎么解决？",charIndex:2},{level:2,title:"为什么要离开现在的公司？",slug:"为什么要离开现在的公司",normalizedTitle:"为什么要离开现在的公司？",charIndex:31},{level:2,title:"未来的职业规划是什么？",slug:"未来的职业规划是什么",normalizedTitle:"未来的职业规划是什么？",charIndex:48},{level:2,title:"下一份工作希望学习到什么？",slug:"下一份工作希望学习到什么",normalizedTitle:"下一份工作希望学习到什么？",charIndex:64},{level:2,title:"团队中对技术选型有冲突的话怎么解决？",slug:"团队中对技术选型有冲突的话怎么解决",normalizedTitle:"团队中对技术选型有冲突的话怎么解决？",charIndex:82},{level:2,title:"你的性格和技能上有什么缺点",slug:"你的性格和技能上有什么缺点",normalizedTitle:"你的性格和技能上有什么缺点",charIndex:105},{level:2,title:"简单描述一下自己是怎么样的人？",slug:"简单描述一下自己是怎么样的人",normalizedTitle:"简单描述一下自己是怎么样的人？",charIndex:123},{level:2,title:"学习中遇到的最大的困难是什么？",slug:"学习中遇到的最大的困难是什么",normalizedTitle:"学习中遇到的最大的困难是什么？",charIndex:143},{level:2,title:"最有成就感的项目是什么？",slug:"最有成就感的项目是什么",normalizedTitle:"最有成就感的项目是什么？",charIndex:163},{level:2,title:"团队合作沟通中遇到过什么问题？",slug:"团队合作沟通中遇到过什么问题",normalizedTitle:"团队合作沟通中遇到过什么问题？",charIndex:180},{level:2,title:"目前为止，坚持得最久一件事情是什么？",slug:"目前为止-坚持得最久一件事情是什么",normalizedTitle:"目前为止，坚持得最久一件事情是什么？",charIndex:200},{level:2,title:"能接受多大强度的加班？",slug:"能接受多大强度的加班",normalizedTitle:"能接受多大强度的加班？",charIndex:223},{level:2,title:"最近在看什么书吗，有没有接触过什么新技术？",slug:"最近在看什么书吗-有没有接触过什么新技术",normalizedTitle:"最近在看什么书吗，有没有接触过什么新技术？",charIndex:239}],headersStr:"最有技术难度的项目是什么？遇到技术难点怎么解决？ 为什么要离开现在的公司？ 未来的职业规划是什么？ 下一份工作希望学习到什么？ 团队中对技术选型有冲突的话怎么解决？ 你的性格和技能上有什么缺点 简单描述一下自己是怎么样的人？ 学习中遇到的最大的困难是什么？ 最有成就感的项目是什么？ 团队合作沟通中遇到过什么问题？ 目前为止，坚持得最久一件事情是什么？ 能接受多大强度的加班？ 最近在看什么书吗，有没有接触过什么新技术？",content:"# 最有技术难度的项目是什么？遇到技术难点怎么解决？\n\n\n# 为什么要离开现在的公司？\n\n\n# 未来的职业规划是什么？\n\n\n# 下一份工作希望学习到什么？\n\n\n# 团队中对技术选型有冲突的话怎么解决？\n\n\n# 你的性格和技能上有什么缺点\n\n\n# 简单描述一下自己是怎么样的人？\n\n\n# 学习中遇到的最大的困难是什么？\n\n\n# 最有成就感的项目是什么？\n\n\n# 团队合作沟通中遇到过什么问题？\n\n\n# 目前为止，坚持得最久一件事情是什么？\n\n\n# 能接受多大强度的加班？\n\n\n# 最近在看什么书吗，有没有接触过什么新技术？",normalizedContent:"# 最有技术难度的项目是什么？遇到技术难点怎么解决？\n\n\n# 为什么要离开现在的公司？\n\n\n# 未来的职业规划是什么？\n\n\n# 下一份工作希望学习到什么？\n\n\n# 团队中对技术选型有冲突的话怎么解决？\n\n\n# 你的性格和技能上有什么缺点\n\n\n# 简单描述一下自己是怎么样的人？\n\n\n# 学习中遇到的最大的困难是什么？\n\n\n# 最有成就感的项目是什么？\n\n\n# 团队合作沟通中遇到过什么问题？\n\n\n# 目前为止，坚持得最久一件事情是什么？\n\n\n# 能接受多大强度的加班？\n\n\n# 最近在看什么书吗，有没有接触过什么新技术？",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"如何设计定时任务系统",frontmatter:{title:"如何设计定时任务系统",date:"2022-11-10T23:01:57.000Z",permalink:"/pages/d01475/",categories:["系统设计"],tags:[null]},regularPath:"/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/023.%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F.html",relativePath:"08.系统设计/023.如何设计定时任务系统.md",key:"v-00dfea7c",path:"/pages/d01475/",headers:[{level:2,title:"1 Quartz",slug:"_1-quartz",normalizedTitle:"1 quartz",charIndex:2},{level:2,title:"2 分布式锁模式",slug:"_2-分布式锁模式",normalizedTitle:"2 分布式锁模式",charIndex:887},{level:2,title:"3 ElasticJob-Lite 框架",slug:"_3-elasticjob-lite-框架",normalizedTitle:"3 elasticjob-lite 框架",charIndex:2219},{level:2,title:"4 中心化流派",slug:"_4-中心化流派",normalizedTitle:"4 中心化流派",charIndex:3321},{level:3,title:"4.1 MQ模式",slug:"_4-1-mq模式",normalizedTitle:"4.1 mq模式",charIndex:3430},{level:3,title:"4.2 XXL-JOB",slug:"_4-2-xxl-job",normalizedTitle:"4.2 xxl-job",charIndex:3640},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5040}],headersStr:"1 Quartz 2 分布式锁模式 3 ElasticJob-Lite 框架 4 中心化流派 4.1 MQ模式 4.2 XXL-JOB 参考",content:'# 1 Quartz\n\nQuartz是一款Java开源任务调度框架，也是很多Java工程师接触任务调度的起点。\n\n下图显示了任务调度的整体流程：\n\nQuartz的核心是三个组件。\n\n * 任务：Job 用于表示被调度的任务；\n * 触发器：Trigger 定义调度时间的元素，即按照什么时间规则去执行任务。一个Job可以被多个Trigger关联，但是一个Trigger 只能关联一个Job；\n * 调度器 ：工厂类创建Scheduler，根据触发器定义的时间规则调度任务。\n\n\n\n上图代码中Quartz 的JobStore是 RAMJobStore，Trigger 和 Job 存储在内存中。\n\n执行任务调度的核心类是 QuartzSchedulerThread 。\n\n\n\n 1. 调度线程从JobStore中获取需要执行的的触发器列表，并修改触发器的状态；\n 2. Fire触发器，修改触发器信息(下次执行触发器的时间，以及触发器状态），并存储起来。\n 3. 最后创建具体的执行任务对象，通过worker线程池执行任务。\n\n接下来再聊聊 Quartz 的集群部署方案。\n\nQuartz的集群部署方案，需要针对不同的数据库类型(MySQL , ORACLE) 在数据库实例上创建Quartz表，JobStore是: JobStoreSupport 。\n\n这种方案是分布式的，没有负责集中管理的节点，而是利用数据库行级锁的方式来实现集群环境下的并发控制。\n\nscheduler实例在集群模式下首先获取{0}LOCKS表中的行锁，Mysql 获取行锁的语句：\n\n\n\n{0}会替换为配置文件默认配置的QRTZ_。sched_name为应用集群的实例名，lock_name就是行级锁名。Quartz主要有两个行级锁触发器访问锁 (TRIGGER_ACCESS) 和 状态访问锁（STATE_ACCESS）。\n\n\n\n这个架构解决了任务的分布式调度问题，同一个任务只能有一个节点运行，其他节点将不执行任务，当碰到大量短任务时，各个节点频繁的竞争数据库锁，节点越多性能就会越差。\n\n\n# 2 分布式锁模式\n\nQuartz的集群模式可以水平扩展，也可以分布式调度，但需要业务方在数据库中添加对应的表，有一定的强侵入性。\n\n有不少研发同学为了避免这种侵入性，也探索出分布式锁模式。\n\n业务场景：电商项目，用户下单后一段时间没有付款，系统就会在超时后关闭该订单。\n\n通常我们会做一个定时任务每两分钟来检查前半小时的订单，将没有付款的订单列表查询出来，然后对订单中的商品进行库存的恢复，然后将该订单设置为无效。\n\n我们使用Spring Schedule的方式做一个定时任务。\n\n@Scheduled(cron = "0 */2 * * * ? ")\npublic void doTask() {\n   log.info("定时任务启动");\n   //执行关闭订单的操作\n   orderService.closeExpireUnpayOrders();\n   log.info("定时任务结束");\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在单服务器运行正常，考虑到高可用，业务量激增，架构会演进成集群模式，在同一时刻有多个服务执行一个定时任务，有可能会导致业务紊乱。\n\n解决方案是在任务执行的时候，使用Redis 分布式锁来解决这类问题。\n\n@Scheduled(cron = "0 */2 * * * ? ")\npublic void doTask() {\n    log.info("定时任务启动");\n    String lockName = "closeExpireUnpayOrdersLock";\n    RedisLock redisLock = redisClient.getLock(lockName);\n    //尝试加锁，最多等待3秒，上锁以后5分钟自动解锁\n    boolean locked = redisLock.tryLock(3, 300, TimeUnit.SECONDS);\n    if(!locked){\n        log.info("没有获得分布式锁:{}" , lockName);\n        return;\n    }\n    try{\n       //执行关闭订单的操作\n       orderService.closeExpireUnpayOrders();\n    } finally {\n       redisLock.unlock();\n    }\n    log.info("定时任务结束");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\nRedis的读写性能极好，分布式锁也比Quartz数据库行级锁更轻量级。当然Redis锁也可以替换成Zookeeper锁，也是同样的机制。\n\n在小型项目中，使用：定时任务框架（Quartz/Spring Schedule）和 分布式锁（redis/zookeeper）有不错的效果。\n\n但是呢？我们可以发现这种组合有两个问题：\n\n 1. 定时任务在分布式场景下有空跑的情况，而且任务也无法做到分片；\n 2. 要想手工触发任务，必须添加额外的代码才能完成。\n\n\n# 3 ElasticJob-Lite 框架\n\nElasticJob-Lite 定位为轻量级无中心化解决方案，使用 jar 的形式提供分布式任务的协调服务。\n\n应用内部定义任务类，实现SimpleJob接口，编写自己任务的实际业务流程即可。\n\npublic class MyElasticJob implements SimpleJob {\n    @Override\n    public void execute(ShardingContext context) {\n        switch (context.getShardingItem()) {\n            case 0:\n                // do something by sharding item 0\n                break;\n            case 1:\n                // do something by sharding item 1\n                break;\n            case 2:\n                // do something by sharding item 2\n                break;\n            // case n: ...\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n举例：应用A有五个任务需要执行，分别是A，B，C，D，E。任务E需要分成四个子任务，应用部署在两台机器上。\n\n\n\n应用A在启动后， 5个任务通过 Zookeeper 协调后被分配到两台机器上，通过Quartz Scheduler 分开执行不同的任务。\n\nElasticJob 从本质上来讲 ，底层任务调度还是通过 Quartz ，相比Redis分布式锁 或者 Quartz 分布式部署 ，它的优势在于可以依赖 Zookeeper 这个大杀器 ，将任务通过负载均衡算法分配给应用内的 Quartz Scheduler容器。\n\n从使用者的角度来讲，是非常简单易用的。但从架构来看，调度器和执行器依然在同一个应用方JVM内，而且容器在启动后，依然需要做负载均衡。应用假如频繁的重启，不断的去选主，对分片做负载均衡，这些都是相对比较重的操作。\n\nElasticJob 的控制台通过读取注册中心数据展现作业状态，更新注册中心数据修改全局任务配置。从一个任务调度平台的角度来看，控制台功能还是偏孱弱的。\n\n\n# 4 中心化流派\n\n中心化的原理是：把调度和任务执行，隔离成两个部分：调度中心和执行器。调度中心模块只需要负责任务调度属性，触发调度命令。执行器接收调度命令，去执行具体的业务逻辑，而且两者都可以进行分布式扩容。\n\n\n# 4.1 MQ模式\n\n先谈谈我在艺龙促销团队接触的第一种中心化架构。\n\n\n\n调度中心依赖Quartz集群模式，当任务调度时候，发送消息到RabbitMQ 。业务应用收到任务消息后，消费任务信息。\n\n这种模型充分利用了MQ解耦的特性，调度中心发送任务，应用方作为执行器的角色，接收任务并执行。\n\n但这种设计强依赖消息队列，可扩展性和功能，系统负载都和消息队列有极大的关联。这种架构设计需要架构师对消息队列非常熟悉。\n\n\n# 4.2 XXL-JOB\n\n> XXL-JOB 是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。\n\nxxl-job 2.3.0架构图\n\n我们重点剖析下架构图 ：\n\n▍ 网络通讯 server-worker 模型\n\n\n\n调度中心和执行器 两个模块之间通讯是 server-worker 模式。调度中心本身就是一个SpringBoot 工程，启动会监听8080端口。\n\n执行器启动后，会启动内置服务（ EmbedServer ）监听9994端口。这样双方都可以给对方发送命令。\n\n那调度中心如何知道执行器的地址信息呢 ？上图中，执行器会定时发送注册命令 ，这样调度中心就可以获取在线的执行器列表。\n\n通过执行器列表，就可以根据任务配置的路由策略选择节点执行任务。常见的路由策略有如下三种：\n\n * 随机节点执行：选择集群中一个可用的执行节点执行调度任务。适用场景：离线订单结算。\n\n\n\n * 广播执行：在集群中所有的执行节点分发调度任务并执行。适用场景：批量更新应用本地缓存。\n   \n   \n\n * 分片执行：按照用户自定义分片逻辑进行拆分，分发到集群中不同节点并行执行，提升资源利用效率。适用场景：海量日志统计。\n\n\n\n▍ 调度器\n\n调度器是任务调度系统里面非常核心的组件。XXL-JOB 的早期版本是依赖Quartz。\n\n但在v2.1.0版本中完全去掉了Quartz的依赖，原来需要创建的 Quartz表也替换成了自研的表。\n\n核心的调度类是：JobTriggerPoolHelper 。调用start方法后，会启动两个线程：scheduleThread 和 ringThread 。\n\n首先 scheduleThread 会定时从数据库加载需要调度的任务，这里从本质上还是基于数据库行锁保证同时只有一个调度中心节点触发任务调度。\n\nConnection conn = XxlJobAdminConfig.getAdminConfig()\n                  .getDataSource().getConnection();\nconnAutoCommit = conn.getAutoCommit();\nconn.setAutoCommit(false);\npreparedStatement = conn.prepareStatement(\n"select * from xxl_job_lock where lock_name = \'schedule_lock\' for update");\npreparedStatement.execute();\n# 触发任务调度 (伪代码)\nfor (XxlJobInfo jobInfo: scheduleList) {\n  // 省略代码\n}\n# 事务提交\nconn.commit();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n调度线程会根据任务的「下次触发时间」，采取不同的动作：\n\n\n\n已过期的任务需要立刻执行的，直接放入线程池中触发执行 ，五秒内需要执行的任务放到 ringData 对象里。\n\nringThread 启动后，定时从 ringData 对象里获取需要执行的任务列表 ，放入到线程池中触发执行。\n\n\n\n\n# 参考\n\n定时任务',normalizedContent:'# 1 quartz\n\nquartz是一款java开源任务调度框架，也是很多java工程师接触任务调度的起点。\n\n下图显示了任务调度的整体流程：\n\nquartz的核心是三个组件。\n\n * 任务：job 用于表示被调度的任务；\n * 触发器：trigger 定义调度时间的元素，即按照什么时间规则去执行任务。一个job可以被多个trigger关联，但是一个trigger 只能关联一个job；\n * 调度器 ：工厂类创建scheduler，根据触发器定义的时间规则调度任务。\n\n\n\n上图代码中quartz 的jobstore是 ramjobstore，trigger 和 job 存储在内存中。\n\n执行任务调度的核心类是 quartzschedulerthread 。\n\n\n\n 1. 调度线程从jobstore中获取需要执行的的触发器列表，并修改触发器的状态；\n 2. fire触发器，修改触发器信息(下次执行触发器的时间，以及触发器状态），并存储起来。\n 3. 最后创建具体的执行任务对象，通过worker线程池执行任务。\n\n接下来再聊聊 quartz 的集群部署方案。\n\nquartz的集群部署方案，需要针对不同的数据库类型(mysql , oracle) 在数据库实例上创建quartz表，jobstore是: jobstoresupport 。\n\n这种方案是分布式的，没有负责集中管理的节点，而是利用数据库行级锁的方式来实现集群环境下的并发控制。\n\nscheduler实例在集群模式下首先获取{0}locks表中的行锁，mysql 获取行锁的语句：\n\n\n\n{0}会替换为配置文件默认配置的qrtz_。sched_name为应用集群的实例名，lock_name就是行级锁名。quartz主要有两个行级锁触发器访问锁 (trigger_access) 和 状态访问锁（state_access）。\n\n\n\n这个架构解决了任务的分布式调度问题，同一个任务只能有一个节点运行，其他节点将不执行任务，当碰到大量短任务时，各个节点频繁的竞争数据库锁，节点越多性能就会越差。\n\n\n# 2 分布式锁模式\n\nquartz的集群模式可以水平扩展，也可以分布式调度，但需要业务方在数据库中添加对应的表，有一定的强侵入性。\n\n有不少研发同学为了避免这种侵入性，也探索出分布式锁模式。\n\n业务场景：电商项目，用户下单后一段时间没有付款，系统就会在超时后关闭该订单。\n\n通常我们会做一个定时任务每两分钟来检查前半小时的订单，将没有付款的订单列表查询出来，然后对订单中的商品进行库存的恢复，然后将该订单设置为无效。\n\n我们使用spring schedule的方式做一个定时任务。\n\n@scheduled(cron = "0 */2 * * * ? ")\npublic void dotask() {\n   log.info("定时任务启动");\n   //执行关闭订单的操作\n   orderservice.closeexpireunpayorders();\n   log.info("定时任务结束");\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在单服务器运行正常，考虑到高可用，业务量激增，架构会演进成集群模式，在同一时刻有多个服务执行一个定时任务，有可能会导致业务紊乱。\n\n解决方案是在任务执行的时候，使用redis 分布式锁来解决这类问题。\n\n@scheduled(cron = "0 */2 * * * ? ")\npublic void dotask() {\n    log.info("定时任务启动");\n    string lockname = "closeexpireunpayorderslock";\n    redislock redislock = redisclient.getlock(lockname);\n    //尝试加锁，最多等待3秒，上锁以后5分钟自动解锁\n    boolean locked = redislock.trylock(3, 300, timeunit.seconds);\n    if(!locked){\n        log.info("没有获得分布式锁:{}" , lockname);\n        return;\n    }\n    try{\n       //执行关闭订单的操作\n       orderservice.closeexpireunpayorders();\n    } finally {\n       redislock.unlock();\n    }\n    log.info("定时任务结束");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\nredis的读写性能极好，分布式锁也比quartz数据库行级锁更轻量级。当然redis锁也可以替换成zookeeper锁，也是同样的机制。\n\n在小型项目中，使用：定时任务框架（quartz/spring schedule）和 分布式锁（redis/zookeeper）有不错的效果。\n\n但是呢？我们可以发现这种组合有两个问题：\n\n 1. 定时任务在分布式场景下有空跑的情况，而且任务也无法做到分片；\n 2. 要想手工触发任务，必须添加额外的代码才能完成。\n\n\n# 3 elasticjob-lite 框架\n\nelasticjob-lite 定位为轻量级无中心化解决方案，使用 jar 的形式提供分布式任务的协调服务。\n\n应用内部定义任务类，实现simplejob接口，编写自己任务的实际业务流程即可。\n\npublic class myelasticjob implements simplejob {\n    @override\n    public void execute(shardingcontext context) {\n        switch (context.getshardingitem()) {\n            case 0:\n                // do something by sharding item 0\n                break;\n            case 1:\n                // do something by sharding item 1\n                break;\n            case 2:\n                // do something by sharding item 2\n                break;\n            // case n: ...\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n举例：应用a有五个任务需要执行，分别是a，b，c，d，e。任务e需要分成四个子任务，应用部署在两台机器上。\n\n\n\n应用a在启动后， 5个任务通过 zookeeper 协调后被分配到两台机器上，通过quartz scheduler 分开执行不同的任务。\n\nelasticjob 从本质上来讲 ，底层任务调度还是通过 quartz ，相比redis分布式锁 或者 quartz 分布式部署 ，它的优势在于可以依赖 zookeeper 这个大杀器 ，将任务通过负载均衡算法分配给应用内的 quartz scheduler容器。\n\n从使用者的角度来讲，是非常简单易用的。但从架构来看，调度器和执行器依然在同一个应用方jvm内，而且容器在启动后，依然需要做负载均衡。应用假如频繁的重启，不断的去选主，对分片做负载均衡，这些都是相对比较重的操作。\n\nelasticjob 的控制台通过读取注册中心数据展现作业状态，更新注册中心数据修改全局任务配置。从一个任务调度平台的角度来看，控制台功能还是偏孱弱的。\n\n\n# 4 中心化流派\n\n中心化的原理是：把调度和任务执行，隔离成两个部分：调度中心和执行器。调度中心模块只需要负责任务调度属性，触发调度命令。执行器接收调度命令，去执行具体的业务逻辑，而且两者都可以进行分布式扩容。\n\n\n# 4.1 mq模式\n\n先谈谈我在艺龙促销团队接触的第一种中心化架构。\n\n\n\n调度中心依赖quartz集群模式，当任务调度时候，发送消息到rabbitmq 。业务应用收到任务消息后，消费任务信息。\n\n这种模型充分利用了mq解耦的特性，调度中心发送任务，应用方作为执行器的角色，接收任务并执行。\n\n但这种设计强依赖消息队列，可扩展性和功能，系统负载都和消息队列有极大的关联。这种架构设计需要架构师对消息队列非常熟悉。\n\n\n# 4.2 xxl-job\n\n> xxl-job 是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。\n\nxxl-job 2.3.0架构图\n\n我们重点剖析下架构图 ：\n\n▍ 网络通讯 server-worker 模型\n\n\n\n调度中心和执行器 两个模块之间通讯是 server-worker 模式。调度中心本身就是一个springboot 工程，启动会监听8080端口。\n\n执行器启动后，会启动内置服务（ embedserver ）监听9994端口。这样双方都可以给对方发送命令。\n\n那调度中心如何知道执行器的地址信息呢 ？上图中，执行器会定时发送注册命令 ，这样调度中心就可以获取在线的执行器列表。\n\n通过执行器列表，就可以根据任务配置的路由策略选择节点执行任务。常见的路由策略有如下三种：\n\n * 随机节点执行：选择集群中一个可用的执行节点执行调度任务。适用场景：离线订单结算。\n\n\n\n * 广播执行：在集群中所有的执行节点分发调度任务并执行。适用场景：批量更新应用本地缓存。\n   \n   \n\n * 分片执行：按照用户自定义分片逻辑进行拆分，分发到集群中不同节点并行执行，提升资源利用效率。适用场景：海量日志统计。\n\n\n\n▍ 调度器\n\n调度器是任务调度系统里面非常核心的组件。xxl-job 的早期版本是依赖quartz。\n\n但在v2.1.0版本中完全去掉了quartz的依赖，原来需要创建的 quartz表也替换成了自研的表。\n\n核心的调度类是：jobtriggerpoolhelper 。调用start方法后，会启动两个线程：schedulethread 和 ringthread 。\n\n首先 schedulethread 会定时从数据库加载需要调度的任务，这里从本质上还是基于数据库行锁保证同时只有一个调度中心节点触发任务调度。\n\nconnection conn = xxljobadminconfig.getadminconfig()\n                  .getdatasource().getconnection();\nconnautocommit = conn.getautocommit();\nconn.setautocommit(false);\npreparedstatement = conn.preparestatement(\n"select * from xxl_job_lock where lock_name = \'schedule_lock\' for update");\npreparedstatement.execute();\n# 触发任务调度 (伪代码)\nfor (xxljobinfo jobinfo: schedulelist) {\n  // 省略代码\n}\n# 事务提交\nconn.commit();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n调度线程会根据任务的「下次触发时间」，采取不同的动作：\n\n\n\n已过期的任务需要立刻执行的，直接放入线程池中触发执行 ，五秒内需要执行的任务放到 ringdata 对象里。\n\nringthread 启动后，定时从 ringdata 对象里获取需要执行的任务列表 ，放入到线程池中触发执行。\n\n\n\n\n# 参考\n\n定时任务',charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"如何提升技术水平？",frontmatter:{title:"如何提升技术水平？",date:"2022-12-09T19:59:10.000Z",permalink:"/pages/c7084e/",categories:["非技术"],tags:[null]},regularPath:"/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/04.%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF%E6%B0%B4%E5%B9%B3%EF%BC%9F.html",relativePath:"10.非技术/04.如何提升技术水平？.md",key:"v-70bb01cc",path:"/pages/c7084e/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:167},{level:2,title:"大部分人在为懒惰找借口",slug:"大部分人在为懒惰找借口",normalizedTitle:"大部分人在为懒惰找借口",charIndex:364},{level:4,title:"1. 没时间是最大的借口",slug:"_1-没时间是最大的借口",normalizedTitle:"1. 没时间是最大的借口",charIndex:458},{level:4,title:"2. 我做的工作QPS不太高、数据量不太大，不像xxx业务，很锻炼人",slug:"_2-我做的工作qps不太高、数据量不太大-不像xxx业务-很锻炼人",normalizedTitle:"2. 我做的工作qps不太高、数据量不太大，不像xxx业务，很锻炼人",charIndex:639},{level:4,title:"3. 公司的技术培训、技术分享太少了",slug:"_3-公司的技术培训、技术分享太少了",normalizedTitle:"3. 公司的技术培训、技术分享太少了",charIndex:739},{level:4,title:"4. 那不是我该干的，那是前端的活、那是运维的活、那是DBA的活、那是xxx的活",slug:"_4-那不是我该干的-那是前端的活、那是运维的活、那是dba的活、那是xxx的活",normalizedTitle:"4. 那不是我该干的，那是前端的活、那是运维的活、那是dba的活、那是xxx的活",charIndex:870},{level:4,title:"5. 你们能不能把需求想的特别清楚了再来找我",slug:"_5-你们能不能把需求想的特别清楚了再来找我",normalizedTitle:"5. 你们能不能把需求想的特别清楚了再来找我",charIndex:972},{level:2,title:"转变思路、加速前进",slug:"转变思路、加速前进",normalizedTitle:"转变思路、加速前进",charIndex:1149},{level:4,title:"1. 转变思路，变被动为主动",slug:"_1-转变思路-变被动为主动",normalizedTitle:"1. 转变思路，变被动为主动",charIndex:1233},{level:4,title:"2. 从眼前工作入手，发扬极客精神，做到极致",slug:"_2-从眼前工作入手-发扬极客精神-做到极致",normalizedTitle:"2. 从眼前工作入手，发扬极客精神，做到极致",charIndex:1716},{level:4,title:"3. 查故障是个捷径",slug:"_3-查故障是个捷径",normalizedTitle:"3. 查故障是个捷径",charIndex:2874},{level:4,title:"4. 思考、思考、再思考",slug:"_4-思考、思考、再思考",normalizedTitle:"4. 思考、思考、再思考",charIndex:3278},{level:4,title:"5. 工作上下游全部门儿清",slug:"_5-工作上下游全部门儿清",normalizedTitle:"5. 工作上下游全部门儿清",charIndex:4105},{level:4,title:"6. 只要跟你相关，你就是Owner",slug:"_6-只要跟你相关-你就是owner",normalizedTitle:"6. 只要跟你相关，你就是owner",charIndex:4625},{level:4,title:"7. 全面了解业务，深入理解需求",slug:"_7-全面了解业务-深入理解需求",normalizedTitle:"7. 全面了解业务，深入理解需求",charIndex:4847},{level:4,title:"8. 利用好业余时间",slug:"_8-利用好业余时间",normalizedTitle:"8. 利用好业余时间",charIndex:5514}],headersStr:"前言 大部分人在为懒惰找借口 1. 没时间是最大的借口 2. 我做的工作QPS不太高、数据量不太大，不像xxx业务，很锻炼人 3. 公司的技术培训、技术分享太少了 4. 那不是我该干的，那是前端的活、那是运维的活、那是DBA的活、那是xxx的活 5. 你们能不能把需求想的特别清楚了再来找我 转变思路、加速前进 1. 转变思路，变被动为主动 2. 从眼前工作入手，发扬极客精神，做到极致 3. 查故障是个捷径 4. 思考、思考、再思考 5. 工作上下游全部门儿清 6. 只要跟你相关，你就是Owner 7. 全面了解业务，深入理解需求 8. 利用好业余时间",content:"本文主要是从笔者的经验出发，分享下对提升技术水平的看法。所谓因材施教、因地制宜，下文分享的方法不一定适合你，所以读者们取其精髓、去其糟粕吧，哪怕其中只有一两点你觉得受用，那我就很高兴了。\n\n阅读对象：本文适用于刚毕业不久的新人、知识面较窄的工程同学、能胜任目前工作但感觉无挑战的同学、忙于工作感觉自己没有时间提升的同学等等。\n\n\n# 前言\n\n还记得2008年，刚参加工作时，啥都不会，一张白纸，一问三不知，一点点慢慢摸索、研究，那段时光很幸福，能感受到自己每天都在进步，每天都会学到新的知识。也曾非常苦闷，思索如何进一步提升自己的技术水平呢？到后来，技术上一次又一次遇到瓶颈，再突破瓶颈，并没有因为一次次的突破而感觉满足，反倒越来越感觉自己会的技术太少，更要虚心地学习。我总结出了一些提升技术水平的方法，下面一一分享。\n\n\n# 大部分人在为懒惰找借口\n\n有时，技术同学之间交流：过去一年，你觉得自己有哪些进步呀？经常会听到这样的回答：需求太多，工作太忙，感觉自己没啥大的进步。我们会听到各种各样的理由，比如：\n\n# 1. 没时间是最大的借口\n\n没时间吃早饭、没时间运动、没时间回去看望亲人、没时间去Review代码、没时间去调查线上Bug。。。这都是最常用的借口。再或者：等忙过了这一阵我就怎么样怎么样。最终结果一般是永远没有去落实。 时间其实是最公平的，每人每天24小时，不多不少。不是没时间，而是没选择而已。因为你潜意识里认为这事不重要，所以就去做了其他更重要的事。\n\n# 2. 我做的工作QPS不太高、数据量不太大，不像xxx业务，很锻炼人\n\n误区：工作挑战不够，每份工作都有自己的挑战，都有死掉N多脑细胞就难以解决的问题。反思下：你现在是否把本职工作做到了最佳？\n\n# 3. 公司的技术培训、技术分享太少了\n\n总有人希望技术培训、分享来提升知识，这是应试教育造成的后遗症，大家习惯了老师把知识灌输到脑子里，而不喜欢自己主动去获取。其实技术分享等，只是穿针引线，大致给你介绍某个东西是什么样的，要深入理解还得靠实践，以赛代练。\n\n# 4. 那不是我该干的，那是前端的活、那是运维的活、那是DBA的活、那是xxx的活\n\n其实你就错失了掌握前端、运维、数据库等知识的大好机会。我们不一定要懂得如何去操作，但是要大致知道这些事该怎么干。\n\n# 5. 你们能不能把需求想的特别清楚了再来找我\n\n技术同学都喜欢清楚的需求，然后自己写代码去实现，但每个需求都清晰是理想状态。提需求的同学又不知道技术细节，他怎么可能每个需求都特别清晰、合理。需求只是手段，不是目的，需求背后要解决的问题才是核心。技术同学应该走出舒适区，更多去了解业务，从而站在技术的角度，提出更好的解决方案，而不是仅仅实现需求。\n\n\n# 转变思路、加速前进\n\n上面列了很多常用的借口，这些都在制约着你的发展。绝大部分都是思想上的懒惰，待在舒适区，不愿意走出去。那要怎么做才能快速提升自己技术能力呢？\n\n# 1. 转变思路，变被动为主动\n\n你要主动去学习，不要等别人，不要被动学习，思想上首先要转变。青春就那么几年，毕业后的四五年是飞速发展的黄金时期。 需要有些好奇心，直播怎么做的？视频是怎么做的？推荐又是怎么回事？抱着对这些事的好奇心，然后主动去了解，能获取大量知识。 看如下两行代码：\n\nMap<Long, UserCache> userCacheMap = userCacheService.getByIds(uids);\nMap<Long, Photo> photoMap = photoService.getByIdsFailFast(photoIds, PhotoGetTimeout.DEFAULT);\n\n\n1\n2\n\n\n这两行代码，我大钢厂的Java工程师肯定写过无数遍，熟的不能再熟了。但是你了解过如何实现的吗？如果要计算QPS，这两接口的QPS大的吓死你。这么高的QPS、这么大的数据量，是如何做到的呢？方案是什么，流程是什么。如果没有深入去了解过，还在抱怨工作无挑战的话，那就相当于你守着金山银山却仍在哭穷。并不是真穷，而是缺少发现财富的眼睛。\n\n# 2. 从眼前工作入手，发扬极客精神，做到极致\n\n有同学经常抱怨没有时间去提升、没有提升的方向，也有些同学很主动，买了很多书来看，但是这些书跟工作关系不太大。我的建议就是：把那些跟现有工作关系不大的书通通扔掉，那是在浪费你的时间。知识如海洋，学以致用，如果学到东西没有用，那学来干嘛呢？学的东西立刻能用，才会印象深刻，从而沉淀在你的脑海中。 一个人提升的过程，其实就是不断超越昨天的你的过程。因此，最好、最快速的提升就是从现有工作入手，对自己高标准、严要求，发扬极客精神，把每行代码都吃透，每行代码都精益求精，甚至连一个空格、一个标点符号都让人挑不出毛病来。第一遍写完的代码，自己反复review，直到感觉没啥问题为止。 有同学会说：项目非常紧，我完全没有时间去反复review自己的代码。对，项目紧是一定的，并不是让你去反复review以前的代码，而是在开发新需求的过程中，就把反复review融入进去，养成一种习惯。比如开发一个功能，编码5个小时，反复review反复修改顶多多花你一小时，总共6小时，对项目不会有太大影响。并且随着时间推移，你的代码质量越来越高，review的时间会逐步减少，整体效率也会越来越高，因为第一遍就能写出漂亮的代码了。 说到极致，我们看两个例子，第一个例子：\n\nMap<Long, Integer> statisCount=new HashMap<Long, Integer>();\n\n\n1\n\n\n这是一个Map的定义，平时咱们都写了千百回了，当时看到这行代码我就给他挑了4个毛病。(1) 等号前后无空格；(2)后面的<Long, Integer>多余，写成<>即可；(3)英文全称是statistics，简称一般是stat，而不是statis，这个简称让人困惑；(4) 对于Map的命名，应该用名词，现在的 xxxCount更像是某个计数，只是一个数，并没有突出是个数据结构Map，当下文你看到statisCount.put(1, 2); 时就懵逼了，statisCount应该是++ 操作，怎么就put了呢？！因此叫 statCountMap 更恰当些。\n\n第二个例子：有同学发企业微信不喜欢用标点符号，全用空格，有时会给别人的阅读造成些困难。比如“才哥 在吗”，有时空格可能看不太清，那请问到底是 “才哥在吗？” 还是 “才哥，在吗？” 这两句话是有差别的。不是说希望大家都用标点符号，而是希望用空格的同学，要考虑下对方的阅读体验，不要造成阅读困难，如果一个空格断句有困难的话，你就多加几个空格嘛，比如4个，这样就完美了。\n\n刚才讲写代码，第二个例子是沟通，希望将极客精神发扬到工作中的方方面面，大到做项目、小到说每一句话，都要求精益求精，整个人会给人一种焕然一新的感觉。\n\n# 3. 查故障是个捷径\n\n咱们每天邮件报警上百封，有时也会碰到线上问题，比如CPU较高、流量较高、频繁Full GC、RpcMonitor报警，也会遇到各种Exception，等等。这些其实都是快速提升技术能力的捷径。 查线上问题，会逼你了解上下游业务，逼你深入下去，而不是停留在代码表面，逼你使用各种工具去分析，最终一定会获益良多。 当然，阻碍你进步的拦路虎也会有很多，比如：这个报警是其他小组的，负责人不是我，不关我事，忽略；问题是什么，没查出来，我也不知道，先用其他方式绕过吧，以后再说；DB查的慢是DBA的责任，得找DBA解决，不该我去查，等等等等。这些都是给自己找的借口，应该跨越系统边界，刨根问底，把问题彻底找出来，不找到真相誓不罢休。 另外：运营或者审核同学有时会在群里反馈问题，好多同学的第一反应是：躲！把这些问题当做没看见，或者觉得不是我负责就不管了。其实这都是在错失技术提升的良机！\n\n# 4. 思考、思考、再思考\n\n如果你去澡堂，大家都把衣服扒了，虽有高矮肥瘦，但都差距不大。人和人之间最大的差距，在于脖子以上的部分，也就是你的大脑。训练大脑就只有一种方式：思考。 思考什么内容呢？真正的需求到底是啥，他们要达到什么目的？我的技术方案是最优的吗，有没有改进空间，有没有哪个细节考虑不周，模型的建立上是否合理，是否符合生活中的模型，有没有杀马特的设计？我怎么去描述这个问题，用什么词语最恰当？我之前跟人沟通，有没有用词不当的地方，有没有沟通不到位的地方，做完事后我周知相关人了吗？这几个API的底层实现是什么样的，会不会有性能瓶颈？如果服务挂了一台怎么办，如果量翻了10倍，能抗住吗，如果抗不住我该如何改进呢？等等等等 吾日三省吾身才能不断进步。 咱们又来看个例子：\n\nif (hashSet.contains(userId)) {\n    // 允许访问\n} else {\n    // 不允许访问\n}\n\n\n1\n2\n3\n4\n5\n\n\n假设你写了上面的几行代码，那如何描述你做了什么事呢？面对不同的人，比如技术、产品、运营、行政、七大姑八大姨、路边摊烤冷面师傅、爷爷奶奶等等，语言该如何表达呢？\n\n大部分技术同学不管面前是什么人，只会一种解释：我判断用户是否在hashSet中，如果在就放过，如果不在就不让访问。如果对方是技术、产品能听懂，其他人估计就一脸懵逼，觉得这个技术同学很难交流了。\n\n这其实体现一个人对这件事的理解和抽象能力，只有不断思考才能站位不同角度去看待问题。\n\n你可以这么解释：(1) 我做了个白名单，只有白名单中的用户才能访问；(2)我做了个防火墙，只有可信任的人才允许访问，坏蛋或者陌生人拒之门外；(3) 我们对系统的安全性进行了一次升级，必须先授权后访问；(4) 我们对访问权限进行了更严格的控制；(5) 我开发了个电子门卫，门卫认识的人才让进；(6) 我相当于聘请了有个保安，对访客的身份进行严格验证。。。等等。\n\n# 5. 工作上下游全部门儿清\n\n当你对现有的工作了如指掌后，接下来就是要扩充知识广度了。而广度的提升会反过来让你的知识深度更深。方法就是：把工作相关的上下游业务全部理清。 有两个方向：1. 横向，2.纵向 横向是指业务的上下游，也就是数据流的上下游。举例说明：某同学做了热门一审相关的事，上下游就包括：视频如何产生、如何进入推荐系统、推荐系统如何推到热门、再到满足什么条件进入admin审核、审核完后如何通知推荐组、审核不过最后如何从热门中下掉，审核通过后如何在热门获得展示，等等。就是从数据的产生到消费，完整的闭环是什么样的？！最好全部捋清楚，这样，你就不仅仅是在做admin热门一审的需求，而是通过一个需求，把整条业务线都搞清楚，从而在技术方案设计上，就能更好地设计方案了。同时，你的技术知识又得到了一次升华。\n\n纵向是指当前业务运行环境的深入。还是以热门一审为例，纵向包括了：热门一审相关的服务部署在什么机房、数据库&runner等部署在哪里、审核人员办公区在哪里、用什么浏览器访问后台、当地办公区网络是哪家运营商的、访问后台页面走哪条线路、通过哪个nginx转发过来等等等等。纵向的梳理对于业务出问题后，能第一时间准确地排查。\n\n# 6. 只要跟你相关，你就是Owner\n\n跟你相关的工作，你需要积极主动地去推动，去沟通其他团队，跟进进度，排除阻碍，从而更好地把自己的那部分工作完成。 大部分技术同学的态度是：那谁接口还没给我，我没法搞。但对方做到什么程度了，什么时候能给，大部分人就一问三不知了。 这样其实不好。你完全可以承担起PM的职责，去跟进相关的事宜，这样会让人觉得你特别靠谱、对你特别放心，同时你也锻炼了沟通协调能力，以及增进了对方业务的了解程度，开阔了眼界。\n\n# 7. 全面了解业务，深入理解需求\n\n技术是为业务服务的，如果你做的业务没人用，即使代码写的再好，价值恐怕也不会大；如果用的人特别多，不管技术上优劣，价值一定不小。 同样，我们要对自己的青春负责，所以，如果你只爱技术不爱业务，不关注业务是否合理，不帮着优化业务，那么可以说：你对自己的青春不太负责。一个公司只有极少数人才只关心架构不关心业务。 因此，技术同学需要了解你做的页面，都哪些人在用，他们怎么用，有哪些用的爽、哪些用的不爽，不爽的如何改进？你需要了解用你页面的人，他们从上班到下班都在干什么，遇事的处理流程大概是什么样的？ 深入了解业务后，对于很多需求，你就有更深入的理解，从而在做需求时，能更好地设计架构，未来有哪些扩展，也能预见了。\n\n人做事一定是这样的：遇到一个问题，着手解决；此时如果直接去找技术同学，请教解决问题的方案，一般会被怼：我忙着呢，你连做啥都不知道，让我怎么做？！ 所以，人一定会先想个解决方案，也就是所谓的需求，再把这个解决方案提给技术，那么问题来了：请问这个解决方案是最优解吗？如果你不了解业务，傻乎乎就做了，后来发现不是最优解，结果又推翻重构，浪费人力，还在感慨程序员命苦：产品一句话技术十行泪啊。 怪谁？！只能怪你自己不懂业务。 因此，技术同学在面对需求时，仔细询问，问清楚需求背后要解决的问题，再来审视需求的合理性，如果你也同意，那就搞起；如果你不同意，你有更好的解决方案，立刻提出来，大家商量着来，把问题一起解掉。 在这个过程中，你已经从一个普通工程师迈向高级工程师、甚至技术经理迈进了。\n\n# 8. 利用好业余时间\n\n每天就24小时，金三胖再牛逼，每天最多工作24小时，不可能工作25小时。对于刚毕业不久的同学，由于处在高速发展期，建议你把业余时间都利用起来，除了吃喝玩乐，业余时间建议你给自己充电。投资黄金、股票、基金、期货等等，再好的投资品不如把时间都投资到自己身上，因为这个不会亏损，并且投资的复利效果会非常明显。除了技术，建议也阅读些其他著作，比如经济、历史、哲学、心理学等等。 对于毕业时间较长的同学，建议业余时间多思考，把所有问题分解的特别细；对于技术方面，更要站在宏观的角度来看待问题。\n\n好了，暂时想到的就这么多，就先写这么多吧！回头有更多想法，我再补充上去！",normalizedContent:"本文主要是从笔者的经验出发，分享下对提升技术水平的看法。所谓因材施教、因地制宜，下文分享的方法不一定适合你，所以读者们取其精髓、去其糟粕吧，哪怕其中只有一两点你觉得受用，那我就很高兴了。\n\n阅读对象：本文适用于刚毕业不久的新人、知识面较窄的工程同学、能胜任目前工作但感觉无挑战的同学、忙于工作感觉自己没有时间提升的同学等等。\n\n\n# 前言\n\n还记得2008年，刚参加工作时，啥都不会，一张白纸，一问三不知，一点点慢慢摸索、研究，那段时光很幸福，能感受到自己每天都在进步，每天都会学到新的知识。也曾非常苦闷，思索如何进一步提升自己的技术水平呢？到后来，技术上一次又一次遇到瓶颈，再突破瓶颈，并没有因为一次次的突破而感觉满足，反倒越来越感觉自己会的技术太少，更要虚心地学习。我总结出了一些提升技术水平的方法，下面一一分享。\n\n\n# 大部分人在为懒惰找借口\n\n有时，技术同学之间交流：过去一年，你觉得自己有哪些进步呀？经常会听到这样的回答：需求太多，工作太忙，感觉自己没啥大的进步。我们会听到各种各样的理由，比如：\n\n# 1. 没时间是最大的借口\n\n没时间吃早饭、没时间运动、没时间回去看望亲人、没时间去review代码、没时间去调查线上bug。。。这都是最常用的借口。再或者：等忙过了这一阵我就怎么样怎么样。最终结果一般是永远没有去落实。 时间其实是最公平的，每人每天24小时，不多不少。不是没时间，而是没选择而已。因为你潜意识里认为这事不重要，所以就去做了其他更重要的事。\n\n# 2. 我做的工作qps不太高、数据量不太大，不像xxx业务，很锻炼人\n\n误区：工作挑战不够，每份工作都有自己的挑战，都有死掉n多脑细胞就难以解决的问题。反思下：你现在是否把本职工作做到了最佳？\n\n# 3. 公司的技术培训、技术分享太少了\n\n总有人希望技术培训、分享来提升知识，这是应试教育造成的后遗症，大家习惯了老师把知识灌输到脑子里，而不喜欢自己主动去获取。其实技术分享等，只是穿针引线，大致给你介绍某个东西是什么样的，要深入理解还得靠实践，以赛代练。\n\n# 4. 那不是我该干的，那是前端的活、那是运维的活、那是dba的活、那是xxx的活\n\n其实你就错失了掌握前端、运维、数据库等知识的大好机会。我们不一定要懂得如何去操作，但是要大致知道这些事该怎么干。\n\n# 5. 你们能不能把需求想的特别清楚了再来找我\n\n技术同学都喜欢清楚的需求，然后自己写代码去实现，但每个需求都清晰是理想状态。提需求的同学又不知道技术细节，他怎么可能每个需求都特别清晰、合理。需求只是手段，不是目的，需求背后要解决的问题才是核心。技术同学应该走出舒适区，更多去了解业务，从而站在技术的角度，提出更好的解决方案，而不是仅仅实现需求。\n\n\n# 转变思路、加速前进\n\n上面列了很多常用的借口，这些都在制约着你的发展。绝大部分都是思想上的懒惰，待在舒适区，不愿意走出去。那要怎么做才能快速提升自己技术能力呢？\n\n# 1. 转变思路，变被动为主动\n\n你要主动去学习，不要等别人，不要被动学习，思想上首先要转变。青春就那么几年，毕业后的四五年是飞速发展的黄金时期。 需要有些好奇心，直播怎么做的？视频是怎么做的？推荐又是怎么回事？抱着对这些事的好奇心，然后主动去了解，能获取大量知识。 看如下两行代码：\n\nmap<long, usercache> usercachemap = usercacheservice.getbyids(uids);\nmap<long, photo> photomap = photoservice.getbyidsfailfast(photoids, photogettimeout.default);\n\n\n1\n2\n\n\n这两行代码，我大钢厂的java工程师肯定写过无数遍，熟的不能再熟了。但是你了解过如何实现的吗？如果要计算qps，这两接口的qps大的吓死你。这么高的qps、这么大的数据量，是如何做到的呢？方案是什么，流程是什么。如果没有深入去了解过，还在抱怨工作无挑战的话，那就相当于你守着金山银山却仍在哭穷。并不是真穷，而是缺少发现财富的眼睛。\n\n# 2. 从眼前工作入手，发扬极客精神，做到极致\n\n有同学经常抱怨没有时间去提升、没有提升的方向，也有些同学很主动，买了很多书来看，但是这些书跟工作关系不太大。我的建议就是：把那些跟现有工作关系不大的书通通扔掉，那是在浪费你的时间。知识如海洋，学以致用，如果学到东西没有用，那学来干嘛呢？学的东西立刻能用，才会印象深刻，从而沉淀在你的脑海中。 一个人提升的过程，其实就是不断超越昨天的你的过程。因此，最好、最快速的提升就是从现有工作入手，对自己高标准、严要求，发扬极客精神，把每行代码都吃透，每行代码都精益求精，甚至连一个空格、一个标点符号都让人挑不出毛病来。第一遍写完的代码，自己反复review，直到感觉没啥问题为止。 有同学会说：项目非常紧，我完全没有时间去反复review自己的代码。对，项目紧是一定的，并不是让你去反复review以前的代码，而是在开发新需求的过程中，就把反复review融入进去，养成一种习惯。比如开发一个功能，编码5个小时，反复review反复修改顶多多花你一小时，总共6小时，对项目不会有太大影响。并且随着时间推移，你的代码质量越来越高，review的时间会逐步减少，整体效率也会越来越高，因为第一遍就能写出漂亮的代码了。 说到极致，我们看两个例子，第一个例子：\n\nmap<long, integer> statiscount=new hashmap<long, integer>();\n\n\n1\n\n\n这是一个map的定义，平时咱们都写了千百回了，当时看到这行代码我就给他挑了4个毛病。(1) 等号前后无空格；(2)后面的<long, integer>多余，写成<>即可；(3)英文全称是statistics，简称一般是stat，而不是statis，这个简称让人困惑；(4) 对于map的命名，应该用名词，现在的 xxxcount更像是某个计数，只是一个数，并没有突出是个数据结构map，当下文你看到statiscount.put(1, 2); 时就懵逼了，statiscount应该是++ 操作，怎么就put了呢？！因此叫 statcountmap 更恰当些。\n\n第二个例子：有同学发企业微信不喜欢用标点符号，全用空格，有时会给别人的阅读造成些困难。比如“才哥 在吗”，有时空格可能看不太清，那请问到底是 “才哥在吗？” 还是 “才哥，在吗？” 这两句话是有差别的。不是说希望大家都用标点符号，而是希望用空格的同学，要考虑下对方的阅读体验，不要造成阅读困难，如果一个空格断句有困难的话，你就多加几个空格嘛，比如4个，这样就完美了。\n\n刚才讲写代码，第二个例子是沟通，希望将极客精神发扬到工作中的方方面面，大到做项目、小到说每一句话，都要求精益求精，整个人会给人一种焕然一新的感觉。\n\n# 3. 查故障是个捷径\n\n咱们每天邮件报警上百封，有时也会碰到线上问题，比如cpu较高、流量较高、频繁full gc、rpcmonitor报警，也会遇到各种exception，等等。这些其实都是快速提升技术能力的捷径。 查线上问题，会逼你了解上下游业务，逼你深入下去，而不是停留在代码表面，逼你使用各种工具去分析，最终一定会获益良多。 当然，阻碍你进步的拦路虎也会有很多，比如：这个报警是其他小组的，负责人不是我，不关我事，忽略；问题是什么，没查出来，我也不知道，先用其他方式绕过吧，以后再说；db查的慢是dba的责任，得找dba解决，不该我去查，等等等等。这些都是给自己找的借口，应该跨越系统边界，刨根问底，把问题彻底找出来，不找到真相誓不罢休。 另外：运营或者审核同学有时会在群里反馈问题，好多同学的第一反应是：躲！把这些问题当做没看见，或者觉得不是我负责就不管了。其实这都是在错失技术提升的良机！\n\n# 4. 思考、思考、再思考\n\n如果你去澡堂，大家都把衣服扒了，虽有高矮肥瘦，但都差距不大。人和人之间最大的差距，在于脖子以上的部分，也就是你的大脑。训练大脑就只有一种方式：思考。 思考什么内容呢？真正的需求到底是啥，他们要达到什么目的？我的技术方案是最优的吗，有没有改进空间，有没有哪个细节考虑不周，模型的建立上是否合理，是否符合生活中的模型，有没有杀马特的设计？我怎么去描述这个问题，用什么词语最恰当？我之前跟人沟通，有没有用词不当的地方，有没有沟通不到位的地方，做完事后我周知相关人了吗？这几个api的底层实现是什么样的，会不会有性能瓶颈？如果服务挂了一台怎么办，如果量翻了10倍，能抗住吗，如果抗不住我该如何改进呢？等等等等 吾日三省吾身才能不断进步。 咱们又来看个例子：\n\nif (hashset.contains(userid)) {\n    // 允许访问\n} else {\n    // 不允许访问\n}\n\n\n1\n2\n3\n4\n5\n\n\n假设你写了上面的几行代码，那如何描述你做了什么事呢？面对不同的人，比如技术、产品、运营、行政、七大姑八大姨、路边摊烤冷面师傅、爷爷奶奶等等，语言该如何表达呢？\n\n大部分技术同学不管面前是什么人，只会一种解释：我判断用户是否在hashset中，如果在就放过，如果不在就不让访问。如果对方是技术、产品能听懂，其他人估计就一脸懵逼，觉得这个技术同学很难交流了。\n\n这其实体现一个人对这件事的理解和抽象能力，只有不断思考才能站位不同角度去看待问题。\n\n你可以这么解释：(1) 我做了个白名单，只有白名单中的用户才能访问；(2)我做了个防火墙，只有可信任的人才允许访问，坏蛋或者陌生人拒之门外；(3) 我们对系统的安全性进行了一次升级，必须先授权后访问；(4) 我们对访问权限进行了更严格的控制；(5) 我开发了个电子门卫，门卫认识的人才让进；(6) 我相当于聘请了有个保安，对访客的身份进行严格验证。。。等等。\n\n# 5. 工作上下游全部门儿清\n\n当你对现有的工作了如指掌后，接下来就是要扩充知识广度了。而广度的提升会反过来让你的知识深度更深。方法就是：把工作相关的上下游业务全部理清。 有两个方向：1. 横向，2.纵向 横向是指业务的上下游，也就是数据流的上下游。举例说明：某同学做了热门一审相关的事，上下游就包括：视频如何产生、如何进入推荐系统、推荐系统如何推到热门、再到满足什么条件进入admin审核、审核完后如何通知推荐组、审核不过最后如何从热门中下掉，审核通过后如何在热门获得展示，等等。就是从数据的产生到消费，完整的闭环是什么样的？！最好全部捋清楚，这样，你就不仅仅是在做admin热门一审的需求，而是通过一个需求，把整条业务线都搞清楚，从而在技术方案设计上，就能更好地设计方案了。同时，你的技术知识又得到了一次升华。\n\n纵向是指当前业务运行环境的深入。还是以热门一审为例，纵向包括了：热门一审相关的服务部署在什么机房、数据库&runner等部署在哪里、审核人员办公区在哪里、用什么浏览器访问后台、当地办公区网络是哪家运营商的、访问后台页面走哪条线路、通过哪个nginx转发过来等等等等。纵向的梳理对于业务出问题后，能第一时间准确地排查。\n\n# 6. 只要跟你相关，你就是owner\n\n跟你相关的工作，你需要积极主动地去推动，去沟通其他团队，跟进进度，排除阻碍，从而更好地把自己的那部分工作完成。 大部分技术同学的态度是：那谁接口还没给我，我没法搞。但对方做到什么程度了，什么时候能给，大部分人就一问三不知了。 这样其实不好。你完全可以承担起pm的职责，去跟进相关的事宜，这样会让人觉得你特别靠谱、对你特别放心，同时你也锻炼了沟通协调能力，以及增进了对方业务的了解程度，开阔了眼界。\n\n# 7. 全面了解业务，深入理解需求\n\n技术是为业务服务的，如果你做的业务没人用，即使代码写的再好，价值恐怕也不会大；如果用的人特别多，不管技术上优劣，价值一定不小。 同样，我们要对自己的青春负责，所以，如果你只爱技术不爱业务，不关注业务是否合理，不帮着优化业务，那么可以说：你对自己的青春不太负责。一个公司只有极少数人才只关心架构不关心业务。 因此，技术同学需要了解你做的页面，都哪些人在用，他们怎么用，有哪些用的爽、哪些用的不爽，不爽的如何改进？你需要了解用你页面的人，他们从上班到下班都在干什么，遇事的处理流程大概是什么样的？ 深入了解业务后，对于很多需求，你就有更深入的理解，从而在做需求时，能更好地设计架构，未来有哪些扩展，也能预见了。\n\n人做事一定是这样的：遇到一个问题，着手解决；此时如果直接去找技术同学，请教解决问题的方案，一般会被怼：我忙着呢，你连做啥都不知道，让我怎么做？！ 所以，人一定会先想个解决方案，也就是所谓的需求，再把这个解决方案提给技术，那么问题来了：请问这个解决方案是最优解吗？如果你不了解业务，傻乎乎就做了，后来发现不是最优解，结果又推翻重构，浪费人力，还在感慨程序员命苦：产品一句话技术十行泪啊。 怪谁？！只能怪你自己不懂业务。 因此，技术同学在面对需求时，仔细询问，问清楚需求背后要解决的问题，再来审视需求的合理性，如果你也同意，那就搞起；如果你不同意，你有更好的解决方案，立刻提出来，大家商量着来，把问题一起解掉。 在这个过程中，你已经从一个普通工程师迈向高级工程师、甚至技术经理迈进了。\n\n# 8. 利用好业余时间\n\n每天就24小时，金三胖再牛逼，每天最多工作24小时，不可能工作25小时。对于刚毕业不久的同学，由于处在高速发展期，建议你把业余时间都利用起来，除了吃喝玩乐，业余时间建议你给自己充电。投资黄金、股票、基金、期货等等，再好的投资品不如把时间都投资到自己身上，因为这个不会亏损，并且投资的复利效果会非常明显。除了技术，建议也阅读些其他著作，比如经济、历史、哲学、心理学等等。 对于毕业时间较长的同学，建议业余时间多思考，把所有问题分解的特别细；对于技术方面，更要站在宏观的角度来看待问题。\n\n好了，暂时想到的就这么多，就先写这么多吧！回头有更多想法，我再补充上去！",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"上级让下级干活的4中方式",frontmatter:{title:"上级让下级干活的4中方式",date:"2022-12-09T20:00:04.000Z",permalink:"/pages/83653c/",categories:["非技术"],tags:[null]},regularPath:"/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/05.%E4%B8%8A%E7%BA%A7%E8%AE%A9%E4%B8%8B%E7%BA%A7%E5%B9%B2%E6%B4%BB%E7%9A%844%E4%B8%AD%E6%96%B9%E5%BC%8F.html",relativePath:"10.非技术/05.上级让下级干活的4中方式.md",key:"v-534e5ed0",path:"/pages/83653c/",headers:[{level:3,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:3,title:"方法一. 价值认同(推荐)",slug:"方法一-价值认同-推荐",normalizedTitle:"方法一. 价值认同(推荐)",charIndex:188},{level:3,title:"方法二. 行政命令",slug:"方法二-行政命令",normalizedTitle:"方法二. 行政命令",charIndex:630},{level:3,title:"方法三. 货币政策",slug:"方法三-货币政策",normalizedTitle:"方法三. 货币政策",charIndex:911},{level:3,title:"方法四. 人际关系",slug:"方法四-人际关系",normalizedTitle:"方法四. 人际关系",charIndex:1281}],headersStr:"前言 方法一. 价值认同(推荐) 方法二. 行政命令 方法三. 货币政策 方法四. 人际关系",content:"# 前言\n\n互联网公司提倡扁平化，人人平等，公司内禁止称呼“张总”“李总”等，也不存在官大一级压死人。下至一线员工，上至CXO，平等对话，就事论事，以德服人。实际上，互联网公司也是层级架构，但被相对弱化了。有层级，就有上级和下级之别，所谓上级，就是那个给你打绩效的人。那么上级想让下级干活，有哪些方法呢？以下是我总结的4大方法，专供为大家茶余饭后、酒桌上吹牛逼时用。\n\n\n# 方法一. 价值认同(推荐)\n\n**概念：**价值认同是指把某件事情对公司、对团队、对用户、对个人的价值说出来，说清楚做了有哪些好处，不做对公司有哪些损失，这事解决了目前存在的哪些问题，把这些价值都说出来，获得下级认可，从而全心全意去做好这件事。比如中台这事，大家都认可它的价值，所以热火朝天去推进。\n\n**适用场景：**大部分场景都适用，应该作为首选方法\n\n**优点：**上下级双方都心悦诚服，价值观一致，目标一致，能劲往一处使\n\n**缺点：**上级有时可能没把价值说清楚；\n\n下级有时格局不够，即使价值很高，可能也不认可；\n\n有些特殊情况下，价值不能明面说出来，比如做这事为了讨好普京的欢心，从而让咱们产品在俄罗斯不被Gov封杀，这种价值就不能明确说出来；\n\n有时，未来的巨大价值只有少部分人能看到，假设2012年时马爸爸让投资部门花1000万收购快手，投资部门一定反对的死去活来，现在1000亿(RMB)都买不到。\n\n以上这些情况，价值认同就会失效，就需要靠别的手段了。\n\n\n# 方法二. 行政命令\n\n**概念：**顾名思义，行政命令就是利用上级的身份发号司令，强制要求下级去做事。上级掌握了下级的绩效考核等，可以解雇不合格的下级。\n\n**适用场景：**当价值认同失效时，如果确实有很大价值，但是下级就是不理解，或者不方便跟他说理由时，适合直接下达行政命令；紧急情况来不及解释，需要快速执行，也适用；\n\n**优点：**落地快，避免了各种浪费时间的讨论、说服等\n\n**缺点：**下级容易产生逆反心理，进而产生对抗；可能出现口服心不服的情况；下级对事情可能理解不深刻，从而影响落地时的效果；若滥用，下级可能觉得不被信任，从而离职或转岗。\n\n\n# 方法三. 货币政策\n\n**概念：**货币政策的意思是上级通过货币奖励方式让下级去做事。包括但不限于加薪、加期权、绩效打高一些、发奖金、请吃饭请喝酒等等。行政命令属于威逼，货币政策属于利诱。本质上是一种货币超发行为，跟各国央行的降息、降准等货币调节手段有异曲同工之处。\n\n**使用场景：**价值认同和行政命令同时失效时，可适当采用；当一些特殊事情，需要下级做出自我牺牲但对方不愿意时，可适合采用此方法，比如出差、加班等；一些对公司作用非常大的重点项目，也适合，比如：“你要是能让国家每年给公司减税1个亿，我奖励你1000万！”；其他一些犯规犯贱不能摆到台面上的事情，也可以考虑货币激励；\n\n**优点：**疗程短，见效快，短期作用非常明显，可激励士气\n\n**缺点：**边际效益递减；易滥用；一旦开先河，后期不好缩减，容易引起不满情绪；\n\n\n# 方法四. 人际关系\n\n**概念：**所谓人际关系是指运用工作内外建立起来的交往来说服对方，可以是上下级的直接交往，也可以借助他人。\n\n**使用场景：**这个方法是不得已而为之，慎用，但当其他方法都失效时，不妨考虑下；当正常沟通陷入僵局时，借助人际关系，尤其是第三者插足，可能会有奇效；\n\n**优点：**柳暗花明又一村\n\n**缺点：**饮鸩止渴",normalizedContent:"# 前言\n\n互联网公司提倡扁平化，人人平等，公司内禁止称呼“张总”“李总”等，也不存在官大一级压死人。下至一线员工，上至cxo，平等对话，就事论事，以德服人。实际上，互联网公司也是层级架构，但被相对弱化了。有层级，就有上级和下级之别，所谓上级，就是那个给你打绩效的人。那么上级想让下级干活，有哪些方法呢？以下是我总结的4大方法，专供为大家茶余饭后、酒桌上吹牛逼时用。\n\n\n# 方法一. 价值认同(推荐)\n\n**概念：**价值认同是指把某件事情对公司、对团队、对用户、对个人的价值说出来，说清楚做了有哪些好处，不做对公司有哪些损失，这事解决了目前存在的哪些问题，把这些价值都说出来，获得下级认可，从而全心全意去做好这件事。比如中台这事，大家都认可它的价值，所以热火朝天去推进。\n\n**适用场景：**大部分场景都适用，应该作为首选方法\n\n**优点：**上下级双方都心悦诚服，价值观一致，目标一致，能劲往一处使\n\n**缺点：**上级有时可能没把价值说清楚；\n\n下级有时格局不够，即使价值很高，可能也不认可；\n\n有些特殊情况下，价值不能明面说出来，比如做这事为了讨好普京的欢心，从而让咱们产品在俄罗斯不被gov封杀，这种价值就不能明确说出来；\n\n有时，未来的巨大价值只有少部分人能看到，假设2012年时马爸爸让投资部门花1000万收购快手，投资部门一定反对的死去活来，现在1000亿(rmb)都买不到。\n\n以上这些情况，价值认同就会失效，就需要靠别的手段了。\n\n\n# 方法二. 行政命令\n\n**概念：**顾名思义，行政命令就是利用上级的身份发号司令，强制要求下级去做事。上级掌握了下级的绩效考核等，可以解雇不合格的下级。\n\n**适用场景：**当价值认同失效时，如果确实有很大价值，但是下级就是不理解，或者不方便跟他说理由时，适合直接下达行政命令；紧急情况来不及解释，需要快速执行，也适用；\n\n**优点：**落地快，避免了各种浪费时间的讨论、说服等\n\n**缺点：**下级容易产生逆反心理，进而产生对抗；可能出现口服心不服的情况；下级对事情可能理解不深刻，从而影响落地时的效果；若滥用，下级可能觉得不被信任，从而离职或转岗。\n\n\n# 方法三. 货币政策\n\n**概念：**货币政策的意思是上级通过货币奖励方式让下级去做事。包括但不限于加薪、加期权、绩效打高一些、发奖金、请吃饭请喝酒等等。行政命令属于威逼，货币政策属于利诱。本质上是一种货币超发行为，跟各国央行的降息、降准等货币调节手段有异曲同工之处。\n\n**使用场景：**价值认同和行政命令同时失效时，可适当采用；当一些特殊事情，需要下级做出自我牺牲但对方不愿意时，可适合采用此方法，比如出差、加班等；一些对公司作用非常大的重点项目，也适合，比如：“你要是能让国家每年给公司减税1个亿，我奖励你1000万！”；其他一些犯规犯贱不能摆到台面上的事情，也可以考虑货币激励；\n\n**优点：**疗程短，见效快，短期作用非常明显，可激励士气\n\n**缺点：**边际效益递减；易滥用；一旦开先河，后期不好缩减，容易引起不满情绪；\n\n\n# 方法四. 人际关系\n\n**概念：**所谓人际关系是指运用工作内外建立起来的交往来说服对方，可以是上下级的直接交往，也可以借助他人。\n\n**使用场景：**这个方法是不得已而为之，慎用，但当其他方法都失效时，不妨考虑下；当正常沟通陷入僵局时，借助人际关系，尤其是第三者插足，可能会有奇效；\n\n**优点：**柳暗花明又一村\n\n**缺点：**饮鸩止渴",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"正确认识Backup",frontmatter:{title:"正确认识Backup",date:"2022-12-09T20:00:52.000Z",permalink:"/pages/ea7ab6/",categories:["非技术"],tags:[null]},regularPath:"/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/06.%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86Backup.html",relativePath:"10.非技术/06.正确认识Backup.md",key:"v-bd4d3ab8",path:"/pages/ea7ab6/",headers:[{level:3,title:"神奇的Backup",slug:"神奇的backup",normalizedTitle:"神奇的backup",charIndex:2},{level:3,title:"老板的如意算盘",slug:"老板的如意算盘",normalizedTitle:"老板的如意算盘",charIndex:266},{level:3,title:"致命Bug",slug:"致命bug",normalizedTitle:"致命bug",charIndex:603},{level:3,title:"正确认识与对待Backup",slug:"正确认识与对待backup",normalizedTitle:"正确认识与对待backup",charIndex:1024}],headersStr:"神奇的Backup 老板的如意算盘 致命Bug 正确认识与对待Backup",content:"# 神奇的Backup\n\nBackup，备份。\n\n比如后端服务，假设只部署在一台服务器上，那要是这台服务器挂了，比如硬件坏了、断网、断电等，然后灾难就发生了，这个服务就挂的死死的。这就是单点故障。\n\n但是，如果你的服务同时部署在两台服务器上，那么当其中一个挂掉时，另外一个能顶上。对外界来说，好像服务没有挂过一样。这两台服务器，就互为备份，互为Backup。\n\n你看，Backup是不是就完美解决了单点问题，服务的稳定性大幅提升呢？！真是神奇的Backup啊\n\n本文想聊的话题是：团队管理中，团队负责人的backup问题。\n\n\n# 老板的如意算盘\n\n我们时不时会听到如下对话：\n\n老板：小伙子，你需要在今年内给自己找个Backup。\n\n下属(某团队负责人)：好的，老板。\n\n老板在下指示，下属言听计从，多么和谐、多么符合社会主义核心价值观的一幅画面啊！但是（据说“但是”前的都是废话），有没有发现个Bug：如果需要Backup的话，那么请问老板他自己的Backup在哪儿？！\n\n我们再来看看老板的如意算盘。\n\n老板下面有很多团队，每个团队都有负责人。如果某一天，某个负责人被其他公司高薪挖走了，或者生病卧床没法干活了，等等。这时就糟糕了，团队群龙无首、一盘散沙了。\n\n那怎么办呢？聪明的老板开动了小脑筋：如果团队负责人有Backup就完美了！！！\n\n所以，我们有时会听到老板对Backup的要求。\n\n\n# 致命Bug\n\n上面，我们提到了个Bug：就是老板都没有Backup。其实还有另外一个致命Bug：一山不容二虎。\n\n先说第一个Bug。也许老板的老板，也就是大老板，他可能要求老板要找Backup。那么请问，老板Backup找到了吗？一年365天他花了多少天在为自己找Backup？他把这当成年度重要工作了吗？答案是显而易见的，没有！\n\n再说第二个Bug。如果一个团队，有两个能力相当的负责人，也就是老板眼中的Backup，那么这个团队会怎么样呢？所谓一山不容二虎，两老虎很可能要打架，谁也不服谁。很可能这个团队开始内耗，各种撕逼，团队成员忙着站队，最终团队分裂成两个小团队。\n\n当然，也有同学会说，你的话只说了半句：一山不容二虎，除非一公一母。没错，在某些团队，可能会有“两个负责人”（注意：打了引号），但通常情况下，这两个负责人能力互补，他们单独拎出来，都不是老虎，他们合起来才是一只老虎。所以，看起来有两只老虎，其实本质上是一只。\n\n\n# 正确认识与对待Backup\n\n下面这段话严重的政治不正确，但却是实话。\n\n总结下：所谓该找Backup，其实是句政治正确的废话！是老板对下属的要求，下属满口答应但不去执行，就好。\n\n那么下属该怎么做呢？正确的做法是4个字：梯队建设！\n\n假设你是团队负责人，且你的能力是90分，那么你应该招聘两三个80分、七八个70分、一大堆60分的人才，这样就完成了梯队建设，而且是层次分明的完美梯队。\n\n但如果你只有60分，那你需要干的事就是找个90分的人，然后退位让贤给他，再跟他学习，力争把自己的能力提升到90分。当然，实际情况是，大部分60分的人占着茅坑不拉屎，不愿意引进比自己厉害的人，业务没搞上去，自己能力也没提上去，白白浪费了大好青春，那就等着老板把你干掉吧。\n\n你的精力都应该花在管理好团队、做好自己的业务上，成绩做出来了，老板们自然不会再提找Backup的事。",normalizedContent:"# 神奇的backup\n\nbackup，备份。\n\n比如后端服务，假设只部署在一台服务器上，那要是这台服务器挂了，比如硬件坏了、断网、断电等，然后灾难就发生了，这个服务就挂的死死的。这就是单点故障。\n\n但是，如果你的服务同时部署在两台服务器上，那么当其中一个挂掉时，另外一个能顶上。对外界来说，好像服务没有挂过一样。这两台服务器，就互为备份，互为backup。\n\n你看，backup是不是就完美解决了单点问题，服务的稳定性大幅提升呢？！真是神奇的backup啊\n\n本文想聊的话题是：团队管理中，团队负责人的backup问题。\n\n\n# 老板的如意算盘\n\n我们时不时会听到如下对话：\n\n老板：小伙子，你需要在今年内给自己找个backup。\n\n下属(某团队负责人)：好的，老板。\n\n老板在下指示，下属言听计从，多么和谐、多么符合社会主义核心价值观的一幅画面啊！但是（据说“但是”前的都是废话），有没有发现个bug：如果需要backup的话，那么请问老板他自己的backup在哪儿？！\n\n我们再来看看老板的如意算盘。\n\n老板下面有很多团队，每个团队都有负责人。如果某一天，某个负责人被其他公司高薪挖走了，或者生病卧床没法干活了，等等。这时就糟糕了，团队群龙无首、一盘散沙了。\n\n那怎么办呢？聪明的老板开动了小脑筋：如果团队负责人有backup就完美了！！！\n\n所以，我们有时会听到老板对backup的要求。\n\n\n# 致命bug\n\n上面，我们提到了个bug：就是老板都没有backup。其实还有另外一个致命bug：一山不容二虎。\n\n先说第一个bug。也许老板的老板，也就是大老板，他可能要求老板要找backup。那么请问，老板backup找到了吗？一年365天他花了多少天在为自己找backup？他把这当成年度重要工作了吗？答案是显而易见的，没有！\n\n再说第二个bug。如果一个团队，有两个能力相当的负责人，也就是老板眼中的backup，那么这个团队会怎么样呢？所谓一山不容二虎，两老虎很可能要打架，谁也不服谁。很可能这个团队开始内耗，各种撕逼，团队成员忙着站队，最终团队分裂成两个小团队。\n\n当然，也有同学会说，你的话只说了半句：一山不容二虎，除非一公一母。没错，在某些团队，可能会有“两个负责人”（注意：打了引号），但通常情况下，这两个负责人能力互补，他们单独拎出来，都不是老虎，他们合起来才是一只老虎。所以，看起来有两只老虎，其实本质上是一只。\n\n\n# 正确认识与对待backup\n\n下面这段话严重的政治不正确，但却是实话。\n\n总结下：所谓该找backup，其实是句政治正确的废话！是老板对下属的要求，下属满口答应但不去执行，就好。\n\n那么下属该怎么做呢？正确的做法是4个字：梯队建设！\n\n假设你是团队负责人，且你的能力是90分，那么你应该招聘两三个80分、七八个70分、一大堆60分的人才，这样就完成了梯队建设，而且是层次分明的完美梯队。\n\n但如果你只有60分，那你需要干的事就是找个90分的人，然后退位让贤给他，再跟他学习，力争把自己的能力提升到90分。当然，实际情况是，大部分60分的人占着茅坑不拉屎，不愿意引进比自己厉害的人，业务没搞上去，自己能力也没提上去，白白浪费了大好青春，那就等着老板把你干掉吧。\n\n你的精力都应该花在管理好团队、做好自己的业务上，成绩做出来了，老板们自然不会再提找backup的事。",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"能力差的人都是什么样的？",frontmatter:{title:"能力差的人都是什么样的？",date:"2022-12-09T19:58:03.000Z",permalink:"/pages/fe4651/",categories:["非技术"],tags:[null]},regularPath:"/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/03.%E8%83%BD%E5%8A%9B%E5%B7%AE%E7%9A%84%E4%BA%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F.html",relativePath:"10.非技术/03.能力差的人是什么样的？.md",key:"v-37ecc426",path:"/pages/fe4651/",headers:[{level:3,title:"差劲的摄影师",slug:"差劲的摄影师",normalizedTitle:"差劲的摄影师",charIndex:409},{level:3,title:"能力差的人都有哪些特点？",slug:"能力差的人都有哪些特点",normalizedTitle:"能力差的人都有哪些特点？",charIndex:855},{level:4,title:"1. 高估自己，自我感觉良好",slug:"_1-高估自己-自我感觉良好",normalizedTitle:"1. 高估自己，自我感觉良好",charIndex:892},{level:4,title:"2. 不知道什么才叫优秀，无知",slug:"_2-不知道什么才叫优秀-无知",normalizedTitle:"2. 不知道什么才叫优秀，无知",charIndex:1037},{level:4,title:"3. 不谦虚，骄傲，不能坦荡承认自己的错误，爱甩锅",slug:"_3-不谦虚-骄傲-不能坦荡承认自己的错误-爱甩锅",normalizedTitle:"3. 不谦虚，骄傲，不能坦荡承认自己的错误，爱甩锅",charIndex:1214},{level:4,title:"4. 逼格低，重个人利益，轻团队利益",slug:"_4-逼格低-重个人利益-轻团队利益",normalizedTitle:"4. 逼格低，重个人利益，轻团队利益",charIndex:1437},{level:4,title:"5. 常逃避问题，而不是解决问题，爱从别人身上找原因",slug:"_5-常逃避问题-而不是解决问题-爱从别人身上找原因",normalizedTitle:"5. 常逃避问题，而不是解决问题，爱从别人身上找原因",charIndex:1716},{level:4,title:"6. 抢功劳，尤其是跟下级抢功劳",slug:"_6-抢功劳-尤其是跟下级抢功劳",normalizedTitle:"6. 抢功劳，尤其是跟下级抢功劳",charIndex:1927},{level:4,title:"7. 。。。（我想起来后再补充）",slug:"_7-。。。-我想起来后再补充",normalizedTitle:"7. 。。。（我想起来后再补充）",charIndex:2193},{level:3,title:"如何正确与能力差的人相处？",slug:"如何正确与能力差的人相处",normalizedTitle:"如何正确与能力差的人相处？",charIndex:2214}],headersStr:"差劲的摄影师 能力差的人都有哪些特点？ 1. 高估自己，自我感觉良好 2. 不知道什么才叫优秀，无知 3. 不谦虚，骄傲，不能坦荡承认自己的错误，爱甩锅 4. 逼格低，重个人利益，轻团队利益 5. 常逃避问题，而不是解决问题，爱从别人身上找原因 6. 抢功劳，尤其是跟下级抢功劳 7. 。。。（我想起来后再补充） 如何正确与能力差的人相处？",content:"“能力差”这三个字是敏感词，容易得罪人。只有讲自己的故事，揭自己的丑才不会得罪他人。本文通过我自己的经历和思考，希望读者能认识到自身或他人的不足，从而正确并聪明对待“能力差”这一普遍现象，补齐短板提升能力，学会与各种人相处。\n\n此时正值2019亚洲杯期间，我也来搞点时髦的东西：噌热点！明晚（1月11号）中国队将会面临第二个对手，菲律宾！中国必胜！\n\n提到国足，很多人都会用“能力差”来形容。但你知道不？中国队主教练里皮日薪40万RMB，你没看错，一天就有40万入账。国脚的年薪普遍过千万，队长郑智年薪大约两到三千万。能力差的人能有这么高的收入？！\n\n其实不是他们能力差，他们是中国足球运动员中的精英，Top 20 的人，要是跟快手足球队踢一场，赢个 30 : 0 轻轻松松。你想想，你是程序员，假设你是中国顶尖的 Top 20 的程序员，你的年收入才何止千万？可能是他们的十倍百倍都不止。 不扯远了，回来！\n\n\n# 差劲的摄影师\n\n元旦节去俄罗斯玩，漫天白雪很漂亮，我老婆（下文简称YY）选好了景，摆好了Pose，我拿着单反，对准她，按快门，茄子！一张照片就完成了，然后洋洋得意递到她面前。\n\n我：“拍的不错吧”\n\nYY：“你自己看一遍，你觉得呢？”\n\n我：“这不挺好嘛，100分！”\n\n接下来就是一顿数落，列出来这些问题：\n\n\\1. 相机角度不对，应该微微向上1° --- 5°，而不是向下，这样显的个儿矮\n\n\\2. 对焦没完全对准，照片放大后脸是虚的，不是实的\n\n\\3. 应该提醒她用头发挡住半张脸，否则显脸大不好看\n\n\\4. 应该提醒稍微抬头，从而不会让人觉得有双下巴，觉得她胖\n\n\\5. 光线不太对，有点逆光，人看起来显黑\n\n\\6. 相机没拿平，应该跟地面在一条水平线，刚照片拍出来是歪的\n\n\\7. 取景不对，人应该在照片三分之一处才是最佳位置\n\n\\8. 。。。（我已经记不清了，此处省略20条）\n\n结论：在摄影方面，我是个能力很差的人，至少现阶段是；而YY是这方面的专家，她是能力强的人。\n\n\n# 能力差的人都有哪些特点？\n\n我作为摄影能力差的人，都有哪些B样呢？\n\n# 1. 高估自己，自我感觉良好\n\n最开始，我觉得自己拍的照片挺好的，也就是自我感觉良好，高估了自己能力。这是能力差的同学普遍存在的问题，不能正确认识自己的优缺点，过于高估自己了。其实嘛，认清自己是件很难很难很难的事（注意：“很难”我用了三遍）。自己啥样，心里没点B数么，有些人真没有。\n\n# 2. 不知道什么才叫优秀，无知\n\n还是以我的故事为例，当YY反问我照片哪里有问题时，我完全看不出有啥问题，这就是无知！\n\n什么是好、什么是坏，压根不知道，没有深入下去，只停留在了表面，因无知而认为这就是最好的。但其实在专业人士眼中，这就是渣。\n\n你不知道有更高的山，所以认为北京香山才是世界第一高山，大约就是这个意思。\n\n能力差的人还有以下表现：\n\n# 3. 不谦虚，骄傲，不能坦荡承认自己的错误，爱甩锅\n\n判断一个是能力强弱的重要标准之一就是：看他是否谦虚。因为谦虚等于正视自身问题，才有接下来的改正，才有了不断进步，能力才会越来越强。\n\n差劲的人往往不谦虚，不能放低姿态，骄傲的很。\n\n他们往往也不愿意承认自己的错误，一出事，第一反应就是甩锅，甩给别人，迫不及待把自己的责任通通撇干净。\n\n甩锅的人其实内心深处是恐惧的，他们怕承担责任，怕别人说他们能力不行，所以甩锅其实是种自我保护行为。\n\n# 4. 逼格低，重个人利益，轻团队利益\n\n团队利益最大化，个人利益才能最大化，很多人看不到这点，不认可这点。\n\n能力差的人往往逼格低，首先想到的是自己，而不是团队；思考问题的思路也是说自己怎么怎么样，而不是站在团队立场思考问题。\n\n其实嘛，如果一个人习惯性地站在团队角度思考问题，思考一件事怎么做才是让团队更好时，他的能力无形中也会获得极大的提升，因为层次高了，收获也自然高了。\n\n能力差的Leader有时会刻意打压下属，因为担心下属能力提高后会威胁自己的地位，这也是逼格低的典型表现。这么做，自己能力上不去的同时，团队利益也受损了，不是双赢，是双输。\n\n# 5. 常逃避问题，而不是解决问题，爱从别人身上找原因\n\n能力差的人遇到问题了，往往不是吾日三省吾身反思自己，而是从别人身上找原因，他会认为同事挤兑他，看不起他，上级不重视他等等。\n\n并且常常不会直面问题，缺乏迎难而上的勇气；遇事就退缩就逃避，往往选择离职来逃避问题。殊不知，这家公司未解决的问题，下家公司还会再次遇到。\n\n每次遇到问题，其实都是打怪升级，提升自己的好时机，差劲的人不懂得利用这些危机，从而错失机遇。\n\n# 6. 抢功劳，尤其是跟下级抢功劳\n\n上面说了，能力差的人喜欢甩锅，出事了巴不得把所有责任推卸出去，其实，他们也经常抢功劳，把别人做的事说成自己做的。尤其比较恶心的是那些跟下级抢功劳的人。明明你一行代码都没写，非得说系统是你开发的，向上邀功领赏时尤其爱这么说；或者只是参与某个项目，然后汇报时说是自己做的，完全忽略了别人的贡献。这些人都是非常差劲的人，不仅能力差，人品也不咋地。\n\n这类人其实内心缺乏安全感，所以要抢功劳，要夸大其词，让别人误认为他很厉害，误认为他很能干，从而他内心觉得安全。但往往跟他合作的人，会觉得很不爽。\n\n# 7. 。。。（我想起来后再补充）\n\n\n# 如何正确与能力差的人相处？\n\n这个我也在持续摸索和总结中。\n\n每个人都各有所长，我们看到某些人在某个子领域属于能力差的人，换个子领域，我们就成了别人眼中差劲的人。完美是不存在的，不同程度的残缺才是世界的真相。\n\n与人相处，我的观念就是：尊重！尊重他们，适当时候指出他们的不足，分享心得给他们，帮助他们改进，扬长避短，补齐短板。大家互相学习，共同进步，共同提高！\n\n但如果遇到那些心胸狭隘之人，还是老死不相往来靠谱些！",normalizedContent:"“能力差”这三个字是敏感词，容易得罪人。只有讲自己的故事，揭自己的丑才不会得罪他人。本文通过我自己的经历和思考，希望读者能认识到自身或他人的不足，从而正确并聪明对待“能力差”这一普遍现象，补齐短板提升能力，学会与各种人相处。\n\n此时正值2019亚洲杯期间，我也来搞点时髦的东西：噌热点！明晚（1月11号）中国队将会面临第二个对手，菲律宾！中国必胜！\n\n提到国足，很多人都会用“能力差”来形容。但你知道不？中国队主教练里皮日薪40万rmb，你没看错，一天就有40万入账。国脚的年薪普遍过千万，队长郑智年薪大约两到三千万。能力差的人能有这么高的收入？！\n\n其实不是他们能力差，他们是中国足球运动员中的精英，top 20 的人，要是跟快手足球队踢一场，赢个 30 : 0 轻轻松松。你想想，你是程序员，假设你是中国顶尖的 top 20 的程序员，你的年收入才何止千万？可能是他们的十倍百倍都不止。 不扯远了，回来！\n\n\n# 差劲的摄影师\n\n元旦节去俄罗斯玩，漫天白雪很漂亮，我老婆（下文简称yy）选好了景，摆好了pose，我拿着单反，对准她，按快门，茄子！一张照片就完成了，然后洋洋得意递到她面前。\n\n我：“拍的不错吧”\n\nyy：“你自己看一遍，你觉得呢？”\n\n我：“这不挺好嘛，100分！”\n\n接下来就是一顿数落，列出来这些问题：\n\n\\1. 相机角度不对，应该微微向上1° --- 5°，而不是向下，这样显的个儿矮\n\n\\2. 对焦没完全对准，照片放大后脸是虚的，不是实的\n\n\\3. 应该提醒她用头发挡住半张脸，否则显脸大不好看\n\n\\4. 应该提醒稍微抬头，从而不会让人觉得有双下巴，觉得她胖\n\n\\5. 光线不太对，有点逆光，人看起来显黑\n\n\\6. 相机没拿平，应该跟地面在一条水平线，刚照片拍出来是歪的\n\n\\7. 取景不对，人应该在照片三分之一处才是最佳位置\n\n\\8. 。。。（我已经记不清了，此处省略20条）\n\n结论：在摄影方面，我是个能力很差的人，至少现阶段是；而yy是这方面的专家，她是能力强的人。\n\n\n# 能力差的人都有哪些特点？\n\n我作为摄影能力差的人，都有哪些b样呢？\n\n# 1. 高估自己，自我感觉良好\n\n最开始，我觉得自己拍的照片挺好的，也就是自我感觉良好，高估了自己能力。这是能力差的同学普遍存在的问题，不能正确认识自己的优缺点，过于高估自己了。其实嘛，认清自己是件很难很难很难的事（注意：“很难”我用了三遍）。自己啥样，心里没点b数么，有些人真没有。\n\n# 2. 不知道什么才叫优秀，无知\n\n还是以我的故事为例，当yy反问我照片哪里有问题时，我完全看不出有啥问题，这就是无知！\n\n什么是好、什么是坏，压根不知道，没有深入下去，只停留在了表面，因无知而认为这就是最好的。但其实在专业人士眼中，这就是渣。\n\n你不知道有更高的山，所以认为北京香山才是世界第一高山，大约就是这个意思。\n\n能力差的人还有以下表现：\n\n# 3. 不谦虚，骄傲，不能坦荡承认自己的错误，爱甩锅\n\n判断一个是能力强弱的重要标准之一就是：看他是否谦虚。因为谦虚等于正视自身问题，才有接下来的改正，才有了不断进步，能力才会越来越强。\n\n差劲的人往往不谦虚，不能放低姿态，骄傲的很。\n\n他们往往也不愿意承认自己的错误，一出事，第一反应就是甩锅，甩给别人，迫不及待把自己的责任通通撇干净。\n\n甩锅的人其实内心深处是恐惧的，他们怕承担责任，怕别人说他们能力不行，所以甩锅其实是种自我保护行为。\n\n# 4. 逼格低，重个人利益，轻团队利益\n\n团队利益最大化，个人利益才能最大化，很多人看不到这点，不认可这点。\n\n能力差的人往往逼格低，首先想到的是自己，而不是团队；思考问题的思路也是说自己怎么怎么样，而不是站在团队立场思考问题。\n\n其实嘛，如果一个人习惯性地站在团队角度思考问题，思考一件事怎么做才是让团队更好时，他的能力无形中也会获得极大的提升，因为层次高了，收获也自然高了。\n\n能力差的leader有时会刻意打压下属，因为担心下属能力提高后会威胁自己的地位，这也是逼格低的典型表现。这么做，自己能力上不去的同时，团队利益也受损了，不是双赢，是双输。\n\n# 5. 常逃避问题，而不是解决问题，爱从别人身上找原因\n\n能力差的人遇到问题了，往往不是吾日三省吾身反思自己，而是从别人身上找原因，他会认为同事挤兑他，看不起他，上级不重视他等等。\n\n并且常常不会直面问题，缺乏迎难而上的勇气；遇事就退缩就逃避，往往选择离职来逃避问题。殊不知，这家公司未解决的问题，下家公司还会再次遇到。\n\n每次遇到问题，其实都是打怪升级，提升自己的好时机，差劲的人不懂得利用这些危机，从而错失机遇。\n\n# 6. 抢功劳，尤其是跟下级抢功劳\n\n上面说了，能力差的人喜欢甩锅，出事了巴不得把所有责任推卸出去，其实，他们也经常抢功劳，把别人做的事说成自己做的。尤其比较恶心的是那些跟下级抢功劳的人。明明你一行代码都没写，非得说系统是你开发的，向上邀功领赏时尤其爱这么说；或者只是参与某个项目，然后汇报时说是自己做的，完全忽略了别人的贡献。这些人都是非常差劲的人，不仅能力差，人品也不咋地。\n\n这类人其实内心缺乏安全感，所以要抢功劳，要夸大其词，让别人误认为他很厉害，误认为他很能干，从而他内心觉得安全。但往往跟他合作的人，会觉得很不爽。\n\n# 7. 。。。（我想起来后再补充）\n\n\n# 如何正确与能力差的人相处？\n\n这个我也在持续摸索和总结中。\n\n每个人都各有所长，我们看到某些人在某个子领域属于能力差的人，换个子领域，我们就成了别人眼中差劲的人。完美是不存在的，不同程度的残缺才是世界的真相。\n\n与人相处，我的观念就是：尊重！尊重他们，适当时候指出他们的不足，分享心得给他们，帮助他们改进，扬长避短，补齐短板。大家互相学习，共同进步，共同提高！\n\n但如果遇到那些心胸狭隘之人，还是老死不相往来靠谱些！",charsets:{cjk:!0}},{title:"关于空降兵的思考",frontmatter:{title:"关于空降兵的思考",date:"2022-12-09T19:57:04.000Z",permalink:"/pages/a734ce/",categories:["非技术"],tags:[null]},regularPath:"/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/02.%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%99%8D%E5%85%B5%E7%9A%84%E6%80%9D%E8%80%83.html",relativePath:"10.非技术/02.关于空降兵的思考.md",key:"v-1130f268",path:"/pages/a734ce/",headers:[{level:3,title:"为什么有空降兵？",slug:"为什么有空降兵",normalizedTitle:"为什么有空降兵？",charIndex:371},{level:3,title:"局外人篇：空降兵易犯的几个错",slug:"局外人篇-空降兵易犯的几个错",normalizedTitle:"局外人篇：空降兵易犯的几个错",charIndex:950},{level:3,title:"员工篇：如何对待空降神兵？",slug:"员工篇-如何对待空降神兵",normalizedTitle:"员工篇：如何对待空降神兵？",charIndex:2340},{level:3,title:"老板篇：如何让空降人才安全落地？",slug:"老板篇-如何让空降人才安全落地",normalizedTitle:"老板篇：如何让空降人才安全落地？",charIndex:2914},{level:3,title:"伞兵篇：你若空降，如何落地？",slug:"伞兵篇-你若空降-如何落地",normalizedTitle:"伞兵篇：你若空降，如何落地？",charIndex:3497},{level:3,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:4872}],headersStr:"为什么有空降兵？ 局外人篇：空降兵易犯的几个错 员工篇：如何对待空降神兵？ 老板篇：如何让空降人才安全落地？ 伞兵篇：你若空降，如何落地？ 结束语",content:"空降兵，这又是个敏感话题！\n\n什么是空降兵呢？就是某个团队新来一个leader，也许是从外面招聘，或者是从其他部门调任，总之，并不是从现有团队提拔，这个新来的leader就像空降伞兵一样突然出现在大家眼前，天降神兵的感觉，因此得名。\n\n本文是笔者对于空降兵这一现象的思考，与大家一起探索如何正确看待空降兵。\n\n下文中的各角色的汇报关系如下：大老板(老板的老板) <---- 老板(大团队负责人) <---- 空降兵(Leader，小团队负责人) <---- 团队成员\n\n特别申明：本文只探讨正常组织发展升级的情况。假设某部门新换老大，他要排除异己，然后对下面团队空降leader，这种非正常情况请参考名著《冰与火之歌：权利的游戏》，不在本文的探讨范围内。本文言论，笔者一概不负责，各位读者权当一乐！还是那句老话：取其精华，去其糟粕！\n\n\n# 为什么有空降兵？\n\n简单来说，就是现有的团队成员，没有一个人的能力达到leader要求。从老板层面来看，苦衷就是：我也想提拔某个人，但是无人可用啊，被逼无奈才从外引进人才。\n\n如果现有成员中的某人能满足要求，那就直接招人，扩大团队就行了，就不用费劲巴拉招空降了。\n\n我们知道：一个公司的瓶颈在CEO的能力，一个团队的瓶颈在于团队leader的能力，他的个人天花板就是团队的天花板。\n\n假设现在某团队的业务，在A同学带领下做到了60分，请问如何做到90分呢？靠A同学吗？大概率是不行的，因为他目前能力上限就是60分，他某天可能会成长到90分，但需要时间，而这个时间是业务快速发展期不能等的。另外，团队成员的天花板也是60分，那他们个人未来怎么发展、怎么成长呢？因此，团队想发展、想升级、想鸟枪换炮、想摩托换小轿车、想绿皮火车换高铁，业务想进一步做好，想做到90分，就必须要找个90分能力的新leader。\n\n所以，空降是团队发展升级的正常现象。\n\n假设一个团队100人，90分leader只有一个，那么，除非他是第一个员工，不算空降，否则从第二个到第一百个，其中一个必定是空降。\n\n咱们工作多年，一定会见到很多例子。今天你可能被别人空降；某天，你也可能空降到其他团队。聊到这儿，道理就很简单了，接下来要做的事也很简单了：咱们每个人都应该正确看待空降。\n\n\n# 局外人篇：空降兵易犯的几个错\n\n能成为空降兵，在短短几个小时的面试中就让老板对你刮目相看，说明过去一定有过人的成绩，也就是说，空降兵都是在以前的公司证明过自己的，业绩突出的人才。人才、人才，首先是人，只要是人，就容易犯错，以下列举了我观察到的空降神兵容易犯的几个错误。\n\n错误一：最大错误：骄傲自满\n\n咱们一起回忆下小学第一节课时，老师教大家的第一个知识吧。老师站在讲台上，语重心长说道：“小朋友们，谦虚使人进步，骄傲使人落后！“ 这估计是很多人学到的第一个人生道理。\n\n空降兵一般都是证明过自己，历史上有过成功经验的人士。这类人士，很容易就忘了小学老师教的东西。过去的成功，让他们自信、也可能让他们过度自信，从而骄傲自满，盛气凌人。看到这，我估计他们的小学老师已经哭晕在厕所：”上学时苦口婆心教你们的东西，又还给老师了！“\n\n很多骄傲的空降兵会说：这事我已经干了N年了，所以就按照我的说的去做吧，肯定没错。\n\n但是别忘了，桔生淮南为橘，生淮北即为枳。你以前这么干可以，但今时不同往日，需要重新要考虑桔子生长的土壤和天气。\n\n骄傲的心态，往往意味着空降兵极有可能无法安全落地，可能会摔死。\n\n错误二：否定一切，把自己当救世主\n\n有些空降兵来到新团队后，由于各方面都跟以前不一样，往往一副看什么都不顺眼的样子，把过去的一切成果都否定掉。\n\n这类人，往往把自己当救世主，认为公司花大价钱挖他过来，就是拯救公司的。\n\n其实，你来之前，公司就正常运转，并不是没你不行。\n\n存在就是合理，无论以前的业务、架构等是什么样子，一定有其合理性，一定是有可取之处的。没有人是救世主！\n\n错误三：做事急于求成，想快速取得成绩\n\n由于刚来团队，有老板的期望，有员工的期待，也有员工的不信任，其实压力很大。这时，很多空降兵就希望快速做出成绩，证明自己，以期站稳脚跟。\n\n这个出发点是没错的，就是要重新证明自己。但是古语云：欲速则不达。最担心的情况是：在没有完全搞清楚状况前，就贸然下决定，结果做出来的东西是半成品，最后要推翻重构，白白浪费了时间和信任。\n\n错误四：任人唯亲、排除异己\n\n新到一个团队，有些空降兵认为事情进展不顺利，是由于没有亲信，以前的人不听自己的话造成的。于是他就开始了换血，排挤那些跟自己观点不合的人，把他们挤出团队。而对于关键岗位，任命自己招聘的人。这就是任人唯亲、排除异己。很明显，这会造成团队动荡，所谓一朝天子一朝臣，就是这个道理。\n\n错误五：拉帮结派\n\n有些空降兵，想尽快扩大在团队的影响力，争取更多团队成员的信任，就会各种名义将成员聚类，比如上家公司、入职时间、大学学校等等。这类行动，容易招来非议，从而让人觉得你在拉帮结派。\n\n以入职时间为例，假设某空降神兵刚入职，就张罗建个新入职员工的群，定期组织聚餐等，还美其名曰：新员工关怀。这种手段就是心术不正，其心可诛。对新员工的关怀，最好是老员工发起。试想一下，你自己本身就是个新员工，怎么能去关怀其他的新员工呢？！\n\n错误六：跪舔老板，却不专注做事\n\n也有些人，非常职业，认为老板是这个世界上最重要的人，所以花大量时间去做向上管理，跪舔老板，而忘了老板招你来是干嘛的。其实，专心做事 + 适当汇报 = 最好的向上管理。别忘了，你的老板还得向他的老板汇报，而汇报内容一定是做的事，你要是不干事，那他拿什么去汇报呢？！\n\n\n# 员工篇：如何对待空降神兵？\n\n员工对于突如其来的空降神兵，是最复杂的。大致来说，分为三类人：\n\n1. 消极抵触\n\n麻蛋，凭什么要招这个人？我们天天加班，累死累活，没功劳也有苦劳啊！为什么不提拔我？或者提拔那谁谁谁也行啊？他来了会不会给我们打低绩效啊？会不会把我们开了啊？老子都快不想干了\n\n2. 积极接纳\n\n新人，新气象，新活力，欢迎欢迎，热烈欢迎！\n\n3. 我是打酱油的\n\n你们爱咋折腾咋折腾，我不掺和，跟谁不是跟，我就是个干活的。\n\n以上三类人，都非常鲜明，出众。\n\n那么，你要想升级打怪，成为一个更优秀的人，该怎么做呢？\n\n首先，要认清自己的不足。这点其实非常难，大部分人都会高估自己。正是因为你有能力上的欠缺，不胜任，没法被提拔，所以才给了别人机会，才有空降这件事，并不是老板不信任你。\n\n其次，努力挖掘空降兵的优点，吸收学习，变成你自己的优点。三人行必有我师！尤其是大多数空降兵，以前做过你正在做的业务，多跟他交流，看看他以前是怎么做的，学习其长处。\n\n最后，合作优先，若他不胜任，则再另做打算。一定是要先与其合作，先一起做事，合作优先。做几件事，就知道他是否胜任了。若胜任，那就继续合作，继续向他学习，毕竟他能带领大家共同打怪升级；若不胜任，跟老板反馈，让他退下来做其他工作，如果他还人品不行，那就干脆滚蛋，从哪儿来回哪儿去。\n\n\n# 老板篇：如何让空降人才安全落地？\n\n文章读到这儿，相信读者比较累了，我们先轻松下。请你看看窗外，北京的窗外，看天空3分钟后再回来继续阅读。\n\n--------3分钟后--------\n\n你看到什么了？看到雾霾了吗？也许今天没有，但是你一定见过北京的雾霾。雾霾是我们国家经济快速发展时，忽视了环境保护而带来的恶果，而现在国家意识到这方面的问题，正在大力整治。\n\n老板在空降人才方面，最常见的错误就像北京那浓厚的雾霾：先污染后治理！\n\n过程往往是这样的：猎头或HR找来某位高级人才的简历，老板面试，群众演员也帮忙面试，最后老板很满意，给了不错薪水的offer，入职后，老板直接宣布：xx 是某某团队的负责人，大家鼓掌欢迎！过了段时间，怨声载道，发现看走眼了，他实际能力不行，不胜任。好吧，那就果断干掉。折腾了一圈，跟几个月前一模一样。这就是”先污染后治理“。\n\n北京的雾霾，尚且可以治理，重现蓝天，但空降兵损坏的人心呢，损失的信任呢，如何治理？！\n\n因此，在空降人才安全落地方面，磨刀不误砍柴工，急不得，欲速则不达，可采用六字方针：先考察后扶正！\n\n新入职的同学，无论职级多么高，他对于业务、对于团队，都有个适应期、磨合期。在这个期限内，对他进行实地检验，考察期结束，再正式任命。\n\n这里先不展开叙述了，我对此事经验不丰富，等他日我心得颇多时，再来补充 ^_^\n\n\n# 伞兵篇：你若空降，如何落地？\n\n坦白说，我没有空降过，我都是从最底层做起的，所以没有经验。但我仍然把我的想法写下来。\n\n1. 最最最重要的是：谦虚\n\n空降兵最重要的是心态，一定要谦虚、要虚心，不要把自己当成救世主，高高在上藐视一切是不行的。要抱着初学者的空杯心态，去学习了解业务，去理解为什么这么设计，前因后果是什么。要看到它的优点和缺点，尤其是优点。\n\n很多空降兵一入职后，都不去了解和学习现有业务，就按照之前在上家公司的经验搞事情，完全不考虑当前公司的环境是否适合，结果可想而知，肯定一地鸡毛。\n\n举个得罪人的BadCase：某公司某CXO入职后第一件事就是把HC锁定，然后说重新review，重新定HC，导致公司的招聘停止几个月了，错过了上半年的抢人黄金期，业务发展受到了一定影响。当时我私下高度评价了他：HC是业务部门跟前任人力老大定的，CXO一来就把原来定的推翻了，新的国家主席上任，也不敢把上届政府签的协议全部推翻，但他敢，他比国家主席还牛，有如此能人异士，民族复兴，国家富强，中国梦的实现指日可待，膜拜！\n\n因此，空降兵一定不要先否定一切，要先维持业务的正常运转，摸清底细，然后再考虑如何做优化调整。\n\n存在就是合理！现在的业务做成这样，一定是在历史的发展过程中做出的相对最优选择。注意，这里是相对最优，不是绝对最优，也就是说，在以前团队成员的能力范围及公司环境双重条件下做的相对最佳选择。很多时候是大家不知道什么叫最好，很多时候是大家明知道什么是最好，但由于组织结构等原因，推不动，各种原因吧。所以，空降到一个新团队，千万不要一来就否定一切，否则大概率会失败。\n\n2. 业务方面，先证明自己再发力\n\n当空降兵到一个新的团队，由于大家对他不了解，还是陌生人关系，所以首要任务是与大家一起做事来证明自己，证明你是有真才实学，并不是徒有虚名。在做这些事的过程中，大家觉得你确实比较厉害，信任就逐渐建立起来了。等信任建立的差不多时，再带领大家一起发力搞大事情，就顺理成章了。\n\n在前期，需要注意一些细节，比如：对与错界限不明显的事，要缓行；要先做那些明确对错的事。\n\n举个例子：假设一上来就挑战周报，说以前周报写的不好，要改版。你看，周报这种事，写或者不写，怎么写，差别大吗？有对错之分吗？没有，对吧。如果一来就折腾这种事，一定会招来非议，可能会说你主次不分，那么多重要的事不做，居然来折腾我们写了好几年的周报。所以，类似周报这种没有对错之分的事，千万不要着急做。等你对团队有充分的掌控力以后，再做。\n\n3. 团队方面，先维稳再优化\n\n当来到一个新团队，一定有部分团队成员是抵触心理，极端情况下可能会出现不配合，对着干。空降兵应该提前预见到这种情况，做好心理准备。团队方面，先保持稳定，先了解每个人的优缺点，肯定和鼓励以前取得的成绩。对团队成员，最好有适当的指导，告诉他们哪些工作怎么做才是更好的，让大家感受到你的到来是对大家的成长有帮助的。要尽快与团队打成一片，比如聚餐、抽烟，下班后一起玩等等，总之要多跟他们交流，了解他们的想法。\n\n对于那些不满足你要求的成员，切勿不要一来就痛下杀手，当你在团队立足未稳前，最好不要出现团队成员流失。\n\n对于新生力量的补充，继续沿用之前的策略和节奏，持续招聘，等你有大的规划时，再加大招聘力度。\n\n\n# 结束语\n\n贪婪与恐惧，是人性的两大弱点。普通人，都害怕变化，对未来的不确定感到恐惧。优秀的人，拥抱变化，适应变化！\n\n职业生涯几十年，会经历无数的空降和被空降，咱们得学会正确处理！\n\n当某一天你收拾好物品，准备离开一家公司时，你能带走的，除了银行卡上的数字和满头丝丝银发外，最宝贵的就是经历各种事所练就的一身本领！",normalizedContent:"空降兵，这又是个敏感话题！\n\n什么是空降兵呢？就是某个团队新来一个leader，也许是从外面招聘，或者是从其他部门调任，总之，并不是从现有团队提拔，这个新来的leader就像空降伞兵一样突然出现在大家眼前，天降神兵的感觉，因此得名。\n\n本文是笔者对于空降兵这一现象的思考，与大家一起探索如何正确看待空降兵。\n\n下文中的各角色的汇报关系如下：大老板(老板的老板) <---- 老板(大团队负责人) <---- 空降兵(leader，小团队负责人) <---- 团队成员\n\n特别申明：本文只探讨正常组织发展升级的情况。假设某部门新换老大，他要排除异己，然后对下面团队空降leader，这种非正常情况请参考名著《冰与火之歌：权利的游戏》，不在本文的探讨范围内。本文言论，笔者一概不负责，各位读者权当一乐！还是那句老话：取其精华，去其糟粕！\n\n\n# 为什么有空降兵？\n\n简单来说，就是现有的团队成员，没有一个人的能力达到leader要求。从老板层面来看，苦衷就是：我也想提拔某个人，但是无人可用啊，被逼无奈才从外引进人才。\n\n如果现有成员中的某人能满足要求，那就直接招人，扩大团队就行了，就不用费劲巴拉招空降了。\n\n我们知道：一个公司的瓶颈在ceo的能力，一个团队的瓶颈在于团队leader的能力，他的个人天花板就是团队的天花板。\n\n假设现在某团队的业务，在a同学带领下做到了60分，请问如何做到90分呢？靠a同学吗？大概率是不行的，因为他目前能力上限就是60分，他某天可能会成长到90分，但需要时间，而这个时间是业务快速发展期不能等的。另外，团队成员的天花板也是60分，那他们个人未来怎么发展、怎么成长呢？因此，团队想发展、想升级、想鸟枪换炮、想摩托换小轿车、想绿皮火车换高铁，业务想进一步做好，想做到90分，就必须要找个90分能力的新leader。\n\n所以，空降是团队发展升级的正常现象。\n\n假设一个团队100人，90分leader只有一个，那么，除非他是第一个员工，不算空降，否则从第二个到第一百个，其中一个必定是空降。\n\n咱们工作多年，一定会见到很多例子。今天你可能被别人空降；某天，你也可能空降到其他团队。聊到这儿，道理就很简单了，接下来要做的事也很简单了：咱们每个人都应该正确看待空降。\n\n\n# 局外人篇：空降兵易犯的几个错\n\n能成为空降兵，在短短几个小时的面试中就让老板对你刮目相看，说明过去一定有过人的成绩，也就是说，空降兵都是在以前的公司证明过自己的，业绩突出的人才。人才、人才，首先是人，只要是人，就容易犯错，以下列举了我观察到的空降神兵容易犯的几个错误。\n\n错误一：最大错误：骄傲自满\n\n咱们一起回忆下小学第一节课时，老师教大家的第一个知识吧。老师站在讲台上，语重心长说道：“小朋友们，谦虚使人进步，骄傲使人落后！“ 这估计是很多人学到的第一个人生道理。\n\n空降兵一般都是证明过自己，历史上有过成功经验的人士。这类人士，很容易就忘了小学老师教的东西。过去的成功，让他们自信、也可能让他们过度自信，从而骄傲自满，盛气凌人。看到这，我估计他们的小学老师已经哭晕在厕所：”上学时苦口婆心教你们的东西，又还给老师了！“\n\n很多骄傲的空降兵会说：这事我已经干了n年了，所以就按照我的说的去做吧，肯定没错。\n\n但是别忘了，桔生淮南为橘，生淮北即为枳。你以前这么干可以，但今时不同往日，需要重新要考虑桔子生长的土壤和天气。\n\n骄傲的心态，往往意味着空降兵极有可能无法安全落地，可能会摔死。\n\n错误二：否定一切，把自己当救世主\n\n有些空降兵来到新团队后，由于各方面都跟以前不一样，往往一副看什么都不顺眼的样子，把过去的一切成果都否定掉。\n\n这类人，往往把自己当救世主，认为公司花大价钱挖他过来，就是拯救公司的。\n\n其实，你来之前，公司就正常运转，并不是没你不行。\n\n存在就是合理，无论以前的业务、架构等是什么样子，一定有其合理性，一定是有可取之处的。没有人是救世主！\n\n错误三：做事急于求成，想快速取得成绩\n\n由于刚来团队，有老板的期望，有员工的期待，也有员工的不信任，其实压力很大。这时，很多空降兵就希望快速做出成绩，证明自己，以期站稳脚跟。\n\n这个出发点是没错的，就是要重新证明自己。但是古语云：欲速则不达。最担心的情况是：在没有完全搞清楚状况前，就贸然下决定，结果做出来的东西是半成品，最后要推翻重构，白白浪费了时间和信任。\n\n错误四：任人唯亲、排除异己\n\n新到一个团队，有些空降兵认为事情进展不顺利，是由于没有亲信，以前的人不听自己的话造成的。于是他就开始了换血，排挤那些跟自己观点不合的人，把他们挤出团队。而对于关键岗位，任命自己招聘的人。这就是任人唯亲、排除异己。很明显，这会造成团队动荡，所谓一朝天子一朝臣，就是这个道理。\n\n错误五：拉帮结派\n\n有些空降兵，想尽快扩大在团队的影响力，争取更多团队成员的信任，就会各种名义将成员聚类，比如上家公司、入职时间、大学学校等等。这类行动，容易招来非议，从而让人觉得你在拉帮结派。\n\n以入职时间为例，假设某空降神兵刚入职，就张罗建个新入职员工的群，定期组织聚餐等，还美其名曰：新员工关怀。这种手段就是心术不正，其心可诛。对新员工的关怀，最好是老员工发起。试想一下，你自己本身就是个新员工，怎么能去关怀其他的新员工呢？！\n\n错误六：跪舔老板，却不专注做事\n\n也有些人，非常职业，认为老板是这个世界上最重要的人，所以花大量时间去做向上管理，跪舔老板，而忘了老板招你来是干嘛的。其实，专心做事 + 适当汇报 = 最好的向上管理。别忘了，你的老板还得向他的老板汇报，而汇报内容一定是做的事，你要是不干事，那他拿什么去汇报呢？！\n\n\n# 员工篇：如何对待空降神兵？\n\n员工对于突如其来的空降神兵，是最复杂的。大致来说，分为三类人：\n\n1. 消极抵触\n\n麻蛋，凭什么要招这个人？我们天天加班，累死累活，没功劳也有苦劳啊！为什么不提拔我？或者提拔那谁谁谁也行啊？他来了会不会给我们打低绩效啊？会不会把我们开了啊？老子都快不想干了\n\n2. 积极接纳\n\n新人，新气象，新活力，欢迎欢迎，热烈欢迎！\n\n3. 我是打酱油的\n\n你们爱咋折腾咋折腾，我不掺和，跟谁不是跟，我就是个干活的。\n\n以上三类人，都非常鲜明，出众。\n\n那么，你要想升级打怪，成为一个更优秀的人，该怎么做呢？\n\n首先，要认清自己的不足。这点其实非常难，大部分人都会高估自己。正是因为你有能力上的欠缺，不胜任，没法被提拔，所以才给了别人机会，才有空降这件事，并不是老板不信任你。\n\n其次，努力挖掘空降兵的优点，吸收学习，变成你自己的优点。三人行必有我师！尤其是大多数空降兵，以前做过你正在做的业务，多跟他交流，看看他以前是怎么做的，学习其长处。\n\n最后，合作优先，若他不胜任，则再另做打算。一定是要先与其合作，先一起做事，合作优先。做几件事，就知道他是否胜任了。若胜任，那就继续合作，继续向他学习，毕竟他能带领大家共同打怪升级；若不胜任，跟老板反馈，让他退下来做其他工作，如果他还人品不行，那就干脆滚蛋，从哪儿来回哪儿去。\n\n\n# 老板篇：如何让空降人才安全落地？\n\n文章读到这儿，相信读者比较累了，我们先轻松下。请你看看窗外，北京的窗外，看天空3分钟后再回来继续阅读。\n\n--------3分钟后--------\n\n你看到什么了？看到雾霾了吗？也许今天没有，但是你一定见过北京的雾霾。雾霾是我们国家经济快速发展时，忽视了环境保护而带来的恶果，而现在国家意识到这方面的问题，正在大力整治。\n\n老板在空降人才方面，最常见的错误就像北京那浓厚的雾霾：先污染后治理！\n\n过程往往是这样的：猎头或hr找来某位高级人才的简历，老板面试，群众演员也帮忙面试，最后老板很满意，给了不错薪水的offer，入职后，老板直接宣布：xx 是某某团队的负责人，大家鼓掌欢迎！过了段时间，怨声载道，发现看走眼了，他实际能力不行，不胜任。好吧，那就果断干掉。折腾了一圈，跟几个月前一模一样。这就是”先污染后治理“。\n\n北京的雾霾，尚且可以治理，重现蓝天，但空降兵损坏的人心呢，损失的信任呢，如何治理？！\n\n因此，在空降人才安全落地方面，磨刀不误砍柴工，急不得，欲速则不达，可采用六字方针：先考察后扶正！\n\n新入职的同学，无论职级多么高，他对于业务、对于团队，都有个适应期、磨合期。在这个期限内，对他进行实地检验，考察期结束，再正式任命。\n\n这里先不展开叙述了，我对此事经验不丰富，等他日我心得颇多时，再来补充 ^_^\n\n\n# 伞兵篇：你若空降，如何落地？\n\n坦白说，我没有空降过，我都是从最底层做起的，所以没有经验。但我仍然把我的想法写下来。\n\n1. 最最最重要的是：谦虚\n\n空降兵最重要的是心态，一定要谦虚、要虚心，不要把自己当成救世主，高高在上藐视一切是不行的。要抱着初学者的空杯心态，去学习了解业务，去理解为什么这么设计，前因后果是什么。要看到它的优点和缺点，尤其是优点。\n\n很多空降兵一入职后，都不去了解和学习现有业务，就按照之前在上家公司的经验搞事情，完全不考虑当前公司的环境是否适合，结果可想而知，肯定一地鸡毛。\n\n举个得罪人的badcase：某公司某cxo入职后第一件事就是把hc锁定，然后说重新review，重新定hc，导致公司的招聘停止几个月了，错过了上半年的抢人黄金期，业务发展受到了一定影响。当时我私下高度评价了他：hc是业务部门跟前任人力老大定的，cxo一来就把原来定的推翻了，新的国家主席上任，也不敢把上届政府签的协议全部推翻，但他敢，他比国家主席还牛，有如此能人异士，民族复兴，国家富强，中国梦的实现指日可待，膜拜！\n\n因此，空降兵一定不要先否定一切，要先维持业务的正常运转，摸清底细，然后再考虑如何做优化调整。\n\n存在就是合理！现在的业务做成这样，一定是在历史的发展过程中做出的相对最优选择。注意，这里是相对最优，不是绝对最优，也就是说，在以前团队成员的能力范围及公司环境双重条件下做的相对最佳选择。很多时候是大家不知道什么叫最好，很多时候是大家明知道什么是最好，但由于组织结构等原因，推不动，各种原因吧。所以，空降到一个新团队，千万不要一来就否定一切，否则大概率会失败。\n\n2. 业务方面，先证明自己再发力\n\n当空降兵到一个新的团队，由于大家对他不了解，还是陌生人关系，所以首要任务是与大家一起做事来证明自己，证明你是有真才实学，并不是徒有虚名。在做这些事的过程中，大家觉得你确实比较厉害，信任就逐渐建立起来了。等信任建立的差不多时，再带领大家一起发力搞大事情，就顺理成章了。\n\n在前期，需要注意一些细节，比如：对与错界限不明显的事，要缓行；要先做那些明确对错的事。\n\n举个例子：假设一上来就挑战周报，说以前周报写的不好，要改版。你看，周报这种事，写或者不写，怎么写，差别大吗？有对错之分吗？没有，对吧。如果一来就折腾这种事，一定会招来非议，可能会说你主次不分，那么多重要的事不做，居然来折腾我们写了好几年的周报。所以，类似周报这种没有对错之分的事，千万不要着急做。等你对团队有充分的掌控力以后，再做。\n\n3. 团队方面，先维稳再优化\n\n当来到一个新团队，一定有部分团队成员是抵触心理，极端情况下可能会出现不配合，对着干。空降兵应该提前预见到这种情况，做好心理准备。团队方面，先保持稳定，先了解每个人的优缺点，肯定和鼓励以前取得的成绩。对团队成员，最好有适当的指导，告诉他们哪些工作怎么做才是更好的，让大家感受到你的到来是对大家的成长有帮助的。要尽快与团队打成一片，比如聚餐、抽烟，下班后一起玩等等，总之要多跟他们交流，了解他们的想法。\n\n对于那些不满足你要求的成员，切勿不要一来就痛下杀手，当你在团队立足未稳前，最好不要出现团队成员流失。\n\n对于新生力量的补充，继续沿用之前的策略和节奏，持续招聘，等你有大的规划时，再加大招聘力度。\n\n\n# 结束语\n\n贪婪与恐惧，是人性的两大弱点。普通人，都害怕变化，对未来的不确定感到恐惧。优秀的人，拥抱变化，适应变化！\n\n职业生涯几十年，会经历无数的空降和被空降，咱们得学会正确处理！\n\n当某一天你收拾好物品，准备离开一家公司时，你能带走的，除了银行卡上的数字和满头丝丝银发外，最宝贵的就是经历各种事所练就的一身本领！",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"对事不对人 vs 对人不对事",frontmatter:{title:"对事不对人 vs 对人不对事",date:"2022-12-09T20:01:55.000Z",permalink:"/pages/74395b/",categories:["非技术"],tags:[null]},regularPath:"/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/07.%E5%AF%B9%E4%BA%8B%E4%B8%8D%E5%AF%B9%E4%BA%BA%20vs%20%E5%AF%B9%E4%BA%BA%E4%B8%8D%E5%AF%B9%E4%BA%8B.html",relativePath:"10.非技术/07.对事不对人 vs 对人不对事.md",key:"v-6bbf2d35",path:"/pages/74395b/",headersStr:null,content:"不管对事不对人，还是对人不对事，都是聚焦思维、简易模式。事情那么负责，人心那么难以猜透，我照看不过来，那我就只看最有把握最重视的那一点。所谓对事不对人，就是不管人的好坏，只看事的对错。所谓对人不对事，就是不管事的对错，只看人的好坏。聚焦于一处，就会放掉另外一处。\n\n对事不对人是一种极端现实主义的态度，我现在与它渐行渐远，是因为发现它表面上主张客观公正，实际上对应着短期机会主义。你不管他是好人坏人，你只管他做的事你认不认可，约等于只管你与他在这件事上的利益是否兼容。如果认可，如果兼容，你们就结成同路人，往前一起走段路。但对事不对人有个问题。虽然做的事表面一样，但做事的那些个人和驱动他们的逻辑完全不同，将来的后果也不一样。同样是去健身房，有人去锻炼，有人仅仅去洗澡。\n\n如果把对事不对人这件事想透了，其实也能心安：能一起走一段就走一段，能走多远那要看下一件事到来的时候，你们是不是还认可看法，兼容利益。这段路一起走也好，到下一个路口相互捅刀也罢，It’s business, nothing personal。都是在商言商，没有个人恩怨，大家随时搭伙，随时拆伙，谁也别多想。\n\n相比之下，对人不对事与其说是一种策略，不如说是一种愿望。它希望在形形色色的观点和林林总总的利益下面，人还有个本色，而本色比观点和利益更靠得住。观点可能一时糊涂，利益可能暂时分岔，但底层还是同一个人，而这个人是可以信赖的。\n\n你对事没信心，但对他这个人有信心。你跟他打交道，肯定得不了满分，你与他不一定每个观点都相互认可，每件事都利益一致，但你也吃亏不到哪里去。跟对事不对人那一派不同，那一派是这一路100分，下一程搞不好就是0分；对人不对事，如果你幸运遇到了对的人，得不到满分，但也永远得不到0分。\n\n所以跟常识相反，对事不对人不是什么公正无偏，而是机会主义；对人不对事也不是什么裙带主义，而属于那种对人还葆有一丝天真，起码还有一些真情实意。\n\n对人不对事这件事关键是得看准人，对人不对事这一派的死穴就是看不准人。要是你对人不对事，遇到的他却是对事不对人，结果就是你把人和事都输掉了。\n\n对事不对人之所以盛行，原因就在于它这个模板容易操作。不计过往，不想将来，只观测眼下的可观察的东西。对人不对事则没有模板，难以操作，看人品，看运气。\n\n如果运气好，已经与值得你跟他对人不对事的人相遇，要特别珍惜。只有你和他都是对人不对事，你们才能相互谅解，不被意见分歧和利益分岔左右，走上共同繁盛的长路。这种际遇可遇不可求，千万珍惜。\n\n在对人不对事，与对事不对人之间，我选择对人不对事，你呢？",normalizedContent:"不管对事不对人，还是对人不对事，都是聚焦思维、简易模式。事情那么负责，人心那么难以猜透，我照看不过来，那我就只看最有把握最重视的那一点。所谓对事不对人，就是不管人的好坏，只看事的对错。所谓对人不对事，就是不管事的对错，只看人的好坏。聚焦于一处，就会放掉另外一处。\n\n对事不对人是一种极端现实主义的态度，我现在与它渐行渐远，是因为发现它表面上主张客观公正，实际上对应着短期机会主义。你不管他是好人坏人，你只管他做的事你认不认可，约等于只管你与他在这件事上的利益是否兼容。如果认可，如果兼容，你们就结成同路人，往前一起走段路。但对事不对人有个问题。虽然做的事表面一样，但做事的那些个人和驱动他们的逻辑完全不同，将来的后果也不一样。同样是去健身房，有人去锻炼，有人仅仅去洗澡。\n\n如果把对事不对人这件事想透了，其实也能心安：能一起走一段就走一段，能走多远那要看下一件事到来的时候，你们是不是还认可看法，兼容利益。这段路一起走也好，到下一个路口相互捅刀也罢，it’s business, nothing personal。都是在商言商，没有个人恩怨，大家随时搭伙，随时拆伙，谁也别多想。\n\n相比之下，对人不对事与其说是一种策略，不如说是一种愿望。它希望在形形色色的观点和林林总总的利益下面，人还有个本色，而本色比观点和利益更靠得住。观点可能一时糊涂，利益可能暂时分岔，但底层还是同一个人，而这个人是可以信赖的。\n\n你对事没信心，但对他这个人有信心。你跟他打交道，肯定得不了满分，你与他不一定每个观点都相互认可，每件事都利益一致，但你也吃亏不到哪里去。跟对事不对人那一派不同，那一派是这一路100分，下一程搞不好就是0分；对人不对事，如果你幸运遇到了对的人，得不到满分，但也永远得不到0分。\n\n所以跟常识相反，对事不对人不是什么公正无偏，而是机会主义；对人不对事也不是什么裙带主义，而属于那种对人还葆有一丝天真，起码还有一些真情实意。\n\n对人不对事这件事关键是得看准人，对人不对事这一派的死穴就是看不准人。要是你对人不对事，遇到的他却是对事不对人，结果就是你把人和事都输掉了。\n\n对事不对人之所以盛行，原因就在于它这个模板容易操作。不计过往，不想将来，只观测眼下的可观察的东西。对人不对事则没有模板，难以操作，看人品，看运气。\n\n如果运气好，已经与值得你跟他对人不对事的人相遇，要特别珍惜。只有你和他都是对人不对事，你们才能相互谅解，不被意见分歧和利益分岔左右，走上共同繁盛的长路。这种际遇可遇不可求，千万珍惜。\n\n在对人不对事，与对事不对人之间，我选择对人不对事，你呢？",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"关于",frontmatter:{title:"关于",date:"2019-12-25T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1},regularPath:"/15.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"15.关于/01.关于.md",key:"v-918dfaf8",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"⚡ 反馈与交流",slug:"⚡-反馈与交流",normalizedTitle:"⚡ 反馈与交流",charIndex:27},{level:2,title:"🐼Me",slug:"🐼me",normalizedTitle:"🐼me",charIndex:156},{level:3,title:"技能",slug:"技能",normalizedTitle:"技能",charIndex:177},{level:2,title:"Java学习",slug:"java学习",normalizedTitle:"java学习",charIndex:14},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:345}],headersStr:"📚Blog ⚡ 反馈与交流 🐼Me 技能 Java学习 ✉️ 联系",content:"# 📚Blog\n\n这是一个Java学习网站\n\n\n# ⚡ 反馈与交流\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n在使用过程中有任何问题和想法，你可以：\n\n * 给我提 Issue。\n\n你也可以在Issue查看别人提的问题和给出解决方案。\n\n * 戳JavaDriver社区\n\n更新日志\n\n\n# 🐼Me\n\n西二旗Java老司机\n\n\n# 技能\n\n * 熟悉 SpringBoot、Mybatis、Netty、Kafka 的拼写\n * 了解 Linux、windows、macOS 的开关机方式\n * 精通 Git 的 pull 和 push，并注册了 GitHub 帐号刷了一些 star\n\n\n# Java学习\n\n\n关注公众号，回复后端资源，即可获取学习资源一份。\n\n\n# ✉️ 联系\n\n * WeChat or QQ: {{ QQ }}\n * Email: 854818303@qq.com\n * GitHub: https://github.com/AdmireAn/JavaDriver",normalizedContent:"# 📚blog\n\n这是一个java学习网站\n\n\n# ⚡ 反馈与交流\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n在使用过程中有任何问题和想法，你可以：\n\n * 给我提 issue。\n\n你也可以在issue查看别人提的问题和给出解决方案。\n\n * 戳javadriver社区\n\n更新日志\n\n\n# 🐼me\n\n西二旗java老司机\n\n\n# 技能\n\n * 熟悉 springboot、mybatis、netty、kafka 的拼写\n * 了解 linux、windows、macos 的开关机方式\n * 精通 git 的 pull 和 push，并注册了 github 帐号刷了一些 star\n\n\n# java学习\n\n\n关注公众号，回复后端资源，即可获取学习资源一份。\n\n\n# ✉️ 联系\n\n * wechat or qq: {{ qq }}\n * email: 854818303@qq.com\n * github: https://github.com/admirean/javadriver",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"关于如何写OKR",frontmatter:{title:"关于如何写OKR",date:"2022-12-09T20:03:06.000Z",permalink:"/pages/6ac68e/",categories:["非技术"],tags:[null]},regularPath:"/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/08.%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%86%99OKR.html",relativePath:"10.非技术/08.关于如何写OKR.md",key:"v-286c1812",path:"/pages/6ac68e/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"提前退休的Case",slug:"提前退休的case",normalizedTitle:"提前退休的case",charIndex:109},{level:2,title:"各团队如何写OKR",slug:"各团队如何写okr",normalizedTitle:"各团队如何写okr",charIndex:865},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1354}],headersStr:"前言 提前退休的Case 各团队如何写OKR 其他",content:"# 前言\n\n接触OKR有几年了，对我自己来说，每个季度或双月都会写OKR，也看了无数次别人写的OKR，但我一直没完全搞懂该怎么去写OKR，所以我每次写的OKR都不一样。最近，我又有新的认识了，用下文记录下来。\n\n\n# 提前退休的Case\n\n先来个故事吧。故事主人翁叫X姐，假设她在公司身居高位，事业有成，家庭和睦，有老公有女儿。X姐给自己定了个目标：40岁财务自由，提前退休。\n\n一起分析下：财务自由后，就能退休了。但要实现财务自由，需要有一大笔钱，并且投资理财的被动收入大于日常开销，还需要家庭稳固，能抵御家庭风险，比如家人生大病等。\n\n可以轻易写出OKR来：\n\nObjective：40岁财务自由，提前退休\n\nKR1. 赚钱，赚到x千万（或x亿）\n\nKR2. 学习理财，平均年化收益达到 y%\n\nKR3. 家庭稳固，能抵御风险\n\nKR1和KR2，X姐自己就能搞定，但KR3需要家庭成员配合。接下来，可以把KR3拆解成详细的Todo list，或者拆成小目标，可以为每个家庭成员制定一个小目标，也可以写成OKR。\n\n例如，X姐父母(下文称为老人)的OKR可以这么写，\n\nObjective：保持身体健康，减少生大病的几率\n\nKR1. 每天锻炼身体一个小时\n\nKR2. 每年定期体检\n\nKR3. 配置合适的保险，比如重疾险等\n\n如上，这么写OKR，似乎就是我们心目中的理想OKR。\n\n这个Case中，X姐是业务方，俩老人其实是支持方，支持X姐的业务，假设没有他们的支持，X姐的目标可能实现不了。\n\n问题来了：请问老人的目标是”40岁财务自由，提前退休“吗？很明显不是！那他们需要对X姐的目标负责吗？也不用，他们只需要自己身体健康就行了，至于X姐能否实现财务自由，他们不用负责，也决定不了。也就是说：OKR中，你要对Objective负责！\n\n请问：老人的O可以定成共建财务自由目标吗？例如，Objective：【与女儿(业务方)共建】40岁财务自由，提前退休。答：似乎可以这么写，但是有点牵强，这么写，文案确实非常漂亮。\n\n\n# 各团队如何写OKR\n\n上述例子中，X姐属于业务方，业务团队；老人属于支持方，支持团队。每个业务方的支持团队可能有N个，每个支持团队可能支持N个业务方。\n\n我们能看到如下事实：\n\n 1. 业务方能清晰制定出目标并拆解\n 2. 支持方必须依赖业务方拆解的小目标\n\n换句话说，支持方的目标可用一句话来总结：支持业务团队的工作\n\n综上，OKR撰写的过程是：\n\n第1步：业务方制定业务目标，撰写OKR，并拆解成各个支持方的小目标\n\n第2步：支持方根据小目标制定OKR，并进一步拆解成更小的目标，给下游支持方\n\n第3步：下游支持方重复第2步，层层拆解，直到全部拆解完成\n\n（当然，在这个过程中，业务方与支持方、支持方与下游支持方需要提前沟通，盘点资源，看看目标能否实现，若不能，可能会纠正目标。业务目标，可以是老板指定，也可以是部门负责人高瞻远瞩制定，也可以是收集部门内大家的意见后决定，这是另外个话题，本文不做讨论）\n\n以咱们所属的运营研发部为例，来看看各个团队如何写OKR。为了简化模型，假设只有运营部一个业务方（实际上有很多个）。\n\n各方关系如下图：\n\n\n\n业务方只有一个：运营。\n\n其他团队，产品、设计、前端、后端、QA、数据等团队，其实都是支持方。但由于产品是业务方的接口人，会根据业务需求来设计产品原型，排优先级，所以产品属于一级支持方。设计、前后端、QA、数据等团队属于二级支持方，支持产品团队的工作。也有三级支持方，比如运维、行政、HR等团队。\n\n对了支持方来说，除了支持业务发展，也有些自身能力建设的工作，比如团队建设、服务监控、性能优化、中台抽象等等，这些工作是支持方主R，在这些事上，支持方自己就成了业务方，需要下游团队的支持。\n\n有了对各团队关系的理解，OKR就比较好写了，模板示例如下：\n\n运营OKR：\n\nO1. 打南方，南方各省月活增长xxx\n\nO2. 搞推广，媒体曝光增加yyy\n\nO3. 促生产，生产者产量提升zzz\n\n产品OKR：\n\nO1. 支持运营团队工作\n\nO2. 现有产品优化\n\nO3. 团队建设\n\n各研发团队OKR：\n\nO1. 支持产品团队工作\n\nO2. 系统优化，提升服务鲁棒性\n\nO3. 团队建设\n\n设计团队OKR：\n\nO1. 支持产品团队工作\n\nO2. 团队建设\n\n上面是以运营研发部为例，其他团队依然适用上述模型。\n\n\n# 其他\n\n有了上述的建模，很多问题就比较好回答了。\n\n\\1. OKR可不可以改？\n\n答：不少人认为OKR是严肃不可以更改的，其实不然。对于业务方，制定业务目标，就应该全力以赴去实现，根据实际情况酌情调整；对于支持团队，业务目标变了，就应该立刻变化，而不是认死理，认为该一成不变。\n\n\\2. OKR中”支持xx团队工作“，不好听，不好看，对团队成员心理可能有影响，怎么办？\n\n答：文案上美化下，建议把业务方拆解出来的小目标作为O，或者把业务目标复制过来，加上【与业务共建】文案。但无论怎么优化文案，本质上支持。\n\n\\3. 研发团队难道都是支持团队吗？\n\n答：不是。风控、推荐等团队对业务结果负责，他们自身就是业务团队。",normalizedContent:"# 前言\n\n接触okr有几年了，对我自己来说，每个季度或双月都会写okr，也看了无数次别人写的okr，但我一直没完全搞懂该怎么去写okr，所以我每次写的okr都不一样。最近，我又有新的认识了，用下文记录下来。\n\n\n# 提前退休的case\n\n先来个故事吧。故事主人翁叫x姐，假设她在公司身居高位，事业有成，家庭和睦，有老公有女儿。x姐给自己定了个目标：40岁财务自由，提前退休。\n\n一起分析下：财务自由后，就能退休了。但要实现财务自由，需要有一大笔钱，并且投资理财的被动收入大于日常开销，还需要家庭稳固，能抵御家庭风险，比如家人生大病等。\n\n可以轻易写出okr来：\n\nobjective：40岁财务自由，提前退休\n\nkr1. 赚钱，赚到x千万（或x亿）\n\nkr2. 学习理财，平均年化收益达到 y%\n\nkr3. 家庭稳固，能抵御风险\n\nkr1和kr2，x姐自己就能搞定，但kr3需要家庭成员配合。接下来，可以把kr3拆解成详细的todo list，或者拆成小目标，可以为每个家庭成员制定一个小目标，也可以写成okr。\n\n例如，x姐父母(下文称为老人)的okr可以这么写，\n\nobjective：保持身体健康，减少生大病的几率\n\nkr1. 每天锻炼身体一个小时\n\nkr2. 每年定期体检\n\nkr3. 配置合适的保险，比如重疾险等\n\n如上，这么写okr，似乎就是我们心目中的理想okr。\n\n这个case中，x姐是业务方，俩老人其实是支持方，支持x姐的业务，假设没有他们的支持，x姐的目标可能实现不了。\n\n问题来了：请问老人的目标是”40岁财务自由，提前退休“吗？很明显不是！那他们需要对x姐的目标负责吗？也不用，他们只需要自己身体健康就行了，至于x姐能否实现财务自由，他们不用负责，也决定不了。也就是说：okr中，你要对objective负责！\n\n请问：老人的o可以定成共建财务自由目标吗？例如，objective：【与女儿(业务方)共建】40岁财务自由，提前退休。答：似乎可以这么写，但是有点牵强，这么写，文案确实非常漂亮。\n\n\n# 各团队如何写okr\n\n上述例子中，x姐属于业务方，业务团队；老人属于支持方，支持团队。每个业务方的支持团队可能有n个，每个支持团队可能支持n个业务方。\n\n我们能看到如下事实：\n\n 1. 业务方能清晰制定出目标并拆解\n 2. 支持方必须依赖业务方拆解的小目标\n\n换句话说，支持方的目标可用一句话来总结：支持业务团队的工作\n\n综上，okr撰写的过程是：\n\n第1步：业务方制定业务目标，撰写okr，并拆解成各个支持方的小目标\n\n第2步：支持方根据小目标制定okr，并进一步拆解成更小的目标，给下游支持方\n\n第3步：下游支持方重复第2步，层层拆解，直到全部拆解完成\n\n（当然，在这个过程中，业务方与支持方、支持方与下游支持方需要提前沟通，盘点资源，看看目标能否实现，若不能，可能会纠正目标。业务目标，可以是老板指定，也可以是部门负责人高瞻远瞩制定，也可以是收集部门内大家的意见后决定，这是另外个话题，本文不做讨论）\n\n以咱们所属的运营研发部为例，来看看各个团队如何写okr。为了简化模型，假设只有运营部一个业务方（实际上有很多个）。\n\n各方关系如下图：\n\n\n\n业务方只有一个：运营。\n\n其他团队，产品、设计、前端、后端、qa、数据等团队，其实都是支持方。但由于产品是业务方的接口人，会根据业务需求来设计产品原型，排优先级，所以产品属于一级支持方。设计、前后端、qa、数据等团队属于二级支持方，支持产品团队的工作。也有三级支持方，比如运维、行政、hr等团队。\n\n对了支持方来说，除了支持业务发展，也有些自身能力建设的工作，比如团队建设、服务监控、性能优化、中台抽象等等，这些工作是支持方主r，在这些事上，支持方自己就成了业务方，需要下游团队的支持。\n\n有了对各团队关系的理解，okr就比较好写了，模板示例如下：\n\n运营okr：\n\no1. 打南方，南方各省月活增长xxx\n\no2. 搞推广，媒体曝光增加yyy\n\no3. 促生产，生产者产量提升zzz\n\n产品okr：\n\no1. 支持运营团队工作\n\no2. 现有产品优化\n\no3. 团队建设\n\n各研发团队okr：\n\no1. 支持产品团队工作\n\no2. 系统优化，提升服务鲁棒性\n\no3. 团队建设\n\n设计团队okr：\n\no1. 支持产品团队工作\n\no2. 团队建设\n\n上面是以运营研发部为例，其他团队依然适用上述模型。\n\n\n# 其他\n\n有了上述的建模，很多问题就比较好回答了。\n\n\\1. okr可不可以改？\n\n答：不少人认为okr是严肃不可以更改的，其实不然。对于业务方，制定业务目标，就应该全力以赴去实现，根据实际情况酌情调整；对于支持团队，业务目标变了，就应该立刻变化，而不是认死理，认为该一成不变。\n\n\\2. okr中”支持xx团队工作“，不好听，不好看，对团队成员心理可能有影响，怎么办？\n\n答：文案上美化下，建议把业务方拆解出来的小目标作为o，或者把业务目标复制过来，加上【与业务共建】文案。但无论怎么优化文案，本质上支持。\n\n\\3. 研发团队难道都是支持团队吗？\n\n答：不是。风控、推荐等团队对业务结果负责，他们自身就是业务团队。",charsets:{cjk:!0},lastUpdated:"2023/02/17, 17:03:51",lastUpdatedTimestamp:1676624631e3},{title:"网站",frontmatter:{title:"网站",permalink:"/pages/beb6c0bd8a66cea6",date:"2020-04-19T11:33:04.000Z",article:!1},regularPath:"/@pages/20.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",relativePath:"@pages/20.收藏夹/01.网站.md",key:"v-7ab50b9f",path:"/pages/beb6c0bd8a66cea6/",headers:[{level:2,title:"推荐",slug:"推荐",normalizedTitle:"推荐",charIndex:12},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:167},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:375},{level:3,title:"社区互动",slug:"社区互动",normalizedTitle:"社区互动",charIndex:596},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:623},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:711},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:775},{level:2,title:"优秀文章",slug:"优秀文章",normalizedTitle:"优秀文章",charIndex:833},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:897},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:382},{level:2,title:"评论系统",slug:"评论系统",normalizedTitle:"评论系统",charIndex:1148},{level:2,title:"前端小工具",slug:"前端小工具",normalizedTitle:"前端小工具",charIndex:1197},{level:2,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:1269},{level:2,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1330},{level:2,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1493},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:1753},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:875},{level:2,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:2090},{level:2,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:2150},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:2180},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2241},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:574},{level:2,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:3342},{level:2,title:"3D",slug:"_3d",normalizedTitle:"3d",charIndex:1967},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:2420},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:139},{level:2,title:"生成器",slug:"生成器",normalizedTitle:"生成器",charIndex:1839},{level:2,title:"元宇宙",slug:"元宇宙",normalizedTitle:"元宇宙",charIndex:4444},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:251},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3329},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:4688},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:5061},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:2330},{level:2,title:"nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:5141},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:5169}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<h2 id="推荐"><a class="header-anchor" href="#推荐">#</a> 推荐</h2>\n<ul>\n<li><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener noreferrer">panjiachen<OutboundLink/></a> by 花裤衩</li>\n<li><a href="https://www.code-nav.cn/" target="_blank" rel="noopener noreferrer">编程导航<OutboundLink/></a> by 程序员鱼皮</li>\n<li><a href="https://r2coding.com/" target="_blank" rel="noopener noreferrer">编程自学之路<OutboundLink/></a> by 程序羊</li>\n<li><a href="https://gitee.com/jishupang/web_atlas" target="_blank" rel="noopener noreferrer">前端知识图谱+B站资源整合<OutboundLink/></a> by 技术胖</li>\n<li><a href="https://shengxinjing.cn/" target="_blank" rel="noopener noreferrer">大圣编程自学网<OutboundLink/></a> by 大圣</li>\n<li><a href="https://devtool.tech/" target="_blank" rel="noopener noreferrer">开发者武器库<OutboundLink/></a></li>\n<li><a href="https://www.fly63.com/tool/home.html" target="_blank" rel="noopener noreferrer">工具大全<OutboundLink/></a></li>\n</ul>\n<p align="center">\n<img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/qrcode.zdqv9mlfc0g.jpg" width="200">\n</p>\n<div class="center-container"><p>关注公众号[有趣研究社]，回复<code>前端资源</code>，获取 <a href="https://github.com/xugaoyi/blog-gitalk-comment/wiki/Front-end-Study" target="_blank" rel="noopener noreferrer">前端学习资料<OutboundLink/></a></p>\n</div>',headersStr:"推荐 文档 社区 社区互动 技巧 博客 电子书 优秀文章 视频 Github 评论系统 前端小工具 代码编辑 Emoji表情 图片工具 思维导图 CSS CDN加速 网站托管 正则 其他 设计 图库 3D 交互 有趣 生成器 元宇宙 教程 产品 实用 Talk 算法 nginx 生活",content:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+B站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ 促进软件开发及相关领域知识与创新的传播\n * V2EX 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * SoBooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用CSS开发技巧\n * 防御性CSS\n\n\n# 视频\n\n * bilibili B站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# Github\n\n * Repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 GitHub Discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> Windows系统下按Win + .\n> Mac系统下按Control + Command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# CSS\n\n * 各种CSS生成器和JS代码片段\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * beTheme\n * UI 中国\n * wallhaven 壁纸网站-\n\n\n# 3D\n\n * sketchfab 3D模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * Little Big Details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * Decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * Product Hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+b站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq 促进软件开发及相关领域知识与创新的传播\n * v2ex 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * sobooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用css开发技巧\n * 防御性css\n\n\n# 视频\n\n * bilibili b站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# github\n\n * repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 github discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> windows系统下按win + .\n> mac系统下按control + command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# css\n\n * 各种css生成器和js代码片段\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n * wallhaven 壁纸网站-\n\n\n# 3d\n\n * sketchfab 3d模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * little big details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * product hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2022/06/20, 22:47:41",lastUpdatedTimestamp:1655736461e3},{title:"常用的前端轮子",frontmatter:{title:"常用的前端轮子",date:"2021-10-09T19:42:02.000Z",permalink:"/pages/47cf96/",article:!1},regularPath:"/@pages/20.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E5%B8%B8%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BD%AE%E5%AD%90.html",relativePath:"@pages/20.收藏夹/02.常用的前端轮子.md",key:"v-09c150e6",path:"/pages/47cf96/",headers:[{level:2,title:"React UI 组件库",slug:"react-ui-组件库",normalizedTitle:"react ui 组件库",charIndex:2},{level:2,title:"Vue UI组件库",slug:"vue-ui组件库",normalizedTitle:"vue ui组件库",charIndex:68},{level:2,title:"常用效果组件",slug:"常用效果组件",normalizedTitle:"常用效果组件",charIndex:124},{level:2,title:"工具类",slug:"工具类",normalizedTitle:"工具类",charIndex:201},{level:2,title:"Vue工具类",slug:"vue工具类",normalizedTitle:"vue工具类",charIndex:331},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:469}],headersStr:"React UI 组件库 Vue UI组件库 常用效果组件 工具类 Vue工具类 其他",content:"# React UI 组件库\n\n * Ant Design\n * React Bootstrap\n * MATERIAL-UI\n\n\n# Vue UI组件库\n\n * Element UI PC端\n * Vant 移动端\n * View UI\n\n\n# 常用效果组件\n\n * Animate.css 动画库\n * Swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生JS\n\n\n# 工具类\n\n * Lodash.js\n * Day.js 处理日期\n * Timeago.js 相对时间，如N小时前\n * Echarts 百度图表\n * Meditor.md 开源在线 Markdown 编辑器\n * validator.js 验证库\n\n\n# Vue工具类\n\n * vue-draggable 基于Sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * H5带笔锋手写签名，支持PC端和移动端",normalizedContent:"# react ui 组件库\n\n * ant design\n * react bootstrap\n * material-ui\n\n\n# vue ui组件库\n\n * element ui pc端\n * vant 移动端\n * view ui\n\n\n# 常用效果组件\n\n * animate.css 动画库\n * swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生js\n\n\n# 工具类\n\n * lodash.js\n * day.js 处理日期\n * timeago.js 相对时间，如n小时前\n * echarts 百度图表\n * meditor.md 开源在线 markdown 编辑器\n * validator.js 验证库\n\n\n# vue工具类\n\n * vue-draggable 基于sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * h5带笔锋手写签名，支持pc端和移动端",charsets:{cjk:!0},lastUpdated:"2022/06/20, 22:47:41",lastUpdatedTimestamp:1655736461e3},{title:"你知道的越多，不知道的也就越多",frontmatter:{title:"你知道的越多，不知道的也就越多",date:"2020-05-06T15:52:40.000Z",permalink:"/pages/f2e63f",sidebar:"auto",categories:["随笔"],tags:["学习","知识","鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",relativePath:"_posts/随笔/你知道的越多，不知道的也就越多.md",key:"v-2db11cb2",path:"/pages/f2e63f/",excerpt:"<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",headersStr:null,content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",normalizedContent:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"我做了一个手写春联小网页，祝大家虎年暴富",frontmatter:{title:"我做了一个手写春联小网页，祝大家虎年暴富",date:"2022-01-28T14:59:51.000Z",permalink:"/pages/829589/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null]},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%88%91%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E6%89%8B%E5%86%99%E6%98%A5%E8%81%94%E5%B0%8F%E7%BD%91%E9%A1%B5%EF%BC%8C%E7%A5%9D%E5%A4%A7%E5%AE%B6%E8%99%8E%E5%B9%B4%E6%9A%B4%E5%AF%8C.html",relativePath:"_posts/随笔/我做了一个手写春联小网页，祝大家虎年暴富.md",key:"v-a5c5f278",path:"/pages/829589/",headers:[{level:3,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:33},{level:3,title:"产品构思",slug:"产品构思",normalizedTitle:"产品构思",charIndex:195},{level:3,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:478},{level:3,title:"开发",slug:"开发",normalizedTitle:"开发",charIndex:487}],excerpt:'<p>手写春联：<a href="https://cl.xugaoyi.com/" target="_blank" rel="noopener noreferrer">https://cl.xugaoyi.com/<OutboundLink/></a></p>\n<h3 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h3>\n<p>虎年春节快到了，首先祝大家新年快乐，轻松暴富。\n最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么UI特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）</p>\n',headersStr:"前言 产品构思 设计 开发",content:'手写春联：https://cl.xugaoyi.com/\n\n\n# 前言\n\n虎年春节快到了，首先祝大家新年快乐，轻松暴富。 最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么UI特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）\n\n\n\n\n# 产品构思\n\n包含手写春节和生成春联两大功能：\n\n * 手写春联\n   \n   * 模拟用笔写字的字迹\n   * 选择画笔颜色\n   * 调整画笔大小\n   * 清空画布\n   * 撤回笔画\n   * 切换上、下联、横批、福字\n   * 随机切换对联提示\n   * 预览图片和下载\n   * 贴春联海报和下载\n\n * 生成模式\n   \n   * 选择画笔颜色\n   * 挑选生成的对联\n   * 输入对联\n   * 随机切换对联\n   * 贴春联海报和下载\n\n * 其他\n   \n   * 快速切换模式按钮\n   * 可控制的背景音乐\n   * 微信分享网页\n\n\n# 设计\n\n\n\n\n# 开发\n\n * 技术栈\n   * vite (打包&构建)\n   * vue3 (页面开发)\n   * vant（ui）\n   * sass (css)\n   * smooth-signature.js (带笔锋手写库)\n\n<template>\n  <div class="wrap" :class="\'mode-\' + mode" @touchstart="handleTouchstart">\n    \x3c!-- 切换模式按钮 --\x3e\n    <div class="toggle-mode-btn" @click="toggleMode">\n      {{ mode === 1 ? \'手写\' : \'生成\' }}\n      <i class="iconfont icon-qiehuan"></i>\n    </div>\n\n    \x3c!-- 工具栏 --\x3e\n    <div\n      class="actions"\n      :style="{ borderTopRightRadius: colorListVisibility ? \'0\' : \'5px\' }"\n    >\n      \x3c!-- 手写模式显示 --\x3e\n      <template v-if="mode === 1">\n        \x3c!-- 调色板 --\x3e\n        <div class="palette btn-block">\n          <div\n            class="cur-color"\n            @click="togglePalette"\n            :style="{ background: colorList[curColorIndex] }"\n          ></div>\n          <ul class="colorList" v-show="colorListVisibility">\n            <li\n              v-for="(item, index) in colorList"\n              :key="item"\n              :style="{ background: item }"\n              @click="selectColor(index)"\n            ></li>\n          </ul>\n        </div>\n\n        \x3c!-- 滑块 --\x3e\n        <div class="slider-box btn-block">\n          <van-slider\n            v-model="progress"\n            vertical\n            @change="changeProgress"\n            bar-height="28"\n            active-color="transparent"\n            :min="50"\n            :max="150"\n          >\n            <template #button>\n              <div class="custom-button"></div>\n            </template>\n          </van-slider>\n        </div>\n\n        \x3c!-- 清空 --\x3e\n        <div class="btn" @click="handleClear">\n          <i class="iconfont icon-lajitong"></i>\n        </div>\n\n        \x3c!-- 撤销 --\x3e\n        <div class="btn" @click="handleUndo">\n          <i class="iconfont icon-fanhui"></i>\n        </div>\n\n        <div class="line"></div>\n\n        \x3c!-- 切换画布的按钮 --\x3e\n        <div\n          class="btn"\n          :class="{ \'cur-active\': curCanvasIndex === index }"\n          v-for="(item, index) in canvasList"\n          :key="item.name"\n          @click="changeCanvas(index)"\n        >\n          {{ item.name }}\n        </div>\n\n        <div class="line"></div>\n\n        <div class="btn prominent" @click="handlePreview">预览</div>\n        <div class="btn prominent" @click="openPosters">贴联</div>\n      </template>\n\n      \x3c!-- 生成模式显示 --\x3e\n      <template v-else>\n        \x3c!-- 选颜色 --\x3e\n        <div\n          class="color-list-quick"\n          :class="{ active: curColorIndex === index }"\n          v-for="(item, index) in colorList"\n          :key="item"\n          :style="{ background: item }"\n          @click="selectColor(index)"\n        ></div>\n        <div class="line"></div>\n        <div class="btn" @click="showPickBox = true">挑选</div>\n        <div class="btn" @click="showInputBox = true">输入</div>\n\n        \x3c!-- 挑选对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showPickBox" title="请挑选对联">\n          <ul class="duilian-list">\n            <li\n              v-for="(item, index) in duilianList"\n              :key="index"\n              @click="handlePickDuilian(item)"\n            >\n              <span>{{ item.shang }}</span\n              >， <span>{{ item.xia }}</span\n              >。\n              <span>{{ item.heng }}</span>\n            </li>\n          </ul>\n        </van-action-sheet>\n\n        \x3c!-- 输入对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showInputBox" title="请输入对联">\n          <van-form @submit="handleSubmitInput">\n            <van-cell-group inset>\n              <van-field\n                v-model="shanglian"\n                name="shang"\n                label="上联"\n                placeholder="上联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字上联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="xialian"\n                name="xia"\n                label="下联"\n                placeholder="下联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字下联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="hengpi"\n                name="heng"\n                label="横批"\n                placeholder="横批"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入4位汉字横批\',\n                    pattern: /^[\\u4e00-\\u9fa5]{4}$/\n                  }\n                ]"\n                clearable\n              />\n            </van-cell-group>\n            <div style="margin: 16px">\n              <van-button\n                round\n                block\n                type="primary"\n                native-type="submit"\n                color="linear-gradient(to right, #ff6034, #c33825)"\n              >\n                完成\n              </van-button>\n            </div>\n          </van-form>\n        </van-action-sheet>\n      </template>\n    </div>\n\n    \x3c!-- 模式1-春联画布 --\x3e\n    <div\n      v-show="mode === 1"\n      v-for="(item, index) in canvasList"\n      :key="item.name"\n    >\n      <canvas\n        class="canvas"\n        :class="item.className"\n        v-show="curCanvasIndex === index"\n        :style="{\n          marginTop:\n            item.height < clientHeight\n              ? `${(clientHeight - item.height) / 2}px`\n              : 0,\n          marginLeft:\n            item.width < clientWidth ? `${(clientWidth - item.width) / 2}px` : 0\n        }"\n      />\n    </div>\n\n    \x3c!-- 模式2-春联画布 --\x3e\n    <div v-show="mode === 2" class="canvas-mode-2">\n      <div class="row">\n        <canvas id="canvas-top" :width="200 * scale" :height="60 * scale" />\n      </div>\n      <div class="row">\n        <canvas id="canvas-left" :width="60 * scale" :height="364 * scale" />\n        <canvas id="canvas-right" :width="60 * scale" :height="364 * scale" />\n      </div>\n    </div>\n\n    \x3c!-- 贴春联按钮 --\x3e\n    <Button class="btn-posters" @click="openPosters" />\n\n    \x3c!-- footer-当前对联提示 --\x3e\n    <footer v-if="duilian.shang">\n      <div class="refresh-btn" @click="handleRefresh(true)">\n        <i class="iconfont icon-shuaxin" :class="{ rotate: isRotate }"></i>\n      </div>\n      <dl class="duilian">\n        <dt>对联</dt>\n        <dd>\n          <div>{{ duilian.shang }}</div>\n          <div>{{ duilian.xia }}</div>\n        </dd>\n      </dl>\n      <dl>\n        <dt>横批</dt>\n        <dd>{{ duilian.heng }}</dd>\n      </dl>\n    </footer>\n\n    \x3c!-- 分享按钮 --\x3e\n    <div class="share-btn" v-if="isShowShareBtn" @click="isShowShareTip = true">\n      <i class="iconfont icon-fenxiang"></i>\n    </div>\n    \x3c!-- 微信分享提示语 --\x3e\n    <div\n      class="share-tip"\n      v-if="isShowShareTip"\n      @click="isShowShareTip = false"\n    >\n      点击右上角把这个工具分享给朋友\n      <div class="hand">👆</div>\n    </div>\n\n    \x3c!-- 保存tip --\x3e\n    <p v-if="isShowTip" class="download-tip">*长按图片保存或转发</p>\n\n    \x3c!-- 版权 --\x3e\n    <div class="copyright">公众号「有趣研究社」 ©版权所有</div>\n\n    \x3c!-- 载入图片元素，用于快速贴图使用, 注意设置crossorigin="anonymous"解决跨域 --\x3e\n    <div v-if="isReadImages">\n      <img\n        crossorigin="anonymous"\n        v-for="(item, index) in bgList"\n        :src="item"\n        :key="item"\n        class="hide-img"\n        :id="`bg-img-` + index"\n      />\n      <img\n        crossorigin="anonymous"\n        class="hide-img"\n        id="qrcode"\n        src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/img/qrcode.zul0pldsuao.png"\n      />\n    </div>\n\n    \x3c!-- 背景音乐 --\x3e\n    <audio\n      src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/cjxq.mp3"\n      id="bgm"\n      ref="bgm"\n      loop\n    />\n    <div\n      class="play-btn"\n      :class="{ paused: !isPlay }"\n      ref="playBtn"\n      @click="handlePlay"\n    >\n      <i class="iconfont icon-yinle"></i>\n    </div>\n  </div>\n\n  <div class="body-bg-img"></div>\n</template>\n\n<script>\nimport { ImagePreview, Notify } from \'vant\'\nimport { isWX, isMobile } from \'@/utils\'\nimport Button from \'@/components/Button.vue\'\nimport dl from \'@/assets/img/yh/dl.jpeg\'\nimport hp from \'@/assets/img/yh/hp.jpeg\'\nimport fz from \'@/assets/img/yh/fz.png\'\n\n// 对联数据\nimport duilianList from \'@/mock/duilian\'\n\nconst PROPORTION = 0.37 // 图片缩小比例\nconst INSTANTIATE_NAME = \'signature\' // 实例名称\nconst MIN_WIDTH = 3 // 画笔最小宽\nconst MAX_WIDTH = 12 // 画笔最大宽\n\n// 海报背景图大小\nconst BG_WIDTH = 750\nconst BG_HEIGHT = 1448\n\n// 贴图定位和大小\nconst POSITION = [\n  { left: 57, top: 510, width: 90, height: 546 }, // 上联\n  { left: 600, top: 510, width: 90, height: 546 }, // 下联\n  { left: 225, top: 345, width: 300, height: 90 }, // 横幅\n  { left: 460, top: 450, width: 130, height: 130 }, // 福字\n]\n\nexport default {\n  name: "Home",\n  components: {\n    Button\n  },\n  data() {\n    return {\n      duilianList,\n      mode: Number(localStorage.getItem(\'mode\')) || 1, // 1 手写，2 生成\n      curCanvasIndex: 0, // 显示哪个画布\n      progress: 100, // 画笔大小的刻度\n      clientWidth: document.documentElement.clientWidth,\n      clientHeight: document.documentElement.clientHeight,\n      canvasList: [\n        {\n          name: \'上联\',\n          className: \'canvas-a\',\n          bgImage: dl,\n          width: 600 * PROPORTION,\n          height: 3640 * PROPORTION,\n        },\n        {\n          name: \'下联\',\n          className: \'canvas-b\',\n          bgImage: dl,\n          width: 600 * PROPORTION,\n          height: 3640 * PROPORTION,\n        },\n        {\n          name: \'横批\',\n          className: \'canvas-c\',\n          bgImage: hp,\n          width: 2000 * PROPORTION,\n          height: 600 * PROPORTION,\n        },\n        {\n          name: \'福字\',\n          className: \'canvas-d\',\n          bgImage: fz,\n          width: 366,\n          height: 366,\n        }\n      ],\n      colorList: [\'#000000\', \'#ffd800\', \'#e8bd48\', \'#ddc08c\',],\n      curColorIndex: 0,\n      colorListVisibility: false, // 画布颜色选择列表可见性\n      isShowTip: false, // 是否显示底部提示语\n      duilian: {}, // 当前对联文本对象\n      isRotate: false, // 刷新icon旋转\n      bgList: [\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/1.4j8qpdnq80i0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/4.4460an8ag5o0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/5.3axtl4xpvy00.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/6.2lnbphdqjaq0.jpeg\',\n      ],\n      isReadImages: false, // 延迟加载图片用\n      isShowShareBtn: false, // 是否显示分享按钮\n      isShowShareTip: false, // 是否显示分享提示语\n      isPlay: false, // 是否在播放\n\n      // 模式2\n      canvasTop: null, // 横批\n      canvasLeft: null, // 上联\n      canvasRight: null, // 下联\n      imgObj1: null, // 横批图片对象\n      imgObj2: null, // 上下联图片对象\n      scale: Math.max(window.devicePixelRatio || 1, 2), // 用于增加画布清晰度\n      showPickBox: false, // 挑选对联的弹框\n      showInputBox: false, // 输入对联的弹框\n      shanglian: \'\', // 输入的上联\n      xialian: \'\', // 输入的下联\n      hengpi: \'\', // 输入的横批\n    };\n  },\n  computed: {\n    // 模式1-当前画布实例\n    curCanvasInstantiate() {\n      return this[INSTANTIATE_NAME + this.curCanvasIndex]\n    }\n  },\n  created() {\n    // 微信浏览器显示分享按钮\n    this.isShowShareBtn = isWX()\n  },\n  mounted() {\n    if (!isMobile()) {\n      Notify({ type: \'warning\', message: \'请用移动端打开获得最佳体验\', duration: 6000, });\n    }\n\n    this.initMode1();\n\n    // 初始化对联提示\n    this.handleRefresh();\n\n    this.initMode2();\n\n    // 按钮添加激活时发光效果class\n    const btnEl = document.querySelectorAll(\'.btn,.btn-block\');\n    btnEl.forEach((item) => {\n      item.addEventListener(\'touchstart\', () => {\n        item.classList.add(\'btn-active\')\n      })\n      item.addEventListener(\'touchend\', () => {\n        setTimeout(() => {\n          item.classList.remove(\'btn-active\')\n        }, 100)\n      })\n    })\n\n    // 延迟加载贴图背景\n    setTimeout(() => {\n      this.isReadImages = true\n    }, 1000)\n  },\n\n  watch: {\n    // 切换画笔颜色\n    curColorIndex() {\n      this.curCanvasInstantiate.color = this.colorList[this.curColorIndex]\n      if (this.mode === 2) {\n        this.refreshDuilian()\n      }\n    },\n    // 切换画布时应用当前画笔颜色和大小\n    curCanvasIndex() {\n      this.curCanvasInstantiate.color = this.colorList[this.curColorIndex]\n      this.handleChangeSize()\n      window.scrollTo(0, 0)\n    }\n  },\n\n  methods: {\n    initMode1() {\n      const { colorList, curColorIndex } = this\n      this.canvasList.forEach((item, index) => {\n        const options = {\n          width: item.width,\n          height: item.height,\n          minWidth: MIN_WIDTH, // 画笔最小宽度(px)\n          maxWidth: MAX_WIDTH, // 画笔最大宽度\n          minSpeed: 1.8, // 画笔达到最小宽度所需最小速度(px/ms)，取值范围1.0-10.0\n          color: colorList[curColorIndex],\n          // 新增的配置\n          bgImage: item.bgImage,\n        };\n\n        this[INSTANTIATE_NAME + index] = new SmoothSignature(document.querySelector(\'.\' + item.className), options);\n      })\n    },\n\n    initMode2() {\n      this.canvasTop = document.getElementById(\'canvas-top\').getContext(\'2d\')\n      this.canvasLeft = document.getElementById(\'canvas-left\').getContext(\'2d\')\n      this.canvasRight = document.getElementById(\'canvas-right\').getContext(\'2d\')\n\n      // 设字体样式\n      const font = "36px xs, cursive"\n      this.canvasTop.font = font\n      this.canvasLeft.font = font\n      this.canvasRight.font = font\n\n      // 增强清晰度\n      const { scale } = this\n      this.canvasTop.scale(scale, scale);\n      this.canvasLeft.scale(scale, scale);\n      this.canvasRight.scale(scale, scale);\n\n      // 设背景图\n      this.imgObj1 = new Image()\n      this.imgObj2 = new Image()\n      this.imgObj1.src = hp\n      this.imgObj2.src = dl\n      this.imgObj1.onload = () => {\n        // 贴背景\n        this.canvasTop.drawImage(this.imgObj1, 0, 0, 200, 60)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handleTopFillText()\n        });\n      }\n      this.imgObj2.onload = () => {\n        // 贴背景\n        this.canvasLeft.drawImage(this.imgObj2, 0, 0, 60, 364)\n        this.canvasRight.drawImage(this.imgObj2, 0, 0, 60, 364)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handleLRFillText(this.canvasLeft, this.duilian.shang)\n          this.handleLRFillText(this.canvasRight, this.duilian.xia)\n        });\n      }\n    },\n\n    // 模式2-刷新对联\n    refreshDuilian() {\n      this.canvasTop.drawImage(this.imgObj1, 0, 0, 200, 60)\n      this.canvasLeft.drawImage(this.imgObj2, 0, 0, 60, 364)\n      this.canvasRight.drawImage(this.imgObj2, 0, 0, 60, 364)\n      this.handleTopFillText()\n      this.handleLRFillText(this.canvasLeft, this.duilian.shang)\n      this.handleLRFillText(this.canvasRight, this.duilian.xia)\n    },\n\n    // 模式2-贴横批\n    handleTopFillText() {\n      // 贴文本\n      this.canvasTop.fillStyle = this.colorList[this.curColorIndex]\n      if (this.duilian.heng) {\n        this.duilian.heng.split(\'\').forEach((item, index) => {\n          const left = 42 * (index + 1) - 22\n          this.canvasTop.fillText(item, left, 40)\n        })\n      }\n    },\n\n    // 模式2-贴上下联\n    handleLRFillText(ctx, text) {\n      ctx.fillStyle = this.colorList[this.curColorIndex]\n      if (text) {\n        text.split(\'\').forEach((item, index) => {\n          const top = 50 * (index + 1) - 8\n          ctx.fillText(item, 13, top)\n        })\n      }\n    },\n\n    // 切换模式\n    toggleMode() {\n      if (this.mode === 1) {\n        this.mode = 2\n        this.refreshDuilian()\n      } else {\n        this.mode = 1\n      }\n      localStorage.setItem(\'mode\', this.mode);\n    },\n\n    // 打开调色板\n    togglePalette() {\n      this.colorListVisibility = !this.colorListVisibility\n    },\n\n    // 关闭调色板\n    handleTouchstart(e) {\n      // 不是点击选择颜色时\n      if (e.path[1]?.classList?.value !== \'colorList\' && e.target.classList?.value !== \'cur-color\') {\n        this.colorListVisibility = false\n      }\n    },\n\n    // 选择颜色\n    selectColor(index) {\n      this.curColorIndex = index\n      this.colorListVisibility = false\n    },\n\n    // 切换画布\n    changeCanvas(index) {\n      this.curCanvasIndex = index\n    },\n\n    // 清空画布\n    handleClear() {\n      this.curCanvasInstantiate.clear();\n    },\n\n    // 撤销笔画\n    handleUndo() {\n      this.curCanvasInstantiate.undo();\n    },\n\n    // 预览\n    handlePreview() {\n      this.showTopTip();\n      this.isShowTip = true\n      const _this = this\n      ImagePreview({\n        images: this.getImageList(),\n        closeable: true,\n        startPosition: this.curCanvasIndex,\n        onClose() {\n          _this.isShowTip = false\n        },\n      });\n    },\n\n    // 打开海报预览\n    openPosters() {\n      // 创建画布\n      const canvas = document.createElement(\'canvas\');\n      canvas.width = BG_WIDTH\n      canvas.height = BG_HEIGHT\n      const ctx = canvas.getContext(\'2d\');\n      const resultImageList = [];\n\n      // 是否隐藏福字\n      const isHideFu = this[INSTANTIATE_NAME + 3].isEmpty()\n      this.bgList.forEach((item, index) => {\n        // 贴背景图\n        ctx.drawImage(document.getElementById(\'bg-img-\' + index), 0, 0, BG_WIDTH, BG_HEIGHT)\n\n        // 贴对联\n        if (this.mode === 1) {\n          this.canvasList.forEach((item, index) => {\n            if (index === 3 && isHideFu) return;\n            const dlCanvas = document.querySelector(\'.\' + item.className)\n            const { left, top, width, height } = POSITION[index]\n            ctx.drawImage(dlCanvas, left, top, width, height)\n          })\n        } else {\n          [\'canvas-left\', \'canvas-right\', \'canvas-top\'].forEach((item, index) => {\n            const dlCanvas = document.getElementById(item)\n            const { left, top, width, height } = POSITION[index]\n            ctx.drawImage(dlCanvas, left, top, width, height)\n          })\n        }\n\n        // 贴二维码\n        ctx.drawImage(document.getElementById("qrcode"), 40, 1280, 580, 136)\n\n        // 贴文本\n        ctx.font = "18px sans-serif"\n        ctx.fillStyle = "#666666"\n        ctx.fillText(\'©公众号「有趣研究社」\', 550, 1420)\n\n        // 导出图片\n        resultImageList.push(canvas.toDataURL(\'image/jpeg\', 0.8))\n      })\n\n      // 打开图片预览\n      this.isShowTip = true\n      const _this = this\n      ImagePreview({\n        images: resultImageList,\n        closeable: true,\n        onClose() {\n          _this.isShowTip = false\n        },\n      });\n      this.showTopTip();\n    },\n\n    // 弹出顶部提示语\n    showTopTip() {\n      if (!sessionStorage.getItem(\'showTip\')) {\n        sessionStorage.setItem(\'showTip\', \'true\');\n        Notify({\n          message: \'长按图片可保存到本地\',\n          color: \'#c33825\',\n          background: \'#eed3ae\',\n        });\n      }\n    },\n\n    // 获取对联图片列表\n    getImageList(type = \'image/png\') {\n      const imageList = []\n      this.canvasList.forEach((item, index) => {\n        if (index === 3) {\n          // `福`字必须是png格式\n          type = \'image/png\'\n        }\n        imageList.push(this[INSTANTIATE_NAME + index].toDataURL(type, 0.8))\n      })\n      return imageList\n    },\n\n    // 进度改变时\n    changeProgress(progress) {\n      this.progress = progress\n      this.handleChangeSize()\n    },\n\n    // 调整画笔大小\n    handleChangeSize() {\n      const { progress } = this\n      this.curCanvasInstantiate.minWidth = MIN_WIDTH * progress / 100\n      this.curCanvasInstantiate.maxWidth = MAX_WIDTH * progress / 100\n    },\n\n    // 刷新对联\n    handleRefresh(rotate) {\n      this.duilian = duilianList[Math.floor(Math.random() * duilianList.length)]\n\n      if (rotate) {\n        if (this.mode === 2) {\n          this.refreshDuilian()\n        }\n        // 使icon旋转\n        this.isRotate = true\n        setTimeout(() => {\n          this.isRotate = false\n        }, 300)\n      }\n    },\n\n    // 播放背景音乐\n    handlePlay() {\n      const { bgm } = this.$refs\n      if (bgm.paused) {\n        bgm.play()\n        this.isPlay = true\n      } else {\n        bgm.pause()\n        this.isPlay = false\n      }\n    },\n\n    // 完成输入对联\n    handleSubmitInput(values) {\n      this.duilian = values\n      this.showInputBox = false\n      this.refreshDuilian()\n    },\n\n    // 完成挑选对联\n    handlePickDuilian(item) {\n      this.duilian = item\n      this.showPickBox = false\n      this.refreshDuilian()\n    }\n  },\n};\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n\n\n更多有趣的小网页欢迎关注公众号有趣研究社:\n\n> 手写春联\n> FC在线模拟器\n> 爱国头像生成器\n> 到账语音生成器',normalizedContent:'手写春联：https://cl.xugaoyi.com/\n\n\n# 前言\n\n虎年春节快到了，首先祝大家新年快乐，轻松暴富。 最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么ui特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）\n\n\n\n\n# 产品构思\n\n包含手写春节和生成春联两大功能：\n\n * 手写春联\n   \n   * 模拟用笔写字的字迹\n   * 选择画笔颜色\n   * 调整画笔大小\n   * 清空画布\n   * 撤回笔画\n   * 切换上、下联、横批、福字\n   * 随机切换对联提示\n   * 预览图片和下载\n   * 贴春联海报和下载\n\n * 生成模式\n   \n   * 选择画笔颜色\n   * 挑选生成的对联\n   * 输入对联\n   * 随机切换对联\n   * 贴春联海报和下载\n\n * 其他\n   \n   * 快速切换模式按钮\n   * 可控制的背景音乐\n   * 微信分享网页\n\n\n# 设计\n\n\n\n\n# 开发\n\n * 技术栈\n   * vite (打包&构建)\n   * vue3 (页面开发)\n   * vant（ui）\n   * sass (css)\n   * smooth-signature.js (带笔锋手写库)\n\n<template>\n  <div class="wrap" :class="\'mode-\' + mode" @touchstart="handletouchstart">\n    \x3c!-- 切换模式按钮 --\x3e\n    <div class="toggle-mode-btn" @click="togglemode">\n      {{ mode === 1 ? \'手写\' : \'生成\' }}\n      <i class="iconfont icon-qiehuan"></i>\n    </div>\n\n    \x3c!-- 工具栏 --\x3e\n    <div\n      class="actions"\n      :style="{ bordertoprightradius: colorlistvisibility ? \'0\' : \'5px\' }"\n    >\n      \x3c!-- 手写模式显示 --\x3e\n      <template v-if="mode === 1">\n        \x3c!-- 调色板 --\x3e\n        <div class="palette btn-block">\n          <div\n            class="cur-color"\n            @click="togglepalette"\n            :style="{ background: colorlist[curcolorindex] }"\n          ></div>\n          <ul class="colorlist" v-show="colorlistvisibility">\n            <li\n              v-for="(item, index) in colorlist"\n              :key="item"\n              :style="{ background: item }"\n              @click="selectcolor(index)"\n            ></li>\n          </ul>\n        </div>\n\n        \x3c!-- 滑块 --\x3e\n        <div class="slider-box btn-block">\n          <van-slider\n            v-model="progress"\n            vertical\n            @change="changeprogress"\n            bar-height="28"\n            active-color="transparent"\n            :min="50"\n            :max="150"\n          >\n            <template #button>\n              <div class="custom-button"></div>\n            </template>\n          </van-slider>\n        </div>\n\n        \x3c!-- 清空 --\x3e\n        <div class="btn" @click="handleclear">\n          <i class="iconfont icon-lajitong"></i>\n        </div>\n\n        \x3c!-- 撤销 --\x3e\n        <div class="btn" @click="handleundo">\n          <i class="iconfont icon-fanhui"></i>\n        </div>\n\n        <div class="line"></div>\n\n        \x3c!-- 切换画布的按钮 --\x3e\n        <div\n          class="btn"\n          :class="{ \'cur-active\': curcanvasindex === index }"\n          v-for="(item, index) in canvaslist"\n          :key="item.name"\n          @click="changecanvas(index)"\n        >\n          {{ item.name }}\n        </div>\n\n        <div class="line"></div>\n\n        <div class="btn prominent" @click="handlepreview">预览</div>\n        <div class="btn prominent" @click="openposters">贴联</div>\n      </template>\n\n      \x3c!-- 生成模式显示 --\x3e\n      <template v-else>\n        \x3c!-- 选颜色 --\x3e\n        <div\n          class="color-list-quick"\n          :class="{ active: curcolorindex === index }"\n          v-for="(item, index) in colorlist"\n          :key="item"\n          :style="{ background: item }"\n          @click="selectcolor(index)"\n        ></div>\n        <div class="line"></div>\n        <div class="btn" @click="showpickbox = true">挑选</div>\n        <div class="btn" @click="showinputbox = true">输入</div>\n\n        \x3c!-- 挑选对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showpickbox" title="请挑选对联">\n          <ul class="duilian-list">\n            <li\n              v-for="(item, index) in duilianlist"\n              :key="index"\n              @click="handlepickduilian(item)"\n            >\n              <span>{{ item.shang }}</span\n              >， <span>{{ item.xia }}</span\n              >。\n              <span>{{ item.heng }}</span>\n            </li>\n          </ul>\n        </van-action-sheet>\n\n        \x3c!-- 输入对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showinputbox" title="请输入对联">\n          <van-form @submit="handlesubmitinput">\n            <van-cell-group inset>\n              <van-field\n                v-model="shanglian"\n                name="shang"\n                label="上联"\n                placeholder="上联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字上联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="xialian"\n                name="xia"\n                label="下联"\n                placeholder="下联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字下联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="hengpi"\n                name="heng"\n                label="横批"\n                placeholder="横批"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入4位汉字横批\',\n                    pattern: /^[\\u4e00-\\u9fa5]{4}$/\n                  }\n                ]"\n                clearable\n              />\n            </van-cell-group>\n            <div style="margin: 16px">\n              <van-button\n                round\n                block\n                type="primary"\n                native-type="submit"\n                color="linear-gradient(to right, #ff6034, #c33825)"\n              >\n                完成\n              </van-button>\n            </div>\n          </van-form>\n        </van-action-sheet>\n      </template>\n    </div>\n\n    \x3c!-- 模式1-春联画布 --\x3e\n    <div\n      v-show="mode === 1"\n      v-for="(item, index) in canvaslist"\n      :key="item.name"\n    >\n      <canvas\n        class="canvas"\n        :class="item.classname"\n        v-show="curcanvasindex === index"\n        :style="{\n          margintop:\n            item.height < clientheight\n              ? `${(clientheight - item.height) / 2}px`\n              : 0,\n          marginleft:\n            item.width < clientwidth ? `${(clientwidth - item.width) / 2}px` : 0\n        }"\n      />\n    </div>\n\n    \x3c!-- 模式2-春联画布 --\x3e\n    <div v-show="mode === 2" class="canvas-mode-2">\n      <div class="row">\n        <canvas id="canvas-top" :width="200 * scale" :height="60 * scale" />\n      </div>\n      <div class="row">\n        <canvas id="canvas-left" :width="60 * scale" :height="364 * scale" />\n        <canvas id="canvas-right" :width="60 * scale" :height="364 * scale" />\n      </div>\n    </div>\n\n    \x3c!-- 贴春联按钮 --\x3e\n    <button class="btn-posters" @click="openposters" />\n\n    \x3c!-- footer-当前对联提示 --\x3e\n    <footer v-if="duilian.shang">\n      <div class="refresh-btn" @click="handlerefresh(true)">\n        <i class="iconfont icon-shuaxin" :class="{ rotate: isrotate }"></i>\n      </div>\n      <dl class="duilian">\n        <dt>对联</dt>\n        <dd>\n          <div>{{ duilian.shang }}</div>\n          <div>{{ duilian.xia }}</div>\n        </dd>\n      </dl>\n      <dl>\n        <dt>横批</dt>\n        <dd>{{ duilian.heng }}</dd>\n      </dl>\n    </footer>\n\n    \x3c!-- 分享按钮 --\x3e\n    <div class="share-btn" v-if="isshowsharebtn" @click="isshowsharetip = true">\n      <i class="iconfont icon-fenxiang"></i>\n    </div>\n    \x3c!-- 微信分享提示语 --\x3e\n    <div\n      class="share-tip"\n      v-if="isshowsharetip"\n      @click="isshowsharetip = false"\n    >\n      点击右上角把这个工具分享给朋友\n      <div class="hand">👆</div>\n    </div>\n\n    \x3c!-- 保存tip --\x3e\n    <p v-if="isshowtip" class="download-tip">*长按图片保存或转发</p>\n\n    \x3c!-- 版权 --\x3e\n    <div class="copyright">公众号「有趣研究社」 ©版权所有</div>\n\n    \x3c!-- 载入图片元素，用于快速贴图使用, 注意设置crossorigin="anonymous"解决跨域 --\x3e\n    <div v-if="isreadimages">\n      <img\n        crossorigin="anonymous"\n        v-for="(item, index) in bglist"\n        :src="item"\n        :key="item"\n        class="hide-img"\n        :id="`bg-img-` + index"\n      />\n      <img\n        crossorigin="anonymous"\n        class="hide-img"\n        id="qrcode"\n        src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/img/qrcode.zul0pldsuao.png"\n      />\n    </div>\n\n    \x3c!-- 背景音乐 --\x3e\n    <audio\n      src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/cjxq.mp3"\n      id="bgm"\n      ref="bgm"\n      loop\n    />\n    <div\n      class="play-btn"\n      :class="{ paused: !isplay }"\n      ref="playbtn"\n      @click="handleplay"\n    >\n      <i class="iconfont icon-yinle"></i>\n    </div>\n  </div>\n\n  <div class="body-bg-img"></div>\n</template>\n\n<script>\nimport { imagepreview, notify } from \'vant\'\nimport { iswx, ismobile } from \'@/utils\'\nimport button from \'@/components/button.vue\'\nimport dl from \'@/assets/img/yh/dl.jpeg\'\nimport hp from \'@/assets/img/yh/hp.jpeg\'\nimport fz from \'@/assets/img/yh/fz.png\'\n\n// 对联数据\nimport duilianlist from \'@/mock/duilian\'\n\nconst proportion = 0.37 // 图片缩小比例\nconst instantiate_name = \'signature\' // 实例名称\nconst min_width = 3 // 画笔最小宽\nconst max_width = 12 // 画笔最大宽\n\n// 海报背景图大小\nconst bg_width = 750\nconst bg_height = 1448\n\n// 贴图定位和大小\nconst position = [\n  { left: 57, top: 510, width: 90, height: 546 }, // 上联\n  { left: 600, top: 510, width: 90, height: 546 }, // 下联\n  { left: 225, top: 345, width: 300, height: 90 }, // 横幅\n  { left: 460, top: 450, width: 130, height: 130 }, // 福字\n]\n\nexport default {\n  name: "home",\n  components: {\n    button\n  },\n  data() {\n    return {\n      duilianlist,\n      mode: number(localstorage.getitem(\'mode\')) || 1, // 1 手写，2 生成\n      curcanvasindex: 0, // 显示哪个画布\n      progress: 100, // 画笔大小的刻度\n      clientwidth: document.documentelement.clientwidth,\n      clientheight: document.documentelement.clientheight,\n      canvaslist: [\n        {\n          name: \'上联\',\n          classname: \'canvas-a\',\n          bgimage: dl,\n          width: 600 * proportion,\n          height: 3640 * proportion,\n        },\n        {\n          name: \'下联\',\n          classname: \'canvas-b\',\n          bgimage: dl,\n          width: 600 * proportion,\n          height: 3640 * proportion,\n        },\n        {\n          name: \'横批\',\n          classname: \'canvas-c\',\n          bgimage: hp,\n          width: 2000 * proportion,\n          height: 600 * proportion,\n        },\n        {\n          name: \'福字\',\n          classname: \'canvas-d\',\n          bgimage: fz,\n          width: 366,\n          height: 366,\n        }\n      ],\n      colorlist: [\'#000000\', \'#ffd800\', \'#e8bd48\', \'#ddc08c\',],\n      curcolorindex: 0,\n      colorlistvisibility: false, // 画布颜色选择列表可见性\n      isshowtip: false, // 是否显示底部提示语\n      duilian: {}, // 当前对联文本对象\n      isrotate: false, // 刷新icon旋转\n      bglist: [\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/1.4j8qpdnq80i0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/4.4460an8ag5o0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/5.3axtl4xpvy00.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/6.2lnbphdqjaq0.jpeg\',\n      ],\n      isreadimages: false, // 延迟加载图片用\n      isshowsharebtn: false, // 是否显示分享按钮\n      isshowsharetip: false, // 是否显示分享提示语\n      isplay: false, // 是否在播放\n\n      // 模式2\n      canvastop: null, // 横批\n      canvasleft: null, // 上联\n      canvasright: null, // 下联\n      imgobj1: null, // 横批图片对象\n      imgobj2: null, // 上下联图片对象\n      scale: math.max(window.devicepixelratio || 1, 2), // 用于增加画布清晰度\n      showpickbox: false, // 挑选对联的弹框\n      showinputbox: false, // 输入对联的弹框\n      shanglian: \'\', // 输入的上联\n      xialian: \'\', // 输入的下联\n      hengpi: \'\', // 输入的横批\n    };\n  },\n  computed: {\n    // 模式1-当前画布实例\n    curcanvasinstantiate() {\n      return this[instantiate_name + this.curcanvasindex]\n    }\n  },\n  created() {\n    // 微信浏览器显示分享按钮\n    this.isshowsharebtn = iswx()\n  },\n  mounted() {\n    if (!ismobile()) {\n      notify({ type: \'warning\', message: \'请用移动端打开获得最佳体验\', duration: 6000, });\n    }\n\n    this.initmode1();\n\n    // 初始化对联提示\n    this.handlerefresh();\n\n    this.initmode2();\n\n    // 按钮添加激活时发光效果class\n    const btnel = document.queryselectorall(\'.btn,.btn-block\');\n    btnel.foreach((item) => {\n      item.addeventlistener(\'touchstart\', () => {\n        item.classlist.add(\'btn-active\')\n      })\n      item.addeventlistener(\'touchend\', () => {\n        settimeout(() => {\n          item.classlist.remove(\'btn-active\')\n        }, 100)\n      })\n    })\n\n    // 延迟加载贴图背景\n    settimeout(() => {\n      this.isreadimages = true\n    }, 1000)\n  },\n\n  watch: {\n    // 切换画笔颜色\n    curcolorindex() {\n      this.curcanvasinstantiate.color = this.colorlist[this.curcolorindex]\n      if (this.mode === 2) {\n        this.refreshduilian()\n      }\n    },\n    // 切换画布时应用当前画笔颜色和大小\n    curcanvasindex() {\n      this.curcanvasinstantiate.color = this.colorlist[this.curcolorindex]\n      this.handlechangesize()\n      window.scrollto(0, 0)\n    }\n  },\n\n  methods: {\n    initmode1() {\n      const { colorlist, curcolorindex } = this\n      this.canvaslist.foreach((item, index) => {\n        const options = {\n          width: item.width,\n          height: item.height,\n          minwidth: min_width, // 画笔最小宽度(px)\n          maxwidth: max_width, // 画笔最大宽度\n          minspeed: 1.8, // 画笔达到最小宽度所需最小速度(px/ms)，取值范围1.0-10.0\n          color: colorlist[curcolorindex],\n          // 新增的配置\n          bgimage: item.bgimage,\n        };\n\n        this[instantiate_name + index] = new smoothsignature(document.queryselector(\'.\' + item.classname), options);\n      })\n    },\n\n    initmode2() {\n      this.canvastop = document.getelementbyid(\'canvas-top\').getcontext(\'2d\')\n      this.canvasleft = document.getelementbyid(\'canvas-left\').getcontext(\'2d\')\n      this.canvasright = document.getelementbyid(\'canvas-right\').getcontext(\'2d\')\n\n      // 设字体样式\n      const font = "36px xs, cursive"\n      this.canvastop.font = font\n      this.canvasleft.font = font\n      this.canvasright.font = font\n\n      // 增强清晰度\n      const { scale } = this\n      this.canvastop.scale(scale, scale);\n      this.canvasleft.scale(scale, scale);\n      this.canvasright.scale(scale, scale);\n\n      // 设背景图\n      this.imgobj1 = new image()\n      this.imgobj2 = new image()\n      this.imgobj1.src = hp\n      this.imgobj2.src = dl\n      this.imgobj1.onload = () => {\n        // 贴背景\n        this.canvastop.drawimage(this.imgobj1, 0, 0, 200, 60)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handletopfilltext()\n        });\n      }\n      this.imgobj2.onload = () => {\n        // 贴背景\n        this.canvasleft.drawimage(this.imgobj2, 0, 0, 60, 364)\n        this.canvasright.drawimage(this.imgobj2, 0, 0, 60, 364)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handlelrfilltext(this.canvasleft, this.duilian.shang)\n          this.handlelrfilltext(this.canvasright, this.duilian.xia)\n        });\n      }\n    },\n\n    // 模式2-刷新对联\n    refreshduilian() {\n      this.canvastop.drawimage(this.imgobj1, 0, 0, 200, 60)\n      this.canvasleft.drawimage(this.imgobj2, 0, 0, 60, 364)\n      this.canvasright.drawimage(this.imgobj2, 0, 0, 60, 364)\n      this.handletopfilltext()\n      this.handlelrfilltext(this.canvasleft, this.duilian.shang)\n      this.handlelrfilltext(this.canvasright, this.duilian.xia)\n    },\n\n    // 模式2-贴横批\n    handletopfilltext() {\n      // 贴文本\n      this.canvastop.fillstyle = this.colorlist[this.curcolorindex]\n      if (this.duilian.heng) {\n        this.duilian.heng.split(\'\').foreach((item, index) => {\n          const left = 42 * (index + 1) - 22\n          this.canvastop.filltext(item, left, 40)\n        })\n      }\n    },\n\n    // 模式2-贴上下联\n    handlelrfilltext(ctx, text) {\n      ctx.fillstyle = this.colorlist[this.curcolorindex]\n      if (text) {\n        text.split(\'\').foreach((item, index) => {\n          const top = 50 * (index + 1) - 8\n          ctx.filltext(item, 13, top)\n        })\n      }\n    },\n\n    // 切换模式\n    togglemode() {\n      if (this.mode === 1) {\n        this.mode = 2\n        this.refreshduilian()\n      } else {\n        this.mode = 1\n      }\n      localstorage.setitem(\'mode\', this.mode);\n    },\n\n    // 打开调色板\n    togglepalette() {\n      this.colorlistvisibility = !this.colorlistvisibility\n    },\n\n    // 关闭调色板\n    handletouchstart(e) {\n      // 不是点击选择颜色时\n      if (e.path[1]?.classlist?.value !== \'colorlist\' && e.target.classlist?.value !== \'cur-color\') {\n        this.colorlistvisibility = false\n      }\n    },\n\n    // 选择颜色\n    selectcolor(index) {\n      this.curcolorindex = index\n      this.colorlistvisibility = false\n    },\n\n    // 切换画布\n    changecanvas(index) {\n      this.curcanvasindex = index\n    },\n\n    // 清空画布\n    handleclear() {\n      this.curcanvasinstantiate.clear();\n    },\n\n    // 撤销笔画\n    handleundo() {\n      this.curcanvasinstantiate.undo();\n    },\n\n    // 预览\n    handlepreview() {\n      this.showtoptip();\n      this.isshowtip = true\n      const _this = this\n      imagepreview({\n        images: this.getimagelist(),\n        closeable: true,\n        startposition: this.curcanvasindex,\n        onclose() {\n          _this.isshowtip = false\n        },\n      });\n    },\n\n    // 打开海报预览\n    openposters() {\n      // 创建画布\n      const canvas = document.createelement(\'canvas\');\n      canvas.width = bg_width\n      canvas.height = bg_height\n      const ctx = canvas.getcontext(\'2d\');\n      const resultimagelist = [];\n\n      // 是否隐藏福字\n      const ishidefu = this[instantiate_name + 3].isempty()\n      this.bglist.foreach((item, index) => {\n        // 贴背景图\n        ctx.drawimage(document.getelementbyid(\'bg-img-\' + index), 0, 0, bg_width, bg_height)\n\n        // 贴对联\n        if (this.mode === 1) {\n          this.canvaslist.foreach((item, index) => {\n            if (index === 3 && ishidefu) return;\n            const dlcanvas = document.queryselector(\'.\' + item.classname)\n            const { left, top, width, height } = position[index]\n            ctx.drawimage(dlcanvas, left, top, width, height)\n          })\n        } else {\n          [\'canvas-left\', \'canvas-right\', \'canvas-top\'].foreach((item, index) => {\n            const dlcanvas = document.getelementbyid(item)\n            const { left, top, width, height } = position[index]\n            ctx.drawimage(dlcanvas, left, top, width, height)\n          })\n        }\n\n        // 贴二维码\n        ctx.drawimage(document.getelementbyid("qrcode"), 40, 1280, 580, 136)\n\n        // 贴文本\n        ctx.font = "18px sans-serif"\n        ctx.fillstyle = "#666666"\n        ctx.filltext(\'©公众号「有趣研究社」\', 550, 1420)\n\n        // 导出图片\n        resultimagelist.push(canvas.todataurl(\'image/jpeg\', 0.8))\n      })\n\n      // 打开图片预览\n      this.isshowtip = true\n      const _this = this\n      imagepreview({\n        images: resultimagelist,\n        closeable: true,\n        onclose() {\n          _this.isshowtip = false\n        },\n      });\n      this.showtoptip();\n    },\n\n    // 弹出顶部提示语\n    showtoptip() {\n      if (!sessionstorage.getitem(\'showtip\')) {\n        sessionstorage.setitem(\'showtip\', \'true\');\n        notify({\n          message: \'长按图片可保存到本地\',\n          color: \'#c33825\',\n          background: \'#eed3ae\',\n        });\n      }\n    },\n\n    // 获取对联图片列表\n    getimagelist(type = \'image/png\') {\n      const imagelist = []\n      this.canvaslist.foreach((item, index) => {\n        if (index === 3) {\n          // `福`字必须是png格式\n          type = \'image/png\'\n        }\n        imagelist.push(this[instantiate_name + index].todataurl(type, 0.8))\n      })\n      return imagelist\n    },\n\n    // 进度改变时\n    changeprogress(progress) {\n      this.progress = progress\n      this.handlechangesize()\n    },\n\n    // 调整画笔大小\n    handlechangesize() {\n      const { progress } = this\n      this.curcanvasinstantiate.minwidth = min_width * progress / 100\n      this.curcanvasinstantiate.maxwidth = max_width * progress / 100\n    },\n\n    // 刷新对联\n    handlerefresh(rotate) {\n      this.duilian = duilianlist[math.floor(math.random() * duilianlist.length)]\n\n      if (rotate) {\n        if (this.mode === 2) {\n          this.refreshduilian()\n        }\n        // 使icon旋转\n        this.isrotate = true\n        settimeout(() => {\n          this.isrotate = false\n        }, 300)\n      }\n    },\n\n    // 播放背景音乐\n    handleplay() {\n      const { bgm } = this.$refs\n      if (bgm.paused) {\n        bgm.play()\n        this.isplay = true\n      } else {\n        bgm.pause()\n        this.isplay = false\n      }\n    },\n\n    // 完成输入对联\n    handlesubmitinput(values) {\n      this.duilian = values\n      this.showinputbox = false\n      this.refreshduilian()\n    },\n\n    // 完成挑选对联\n    handlepickduilian(item) {\n      this.duilian = item\n      this.showpickbox = false\n      this.refreshduilian()\n    }\n  },\n};\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n\n\n更多有趣的小网页欢迎关注公众号有趣研究社:\n\n> 手写春联\n> fc在线模拟器\n> 爱国头像生成器\n> 到账语音生成器',charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"拥抱生活，拥抱快乐",frontmatter:{title:"拥抱生活，拥抱快乐",date:"2020-06-26T20:40:38.000Z",permalink:"/pages/cd8bde/",sidebar:"auto",categories:["随笔"],tags:["鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",relativePath:"_posts/随笔/拥抱生活，拥抱快乐.md",key:"v-7d77d69c",path:"/pages/cd8bde/",excerpt:"<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",headersStr:null,content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-48f7eec0",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-5f8dfe80",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-64f9b920",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/19, 21:26:01",lastUpdatedTimestamp:1652966761e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/JAVADRIVER.png",heroText:"JavaDriver",tagline:"🚀精选大厂Java面试题",actionText:"开始使用 →",actionLink:"/pages/a030ff/",bannerBg:"none",features:[{title:"联系源码",details:"围绕源码讲解面试题，知其然知所以然，做到真正明白一道题，不惧面试官从任何角度发起提问。"},{title:"生动直观",details:"图、文、表格、动画帮助你更好的理解。"},{title:"题目来源",details:"题目来源国内大中厂面试者的反馈，包括但不限于阿里巴巴、腾讯、美团、字节跳动、快手、京东、拼多多、小红书、滴滴。"}],postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-2cf94a0e",path:"/",headers:[{level:2,title:"🎖友情链接",slug:"🎖友情链接",normalizedTitle:"🎖友情链接",charIndex:11},{level:2,title:"🎉上新推荐",slug:"🎉上新推荐",normalizedTitle:"🎉上新推荐",charIndex:723},{level:2,title:"⚡️未来...",slug:"⚡️未来",normalizedTitle:"⚡️未来...",charIndex:775},{level:2,title:"⚡ 反馈与交流",slug:"⚡-反馈与交流",normalizedTitle:"⚡ 反馈与交流",charIndex:839}],headersStr:"🎖友情链接 🎉上新推荐 ⚡️未来... ⚡ 反馈与交流",content:"支持这个项目\n\n\n# 🎖友情链接\n\nOpenHarmony\n\n开放原子开源基金会\n\nMyBatis-Plus官网\n\n🚀为简化开发而生\n\nvuepress-theme-vdoing\n\n优秀的vuepress主题\n\nVForm官网\n\n低代码表单优选方案，拖拽式设计，一键生成源码\n\n- name: OpenHarmony\n  desc: 开放原子开源基金会\n  link: https://docs.openharmony.cn/pages/000000/\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: MyBatis-Plus官网\n  desc: 🚀为简化开发而生\n  link: https://baomidou.com/\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: vuepress-theme-vdoing\n  desc: 优秀的vuepress主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: VForm官网\n  desc: 低代码表单优选方案，拖拽式设计，一键生成源码\n  link: http://www.vform666.com\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n# 🎉上新推荐\n\n * v1.1.x：第一个版本，快去 看看 吧~\n\n更多上新请查阅：更新日志\n\n\n\n# ⚡️未来...\n\n提示\n\n期待 更多Java领域的面试题正式发布...\n\n还希望大家多多 💖支持 哟，持续关注吧~\n\n\n\n# ⚡ 反馈与交流\n\n在使用过程中有任何问题和想法，你可以：\n\n * 给我提 Issue。\n\n你也可以在Issue查看别人提的问题和给出解决方案。\n\n * 戳JavaDriver社区\n\n",normalizedContent:"支持这个项目\n\n\n# 🎖友情链接\n\nopenharmony\n\n开放原子开源基金会\n\nmybatis-plus官网\n\n🚀为简化开发而生\n\nvuepress-theme-vdoing\n\n优秀的vuepress主题\n\nvform官网\n\n低代码表单优选方案，拖拽式设计，一键生成源码\n\n- name: openharmony\n  desc: 开放原子开源基金会\n  link: https://docs.openharmony.cn/pages/000000/\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: mybatis-plus官网\n  desc: 🚀为简化开发而生\n  link: https://baomidou.com/\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: vuepress-theme-vdoing\n  desc: 优秀的vuepress主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: vform官网\n  desc: 低代码表单优选方案，拖拽式设计，一键生成源码\n  link: http://www.vform666.com\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n# 🎉上新推荐\n\n * v1.1.x：第一个版本，快去 看看 吧~\n\n更多上新请查阅：更新日志\n\n\n\n# ⚡️未来...\n\n提示\n\n期待 更多java领域的面试题正式发布...\n\n还希望大家多多 💖支持 哟，持续关注吧~\n\n\n\n# ⚡ 反馈与交流\n\n在使用过程中有任何问题和想法，你可以：\n\n * 给我提 issue。\n\n你也可以在issue查看别人提的问题和给出解决方案。\n\n * 戳javadriver社区\n\n",charsets:{cjk:!0},lastUpdated:"2022/06/20, 22:47:41",lastUpdatedTimestamp:1655736461e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"Java相关",link:"/java/",items:[{text:"基础",link:"/pages/a030ff/"},{text:"并发",link:"/pages/0da4b0/"},{text:"JVM",link:"/pages/948850/"},{text:"设计模式",link:"/pages/b37ad7/"}]},{text:"计算机基础",link:"/basic/",items:[{text:"计算机网络",link:"/pages/e00207/"},{text:"操作系统",link:"/pages/e5f2d7/"},{text:"数据结构",link:"/pages/a25c3a/"},{text:"算法",link:"/pages/92288a/"}]},{text:"数据库",link:"/database/",items:[{text:"MYSQL",link:"/pages/3a8659/"},{text:"REDIS",link:"/pages/d70c1f/"}]},{text:"中间件",link:"/middleware/",items:[{text:"Netty",link:"/pages/40f3c9/"},{text:"Kafka",link:"/pages/561f34/"}]},{text:"系统设计",link:"/pages/01b9b2/"},{text:"非技术",link:"/pages/5e507a/"},{text:"关于",link:"/about/"},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/JAVADRIVER.png",repo:"https://github.com/AdmireAn/JavaDriver",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",sidebar:{"/00.目录页/":[["01.Java相关.md","Java相关","/java"],["02.计算机基础.md","计算机基础","/basic"],["03.数据库.md","数据库","/database"],["04.中间件.md","中间件","/middleware"]],catalogue:{"Java相关":"/java","计算机基础":"/basic","数据库":"/database","中间件":"/middleware"},"/01.Java相关/":[{title:"基础",collapsable:!0,children:[["10.基础/001.Java 异常有哪些类型？.md","Java 异常有哪些类型？","/pages/a030ff/"],["10.基础/010.HashMap 与 ConcurrentHashMap 的实现原理是怎样的？.md","HashMap 与 ConcurrentHashMap 的实现原理是怎样的？","/pages/d1c564/"],["10.基础/020.Java 中接口和抽象类的区别.md","Java 中接口和抽象类的区别","/pages/826c8b/"],["10.基础/030.为什么重写 equals 必须重写 hashcode ？.md","为什么重写 equals 必须重写 hashcode ？","/pages/0d22ad/"],["10.基础/040.== 和 equals() 的区别？.md","== 和 equals() 的区别？","/pages/06b28a/"],["10.基础/050.String，StringBuffer，StringBuilder 之间有什么区别？.md","String，StringBuffer，StringBuilder 之间有什么区别？","/pages/211d8c/"],["10.基础/060.简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度.md","简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度","/pages/305919/"],["10.基础/070.简述 BIO, NIO, AIO 的区别.md","简述 BIO, NIO, AIO 的区别","/pages/276740/"],["10.基础/080.在一个静态方法内调用一个非静态成员为什么是非法的？.md","在一个静态方法内调用一个非静态成员为什么是非法的？","/pages/56314c/"],["10.基础/090.简述 Java 的反射机制及其应用场景.md","简述 Java 的反射机制及其应用场景","/pages/fae5d5/"],["10.基础/100.Java 类的加载流程是怎样的？.md","Java 类的加载流程是怎样的？","/pages/33c5d6/"],["10.基础/110.什么是双亲委派机制？.md","什么是双亲委派机制？","/pages/38bcaf/"],["10.基础/120.Java 中 sleep() 与 wait() 的区别 .md","Java 中 sleep() 与 wait() 的区别","/pages/d69890/"],["10.基础/130.简述 Java 中 final 关键字的作用.md","简述 Java 中 final 关键字的作用","/pages/2b00a3/"],["10.基础/140.String 类能不能被继承？为什么？.md","String 类能不能被继承？为什么？","/pages/73113f/"],["10.基础/150.Java 缓冲流 buffer 的用途和原理是什么？.md","Java 缓冲流 buffer 的用途和原理是什么？","/pages/115772/"],["10.基础/160.简述动态代理与静态代理 .md","简述动态代理与静态代理","/pages/37dba4/"],["10.基础/170.阻塞队列都有哪几种，有什么区别？.md","阻塞队列都有哪几种，有什么区别？","/pages/e9ce4e/"],["10.基础/180.简述 HashSet 实现原理.md","简述 HashSet 实现原理","/pages/75552c/"]]},{title:"并发",collapsable:!0,children:[["20.并发/001.线程池是如何实现的？.md","线程池是如何实现的？","/pages/0da4b0/"],["20.并发/020.简述 CAS 原理，什么是 ABA 问题，怎么解决？.md","简述 CAS 原理，什么是 ABA 问题，怎么解决？","/pages/3356c6/"],["20.并发/030.简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点.md","简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点","/pages/97245f/"],["20.并发/040.Synchronized 关键字底层是如何实现的？.md","Synchronized 与 Lock 相比优缺点分别是什么？","/pages/d5d161/"],["20.并发/050.重入锁是如何实现的？.md","重入锁是如何实现的？","/pages/9b59d1/"],["20.并发/060.volatile 关键字解决了什么问题，它的实现原理是什么？.md","volatile 关键字解决了什么问题，它的实现原理是什么？","/pages/383264/"],["20.并发/070.简述 Java 锁升级的机制.md","简述 Java 锁升级的机制","/pages/ff0616/"],["20.并发/080.简述 Java AQS 的原理以及使用场景.md","简述 Java AQS 的原理以及使用场景","/pages/52a687/"],["20.并发/090.什么是公平锁？什么是非公平锁？.md","什么是公平锁？什么是非公平锁？","/pages/fd6a59/"],["20.并发/100.Java 的线程有哪些状态，转换关系是怎么样的？.md","Java 的线程有哪些状态，转换关系是怎么样的？","/pages/52483b/"],["20.并发/110.Java 是如何实现线程安全的，哪些数据结构是线程安全的？.md","Java 是如何实现线程安全的，哪些数据结构是线程安全的？","/pages/c1f760/"],["20.并发/115.手写死锁.md","手写死锁","/pages/ce292c/"],["20.并发/120.为什么我们不能直接调用 run() 方法？.md","为什么我们不能直接调用 run() 方法？","/pages/13856f/"],["20.并发/130.Java 线程有哪些常用方法？.md","Java 线程有哪些常用方法？","/pages/a6c84e/"],["20.并发/140.手写生产者消费者模型.md","手写生产者消费者模型","/pages/2b8c6e/"],["20.并发/150.ThreadLocal 实现原理是什么？为什么要使用弱引用？.md","ThreadLocal 实现原理是什么？为什么要使用弱引用？","/pages/b3e720/"]]},{title:"JVM",collapsable:!0,children:[["30.JVM/001.Java 中垃圾回收机制中如何判断对象需要回收？.md","Java 中垃圾回收机制中如何判断对象需要回收？","/pages/948850/"],["30.JVM/010.常见的 GC 回收算法有哪些？.md","常见的 GC 回收算法有哪些？","/pages/9b26e8/"],["30.JVM/020.Java 中如何进行 GC 调优？.md","Java 中如何进行 GC 调优？","/pages/07a030/"],["30.JVM/030.JMM 中内存模型是怎样的？什么是指令序列重排序？.md","JMM 中内存模型是怎样的？什么是指令序列重排序？","/pages/c8e6cb/"],["30.JVM/040.JVM 内存是如何对应到操作系统内存的？.md","JVM 内存是如何对应到操作系统内存的？","/pages/da65e7/"],["30.JVM/050.JVM 是怎么去调优的？了解哪些参数和指令？.md","JVM 是怎么去调优的？了解哪些参数和指令？","/pages/d730dd/"],["30.JVM/060.什么是内存泄漏，怎么确定内存泄漏？.md","什么是内存泄漏，怎么确定内存泄漏？","/pages/3ab5f5/"],["30.JVM/070.简述 CMS 与 G1 机制的区别.md","简述 CMS 与 G1 机制的区别","/pages/be69af/"]]},{title:"设计模式",collapsable:!0,children:[["40.设计模式/002.实现单例设计模式（懒汉，饿汉）.md","实现单例设计模式（懒汉，饿汉）","/pages/b37ad7/"],["40.设计模式/003.什么是设计模式 .md","什么是设计模式","/pages/3d768c/"],["40.设计模式/004.工厂模式使用场景 能举个例子吗.md","工厂模式使用场景 能举个例子吗","/pages/f15489/"],["40.设计模式/005.装饰者模式.md","简述装饰者模式","/pages/47a4e3/"],["40.设计模式/010.适配器模式.md","适配器模式","/pages/827fc4/"],["40.设计模式/020.代理模式.md","代理模式","/pages/dd3a6f/"],["40.设计模式/030.责任链模式.md","责任链模式","/pages/d3ff35/"],["40.设计模式/040.模板方法模式.md","模板方法模式","/pages/43b656/"],["40.设计模式/050.策略模式.md","策略模式","/pages/78c7aa/"],["40.设计模式/060.观察模式.md","观察模式","/pages/cbff3c/"]]}],"/02.计算机基础/":[{title:"计算机网络",collapsable:!0,children:[["10.计算机网络/01.简述 TCP 三次握手以及四次挥手.md","简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？","/pages/e00207/"],["10.计算机网络/010.简述常见的 HTTP 状态码的含义.md","简述常见的 HTTP 状态码的含义","/pages/f33310/"],["10.计算机网络/020.从输入 URL 到展现页面的全过程.md","从输入 URL 到展现页面的全过程","/pages/ab48ba/"],["10.计算机网络/030.HTTP 中 GET 和 POST 区别.md","HTTP 中 GET 和 POST 区别","/pages/a0e400/"],["10.计算机网络/040.TCP 怎么保证可靠传输.md","TCP 怎么保证可靠传输","/pages/5fcc49/"],["10.计算机网络/050.什么是 TCP 粘包和拆包？.md","什么是 TCP 粘包和拆包？","/pages/2822ac/"],["10.计算机网络/060.简述 HTTPS 的加密与认证过程.md","简述 HTTPS 的加密与认证过程","/pages/12c0cc/"],["10.计算机网络/070.简述对称与非对称加密的概念.md","简述对称与非对称加密的概念","/pages/057092/"],["10.计算机网络/080.TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？.md","TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？","/pages/cc4b24/"],["10.计算机网络/090.如何解决 TCP 传输丢包问题？.md","如何解决 TCP 传输丢包问题？","/pages/a656a9/"],["10.计算机网络/100.TCP 长连接和短连接有那么不同的使用场景？.md","TCP 长连接和短连接有那么不同的使用场景？","/pages/dda19e/"],["10.计算机网络/110.TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？.md","TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？","/pages/212438/"],["10.计算机网络/120.HTTP 与 HTTPS 有哪些区别？.md","HTTP 与 HTTPS 有哪些区别？","/pages/253334/"],["10.计算机网络/130.TCP 中常见的拥塞控制算法有哪些？.md","TCP 中常见的拥塞控制算法有哪些？","/pages/9ccc31/"],["10.计算机网络/140.简述 HTTP 1.0，1.1，2.0 的主要区别 .md","简述 HTTP 1.0，1.1，2.0 的主要区别","/pages/f50b70/"],["10.计算机网络/150.从系统层面上，UDP如何保证尽量可靠？.md","从系统层面上，UDP如何保证尽量可靠？","/pages/e57cfe/"],["10.计算机网络/160.TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？.md","TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？","/pages/15d37a/"],["10.计算机网络/170.简述 TCP 滑动窗口.md","简述 TCP 滑动窗口","/pages/dae451/"],["10.计算机网络/171. 简述TCP重传机制.md","简述TCP重传机制","/pages/a219df/"],["10.计算机网络/180.简述 JWT 的原理和校验机制.md","简述 JWT 的原理和校验机制","/pages/34d064/"],["10.计算机网络/190.为什么需要序列化？有什么序列化的方式？.md","为什么需要序列化？有什么序列化的方式？","/pages/68d6c8/"],["10.计算机网络/200.简述 iPv4 和 iPv6 的区别.md","简述 iPv4 和 iPv6 的区别","/pages/6a2e50/"],["10.计算机网络/210.TCP 中 SYN 攻击是什么？如何防止？.md","TCP 中 SYN 攻击是什么？如何防止？","/pages/d0c6d3/"],["10.计算机网络/220.简述 DDOS 攻击原理，如何防范它？.md","简述 DDOS 攻击原理，如何防范它？","/pages/056828/"],["10.计算机网络/230.什么是 ARP 协议？简述其使用场景.md","什么是 ARP 协议？简述其使用场景","/pages/665162/"],["10.计算机网络/240.什么是跨域，什么情况下会发生跨域请求？.md","什么是跨域，什么情况下会发生跨域请求？","/pages/eadd05/"],["10.计算机网络/250.Cookie 和 Session 的关系和区别是什么？.md","Cookie 和 Session 的关系和区别是什么？","/pages/980cc7/"],["10.计算机网络/260.简述 WebSocket 是如何进行传输的.md","简述 WebSocket 是如何进行传输的","/pages/172129/"],["10.计算机网络/270.DNS 查询服务器的基本流程是什么？DNS 劫持是什么？.md","DNS 查询服务器的基本流程是什么？DNS 劫持是什么？","/pages/017113/"],["10.计算机网络/280.RestFul 是什么？RestFul 请求的 URL 有什么特点？.md","RestFul 是什么？RestFul 请求的 URL 有什么特点？","/pages/c08bb6/"],["10.计算机网络/290.简述 HTTP 报文头部的组成结构.md","简述 HTTP 报文头部的组成结构","/pages/dfb780/"]]},{title:"操作系统",collapsable:!0,children:[["20.操作系统/01.进程间有哪些通信方式？.md","进程间有哪些通信方式？","/pages/e5f2d7/"],["20.操作系统/010.简述自旋锁与互斥锁的使用场景.md","简述自旋锁与互斥锁的使用场景","/pages/9e6232/"],["20.操作系统/020.进程和线程之间有什么区别？.md","进程和线程之间有什么区别？","/pages/c2fd8a/"],["20.操作系统/030.简述几个常用的 Linux 命令以及他们的功能.md","简述几个常用的 Linux 命令以及他们的功能","/pages/198887/"],["20.操作系统/060.进程有多少种状态？.md","进程有多少种状态？","/pages/165ea8/"],["20.操作系统/070.简述 select, poll, epoll 的使用场景以及区别.md","简述 select, poll, epoll 的使用场景以及区别","/pages/68ea00/"],["20.操作系统/080.Linux 下如何排查 CPU 以及 内存占用过多？.md","Linux 下如何排查 CPU 以及 内存占用过多？","/pages/b043a6/"],["20.操作系统/090.进程通信中的管道实现原理是什么？.md","进程通信中的管道实现原理是什么？","/pages/8e880a/"],["20.操作系统/100.Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？.md","Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？","/pages/326cf9/"],["20.操作系统/110.如何调试服务器内存占用过高的问题？.md","如何调试服务器内存占用过高的问题？","/pages/3653a2/"],["20.操作系统/120.Linux 如何查看实时的滚动日志？.md","Linux 如何查看实时的滚动日志？","/pages/f6e4d2/"],["20.操作系统/130.简述 Linux 零拷贝的原理.md","简述 Linux 零拷贝的原理","/pages/b43547/"],["20.操作系统/140.为什么进程切换慢，线程切换快？.md","为什么进程切换慢，线程切换快？","/pages/773d64/"],["20.操作系统/150.简述创建进程的流程.md","简述创建进程的流程","/pages/c64d20/"],["20.操作系统/160.简述 Linux 虚拟内存的页面置换算法.md","简述 Linux 虚拟内存的页面置换算法","/pages/93b870/"],["20.操作系统/170.简述 Linux 进程调度的算法.md","简述 Linux 进程调度的算法","/pages/36fd29/"],["20.操作系统/180.什么时候会由用户态陷入内核态？.md","什么时候会由用户态陷入内核态？","/pages/b84950/"],["20.操作系统/190.Linux 下如何查看端口被哪个进程占用？.md","Linux 下如何查看端口被哪个进程占用？","/pages/4c2d8e/"],["20.操作系统/200.Linux 中虚拟内存和物理内存有什么区别？有什么优点？.md","Linux 中虚拟内存和物理内存有什么区别？有什么优点？","/pages/3bab8c/"],["20.操作系统/210.简述 traceroute 命令的原理.md","简述 traceroute 命令的原理","/pages/655f8f/"],["20.操作系统/220.简述IO模型.md","简述IO模型","/pages/782c23/"]]},{title:"数据结构",collapsable:!0,children:[["30.数据结构/01.数组.md","数组","/pages/a25c3a/"],["30.数据结构/02.链表.md","链表","/pages/f376bd/"],["30.数据结构/10.栈.md","栈","/pages/f27af6/"],["30.数据结构/20.队列.md","队列","/pages/308e3b/"],["30.数据结构/30.树.md","树","/pages/c29bff/"],["30.数据结构/40.图.md","图","/pages/83330c/"]]},{title:"算法",collapsable:!0,children:[["40.算法/01.递归.md","递归","/pages/92288a/"],["40.算法/10.时间复杂度.md","时间复杂度","/pages/fd9be6/"],["40.算法/20.排序.md","排序","/pages/3205b9/"],["40.算法/30.二分查找.md","二分查找","/pages/e53094/"],["40.算法/40.双指针.md","双指针","/pages/30153a/"]]},{title:"剑指Offer题解",collapsable:!0,children:[["50.剑指Offer题解/01.数组与矩阵.md","数组与矩阵","/pages/5fd35f/"],["50.剑指Offer题解/05.栈队列堆.md","栈队列堆","/pages/8d145e/"],["50.剑指Offer题解/06.双指针.md","双指针","/pages/4b7917/"],["50.剑指Offer题解/10.链表.md","链表","/pages/f55bff/"],["50.剑指Offer题解/15.树.md","树","/pages/873a10/"],["50.剑指Offer题解/20.贪心.md","贪心","/pages/b54770/"],["50.剑指Offer题解/25.分治.md","分治","/pages/87a843/"],["50.剑指Offer题解/30.排序.md","排序","/pages/d3dd7b/"],["50.剑指Offer题解/35.动态规划.md","动态规划","/pages/6546a2/"],["50.剑指Offer题解/40.数学.md","数学","/pages/9c176f/"]]}],"/03.数据库/":[{title:"MYSQL相关",collapsable:!0,children:[["01.MYSQL相关/001.MySQL中 InnoDB 和 MylSAM 的区别是什么？.md","MySQL中 InnoDB 和 MylSAM 的区别是什么？","/pages/3a8659/"],["01.MYSQL相关/006.聚簇索引和非聚簇索引有什么区别？.md","聚簇索引和非聚簇索引有什么区别？","/pages/a5adb0/"],["01.MYSQL相关/007.简述 MySQL 常见索引类型，介绍一下覆盖索引.md","简述 MySQL 常见索引类型，介绍一下覆盖索引","/pages/17b014/"],["01.MYSQL相关/010.简述Mysql的事务隔离级别.md","简述Mysql的事务隔离级别","/pages/9f2936/"],["01.MYSQL相关/015.说一下Mysql锁.md","说一下Mysql锁","/pages/b17e88/"],["01.MYSQL相关/020.MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么.md","MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么","/pages/bc5538/"],["01.MYSQL相关/030.简述乐观锁以及悲观锁的区别以及使用场景.md","简述乐观锁以及悲观锁的区别以及使用场景","/pages/57561d/"],["01.MYSQL相关/040.简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？.md","简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？","/pages/36672c/"],["01.MYSQL相关/050.简述什么是最左匹配原则.md","简述什么是最左匹配原则","/pages/7a1f1e/"],["01.MYSQL相关/060.MySQL 联合索引底层原理是什么？.md","MySQL 联合索引底层原理是什么？","/pages/52773a/"],["01.MYSQL相关/070.产生死锁的必要条件有哪些？如何解决死锁？.md","产生死锁的必要条件有哪些？如何解决死锁？","/pages/f4cf50/"],["01.MYSQL相关/080.简述常见的负载均衡算法.md","简述常见的负载均衡算法","/pages/f2dbbe/"],["01.MYSQL相关/090.简述 MySQL 的主从同步机制，如果同步失败会怎么样？.md","简述 MySQL 的主从同步机制，如果同步失败会怎么样？","/pages/1ac30e/"],["01.MYSQL相关/100.如何设计数据库压测方案？.md","如何设计数据库压测方案？","/pages/a8eb47/"],["01.MYSQL相关/110.简述数据库中什么情况下进行分库，什么情况下进行分表？.md","简述数据库中什么情况下进行分库，什么情况下进行分表？","/pages/ac0bb8/"],["01.MYSQL相关/120.数据库的读写分离的作用是什么？如何实现？.md","数据库的读写分离的作用是什么？如何实现？","/pages/f62359/"],["01.MYSQL相关/130.简述 undo log 和 redo log 的作用.md","简述 undo log 和 redo log 的作用","/pages/7bbbf6/"],["01.MYSQL相关/140.什么是 SQL 注入攻击？如何防止这类攻击？.md","什么是 SQL 注入攻击？如何防止这类攻击？","/pages/b4338e/"],["01.MYSQL相关/150.MySQL 中 join 与 left join 的区别是什么？.md","MySQL 中 join 与 left join 的区别是什么？","/pages/429100/"],["01.MYSQL相关/160.简述 MySQL MVCC 的实现原理 .md","简述 MySQL MVCC 的实现原理","/pages/1656d8/"],["01.MYSQL相关/170.MySQL 中 varchar 和 char 的区别是什么？.md","MySQL 中 varchar 和 char 的区别是什么？","/pages/d97948/"],["01.MYSQL相关/180.模糊查询是如何实现的？.md","模糊查询是如何实现的？","/pages/32696d/"]]},{title:"REDIS相关",collapsable:!0,children:[["02.REDIS相关/001.Redis 有几种数据结构？Zset 是如何实现的？.md","Redis 有几种数据结构？Zset 是如何实现的？","/pages/d70c1f/"],["02.REDIS相关/002.为什么 Redis 在单线程下能如此快？.md","为什么 Redis 在单线程下能如此快？","/pages/d66211/"],["02.REDIS相关/005.简述 Redis 字符串的底层结构.md","简述 Redis 字符串的底层结构","/pages/34aec2/"],["02.REDIS相关/010.Redis的缓存淘汰策略有哪些？.md","Redis的缓存淘汰策略有哪些？","/pages/9326cc/"],["02.REDIS相关/020.简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点.md","简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点","/pages/7e708d/"],["02.REDIS相关/030.Redis 如何实现分布式锁？.md","Redis 如何实现分布式锁？","/pages/656f46/"],["02.REDIS相关/040.简述 Redis 集群配置以及基础原理.md","简述 Redis 集群配置以及基础原理","/pages/338e30/"],["02.REDIS相关/050.简述 Redis 中跳表的应用以及优缺点.md","简述 Redis 中跳表的应用以及优缺点","/pages/a42826/"],["02.REDIS相关/060.Redis 中，sentinel 和 cluster 的区别和适用场景是什么？.md","Redis 中，sentinel 和 cluster 的区别和适用场景是什么？","/pages/e2e910/"],["02.REDIS相关/070.简述 Redis 中如何防止缓存雪崩和缓存击穿.md","简述 Redis 中如何防止缓存雪崩和缓存击穿","/pages/03cd25/"],["02.REDIS相关/080.简述 Redis 的线程模型以及底层架构设计.md","简述 Redis 的线程模型以及底层架构设计","/pages/9c28c9/"],["02.REDIS相关/100.简述 Redis 的哨兵机制.md","简述 Redis 的哨兵机制","/pages/cc8507/"],["02.REDIS相关/110.简述 Redis 如何处理热点 key 访问.md","简述 Redis 如何处理热点 key 访问","/pages/795c09/"],["02.REDIS相关/120.Redis 序列化有哪些方式？.md","Redis 序列化有哪些方式？","/pages/0d3c6b/"]]}],"/04.中间件/":[{title:"Netty",collapsable:!0,children:[["10.Netty/001.你熟悉哪些IO模型？.md","Netty","/pages/40f3c9/"],["10.Netty/010.TCP粘包拆包问题的解决之道.md","TCP粘包拆包问题的解决之道","/pages/3db019/"],["10.Netty/015.Netty中有哪些解码器？.md","Netty中有哪些解码器？","/pages/59089d/"],["10.Netty/020.为什么Netty要自己写一个ByteBuf.md","为什么Netty要自己写一个ByteBuf","/pages/ef17ee/"],["10.Netty/030.ChannelPipeline和ChannelHandler.md","ChannelPipeline和ChannelHandler","/pages/f851b6/"],["10.Netty/040.EventLoop和EventLoopGroup.md","EventLoop和EventLoopGroup","/pages/e7aa60/"],["10.Netty/050.Java NIO了解吗？.md","Java NIO了解吗？","/pages/bfdcc8/"]]},{title:"Kafka",collapsable:!0,children:[["40.Kafka/001.Kafka包含那几部分.md","Kafka","/pages/561f34/"],["40.Kafka/010.生产者.md","生产者","/pages/fe7ca2/"],["40.Kafka/020.消费者.md","消费者","/pages/fed167/"],["40.Kafka/030.集群下的Kafka要考虑哪些事情.md","集群下的Kafka要考虑哪些事情","/pages/8d1d04/"],["40.Kafka/040.如何保证Kafka的可靠性.md","如何保证Kafka的可靠性","/pages/76a94c/"]]}],"/08.系统设计/":[["001.系统设计.md","系统设计","/pages/01b9b2/"],["005.电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？.md","电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？","/pages/379160/"],["006.如何解决缓存与数据库不一致的问题？.md","如何解决缓存与数据库不一致的问题？","/pages/ac945d/"],["010.什么是 CAP ？什么是最终一致性？什么是幂等操作？.md","什么是 CAP ？什么是最终一致性？什么是幂等操作？","/pages/20c647/"],["020.简述什么是两阶段提交？.md","简述什么是两阶段提交？","/pages/4eae5b/"],["021.设计 Tiny URL 系统.md","设计 Tiny URL 系统","/pages/7c8753/"],["022.如何实现唯一的分布式 ID.md","如何实现唯一的分布式 ID","/pages/e5252b/"],["023.如何设计定时任务系统.md","如何设计定时任务系统","/pages/d01475/"],["024.电商-商品系统设计.md","电商-商品系统设计","/pages/bb7e83/"]],"/10.非技术/":[["01.非技术问题.md","非技术问题","/pages/5e507a/"],["02.关于空降兵的思考.md","关于空降兵的思考","/pages/a734ce/"],["03.能力差的人是什么样的？.md","能力差的人都是什么样的？","/pages/fe4651/"],["04.如何提升技术水平？.md","如何提升技术水平？","/pages/c7084e/"],["05.上级让下级干活的4中方式.md","上级让下级干活的4中方式","/pages/83653c/"],["06.正确认识Backup.md","正确认识Backup","/pages/ea7ab6/"],["07.对事不对人 vs 对人不对事.md","对事不对人 vs 对人不对事","/pages/74395b/"],["08.关于如何写OKR.md","关于如何写OKR","/pages/6ac68e/"]],"/15.关于/":[["01.关于.md","关于","/about"]]},author:{name:"YoungAnn",link:"https://github.com/AdmireAn/JavaDriver"},blogger:{avatar:"https://tva1.sinaimg.cn/large/e6c9d24egy1h2f580pnmdj213w0u0422.jpg",name:"YoungAnn",slogan:"西二旗Java老司机一枚 致力于社会主义添砖Java"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:854818303@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/AdmireAn"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2022,copyrightInfo:'YoungAnnn | <a href="https://github.com/AdmireAn/JavaDriver" target="_blank">MIT License</a>'},htmlModules:{homeSidebarB:'<div style="padding: 0.95rem">\n    <p style="\n      color: var(--textColor);\n      opacity: 0.9;\n      font-size: 20px;\n      font-weight: bold;\n      margin: 0 0 8px 0;\n    ">问题反馈</p>\n    <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2h0q9m8wzj20b40b4myw.jpg"  style="width:100%;" />\n    [<b>扫码反馈</b>]<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>\n    </p>\n    </div>'}},locales:{"/":{lang:"zh-CN",title:"JavaDriver",description:"Java学习与总结",path:"/"}}},ss=(t(159),t(219),t(148),t(229)),cs=t(230),ds=(t(394),t(244),t(43));var us={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,a=e.home;return!(t||!1===r||!0===a)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(ds.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(ds.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(ds.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,a){var i=n[r].frontmatter,o=i.categories,l=i.tags;"array"===Object(ds.n)(o)&&o.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(ds.n)(l)&&l.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},a=0,i=n.length;a<i;a++)r(a);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var a in n.tags)t.push({key:a,length:n.tags[a].length});return{categories:e,tags:t}}(this.$groupPosts)}}};ja.component(ss.default),ja.component(cs.default);function ps(n){return n.toString().padStart(2,"0")}t(398);ja.component("Badge",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,713))})),ja.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,230))})),ja.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,229))}));t(399);var hs,fs,ms=t(50),gs=(t(402),t(142),t(228)),vs=t.n(gs),bs=t(107);"valine"===(fs="gitalk")?t.e(213).then(t.t.bind(null,502,7)).then((function(n){return n.default})):"gitalk"===fs&&Promise.all([t.e(0),t.e(212)]).then(t.t.bind(null,503,7)).then((function(){return t.e(211).then(t.t.bind(null,504,7))})).then((function(n){return hs=n.default}));function ys(n,e){var t={};return Reflect.ownKeys(n).forEach((function(r){if("string"==typeof n[r])try{t[r]=vs.a.render(n[r],e)}catch(e){console.warn('Comment config option error at key named "'.concat(r,'"')),console.warn("More info: ".concat(e.message)),t[r]=n[r]}else t[r]=n[r]})),t}console.log('How to use "'.concat("gitalk",'" in ').concat(bs.name,"@v").concat(bs.version,":"),bs.homepage);var Es={render:function(n,e){var t=document.createElement("div");t.id=e,document.querySelector("main.page").appendChild(t),new hs(ys({clientID:"0da91d0586b0f2ec6868",clientSecret:"c8e2f12b870b53708500bd8c368b55c07f915034",repo:"blog-gitalk-comment",owner:"YoungAnnn",admin:["YoungAnnn"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear:function(n){var e=document.querySelector("#".concat(n));return e&&e.remove(),!0}},xs=null;function ks(n){return Es.clear("vuepress-plugin-comment")}function ws(n){return!1!==n.comment&&!1!==n.comments}function Ts(n){if(clearTimeout(xs),document.querySelector("main.page"))return Es.render(n,"vuepress-plugin-comment");xs=setTimeout((function(){return Ts(n)}),200)}var As={mounted:function(){var n=this;xs=setTimeout((function(){var e=Object(ms.a)({to:{},from:{}},n.$frontmatter);ks()&&ws(e)&&Ts(e)}),1e3),this.$router.afterEach((function(e,t){if(!e||!t||e.path!==t.path){var r=Object(ms.a)({to:e,from:t},n.$frontmatter);ks()&&ws(r)&&Ts(r)}}))}},Ss=Object(as.a)(As,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports,Bs=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,a=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(ps(n.getUTCMonth()+1),"-").concat(ps(n.getUTCDate())," ").concat(ps(n.getUTCHours()),":").concat(ps(n.getUTCMinutes()),":").concat(ps(n.getUTCSeconds()))}(r)),a?n.author=a:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(us)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},function(n){var e=n.router;"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),e.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},function(n){n.Vue.component("Comment",Ss)}],Is=["Comment"];t(222);function Cs(n,e){return(Cs=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(223);function _s(n){return(_s=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function Ps(n,e){if(e&&("object"===So(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function zs(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=_s(n);if(e){var a=_s(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return Ps(this,t)}}var js=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&Cs(n,e)}(t,n);var e=zs(t);function t(){return cl(this,t),e.apply(this,arguments)}return ul(t)}(function(){function n(){cl(this,n),this.store=new ja({data:{state:{}}})}return ul(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){ja.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(js.prototype,{getPageAsyncComponent:Uo,getLayoutAsyncComponent:Jo,getAsyncComponent:Ho,getVueComponent:Ko});var Ls={install:function(n){var e=new js;n.$vuepress=e,n.prototype.$vuepress=e}};function Os(n){n.beforeEach((function(e,t,r){if(Ds(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var a=e.path.replace(/\/$/,"")+".html";Ds(n,a)?r(a):r()}else r();else{var i=e.path+"/",o=e.path+".html";Ds(n,o)?r(o):Ds(n,i)?r(i):r()}}))}function Ds(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var Ms={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Go("pageKey",e),ja.component(e)||ja.component(e,Uo(e)),ja.component(e)?n(e):n("")}},Rs={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},Fs={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ns=(t(407),t(408),Object(as.a)(Fs,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function qs(){return(qs=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,a,i;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ls.routerBase||ls.base,Os(r=new To({base:t,mode:"history",fallback:!1,routes:os,scrollBehavior:function(n,e,t){return t||(n.hash?!ja.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),a={},n.prev=4,n.next=7,Promise.all(Bs.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:ja,options:a,router:r,siteData:ls,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return i=new ja(Object.assign(a,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Is.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:i,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}ja.config.productionTip=!1,ja.use(To),ja.use(Ls),ja.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ja;Ao(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),a=new r,i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),o={};return Object.keys(i).reduce((function(n,e){return e.startsWith("$")&&(n[e]=i[e].get),n}),o),{computed:o}}((function(n){return function(){function e(){cl(this,e)}return ul(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var a in r)"/"===a?e=r[a]:0===this.$page.path.indexOf(a)&&(n=r[a]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),ls)),ja.component("Content",Ms),ja.component("ContentSlotsDistributor",Rs),ja.component("OutboundLink",Ns),ja.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),ja.component("Layout",Jo("Layout")),ja.component("NotFound",Jo("NotFound")),ja.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"2d146fda"},function(n){return qs.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);