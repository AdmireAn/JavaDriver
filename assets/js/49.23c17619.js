(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{551:function(a,v,t){"use strict";t.r(v);var r=t(21),_=Object(r.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"java-内存模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-内存模型"}},[a._v("#")]),a._v(" Java 内存模型")]),a._v(" "),t("p",[a._v("同一套内存模型规范，不同语言在实现上可能会有些差别。接下来着重讲一下 Java 内存模型实现原理。")]),a._v(" "),t("p",[a._v("Java 运行时内存区域与硬件内存的关系")]),a._v(" "),t("p",[a._v("了解过 JVM 的同学都知道，JVM 运行时内存区域是分片的，分为栈、堆等，其实这些都是 JVM 定义的逻辑概念。在传统的硬件内存架构中是没有栈和堆这种概念。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h6azfyvt0oj20hs081aaf.jpg",alt:""}})]),a._v(" "),t("p",[a._v("从图中可以看出栈和堆既存在于高速缓存中又存在于主内存中，所以两者并没有很直接的关系。")]),a._v(" "),t("h2",{attrs:{id:"java-线程与主内存的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-线程与主内存的关系"}},[a._v("#")]),a._v(" Java 线程与主内存的关系")]),a._v(" "),t("p",[a._v("Java 内存模型是一种规范，定义了很多东西：")]),a._v(" "),t("p",[a._v("所有的变量都存储在主内存（Main Memory）中。\n每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的拷贝副本。\n线程对变量的所有操作都必须在本地内存中进行，而不能直接读写主内存。\n不同的线程之间无法直接访问对方本地内存中的变量。\n看文字太枯燥了，我又画了一张图：")]),a._v(" "),t("h2",{attrs:{id:"线程间通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程间通信"}},[a._v("#")]),a._v(" 线程间通信")]),a._v(" "),t("p",[a._v("如果两个线程都对一个共享变量进行操作，共享变量初始值为 1，每个线程都变量进行加 1，预期共享变量的值为 3。在 JMM 规范下会有一系列的操作。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h6azg831isj20hs0di3z5.jpg",alt:""}})]),a._v(" "),t("p",[a._v("为了更好的控制主内存和本地内存的交互，Java 内存模型定义了八种操作来实现：")]),a._v(" "),t("ul",[t("li",[a._v("lock：锁定。作用于主内存的变量，把一个变量标识为一条线程独占状态。")]),a._v(" "),t("li",[a._v("unlock：解锁。作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。")]),a._v(" "),t("li",[a._v("read：读取。作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用")]),a._v(" "),t("li",[a._v("load：载入。作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。")]),a._v(" "),t("li",[a._v("use：使用。作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。")]),a._v(" "),t("li",[a._v("assign：赋值。作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。")]),a._v(" "),t("li",[a._v("store：存储。作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。")]),a._v(" "),t("li",[a._v("write：写入。作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。\n注意：工作内存也就是本地内存的意思。")])]),a._v(" "),t("h2",{attrs:{id:"有态度的总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有态度的总结"}},[a._v("#")]),a._v(" 有态度的总结")]),a._v(" "),t("p",[a._v("由于CPU 和主内存间存在数量级的速率差，想到了引入了多级高速缓存的传统硬件内存架构来解决，多级高速缓存作为 CPU 和主内间的缓冲提升了整体性能。解决了速率差的问题，却又带来了缓存一致性问题。")]),a._v(" "),t("p",[a._v("数据同时存在于高速缓存和主内存中，如果不加以规范势必造成灾难，因此在传统机器上又抽象出了内存模型。")]),a._v(" "),t("p",[a._v("Java 语言在遵循内存模型的基础上推出了 JMM 规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。")]),a._v(" "),t("p",[a._v("为了更精准控制工作内存和主内存间的交互，JMM 还定义了八种操作：lock, unlock, read, load,use,assign, store, write。")]),a._v(" "),t("p",[a._v("好了，今天就给大家介绍到这里，简单总结下Java内存模型的定义：Java内存模型并不是一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发操作不会产生歧义；但是，也必须得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存等）来获取更好的执行速度。经过长时间的验证和修补，在JDK1.5发布后，Java内存模型就已经成熟和完善起来了。")]),a._v(" "),t("p",[a._v("参考：\n"),t("a",{attrs:{href:"https://baijiahao.baidu.com/s?id=1700599301374287320&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"}},[a._v("全面学习掌握Java内存模型"),t("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=_.exports}}]);