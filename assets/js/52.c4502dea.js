(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{554:function(t,a,r){"use strict";r.r(a);var e=r(21),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"g1特有数据结构和算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1特有数据结构和算法"}},[t._v("#")]),t._v(" G1特有数据结构和算法")]),t._v(" "),r("h3",{attrs:{id:"region"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#region"}},[t._v("#")]),t._v(" Region")]),t._v(" "),r("p",[t._v("堆仍然有新生代(eden、survivor)、老年代的划分，但是不再要求它们是内存连续的。每个区都由多个Region组成。\n部分老年代Region存储Humongous对象(即下图的H)，这种对象大小大于等于Region的一半。\n"),r("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h6b2i7la2aj20iu0akdgh.jpg",alt:""}})]),t._v(" "),r("p",[t._v("(图片来源-Java Hotspot G1 GC的一些关键技术)")]),t._v(" "),r("h3",{attrs:{id:"satb算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#satb算法"}},[t._v("#")]),t._v(" SATB算法")]),t._v(" "),r("p",[t._v("全称Snapshot-At-The-Beginning，起始时活对象的快照。在理解SATB前需要先了解以下知识。")]),t._v(" "),r("h3",{attrs:{id:"三色标记法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三色标记法"}},[t._v("#")]),t._v(" 三色标记法")]),t._v(" "),r("p",[t._v("CMS和G1的算法都是通过对gc root 进行遍历，并进行三色标记。标记规则为")]),t._v(" "),r("p",[t._v("黑色(black): 节点被遍历完成，而且子节点都遍历完成。\n灰色(gray): 当前正在遍历的节点，而且子节点（即对象的域）还没有遍历。遍历完所有子节点后，将成为黑色\n白色(white): 还没有遍历到的节点，即灰色节点的子节点。扫描结束仍是白色时会被回收。\n并发扫描时，对于白色有两种情况同时发生时，可能会漏标导致被误回收：")]),t._v(" "),r("p",[t._v("增加了被黑色引用的关系。\n被灰色下应用，删除了到它的引用\n具体执行过程：https://www.cnblogs.com/javaadu/p/10713956.html")]),t._v(" "),r("p",[t._v("按照R大的说法：CMS的incremental update设计使得它在remark阶段必须重新扫描所有线程栈和整个young gen作为root；G1的SATB设计在remark阶段则只需要扫描剩下的satb_mark_queue。")]),t._v(" "),r("h3",{attrs:{id:"rset"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rset"}},[t._v("#")]),t._v(" RSet")]),t._v(" "),r("p",[t._v("全称Remember Set，记录一个Region里的对象被哪些其他Region引用。\n相对应地，有另一种辅助数据结构Collection Set（CSet），它记录了GC要收集的Region集合。GC时只需扫描CSet中各个Rset即可。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h6b2ihn8mfj20gf0a1aad.jpg",alt:""}}),t._v("\n(Tips for Tuning the Garbage First Garbage Collector)")]),t._v(" "),r("p",[t._v("更详细的访问机制和回收过程这里不再展开，有兴趣可以参考后文引用文献。")]),t._v(" "),r("p",[t._v("Pause Prediction Model\n暂停预测模型，G1根据它计算出的历史数据来预测本次收集需要选择的Region数量，从而尽量满足用户设定的目标停顿时间。\n具体算法和公式略，可见Java Hotspot G1 GC的一些关键技术")]),t._v(" "),r("h3",{attrs:{id:"垃圾回收过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收过程"}},[t._v("#")]),t._v(" 垃圾回收过程")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h6b2isd0khj20u406kmxx.jpg",alt:""}}),t._v("\n分为以下几步：")]),t._v(" "),r("p",[t._v("初始标记（Initial Mark）—— 标记GC root能直接关联的对象（短暂STW）\n并发标记（Concurrent mark）—— GCRootsTracing，从并发标记中的root遍历，对不可达的对象进行标记，耗时长但可并行\n最终标记（Final Remark）—— 收集并发标记期间产生的新垃圾（短暂STW）,采用了SATB算法比CMS更快\n筛选回收（Live Data Counting and Evacuation）—— 对各个Region的回收性价比排序，在保证时间可控的情况下清除失活对象，清除Remember Sets\n作为对比，CMS的回收过程\n"),r("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h6b2iyik1ij20ug06g750.jpg",alt:""}})]),t._v(" "),r("p",[t._v("初始标记（CMS Initial Mark）—— 标记GC root能直接关联的对象（短暂STW）\n并发标记（CMS Concurrent Mark）—— GCRootsTracing，从并发标记中的root遍历，对不可达的对象进行标记\n重新标记（CMS Remark）—— 修正并发标记期间因为用户操作导致标记发生变更的对象，有STW\n并发清除（CMS Concurrent Sweep）")]),t._v(" "),r("h3",{attrs:{id:"与cms相比的优势"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#与cms相比的优势"}},[t._v("#")]),t._v(" 与CMS相比的优势")]),t._v(" "),r("p",[t._v("并发度更高，充分利用CPU多线程 —— CMS对CPU资源敏感，需要占用25%的线程，如果核数小于4更会占用一半的资源。\n整体上是标记-整理(分代)，局部是复制(分Region)，运行期不产生碎片 —— CMS是标记-清除，会产生空间碎片和本次回收期间产生导致本次无法回收的浮动垃圾\n可预测的停顿(基于Region)")]),t._v(" "),r("h2",{attrs:{id:"cms"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cms"}},[t._v("#")]),t._v(" CMS")]),t._v(" "),r("h3",{attrs:{id:"什么是cms"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是cms"}},[t._v("#")]),t._v(" 什么是CMS？")]),t._v(" "),r("p",[t._v("Concurrent Mark Sweep。")]),t._v(" "),r("p",[t._v("看名字就知道，CMS是一款并发、使用标记-清除算法的gc。")]),t._v(" "),r("p",[t._v("CMS是针对老年代进行回收的GC。")]),t._v(" "),r("h3",{attrs:{id:"cms有什么用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cms有什么用"}},[t._v("#")]),t._v(" CMS有什么用？")]),t._v(" "),r("p",[t._v("CMS以获取最小停顿时间为目的。")]),t._v(" "),r("p",[t._v("在一些对响应时间有很高要求的应用或网站中，用户程序不能有长时间的停顿，CMS 可以用于此场景。")]),t._v(" "),r("h3",{attrs:{id:"cms如何执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cms如何执行"}},[t._v("#")]),t._v(" CMS如何执行？")]),t._v(" "),r("p",[t._v("总体来说CMS的执行过程可以分为以下几个阶段：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("      3.1 初始标记(STW)\n\n      3.2 并发标记\n\n      3.3 并发预清理\n\n      3.4 重标记(STW)\n\n      3.5 并发清理\n\n      3.6 重置\n")])])]),r("p",[t._v("参考：\n"),r("a",{attrs:{href:"https://www.bbsmax.com/A/QV5Z37vydy/",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于GC(下)：CMS和G1GC的比较"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://www.cnblogs.com/lzmrex/articles/12887198.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("详解CMS垃圾回收机制"),r("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);