(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{528:function(t,v,_){"use strict";_.r(v);var r=_(21),e=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"简述动态代理与静态代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简述动态代理与静态代理"}},[t._v("#")]),t._v(" 简述动态代理与静态代理")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th"),t._v(" "),_("th",[t._v("静态代理")]),t._v(" "),_("th",[t._v("动态代理")])])]),t._v(" "),_("tbody",[_("tr",[_("td"),t._v(" "),_("td",[t._v("由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的 .class 文件就已经存在了")]),t._v(" "),_("td",[t._v("在程序运行时运用反射机制动态创建而成，动态就是在程序运行时生成的，而不是编译时。")])]),t._v(" "),_("tr",[_("td",[t._v("应用场景")]),t._v(" "),_("td",[t._v("AspectJ AOP")]),t._v(" "),_("td",[t._v("Spring AOP、RPC 框架")])]),t._v(" "),_("tr",[_("td",[t._v("优点")]),t._v(" "),_("td",[t._v("在不修改目标对象的前提下，可以通过代理对象对目标对象功能扩展")]),t._v(" "),_("td",[t._v("不会会产生很多静态类，通过一个代理类完成全部的代理功能")])]),t._v(" "),_("tr",[_("td",[t._v("缺点")]),t._v(" "),_("td",[t._v("1.代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。"),_("br"),t._v(" 2.代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。")]),t._v(" "),_("td")])])]),t._v(" "),_("blockquote",[_("p",[t._v("1.AspectJ 的底层技术就是静态代理，用一种 AspectJ 支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。"),_("br"),t._v("\n2.JDK 动态代理："),_("br")]),t._v(" "),_("ul",[_("li",[t._v("代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理"),_("br")]),t._v(" "),_("li",[t._v("代理对象的生成，是通过 JDK 的 API（反射机制），动态的在内存中构建代理对象，在 Java 中要想实现动态代理机制，需要 java.lang.reflect.InvocationHandler 接口和 java.lang.reflect.Proxy 类的支持"),_("br"),t._v("\n3.cglib 代理:")]),t._v(" "),_("li",[t._v("静态代理和 JDK 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。"),_("br"),t._v("\n*cglib (opens new window)(Code Generation Library)是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。cglib 通过继承方式实现代理。它广泛的被许多 AOP 的框架使用，比如我们的 Spring AOP。"),_("br"),t._v("\n*cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。"),_("br"),t._v("\n*cglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。"),_("br")])])])])}),[],!1,null,null,null);v.default=e.exports}}]);