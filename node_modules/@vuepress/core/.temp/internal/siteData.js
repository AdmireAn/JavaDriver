/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "",
  "description": "",
  "base": "/JavaDriver/",
  "headTags": [
    [
      "link",
      {
        "rel": "icon",
        "href": "/JavaDriver/img/JAVADRIVER.png"
      }
    ],
    [
      "meta",
      {
        "name": "keywords",
        "content": "Java相关技术"
      }
    ],
    [
      "meta",
      {
        "name": "baidu-site-verification",
        "content": "7F55weZDDc"
      }
    ],
    [
      "meta",
      {
        "name": "theme-color",
        "content": "#11a8cd"
      }
    ]
  ],
  "pages": [
    {
      "title": "Java相关",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "01.Java相关",
            "imgUrl": "/img/web.png",
            "description": "Java基础、JVM、并发、设计模式"
          }
        },
        "title": "Java相关",
        "date": "2020-03-11T21:50:53.000Z",
        "permalink": "/java",
        "sidebar": false,
        "article": false,
        "comment": false,
        "editLink": false
      },
      "regularPath": "/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.Java%E7%9B%B8%E5%85%B3.html",
      "relativePath": "00.目录页/01.Java相关.md",
      "key": "v-36edf5bb",
      "path": "/java/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "计算机基础",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "02.计算机基础",
            "imgUrl": "/img/ui.png",
            "description": "计算机网络、数据结构、"
          }
        },
        "title": "计算机基础",
        "date": "2020-03-11T21:50:54.000Z",
        "permalink": "/basic",
        "sidebar": false,
        "article": false,
        "comment": false,
        "editLink": false
      },
      "regularPath": "/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html",
      "relativePath": "00.目录页/02.计算机基础.md",
      "key": "v-10f5d0e5",
      "path": "/basic/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "中间件",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "04.中间件",
            "imgUrl": "/img/more.png",
            "description": "Dubbo、Mybatis"
          }
        },
        "title": "中间件",
        "date": "2020-03-11T21:50:56.000Z",
        "permalink": "/middleware",
        "sidebar": false,
        "article": false,
        "comment": false,
        "editLink": false
      },
      "regularPath": "/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E4%B8%AD%E9%97%B4%E4%BB%B6.html",
      "relativePath": "00.目录页/04.中间件.md",
      "key": "v-7abe58c4",
      "path": "/middleware/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "数据库",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "03.数据库",
            "imgUrl": "/img/other.png",
            "description": "Mysql、Redis"
          }
        },
        "title": "数据库",
        "date": "2020-03-11T21:50:55.000Z",
        "permalink": "/database",
        "sidebar": false,
        "article": false,
        "comment": false,
        "editLink": false
      },
      "regularPath": "/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%95%B0%E6%8D%AE%E5%BA%93.html",
      "relativePath": "00.目录页/03.数据库.md",
      "key": "v-a612ff08",
      "path": "/database/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 异常有哪些类型？",
      "frontmatter": {
        "title": "Java 异常有哪些类型？",
        "date": "2022-03-11T00:42:02.000Z",
        "permalink": "/pages/a030ff/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/001.Java%20%E5%BC%82%E5%B8%B8%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/001.Java 异常有哪些类型？.md",
      "key": "v-8bf153e4",
      "path": "/pages/a030ff/",
      "headers": [
        {
          "level": 2,
          "title": "Java 异常有哪些类型？",
          "slug": "java-异常有哪些类型",
          "normalizedTitle": "java 异常有哪些类型？",
          "charIndex": 2
        }
      ],
      "headersStr": "Java 异常有哪些类型？",
      "content": "# Java 异常有哪些类型？\n\n\n\n图片来自：https://chercher.tech/java-programming/exceptions-java\n\n\n\n * 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。\n * Exception 能被程序本身处理(try-catch)， Error 是无法处理的(只能尽量避免)。\n * Exception有区分checked、unchecked异常，其中checked类型的异常强制处理（try-catch或者throw）",
      "normalizedContent": "# java 异常有哪些类型？\n\n\n\n图片来自：https://chercher.tech/java-programming/exceptions-java\n\n\n\n * 在 java 中，所有的异常都有一个共同的祖先 java.lang 包中的 throwable 类。\n * exception 能被程序本身处理(try-catch)， error 是无法处理的(只能尽量避免)。\n * exception有区分checked、unchecked异常，其中checked类型的异常强制处理（try-catch或者throw）",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "HashMap 与 ConcurrentHashMap 的实现原理是怎样的？",
      "frontmatter": {
        "title": "HashMap 与 ConcurrentHashMap 的实现原理是怎样的？",
        "date": "2022-04-04T14:21:18.000Z",
        "permalink": "/pages/d1c564/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/010.HashMap%20%E4%B8%8E%20ConcurrentHashMap%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/010.HashMap 与 ConcurrentHashMap 的实现原理是怎样的？.md",
      "key": "v-0734374b",
      "path": "/pages/d1c564/",
      "headers": [
        {
          "level": 2,
          "title": "HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？",
          "slug": "hashmap-与-concurrenthashmap-的实现原理是怎样的-concurrenthashmap-是如何保证线程安全的",
          "normalizedTitle": "hashmap 与 concurrenthashmap 的实现原理是怎样的？concurrenthashmap 是如何保证线程安全的？",
          "charIndex": 2
        }
      ],
      "headersStr": "HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？",
      "content": "# HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？\n\n                 HASHMAP     CONCURRENTHASHMAP\n是否线程安全           不安全         安全\nJDK1.7-数据结构      数组+链表       数组+链表+Segment\nJDK1.7-数据结构-图示               \n锁粒度              ---         对segment加锁，最大并发修改线程数=segment数量\n---              ---         ---\nJDK1.8-数据结构      数组+链表+红黑树   数组+链表+红黑树\nJDK1.8-数据结构-图示               \n锁粒度              ---         HashEntry（首节点），最大并发修改线程数=数组.size\n\n> Q1：ConcurrentHashMap 中变量使用 final 和 volatile 修饰有什么用呢？\n> A：Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。\n> Node的元素val和指针next是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。\n\n> Q2：ConcurrentHashMap在JDK 7和8之间的区别\n> A:去掉了Segment这种数据结构\n> 增加了红黑树结构来优化链表，解决了长链表遍历慢的问题",
      "normalizedContent": "# hashmap 与 concurrenthashmap 的实现原理是怎样的？concurrenthashmap 是如何保证线程安全的？\n\n                 hashmap     concurrenthashmap\n是否线程安全           不安全         安全\njdk1.7-数据结构      数组+链表       数组+链表+segment\njdk1.7-数据结构-图示               \n锁粒度              ---         对segment加锁，最大并发修改线程数=segment数量\n---              ---         ---\njdk1.8-数据结构      数组+链表+红黑树   数组+链表+红黑树\njdk1.8-数据结构-图示               \n锁粒度              ---         hashentry（首节点），最大并发修改线程数=数组.size\n\n> q1：concurrenthashmap 中变量使用 final 和 volatile 修饰有什么用呢？\n> a：final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。\n> node的元素val和指针next是用 volatile 修饰的，在多线程环境下线程a修改结点的val或者新增节点的时候是对线程b可见的。\n\n> q2：concurrenthashmap在jdk 7和8之间的区别\n> a:去掉了segment这种数据结构\n> 增加了红黑树结构来优化链表，解决了长链表遍历慢的问题",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 中接口和抽象类的区别",
      "frontmatter": {
        "title": "Java 中接口和抽象类的区别",
        "date": "2022-04-04T14:22:16.000Z",
        "permalink": "/pages/826c8b/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/020.Java%20%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB.html",
      "relativePath": "01.Java相关/10.基础/020.Java 中接口和抽象类的区别.md",
      "key": "v-4e1fd39c",
      "path": "/pages/826c8b/",
      "headers": [
        {
          "level": 2,
          "title": "Java 中接口和抽象类的区别",
          "slug": "java-中接口和抽象类的区别",
          "normalizedTitle": "java 中接口和抽象类的区别",
          "charIndex": 2
        }
      ],
      "headersStr": "Java 中接口和抽象类的区别",
      "content": "# Java 中接口和抽象类的区别\n\n          抽象类                     接口\n修饰符       abstract                interface\n从设计层面来说   是一种模板设计,抽象类要被子类继承       是一种行为的规范，接口要被类实现\n使用场景      在代码实现方面发挥作用，可以实现代码的重用   在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约\n\n抽象类-经典使用场景: StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类\n\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    /**\n     * The value is used for character storage.\n     */\n    char[] value;\n\n    /**\n     * The count is the number of characters used.\n     */\n    int count;\n\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",
      "normalizedContent": "# java 中接口和抽象类的区别\n\n          抽象类                     接口\n修饰符       abstract                interface\n从设计层面来说   是一种模板设计,抽象类要被子类继承       是一种行为的规范，接口要被类实现\n使用场景      在代码实现方面发挥作用，可以实现代码的重用   在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约\n\n抽象类-经典使用场景: stringbuilder 与 stringbuffer 都继承自 abstractstringbuilder 类\n\nabstract class abstractstringbuilder implements appendable, charsequence {\n    /**\n     * the value is used for character storage.\n     */\n    char[] value;\n\n    /**\n     * the count is the number of characters used.\n     */\n    int count;\n\n    abstractstringbuilder(int capacity) {\n        value = new char[capacity];\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "String，StringBuffer，StringBuilder 之间有什么区别？",
      "frontmatter": {
        "title": "String，StringBuffer，StringBuilder 之间有什么区别？",
        "date": "2022-04-04T14:24:07.000Z",
        "permalink": "/pages/211d8c/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/050.String%EF%BC%8CStringBuffer%EF%BC%8CStringBuilder%20%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/050.String，StringBuffer，StringBuilder 之间有什么区别？.md",
      "key": "v-7f48b402",
      "path": "/pages/211d8c/",
      "headers": [
        {
          "level": 2,
          "title": "String，StringBuffer，StringBuilder 之间有什么区别？",
          "slug": "string-stringbuffer-stringbuilder-之间有什么区别",
          "normalizedTitle": "string，stringbuffer，stringbuilder 之间有什么区别？",
          "charIndex": 2
        }
      ],
      "headersStr": "String，StringBuffer，StringBuilder 之间有什么区别？",
      "content": "# String，StringBuffer，StringBuilder 之间有什么区别？\n\n * String 对象是不可变的。String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]。\n * StringBuffer，StringBuilder是可变的\n * StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 是线程不安全的。\n\n        STRING   STRINGBUFFER         STRINGBUILDER\n可变性     不可变      可变                   可变\n线程安全性   安全       安全                   不安全\n使用场景    操作少量数据   多线程操作字符串缓冲区下操作大量数据   单线程操作字符串缓冲区下操作大量数据",
      "normalizedContent": "# string，stringbuffer，stringbuilder 之间有什么区别？\n\n * string 对象是不可变的。string 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]。\n * stringbuffer，stringbuilder是可变的\n * stringbuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。stringbuilder 是线程不安全的。\n\n        string   stringbuffer         stringbuilder\n可变性     不可变      可变                   可变\n线程安全性   安全       安全                   不安全\n使用场景    操作少量数据   多线程操作字符串缓冲区下操作大量数据   单线程操作字符串缓冲区下操作大量数据",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "== 和 equals() 的区别？",
      "frontmatter": {
        "title": "== 和 equals() 的区别？",
        "date": "2022-04-04T14:23:40.000Z",
        "permalink": "/pages/06b28a/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/040.==%20%E5%92%8C%20equals()%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/040.== 和 equals() 的区别？.md",
      "key": "v-d8a2f15c",
      "path": "/pages/06b28a/",
      "headers": [
        {
          "level": 2,
          "title": "== 和 equals() 的区别？",
          "slug": "和-equals-的区别",
          "normalizedTitle": "== 和 equals() 的区别？",
          "charIndex": 2
        }
      ],
      "headersStr": "== 和 equals() 的区别？",
      "content": "# == 和 equals() 的区别？\n\n * == : 基本数据类型==比较的是值，引用数据类型==比较的是内存地址。\n * 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n\npublic static void main(String[] args) {\n\t\tString s1 = new String(\"hello\"); // s1 为一个引用\n        String s2 = new String(\"hello\"); // s2和s1内容一样\n        String s3 = \"world\"; // 放在常量池中\n        String s4 = \"world\"; // 从常量池中查找\n        String o1 = new Object(); // o1 为一个引用\n        String o2 = new Object(); // o2 为另一个引用\n        if (aa == bb) // true 都是常量池的地址\n            System.out.println(\"aa==bb\");\n        if (s1 == s2) // false，比较地址，s1 s2是两次new出来的对象，地址肯定不同\n            System.out.println(\"a==b\");\n        if (s1.equals(s2)) // true String的equals方法被重写了 比较的是内容\n            System.out.println(\"aEQb\");\n        if (o1 == o2) // false Object没有重写equals 比较地址\n            System.out.println(\"aa==bb\");\n        if (o1.equals(o2)) // false 比较地址 Object没有重写equals 比较地址\n            System.out.println(\"a==b\");\n        if (55 == 55L) { // true 基本数据类型  比较的是数值\n            System.out.println(\"true\");\n        } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",
      "normalizedContent": "# == 和 equals() 的区别？\n\n * == : 基本数据类型==比较的是值，引用数据类型==比较的是内存地址。\n * 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n\npublic static void main(string[] args) {\n\t\tstring s1 = new string(\"hello\"); // s1 为一个引用\n        string s2 = new string(\"hello\"); // s2和s1内容一样\n        string s3 = \"world\"; // 放在常量池中\n        string s4 = \"world\"; // 从常量池中查找\n        string o1 = new object(); // o1 为一个引用\n        string o2 = new object(); // o2 为另一个引用\n        if (aa == bb) // true 都是常量池的地址\n            system.out.println(\"aa==bb\");\n        if (s1 == s2) // false，比较地址，s1 s2是两次new出来的对象，地址肯定不同\n            system.out.println(\"a==b\");\n        if (s1.equals(s2)) // true string的equals方法被重写了 比较的是内容\n            system.out.println(\"aeqb\");\n        if (o1 == o2) // false object没有重写equals 比较地址\n            system.out.println(\"aa==bb\");\n        if (o1.equals(o2)) // false 比较地址 object没有重写equals 比较地址\n            system.out.println(\"a==b\");\n        if (55 == 55l) { // true 基本数据类型  比较的是数值\n            system.out.println(\"true\");\n        } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "为什么重写 equals 必须重写 hashcode ？",
      "frontmatter": {
        "title": "为什么重写 equals 必须重写 hashcode ？",
        "date": "2022-04-04T14:23:08.000Z",
        "permalink": "/pages/0d22ad/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/030.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99%20equals%20%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99%20hashcode%20%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/030.为什么重写 equals 必须重写 hashcode ？.md",
      "key": "v-57012c44",
      "path": "/pages/0d22ad/",
      "headers": [
        {
          "level": 2,
          "title": "为什么重写 equals 必须重写 hashcode ？",
          "slug": "为什么重写-equals-必须重写-hashcode",
          "normalizedTitle": "为什么重写 equals 必须重写 hashcode ？",
          "charIndex": 2
        }
      ],
      "headersStr": "为什么重写 equals 必须重写 hashcode ？",
      "content": "# 为什么重写 equals 必须重写 hashcode ？\n\n如果 我们重写了 equals 没有重写 hashcode 会导致HashSet 里面可以存储重复的元素。\n\n\n以 HashSet 为例来说\nHashSet 底层是数组结构 存储的元素不重复（ O1和O2重复的意思是O1.equals(O2)==true ）\nadd 一个元素进来放在哪里呢？\n是根据元素的hash值（即 hashcode ）来确定数组下标 将元素放在里面。\n如果 我们重写了 equals 没有重写 hashcode\n那么 可能会产生这样的数据： O1.equals(O2)==true 但是O1.hashcode()!=O2.hashcode()\n导致 HashSet 里面可以存储重复的元素。",
      "normalizedContent": "# 为什么重写 equals 必须重写 hashcode ？\n\n如果 我们重写了 equals 没有重写 hashcode 会导致hashset 里面可以存储重复的元素。\n\n\n以 hashset 为例来说\nhashset 底层是数组结构 存储的元素不重复（ o1和o2重复的意思是o1.equals(o2)==true ）\nadd 一个元素进来放在哪里呢？\n是根据元素的hash值（即 hashcode ）来确定数组下标 将元素放在里面。\n如果 我们重写了 equals 没有重写 hashcode\n那么 可能会产生这样的数据： o1.equals(o2)==true 但是o1.hashcode()!=o2.hashcode()\n导致 hashset 里面可以存储重复的元素。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",
      "frontmatter": {
        "title": "简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",
        "date": "2022-04-04T14:24:34.000Z",
        "permalink": "/pages/305919/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/060.%E7%AE%80%E8%BF%B0%20ArrayList%20%E4%B8%8E%20LinkedList%20%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html",
      "relativePath": "01.Java相关/10.基础/060.简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度.md",
      "key": "v-57b2551a",
      "path": "/pages/305919/",
      "headers": [
        {
          "level": 2,
          "title": "简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",
          "slug": "简述-arraylist-与-linkedlist-的底层实现以及常见操作的时间复杂度",
          "normalizedTitle": "简述 arraylist 与 linkedlist 的底层实现以及常见操作的时间复杂度",
          "charIndex": 2
        }
      ],
      "headersStr": "简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",
      "content": "# 简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度\n\n        ARRAYLIST                                   LINKEDLIST\n线程安全    不安全                                         不安全\n底层结构    Object 数组                                   双向链表\n适用场景    按照数组下表快速访问元素 时间复杂度就是 O(1)                   顺序访问元素\n不适用场景   在指定位置n插入、删除, 会导致位置n后面的元素移动 时间复杂度就是 O(n-1)   随机访问元素",
      "normalizedContent": "# 简述 arraylist 与 linkedlist 的底层实现以及常见操作的时间复杂度\n\n        arraylist                                   linkedlist\n线程安全    不安全                                         不安全\n底层结构    object 数组                                   双向链表\n适用场景    按照数组下表快速访问元素 时间复杂度就是 o(1)                   顺序访问元素\n不适用场景   在指定位置n插入、删除, 会导致位置n后面的元素移动 时间复杂度就是 o(n-1)   随机访问元素",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 BIO, NIO, AIO 的区别",
      "frontmatter": {
        "title": "简述 BIO, NIO, AIO 的区别",
        "date": "2022-04-04T14:25:08.000Z",
        "permalink": "/pages/276740/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/070.%E7%AE%80%E8%BF%B0%20BIO,%20NIO,%20AIO%20%E7%9A%84%E5%8C%BA%E5%88%AB.html",
      "relativePath": "01.Java相关/10.基础/070.简述 BIO, NIO, AIO 的区别.md",
      "key": "v-d4e20148",
      "path": "/pages/276740/",
      "headers": [
        {
          "level": 2,
          "title": "简述 BIO, NIO, AIO 的区别",
          "slug": "简述-bio-nio-aio-的区别",
          "normalizedTitle": "简述 bio, nio, aio 的区别",
          "charIndex": 2
        }
      ],
      "headersStr": "简述 BIO, NIO, AIO 的区别",
      "content": "# 简述 BIO, NIO, AIO 的区别\n\nlinux中所有的外部设备都是一个文件，socket也是一个文件，有文件描述符（fd）指向它。\n\n       BIO (BLOCKING I/O)                NIO (NON-BLOCKING/NEW I/O)           AIO (ASYNCHRONOUS I/O)\n描述     在用户进程空间调用recvfrom,直到有数据才读取数据并返回   轮训调用recvfrom，直到有数据                   通知内核数据读取操作即可。用户进程不需要等待并读取数据。\n图示                                                                            \n使用场景   活动连接数不是特别高（小于单机 1000）的情况          对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发   我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。",
      "normalizedContent": "# 简述 bio, nio, aio 的区别\n\nlinux中所有的外部设备都是一个文件，socket也是一个文件，有文件描述符（fd）指向它。\n\n       bio (blocking i/o)                nio (non-blocking/new i/o)           aio (asynchronous i/o)\n描述     在用户进程空间调用recvfrom,直到有数据才读取数据并返回   轮训调用recvfrom，直到有数据                   通知内核数据读取操作即可。用户进程不需要等待并读取数据。\n图示                                                                            \n使用场景   活动连接数不是特别高（小于单机 1000）的情况          对于高负载、高并发的（网络）应用，应使用 nio 的非阻塞模式来开发   我发现就目前来说 aio 的应用还不是很广泛，netty 之前也尝试使用过 aio，不过又放弃了。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "在一个静态方法内调用一个非静态成员为什么是非法的？",
      "frontmatter": {
        "title": "在一个静态方法内调用一个非静态成员为什么是非法的？",
        "date": "2022-04-04T14:25:35.000Z",
        "permalink": "/pages/56314c/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/080.%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/080.在一个静态方法内调用一个非静态成员为什么是非法的？.md",
      "key": "v-d32e07ea",
      "path": "/pages/56314c/",
      "headers": [
        {
          "level": 2,
          "title": "在一个静态方法内调用一个非静态成员为什么是非法的？",
          "slug": "在一个静态方法内调用一个非静态成员为什么是非法的",
          "normalizedTitle": "在一个静态方法内调用一个非静态成员为什么是非法的？",
          "charIndex": 2
        }
      ],
      "headersStr": "在一个静态方法内调用一个非静态成员为什么是非法的？",
      "content": "# 在一个静态方法内调用一个非静态成员为什么是非法的？\n\n从java的生命周期角度来说，静态方法的初始化早于非静态方法。\n\n        静态方法   非静态成员\n初始化阶段   准备     使用",
      "normalizedContent": "# 在一个静态方法内调用一个非静态成员为什么是非法的？\n\n从java的生命周期角度来说，静态方法的初始化早于非静态方法。\n\n        静态方法   非静态成员\n初始化阶段   准备     使用",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 Java 的反射机制及其应用场景",
      "frontmatter": {
        "title": "简述 Java 的反射机制及其应用场景",
        "date": "2022-04-04T14:25:59.000Z",
        "permalink": "/pages/fae5d5/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/090.%E7%AE%80%E8%BF%B0%20Java%20%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html",
      "relativePath": "01.Java相关/10.基础/090.简述 Java 的反射机制及其应用场景.md",
      "key": "v-85b06162",
      "path": "/pages/fae5d5/",
      "headers": [
        {
          "level": 2,
          "title": "简述 Java 的反射机制及其应用场景",
          "slug": "简述-java-的反射机制及其应用场景",
          "normalizedTitle": "简述 java 的反射机制及其应用场景",
          "charIndex": 2
        }
      ],
      "headersStr": "简述 Java 的反射机制及其应用场景",
      "content": "# 简述 Java 的反射机制及其应用场景\n\n*** Java 的反射机制 ***\n这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息\n包括其modifiers(诸如public, static 等)、superclass(例如Object)、实现之interfaces(例如Cloneable)，也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。\nJava反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。\n换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。\n\n\n*** 应用场景 ***\nArthas\nRPC框架中的 动态代理\nSpring 加载 XML\nJava 动态代理\nJDBC 驱动加载\n",
      "normalizedContent": "# 简述 java 的反射机制及其应用场景\n\n*** java 的反射机制 ***\n这个机制允许程序在运行时透过reflection apis取得任何一个已知名称的class的内部信息\n包括其modifiers(诸如public, static 等)、superclass(例如object)、实现之interfaces(例如cloneable)，也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。\njava反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。\n换言之，java可以加载一个运行时才得知名称的class，获得其完整结构。\n\n\n*** 应用场景 ***\narthas\nrpc框架中的 动态代理\nspring 加载 xml\njava 动态代理\njdbc 驱动加载\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 类的加载流程是怎样的？",
      "frontmatter": {
        "title": "Java 类的加载流程是怎样的？",
        "date": "2022-04-04T14:26:24.000Z",
        "permalink": "/pages/33c5d6/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/100.Java%20%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/100.Java 类的加载流程是怎样的？.md",
      "key": "v-4c273a66",
      "path": "/pages/33c5d6/",
      "headers": [
        {
          "level": 2,
          "title": "Java 类的加载流程是怎样的？",
          "slug": "java-类的加载流程是怎样的",
          "normalizedTitle": "java 类的加载流程是怎样的？",
          "charIndex": 2
        }
      ],
      "headersStr": "Java 类的加载流程是怎样的？",
      "content": "# Java 类的加载流程是怎样的？\n\n类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。 其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。\n\n      做什么\n加载    类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例\n验证    验证类数据信息是否符合JVM规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等\n准备    为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）\n      被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在ConstantValue属性，则在准备阶段，其值就是ConstantValue的值\n解析    可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)\n初始化   初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。",
      "normalizedContent": "# java 类的加载流程是怎样的？\n\n类从被加载到jvm中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。 其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。\n\n      做什么\n加载    类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到jvm内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.class对象实例\n验证    验证类数据信息是否符合jvm规范，是否是一个有效的字节码文件，验证内容涵盖了类数据信息的格式验证、语义分析、操作验证等\n准备    为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）\n      被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在constantvalue属性，则在准备阶段，其值就是constantvalue的值\n解析    可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)\n初始化   初始化，为类的静态变量赋予正确的初始值，jvm负责对类进行初始化，主要对类变量进行初始化。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "什么是双亲委派机制？",
      "frontmatter": {
        "title": "什么是双亲委派机制？",
        "date": "2022-04-04T14:26:57.000Z",
        "permalink": "/pages/38bcaf/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/110.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/110.什么是双亲委派机制？.md",
      "key": "v-7665e30e",
      "path": "/pages/38bcaf/",
      "headers": [
        {
          "level": 2,
          "title": "什么是双亲委派机制？",
          "slug": "什么是双亲委派机制",
          "normalizedTitle": "什么是双亲委派机制？",
          "charIndex": 2
        }
      ],
      "headersStr": "什么是双亲委派机制？",
      "content": "# 什么是双亲委派机制？\n\n双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。\n\n\n\n加载器                       加载哪些类\nbootstrap classloader     加载jre/lib/rt.jar\nextension classloader     jre/lib/ext/*.jar\napplication classloader   加载应用程序目录\n自定义ClassLoader            定制化加载\n\n再来读一下java.lang.ClassLoader这段代码 是不是通透了许多？\n\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n    //              -----??-----\n    protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n            // 首先，检查是否已经被类加载器加载过\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                try {\n                    // 存在父加载器，递归的交由父加载器\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        // 直到最上面的Bootstrap类加载器\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n \n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    c = findClass(name);\n                }\n            }\n            return c;\n    }\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> Q1：使用双亲委派有什么好处？\n> A：双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。\n> 考虑到安全因素。\n> 假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。\n\n> Q2：什么场景需要破坏双亲委派？\n> 双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载）\n> 基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API 但没有绝对，如果基础类调用会用户的代码怎么办呢？ 比如JDBC驱动加载。 这种场景就需要用到SPI机制，是不符合双亲委派的。\n\n> Q3：JDBC、Tomcat中为什么要破坏双亲委派模型\n> A：JDBC\n> 先来回顾一下JDBC的用法\n\nString url = \"jdbc:mysql:///consult?serverTimezone=UTC\";\nString user = \"root\";\nString password = \"root\";\n\nClass.forName(\"com.mysql.jdbc.Driver\");\nConnection connection = DriverManager.getConnection(url, user, password);\n\n\n1\n2\n3\n4\n5\n6\n\n\n> DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，DriverManager位于 JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载.\n> JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包位于服务商MySQL提供的 Jar 中包含Driver的实现，按照双亲委派模型应该由application classloader加载\n> 实际上却是由BootStrap类加载器加载。\n> 这是因为：根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。\n> 这就破坏了双亲委派模型。\n\nTomcat\n每个webappClassLoader加载自己目录下的class文件\n\n> Tomcat支持部署多个Web应用，多个Web应用可能使用不同版本的JDK、也可能在应用内部定义全限定名一样的类，所以要做到应用隔离。",
      "normalizedContent": "# 什么是双亲委派机制？\n\n双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。\n\n\n\n加载器                       加载哪些类\nbootstrap classloader     加载jre/lib/rt.jar\nextension classloader     jre/lib/ext/*.jar\napplication classloader   加载应用程序目录\n自定义classloader            定制化加载\n\n再来读一下java.lang.classloader这段代码 是不是通透了许多？\n\n    public class<?> loadclass(string name) throws classnotfoundexception {\n        return loadclass(name, false);\n    }\n    //              -----??-----\n    protected class<?> loadclass(string name, boolean resolve)\n        throws classnotfoundexception\n    {\n            // 首先，检查是否已经被类加载器加载过\n            class<?> c = findloadedclass(name);\n            if (c == null) {\n                try {\n                    // 存在父加载器，递归的交由父加载器\n                    if (parent != null) {\n                        c = parent.loadclass(name, false);\n                    } else {\n                        // 直到最上面的bootstrap类加载器\n                        c = findbootstrapclassornull(name);\n                    }\n                } catch (classnotfoundexception e) {\n                    // classnotfoundexception thrown if class not found\n                    // from the non-null parent class loader\n                }\n \n                if (c == null) {\n                    // if still not found, then invoke findclass in order\n                    // to find the class.\n                    c = findclass(name);\n                }\n            }\n            return c;\n    }\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n> q1：使用双亲委派有什么好处？\n> a：双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。\n> 考虑到安全因素。\n> 假设通过网络传递一个名为java.lang.integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心java api发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.integer，而直接返回已加载过的integer.class，这样便可以防止核心api库被随意篡改。\n\n> q2：什么场景需要破坏双亲委派？\n> 双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载）\n> 基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的api 但没有绝对，如果基础类调用会用户的代码怎么办呢？ 比如jdbc驱动加载。 这种场景就需要用到spi机制，是不符合双亲委派的。\n\n> q3：jdbc、tomcat中为什么要破坏双亲委派模型\n> a：jdbc\n> 先来回顾一下jdbc的用法\n\nstring url = \"jdbc:mysql:///consult?servertimezone=utc\";\nstring user = \"root\";\nstring password = \"root\";\n\nclass.forname(\"com.mysql.jdbc.driver\");\nconnection connection = drivermanager.getconnection(url, user, password);\n\n\n1\n2\n3\n4\n5\n6\n\n\n> drivermanager 类中要加载各个实现了driver接口的类，然后进行管理，drivermanager位于 java_home中jre/lib/rt.jar 包，由bootstrap类加载器加载.\n> jdbc的driver接口定义在jdk中，其实现由各个数据库的服务商来提供，比如mysql驱动包位于服务商mysql提供的 jar 中包含driver的实现，按照双亲委派模型应该由application classloader加载\n> 实际上却是由bootstrap类加载器加载。\n> 这是因为：根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。\n> 这就破坏了双亲委派模型。\n\ntomcat\n每个webappclassloader加载自己目录下的class文件\n\n> tomcat支持部署多个web应用，多个web应用可能使用不同版本的jdk、也可能在应用内部定义全限定名一样的类，所以要做到应用隔离。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 中 sleep() 与 wait() 的区别",
      "frontmatter": {
        "title": "Java 中 sleep() 与 wait() 的区别",
        "date": "2022-04-04T14:27:16.000Z",
        "permalink": "/pages/d69890/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/120.Java%20%E4%B8%AD%20sleep()%20%E4%B8%8E%20wait()%20%E7%9A%84%E5%8C%BA%E5%88%AB%20.html",
      "relativePath": "01.Java相关/10.基础/120.Java 中 sleep() 与 wait() 的区别 .md",
      "key": "v-6ff6e2f0",
      "path": "/pages/d69890/",
      "headers": [
        {
          "level": 2,
          "title": "Java 中 sleep() 与 wait() 的区别",
          "slug": "java-中-sleep-与-wait-的区别",
          "normalizedTitle": "java 中 sleep() 与 wait() 的区别",
          "charIndex": 2
        }
      ],
      "headersStr": "Java 中 sleep() 与 wait() 的区别",
      "content": "# Java 中 sleep() 与 wait() 的区别\n\n两者都可以暂停线程的执行。区别如下：\n\n\n       SLEEP()                                       WAIT()\n       不让出锁                                          让出锁\n使用场景   用于暂停执行                                        用于线程间交互/通信\n唤醒方式   线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒   需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法\n\nyield() 和 join() 你了解吗？\n\n       YIELD()                                                 JOIN()\n描述     调用yield方法，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。   在线程A中调用线程B.join(),那么线程A会等待，cpu时间片给线程B执行，让线程B先执行，然后A再执行。\n使用场景   很少使用                                                    使异步执行的线程变成同步执行，底层是wait方法\n\npublic class JoinTest {\n\tpublic static void main(String[] args) {\n\t\tThread t = new Thread(new ThreadImp());\n\t\tt.start();\n\t\ttry {\n\t\t\tt.join(1000);//主程序等待t结束,只等1s\n\t\t\tif(t.isAlive()){\n\t\t\t\tSystem.out.println(\"t has not finished\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"t has finished\");\n\t\t\t}\n\t\t\tSystem.out.println(\"Joinfinished\");\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",
      "normalizedContent": "# java 中 sleep() 与 wait() 的区别\n\n两者都可以暂停线程的执行。区别如下：\n\n\n       sleep()                                       wait()\n       不让出锁                                          让出锁\n使用场景   用于暂停执行                                        用于线程间交互/通信\n唤醒方式   线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒   需要别的线程调用同一个对象上的 notify() 或者 notifyall() 方法\n\nyield() 和 join() 你了解吗？\n\n       yield()                                                 join()\n描述     调用yield方法，会给线程调度器一个当前线程愿意让出cpu使用的暗示，但是线程调度器可能会忽略这个暗示。   在线程a中调用线程b.join(),那么线程a会等待，cpu时间片给线程b执行，让线程b先执行，然后a再执行。\n使用场景   很少使用                                                    使异步执行的线程变成同步执行，底层是wait方法\n\npublic class jointest {\n\tpublic static void main(string[] args) {\n\t\tthread t = new thread(new threadimp());\n\t\tt.start();\n\t\ttry {\n\t\t\tt.join(1000);//主程序等待t结束,只等1s\n\t\t\tif(t.isalive()){\n\t\t\t\tsystem.out.println(\"t has not finished\");\n\t\t\t}else{\n\t\t\t\tsystem.out.println(\"t has finished\");\n\t\t\t}\n\t\t\tsystem.out.println(\"joinfinished\");\n\t\t} catch (exception e) {\n\t\t\tsystem.out.println(e);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 Java 中 final 关键字的作用",
      "frontmatter": {
        "title": "简述 Java 中 final 关键字的作用",
        "date": "2022-04-04T14:27:44.000Z",
        "permalink": "/pages/2b00a3/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/130.%E7%AE%80%E8%BF%B0%20Java%20%E4%B8%AD%20final%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8.html",
      "relativePath": "01.Java相关/10.基础/130.简述 Java 中 final 关键字的作用.md",
      "key": "v-620ebadc",
      "path": "/pages/2b00a3/",
      "headers": [
        {
          "level": 2,
          "title": "简述 Java 中 final 关键字的作用",
          "slug": "简述-java-中-final-关键字的作用",
          "normalizedTitle": "简述 java 中 final 关键字的作用",
          "charIndex": 2
        }
      ],
      "headersStr": "简述 Java 中 final 关键字的作用",
      "content": "# 简述 Java 中 final 关键字的作用\n\n\nfinal 关键字主要用在三个地方：变量、方法、类。\n\n\n修饰对象   限制                                     使用场景\n类      被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改   Java的一些核心的API都是final类，例如String、Integer、Math等\n方法     子类不可以重写父类中被final修饰的方法                  比如 模板方法，可以用来固定算法\n成员变量   被修饰的成员变量必须在定义时或者构造器中进行初始化赋值，且不可再修改     \n局部变量   final修饰局部变量时只能初始化(赋值)一次，但也可以不初始化       \n方法参数   final修饰方法参数时，是在调用方法传递参数时候初始化的          \n\n> final修饰变量要说明几点：\n> 1.修饰基本类型数据，final会将值变为一个常数（创建后不能被修改）；\n> 2.修饰的是引用类型，引用的指向 是不可变，但对象里面的属性可以改变 。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。\n> 3.方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值。\n\n//这段代码可以正常编译运行 因为final修饰的是引用类型，引用的指向 是不可变，但对象里面的属性可以改变\npublic class Test {\n    public static void main(String[] args)  {\n        final MyClass myClass = new MyClass();\n        System.out.println(++myClass.i); \n \n    }\n}\n\nclass MyClass {\n    public int i = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",
      "normalizedContent": "# 简述 java 中 final 关键字的作用\n\n\nfinal 关键字主要用在三个地方：变量、方法、类。\n\n\n修饰对象   限制                                     使用场景\n类      被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改   java的一些核心的api都是final类，例如string、integer、math等\n方法     子类不可以重写父类中被final修饰的方法                  比如 模板方法，可以用来固定算法\n成员变量   被修饰的成员变量必须在定义时或者构造器中进行初始化赋值，且不可再修改     \n局部变量   final修饰局部变量时只能初始化(赋值)一次，但也可以不初始化       \n方法参数   final修饰方法参数时，是在调用方法传递参数时候初始化的          \n\n> final修饰变量要说明几点：\n> 1.修饰基本类型数据，final会将值变为一个常数（创建后不能被修改）；\n> 2.修饰的是引用类型，引用的指向 是不可变，但对象里面的属性可以改变 。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。\n> 3.方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值。\n\n//这段代码可以正常编译运行 因为final修饰的是引用类型，引用的指向 是不可变，但对象里面的属性可以改变\npublic class test {\n    public static void main(string[] args)  {\n        final myclass myclass = new myclass();\n        system.out.println(++myclass.i); \n \n    }\n}\n\nclass myclass {\n    public int i = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "String 类能不能被继承？为什么？",
      "frontmatter": {
        "title": "String 类能不能被继承？为什么？",
        "date": "2022-04-04T14:28:11.000Z",
        "permalink": "/pages/73113f/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/140.String%20%E7%B1%BB%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/140.String 类能不能被继承？为什么？.md",
      "key": "v-5290507e",
      "path": "/pages/73113f/",
      "headers": [
        {
          "level": 2,
          "title": "String 类能不能被继承？为什么？",
          "slug": "string-类能不能被继承-为什么",
          "normalizedTitle": "string 类能不能被继承？为什么？",
          "charIndex": 2
        }
      ],
      "headersStr": "String 类能不能被继承？为什么？",
      "content": "# String 类能不能被继承？为什么？\n\n不可以，String 是被final修饰的。\n\n\npublic final class String implements java.io.Serializable, Comparable<String>, CharSequence {\n    // 省略...　\n}\n\n\n1\n2\n3\n\n\n> Q:String 为什么是 final 类型？\n> A:被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改",
      "normalizedContent": "# string 类能不能被继承？为什么？\n\n不可以，string 是被final修饰的。\n\n\npublic final class string implements java.io.serializable, comparable<string>, charsequence {\n    // 省略...　\n}\n\n\n1\n2\n3\n\n\n> q:string 为什么是 final 类型？\n> a:被final修饰的类，是不可以被继承的，这样做的目的可以保证该类不被修改",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述动态代理与静态代理",
      "frontmatter": {
        "title": "简述动态代理与静态代理",
        "date": "2022-04-04T14:29:39.000Z",
        "permalink": "/pages/37dba4/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/160.%E7%AE%80%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%20.html",
      "relativePath": "01.Java相关/10.基础/160.简述动态代理与静态代理 .md",
      "key": "v-75844e97",
      "path": "/pages/37dba4/",
      "headers": [
        {
          "level": 2,
          "title": "简述动态代理与静态代理",
          "slug": "简述动态代理与静态代理",
          "normalizedTitle": "简述动态代理与静态代理",
          "charIndex": 2
        }
      ],
      "headersStr": "简述动态代理与静态代理",
      "content": "# 简述动态代理与静态代理\n\n       静态代理                                                                                                      动态代理\n       由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的 .class 文件就已经存在了                                                     在程序运行时运用反射机制动态创建而成，动态就是在程序运行时生成的，而不是编译时。\n应用场景   AspectJ AOP                                                                                               Spring AOP、RPC 框架\n优点     在不修改目标对象的前提下，可以通过代理对象对目标对象功能扩展                                                                            不会会产生很多静态类，通过一个代理类完成全部的代理功能\n缺点     1.代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。   \n       2.代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n\n> 1.AspectJ 的底层技术就是静态代理，用一种 AspectJ 支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。\n> 2.JDK 动态代理：\n> \n> \n>  * 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理\n>    \n>  * 代理对象的生成，是通过 JDK 的 API（反射机制），动态的在内存中构建代理对象，在 Java 中要想实现动态代理机制，需要 java.lang.reflect.InvocationHandler 接口和 java.lang.reflect.Proxy 类的支持\n>    3.cglib 代理:\n>  * 静态代理和 JDK 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。\n>    *cglib (opens new window)(Code Generation Library)是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。cglib 通过继承方式实现代理。它广泛的被许多 AOP 的框架使用，比如我们的 Spring AOP。\n>    *cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。\n>    *cglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。\n>    ",
      "normalizedContent": "# 简述动态代理与静态代理\n\n       静态代理                                                                                                      动态代理\n       由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的 .class 文件就已经存在了                                                     在程序运行时运用反射机制动态创建而成，动态就是在程序运行时生成的，而不是编译时。\n应用场景   aspectj aop                                                                                               spring aop、rpc 框架\n优点     在不修改目标对象的前提下，可以通过代理对象对目标对象功能扩展                                                                            不会会产生很多静态类，通过一个代理类完成全部的代理功能\n缺点     1.代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。   \n       2.代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n\n> 1.aspectj 的底层技术就是静态代理，用一种 aspectj 支持的特定语言编写切面，通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，相对于下面说的运行时增强，编译时增强的性能更好。\n> 2.jdk 动态代理：\n> \n> \n>  * 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理\n>    \n>  * 代理对象的生成，是通过 jdk 的 api（反射机制），动态的在内存中构建代理对象，在 java 中要想实现动态代理机制，需要 java.lang.reflect.invocationhandler 接口和 java.lang.reflect.proxy 类的支持\n>    3.cglib 代理:\n>  * 静态代理和 jdk 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。\n>    *cglib (opens new window)(code generation library)是一个基于 asm 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。cglib 通过继承方式实现代理。它广泛的被许多 aop 的框架使用，比如我们的 spring aop。\n>    *cglib 包的底层是通过使用字节码处理框架 asm 来转换字节码并生成新的类。\n>    *cglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。\n>    ",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 缓冲流 buffer 的用途和原理是什么？",
      "frontmatter": {
        "title": "Java 缓冲流 buffer 的用途和原理是什么？",
        "date": "2022-04-04T14:29:13.000Z",
        "permalink": "/pages/115772/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/150.Java%20%E7%BC%93%E5%86%B2%E6%B5%81%20buffer%20%E7%9A%84%E7%94%A8%E9%80%94%E5%92%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/150.Java 缓冲流 buffer 的用途和原理是什么？.md",
      "key": "v-6f5c6512",
      "path": "/pages/115772/",
      "headers": [
        {
          "level": 2,
          "title": "Java 缓冲流 buffer 的用途和原理是什么？",
          "slug": "java-缓冲流-buffer-的用途和原理是什么",
          "normalizedTitle": "java 缓冲流 buffer 的用途和原理是什么？",
          "charIndex": 2
        }
      ],
      "headersStr": "Java 缓冲流 buffer 的用途和原理是什么？",
      "content": "# Java 缓冲流 buffer 的用途和原理是什么？\n\nbuffer本质是一个字节数组（ByteBuff），同时提供数据的结构化访问以及维护读写位置。\n而运用BufferedInputStream，则可以一次性读n个字节到内存中的缓冲区，这样在内存中读取数据会快很多。 1.流是单向的 所以会有输入流、输出流\n2.字节流一般用于处理文件、视频、音频等，字符流一般用于处理文本数据。\n3.原理：维护一个数组、一个指针\n\n\npublic class BufferedInputStream extends FilterInputStream{\n    private static int DEFAULT_BUFFER_SIZE = 8192;\n    private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n    // 缓冲数组\n    protected volatile byte buf[];\n    // bufUpdater提供buf的compareAndSet方法，这是必要的，因为close()可以是异步的，可以将buf是否为null作为是否close的主要指标。\n    private static final AtomicReferenceFieldUpdater<BufferedInputStream, byte[]> bufUpdater =\n        AtomicReferenceFieldUpdater.newUpdater(BufferedInputStream.class,  byte[].class, \"buf\");\n    // buf中的有效字节数\n    protected int count;\n    // buf中的当前字节位置\n    protected int pos;\n    \n    public BufferedInputStream(InputStream in) {\n        this(in, DEFAULT_BUFFER_SIZE);\n    }\n\n    public BufferedInputStream(InputStream in, int size) {\n        super(in);\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Buffer size <= 0\");\n        }\n        buf = new byte[size];\n    }\n\n   //读方法 -> 数据写入到数组buf中\n    public synchronized int read() throws IOException {\n        // 当读完buf中的数据后，就需要把InputStream的数据重新填充到buf\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        // 返回buf的下一个字节 指针后移\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n",
      "normalizedContent": "# java 缓冲流 buffer 的用途和原理是什么？\n\nbuffer本质是一个字节数组（bytebuff），同时提供数据的结构化访问以及维护读写位置。\n而运用bufferedinputstream，则可以一次性读n个字节到内存中的缓冲区，这样在内存中读取数据会快很多。 1.流是单向的 所以会有输入流、输出流\n2.字节流一般用于处理文件、视频、音频等，字符流一般用于处理文本数据。\n3.原理：维护一个数组、一个指针\n\n\npublic class bufferedinputstream extends filterinputstream{\n    private static int default_buffer_size = 8192;\n    private static int max_buffer_size = integer.max_value - 8;\n    // 缓冲数组\n    protected volatile byte buf[];\n    // bufupdater提供buf的compareandset方法，这是必要的，因为close()可以是异步的，可以将buf是否为null作为是否close的主要指标。\n    private static final atomicreferencefieldupdater<bufferedinputstream, byte[]> bufupdater =\n        atomicreferencefieldupdater.newupdater(bufferedinputstream.class,  byte[].class, \"buf\");\n    // buf中的有效字节数\n    protected int count;\n    // buf中的当前字节位置\n    protected int pos;\n    \n    public bufferedinputstream(inputstream in) {\n        this(in, default_buffer_size);\n    }\n\n    public bufferedinputstream(inputstream in, int size) {\n        super(in);\n        if (size <= 0) {\n            throw new illegalargumentexception(\"buffer size <= 0\");\n        }\n        buf = new byte[size];\n    }\n\n   //读方法 -> 数据写入到数组buf中\n    public synchronized int read() throws ioexception {\n        // 当读完buf中的数据后，就需要把inputstream的数据重新填充到buf\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        // 返回buf的下一个字节 指针后移\n        return getbufifopen()[pos++] & 0xff;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 HashSet 实现原理",
      "frontmatter": {
        "title": "简述 HashSet 实现原理",
        "date": "2022-04-04T14:30:47.000Z",
        "permalink": "/pages/75552c/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/180.%E7%AE%80%E8%BF%B0%20HashSet%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",
      "relativePath": "01.Java相关/10.基础/180.简述 HashSet 实现原理.md",
      "key": "v-b21bbc4c",
      "path": "/pages/75552c/",
      "headers": [
        {
          "level": 2,
          "title": "简述 HashSet 实现原理",
          "slug": "简述-hashset-实现原理",
          "normalizedTitle": "简述 hashset 实现原理",
          "charIndex": 2
        }
      ],
      "headersStr": "简述 HashSet 实现原理",
      "content": "# 简述 HashSet 实现原理\n\n底层结构是 HashMap 。value都是存放同一个虚拟对象。\n\npublic class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable {\n    static final long serialVersionUID = -5024744406713321676L;\n \n    private transient HashMap<E,Object> map;\n \n    // 虚拟对象\n    private static final Object PRESENT = new Object();\n \n    // 无参构造\n    public HashSet() {\n        map = new HashMap<>();\n    }\n \n    // 集合构造\n    public HashSet(Collection<? extends E> c) {\n        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));\n        addAll(c);\n    }\n \n    // 初始化容量及负载因子构造\n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap<>(initialCapacity, loadFactor);\n    }\n \n    // 初始化容量构造\n    public HashSet(int initialCapacity) {\n        map = new HashMap<>(initialCapacity);\n    }\n \n    // 由于默认修饰符，同包可访问，我们用不到，在LinkedLinkedHashMap中有具体应用，后期会讲解\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap<>(initialCapacity, loadFactor);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",
      "normalizedContent": "# 简述 hashset 实现原理\n\n底层结构是 hashmap 。value都是存放同一个虚拟对象。\n\npublic class hashset<e> extends abstractset<e> implements set<e>, cloneable, java.io.serializable {\n    static final long serialversionuid = -5024744406713321676l;\n \n    private transient hashmap<e,object> map;\n \n    // 虚拟对象\n    private static final object present = new object();\n \n    // 无参构造\n    public hashset() {\n        map = new hashmap<>();\n    }\n \n    // 集合构造\n    public hashset(collection<? extends e> c) {\n        map = new hashmap<>(math.max((int) (c.size()/.75f) + 1, 16));\n        addall(c);\n    }\n \n    // 初始化容量及负载因子构造\n    public hashset(int initialcapacity, float loadfactor) {\n        map = new hashmap<>(initialcapacity, loadfactor);\n    }\n \n    // 初始化容量构造\n    public hashset(int initialcapacity) {\n        map = new hashmap<>(initialcapacity);\n    }\n \n    // 由于默认修饰符，同包可访问，我们用不到，在linkedlinkedhashmap中有具体应用，后期会讲解\n    hashset(int initialcapacity, float loadfactor, boolean dummy) {\n        map = new linkedhashmap<>(initialcapacity, loadfactor);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "阻塞队列都有哪几种，有什么区别？",
      "frontmatter": {
        "title": "阻塞队列都有哪几种，有什么区别？",
        "date": "2022-04-04T14:30:18.000Z",
        "permalink": "/pages/e9ce4e/",
        "categories": [
          "Java相关",
          "基础"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/10.%E5%9F%BA%E7%A1%80/170.%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E9%83%BD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.html",
      "relativePath": "01.Java相关/10.基础/170.阻塞队列都有哪几种，有什么区别？.md",
      "key": "v-1218fa85",
      "path": "/pages/e9ce4e/",
      "headers": [
        {
          "level": 2,
          "title": "阻塞队列都有哪几种，有什么区别？",
          "slug": "阻塞队列都有哪几种-有什么区别",
          "normalizedTitle": "阻塞队列都有哪几种，有什么区别？",
          "charIndex": 2
        }
      ],
      "headersStr": "阻塞队列都有哪几种，有什么区别？",
      "content": "# 阻塞队列都有哪几种，有什么区别？\n\njava.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：\n\n\nFIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）\n优先级队列 ：PriorityBlockingQueue\n延时队列 ： DelayQueue\n同步队列 ： SynchronousQueue\n\n\njava.util.concurrent.BlockingQueue提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。\n\n\n                        \nLinkedBlockingQueue     1.内部是用链表实现的\n                        2.默认容量是 Integer.MAX_VALUE\n                        3.队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能\n                        4.会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于GC可能存在较大影响\n                        5.在无界的情况下，可能会造成内存溢出等问题。\nArrayBlockingQueue      1.ArrayBlockingQueue 是最典型的有界队列\n                        2.其内部是用数组存储元素的\n                        3.利用 ReentrantLock 实现线程安全,添加操作和移除操作采用的同一个ReenterLock锁\n                        4.在创建它的时候就需要指定它的容量，之后也不可以再扩容了\n                        5.构造函数中我们同样可以指定是否是公平的\nPriorityBlockingQueue   1.无界阻塞队列\n                        2. 支持优先级,可以通过自定义类实现 compareTo() 方法来指定元素排序规则\nDelayQueue              1.无界队列\n                        2.放入的元素必须实现 Delayed 接口\n                        3.内部使用了 PriorityQueue 的能力来进行排序\nSynchronousQueue        容量为\n                        0,所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取",
      "normalizedContent": "# 阻塞队列都有哪几种，有什么区别？\n\njava.util.concurrent.blockingqueue 接口有以下阻塞队列的实现：\n\n\nfifo 队列 ：linkedblockingqueue、arrayblockingqueue（固定长度）\n优先级队列 ：priorityblockingqueue\n延时队列 ： delayqueue\n同步队列 ： synchronousqueue\n\n\njava.util.concurrent.blockingqueue提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。\n\n\n                        \nlinkedblockingqueue     1.内部是用链表实现的\n                        2.默认容量是 integer.max_value\n                        3.队列中的锁是分离的，其添加采用的是putlock，移除采用的则是takelock，这样能大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能\n                        4.会生成一个额外的node对象。这可能在长时间内需要高效并发地处理大批量数据的时，对于gc可能存在较大影响\n                        5.在无界的情况下，可能会造成内存溢出等问题。\narrayblockingqueue      1.arrayblockingqueue 是最典型的有界队列\n                        2.其内部是用数组存储元素的\n                        3.利用 reentrantlock 实现线程安全,添加操作和移除操作采用的同一个reenterlock锁\n                        4.在创建它的时候就需要指定它的容量，之后也不可以再扩容了\n                        5.构造函数中我们同样可以指定是否是公平的\npriorityblockingqueue   1.无界阻塞队列\n                        2. 支持优先级,可以通过自定义类实现 compareto() 方法来指定元素排序规则\ndelayqueue              1.无界队列\n                        2.放入的元素必须实现 delayed 接口\n                        3.内部使用了 priorityqueue 的能力来进行排序\nsynchronousqueue        容量为\n                        0,所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "线程池是如何实现的？",
      "frontmatter": {
        "title": "线程池是如何实现的？",
        "date": "2022-04-04T14:38:19.000Z",
        "permalink": "/pages/0da4b0/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/001.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/001.线程池是如何实现的？.md",
      "key": "v-45fc1217",
      "path": "/pages/0da4b0/",
      "headers": [
        {
          "level": 3,
          "title": "使用线程池有哪些好处",
          "slug": "使用线程池有哪些好处",
          "normalizedTitle": "使用线程池有哪些好处",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "线程池的创建",
          "slug": "线程池的创建",
          "normalizedTitle": "线程池的创建",
          "charIndex": 163
        },
        {
          "level": 3,
          "title": "向线程池提交一个任务后，线程池是如何处理这个任务的呢？",
          "slug": "向线程池提交一个任务后-线程池是如何处理这个任务的呢",
          "normalizedTitle": "向线程池提交一个任务后，线程池是如何处理这个任务的呢？",
          "charIndex": 1987
        },
        {
          "level": 3,
          "title": "线程池是如何工作的呢？",
          "slug": "线程池是如何工作的呢",
          "normalizedTitle": "线程池是如何工作的呢？",
          "charIndex": 3296
        },
        {
          "level": 3,
          "title": "向线程池提交任务",
          "slug": "向线程池提交任务",
          "normalizedTitle": "向线程池提交任务",
          "charIndex": 5167
        },
        {
          "level": 3,
          "title": "关闭线程池",
          "slug": "关闭线程池",
          "normalizedTitle": "关闭线程池",
          "charIndex": 6580
        },
        {
          "level": 3,
          "title": "合理的配置线程池",
          "slug": "合理的配置线程池",
          "normalizedTitle": "合理的配置线程池",
          "charIndex": 6963
        }
      ],
      "headersStr": "使用线程池有哪些好处 线程池的创建 向线程池提交一个任务后，线程池是如何处理这个任务的呢？ 线程池是如何工作的呢？ 向线程池提交任务 关闭线程池 合理的配置线程池",
      "content": "# 使用线程池有哪些好处\n\n 1. 降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁的消耗。\n 2. 提高相应速度。当任务到达时，任务可以不需要线程创建就可以执行。\n 3. 提高线程的可管理性。线程是稀缺资源、如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性。使用线程池可以统一分配、调优和监控。\n\n\n# 线程池的创建\n\n我们可以通过 ThreadPoolExecutor 来创建一个线程池\n\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {//...}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建一个线程池需要传入如下几个参数：\n\n * corePoolSize： 线程池中的常驻核心线程数。\n   当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建线程。当线程池中的线程数量到达 corePoolSize 时就不再创建。如果调用了线程池的 prestartAllCoreThread()方法，线程池会在启动后就创建所有核心线程。\n\n * workQueue： 存放任务的阻塞队列，被提交但尚未被执行的任务。\n   可以选择如下几个阻塞队列： 1.ArrayBlockingQueue 2.LinkedBlockingQueue:吞吐量高于LinkedBlockingQueue，是 Executors.newFixedThreadPool()创建的线程池的默认队列。 3.SynchronousQueue:一个不存储元素的队列。每个提交的任务都必须等到线程来执行，否则阻塞提交。是 Executors.newCachedThreadPool()创建的线程池的默认队列。 4.PriorityBlockingQueue:一个具有优先级的无限阻塞队列。\n\n * maximumPoolSize： 线程池最大线程数量。\n   如果队列满了并且已经创建的线程数量小于最大线程数量，则线程池会再继续创建新的线程执行任务。值得注意的是如果使用无界队列 (比如LinkedBlockingQueue)这个参数就没有意义了。\n\n * threadFactory： 用于设置创建线程的工厂\n   可以给创建的线程设置有意义的名字，可方便排查问题\n\n * handler： 拒绝策略，表示当队列满了且工作线程都满了如何来拒绝请求执行的线程的策略，默认是AbortPolicy策略，主要有四种类型。\n\n 1. AbortPolicy 直接抛出RegectedExcutionException 异常阻止系统正常进行，默认策略\n\n 2. DiscardPolicy 直接丢弃任务，不予任何处理也不抛出异常，如果允许任务丢失，这是最好的一种方案\n\n 3. DiscardOldestPolicy 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务\n\n 4. CallerRunsPolicy 交给线程池调用所在的线程进行处理，“调用者运行”的一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量\n\n以上内置拒绝策略均实现了 RejectExcutionHandler 接口，我们也可以实现接口RejectExcutionHandler来自定义策略，如记录日志或者持久化不能拒绝的任务。\n\n * keepAliveTime： 非核心线程存活时间\n   线程池中非核心线程空闲的存活时间 当前线程池数量超过 corePoolSize 时，当空闲时间达到 keepAliveTime 值时，非核心线程会被销毁直到只剩下 corePoolSize 个线程为止。\n   \n\n> tips:如果任务很多并且任务执行时间比较短，可以调大 keepAliveTime ，提高线程利用率。\n\n * unit： keepAliveTime 的时间单位\n   \n\n\n# 向线程池提交一个任务后，线程池是如何处理这个任务的呢？\n\n\n\n 1. 如果当前运行的线程数<corePoolSize，则创建新线程来执行任务（这一步骤需要获取全局锁）。\n 2. 如果当前运行的线程数>=corePoolSize，则将任务加入阻塞队列。\n 3. 如果队列已满或者不能加入，接下来的处理分两种情况：\n    1. 线程池中的线程是否都处于工作状态。创建新的线程来执行任务（这一步骤需要获取全局锁）。\n    2. 线程池中有空闲的线程，则用其来执行任务。\n 4. 如果创建新线程会导致线程数量>maximumPoolSize，则执行拒绝策略。\n\n我们再从源码的角度来理解下这个过程：\nThreadPoolExecutor#execute(Runnble command) 方法\n\npublic void execute(Runnable command) {\n  // 参数校验\n    if (command == null)\n        throw new NullPointerException();\n        \n    // 从 c 的值可以判断出线程池的状态, 以及线程池中线程的数量\n    int c = ctl.get();\n    // 1. 如果线程池的线程数量 小于 核心线程数\n    if (workerCountOf(c) < corePoolSize) {\n        // 添加一个核心线程 command 表示一个具体的任务， true 表示为核心线程\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 2. 如果线程池处于 RUNNING 状态（只有处于此状态，才能接受新的任务）\n    // 并且线程池的数量大于核心线程数, 就把任务添加到阻塞队列\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    // 3. 如果队列也满了，就创建一个非核心线程（core==false）\n    else if (!addWorker(command, false))\n        // 如果创建失败，就执行拒绝策略\n        reject(command);\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 线程池是如何工作的呢？\n\n线程池中有一个 workers 集合，里面记录了所有的工作线程，只有拿到 mainLock 锁的线程才能访问。 ThreadPoolExecutor#workers 属性\n\nprivate final HashSet<Worker> workers = new HashSet<Worker>();\n\n\n1\n\n\n线程池创建线程时，会将线程包装成 Worker ，Worker 在执行任务后还会循环获取队里里的任务。我们可以从 Worker 类的 run() 方法看到这一点。\n\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码关键点是while循环和getTask()方法，通过循环不断的调用getTask()从阻塞队列中获取任务，通过这个方法，它与阻塞队列建立桥梁。\n\n\n# 向线程池提交任务\n\n有两个方法提交任务，分别是execute(),submit()\n\n\n * execute()：execute只能提交Runnable类型的任务,用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。如果遇到异常会直接抛出。使用方法如下：\n\npublic static void main(String[] args) throws Exception{\n        ExecutorService es = Executors.newSingleThreadExecutor();\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Runnable线程处理开始...\");\n            }\n        };\n        es.execute(runnable);\n        es.shutdown();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * submit()：submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务，会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。如果遇到异常不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常。使用方法：\n\npublic static void main(String[] args) throws Exception{\n        ExecutorService es = Executors.newSingleThreadExecutor();\n        Callable callable = new Callable() {\n            @Override\n            public String call() throws Exception {\n                System.out.println(\"线程处理开始...\");\n                return \"hello world\";\n            }\n        };\n        Future<String> future = es.submit(callable);\n        while(true) {\n            //idDone:如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。\n            if(future.isDone()) {\n                System.out.println(\"任务执行完成：\" + future.get());\n                break;\n            }\n        }\n        es.shutdown();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 关闭线程池\n\n可以通过shutdown和shutdownNow方法来关闭线程池。他们的原理是遍历线程池的中工作线程，调用其interrupt()方法来中断线程，所以，无法相应中断的任务永远无法被终止。但是他们也存在一定的区别：\n\n * shutdown：将线程的状态设置为 SHUTDOWN 状态，然后中断没有执行任务的线程。\n * shutdownNow：首先将线程的状态设置为 STOP ，然后尝试停止所有正在执行或者暂停任务的线程，并返回队列中的待执行任务。\n\n只要调用了这两个方法中的任意一个，isShutdown()方法就会返回true，当所有任务都关闭后，才表示线程池关闭成功，这是调用isTerminaed()方法才会返回 true 。\n\n\n通常调用 shutdown 来关闭线程池，如果不需要等任务执行完可以调用 shutdownNow 。\n\n\n# 合理的配置线程池\n\n 1. 最大线程数 maximumPoolSize 的是指可参考如下规则：\n    * CPU 密集型任务应该配置尽可能小的线程，如cpu数量+1。\n    * IO密集型任务线程并不是一直占用cpu，则应该适度更多的配置线程，如2*cpu数量\n    * 可以通过 Runtime.getRuntime().availableProcessors() 获得当前设备的 cpu 个数。\n 2. 建议使用有界队列。如果任务执行速度变慢，线程池不断向队列中 add 元素，会有内存溢出的风险。",
      "normalizedContent": "# 使用线程池有哪些好处\n\n 1. 降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁的消耗。\n 2. 提高相应速度。当任务到达时，任务可以不需要线程创建就可以执行。\n 3. 提高线程的可管理性。线程是稀缺资源、如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性。使用线程池可以统一分配、调优和监控。\n\n\n# 线程池的创建\n\n我们可以通过 threadpoolexecutor 来创建一个线程池\n\npublic threadpoolexecutor(int corepoolsize,\n                              int maximumpoolsize,\n                              long keepalivetime,\n                              timeunit unit,\n                              blockingqueue<runnable> workqueue,\n                              threadfactory threadfactory,\n                              rejectedexecutionhandler handler) {//...}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建一个线程池需要传入如下几个参数：\n\n * corepoolsize： 线程池中的常驻核心线程数。\n   当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建线程。当线程池中的线程数量到达 corepoolsize 时就不再创建。如果调用了线程池的 prestartallcorethread()方法，线程池会在启动后就创建所有核心线程。\n\n * workqueue： 存放任务的阻塞队列，被提交但尚未被执行的任务。\n   可以选择如下几个阻塞队列： 1.arrayblockingqueue 2.linkedblockingqueue:吞吐量高于linkedblockingqueue，是 executors.newfixedthreadpool()创建的线程池的默认队列。 3.synchronousqueue:一个不存储元素的队列。每个提交的任务都必须等到线程来执行，否则阻塞提交。是 executors.newcachedthreadpool()创建的线程池的默认队列。 4.priorityblockingqueue:一个具有优先级的无限阻塞队列。\n\n * maximumpoolsize： 线程池最大线程数量。\n   如果队列满了并且已经创建的线程数量小于最大线程数量，则线程池会再继续创建新的线程执行任务。值得注意的是如果使用无界队列 (比如linkedblockingqueue)这个参数就没有意义了。\n\n * threadfactory： 用于设置创建线程的工厂\n   可以给创建的线程设置有意义的名字，可方便排查问题\n\n * handler： 拒绝策略，表示当队列满了且工作线程都满了如何来拒绝请求执行的线程的策略，默认是abortpolicy策略，主要有四种类型。\n\n 1. abortpolicy 直接抛出regectedexcutionexception 异常阻止系统正常进行，默认策略\n\n 2. discardpolicy 直接丢弃任务，不予任何处理也不抛出异常，如果允许任务丢失，这是最好的一种方案\n\n 3. discardoldestpolicy 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务\n\n 4. callerrunspolicy 交给线程池调用所在的线程进行处理，“调用者运行”的一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量\n\n以上内置拒绝策略均实现了 rejectexcutionhandler 接口，我们也可以实现接口rejectexcutionhandler来自定义策略，如记录日志或者持久化不能拒绝的任务。\n\n * keepalivetime： 非核心线程存活时间\n   线程池中非核心线程空闲的存活时间 当前线程池数量超过 corepoolsize 时，当空闲时间达到 keepalivetime 值时，非核心线程会被销毁直到只剩下 corepoolsize 个线程为止。\n   \n\n> tips:如果任务很多并且任务执行时间比较短，可以调大 keepalivetime ，提高线程利用率。\n\n * unit： keepalivetime 的时间单位\n   \n\n\n# 向线程池提交一个任务后，线程池是如何处理这个任务的呢？\n\n\n\n 1. 如果当前运行的线程数<corepoolsize，则创建新线程来执行任务（这一步骤需要获取全局锁）。\n 2. 如果当前运行的线程数>=corepoolsize，则将任务加入阻塞队列。\n 3. 如果队列已满或者不能加入，接下来的处理分两种情况：\n    1. 线程池中的线程是否都处于工作状态。创建新的线程来执行任务（这一步骤需要获取全局锁）。\n    2. 线程池中有空闲的线程，则用其来执行任务。\n 4. 如果创建新线程会导致线程数量>maximumpoolsize，则执行拒绝策略。\n\n我们再从源码的角度来理解下这个过程：\nthreadpoolexecutor#execute(runnble command) 方法\n\npublic void execute(runnable command) {\n  // 参数校验\n    if (command == null)\n        throw new nullpointerexception();\n        \n    // 从 c 的值可以判断出线程池的状态, 以及线程池中线程的数量\n    int c = ctl.get();\n    // 1. 如果线程池的线程数量 小于 核心线程数\n    if (workercountof(c) < corepoolsize) {\n        // 添加一个核心线程 command 表示一个具体的任务， true 表示为核心线程\n        if (addworker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 2. 如果线程池处于 running 状态（只有处于此状态，才能接受新的任务）\n    // 并且线程池的数量大于核心线程数, 就把任务添加到阻塞队列\n    if (isrunning(c) && workqueue.offer(command)) {\n        int recheck = ctl.get();\n        if (! isrunning(recheck) && remove(command))\n            reject(command);\n        else if (workercountof(recheck) == 0)\n            addworker(null, false);\n    }\n    // 3. 如果队列也满了，就创建一个非核心线程（core==false）\n    else if (!addworker(command, false))\n        // 如果创建失败，就执行拒绝策略\n        reject(command);\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 线程池是如何工作的呢？\n\n线程池中有一个 workers 集合，里面记录了所有的工作线程，只有拿到 mainlock 锁的线程才能访问。 threadpoolexecutor#workers 属性\n\nprivate final hashset<worker> workers = new hashset<worker>();\n\n\n1\n\n\n线程池创建线程时，会将线程包装成 worker ，worker 在执行任务后还会循环获取队里里的任务。我们可以从 worker 类的 run() 方法看到这一点。\n\nfinal void runworker(worker w) {\n        thread wt = thread.currentthread();\n        runnable task = w.firsttask;\n        w.firsttask = null;\n        w.unlock(); // allow interrupts\n        boolean completedabruptly = true;\n        try {\n            while (task != null || (task = gettask()) != null) {\n                w.lock();\n                if ((runstateatleast(ctl.get(), stop) ||\n                     (thread.interrupted() &&\n                      runstateatleast(ctl.get(), stop))) &&\n                    !wt.isinterrupted())\n                    wt.interrupt();\n                try {\n                    beforeexecute(wt, task);\n                    throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (runtimeexception x) {\n                        thrown = x; throw x;\n                    } catch (error x) {\n                        thrown = x; throw x;\n                    } catch (throwable x) {\n                        thrown = x; throw new error(x);\n                    } finally {\n                        afterexecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedtasks++;\n                    w.unlock();\n                }\n            }\n            completedabruptly = false;\n        } finally {\n            processworkerexit(w, completedabruptly);\n        }\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码关键点是while循环和gettask()方法，通过循环不断的调用gettask()从阻塞队列中获取任务，通过这个方法，它与阻塞队列建立桥梁。\n\n\n# 向线程池提交任务\n\n有两个方法提交任务，分别是execute(),submit()\n\n\n * execute()：execute只能提交runnable类型的任务,用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。如果遇到异常会直接抛出。使用方法如下：\n\npublic static void main(string[] args) throws exception{\n        executorservice es = executors.newsinglethreadexecutor();\n        runnable runnable = new runnable() {\n            @override\n            public void run() {\n                system.out.println(\"runnable线程处理开始...\");\n            }\n        };\n        es.execute(runnable);\n        es.shutdown();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * submit()：submit既可以提交runnable类型的任务，也可以提交callable类型的任务，会有一个类型为future的返回值，但当任务类型为runnable时，返回值为null。如果遇到异常不会直接抛出，只有在使用future的get方法获取返回值时，才会抛出异常。使用方法：\n\npublic static void main(string[] args) throws exception{\n        executorservice es = executors.newsinglethreadexecutor();\n        callable callable = new callable() {\n            @override\n            public string call() throws exception {\n                system.out.println(\"线程处理开始...\");\n                return \"hello world\";\n            }\n        };\n        future<string> future = es.submit(callable);\n        while(true) {\n            //iddone:如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。\n            if(future.isdone()) {\n                system.out.println(\"任务执行完成：\" + future.get());\n                break;\n            }\n        }\n        es.shutdown();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 关闭线程池\n\n可以通过shutdown和shutdownnow方法来关闭线程池。他们的原理是遍历线程池的中工作线程，调用其interrupt()方法来中断线程，所以，无法相应中断的任务永远无法被终止。但是他们也存在一定的区别：\n\n * shutdown：将线程的状态设置为 shutdown 状态，然后中断没有执行任务的线程。\n * shutdownnow：首先将线程的状态设置为 stop ，然后尝试停止所有正在执行或者暂停任务的线程，并返回队列中的待执行任务。\n\n只要调用了这两个方法中的任意一个，isshutdown()方法就会返回true，当所有任务都关闭后，才表示线程池关闭成功，这是调用isterminaed()方法才会返回 true 。\n\n\n通常调用 shutdown 来关闭线程池，如果不需要等任务执行完可以调用 shutdownnow 。\n\n\n# 合理的配置线程池\n\n 1. 最大线程数 maximumpoolsize 的是指可参考如下规则：\n    * cpu 密集型任务应该配置尽可能小的线程，如cpu数量+1。\n    * io密集型任务线程并不是一直占用cpu，则应该适度更多的配置线程，如2*cpu数量\n    * 可以通过 runtime.getruntime().availableprocessors() 获得当前设备的 cpu 个数。\n 2. 建议使用有界队列。如果任务执行速度变慢，线程池不断向队列中 add 元素，会有内存溢出的风险。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 CAS 原理，什么是 ABA 问题，怎么解决？",
      "frontmatter": {
        "title": "简述 CAS 原理，什么是 ABA 问题，怎么解决？",
        "date": "2022-04-04T14:32:48.000Z",
        "permalink": "/pages/3356c6/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/020.%E7%AE%80%E8%BF%B0%20CAS%20%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%20ABA%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/020.简述 CAS 原理，什么是 ABA 问题，怎么解决？.md",
      "key": "v-5390e3d4",
      "path": "/pages/3356c6/",
      "headers": [
        {
          "level": 2,
          "title": "简述 CAS 原理，什么是 ABA 问题，怎么解决？",
          "slug": "简述-cas-原理-什么是-aba-问题-怎么解决",
          "normalizedTitle": "简述 cas 原理，什么是 aba 问题，怎么解决？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "CAS实现原子操作",
          "slug": "cas实现原子操作",
          "normalizedTitle": "cas实现原子操作",
          "charIndex": 33
        },
        {
          "level": 3,
          "title": "ABA问题",
          "slug": "aba问题",
          "normalizedTitle": "aba问题",
          "charIndex": 256
        }
      ],
      "headersStr": "简述 CAS 原理，什么是 ABA 问题，怎么解决？ CAS实现原子操作 ABA问题",
      "content": "# 简述 CAS 原理，什么是 ABA 问题，怎么解决？\n\n\n# CAS实现原子操作\n\nCAS理论是 juc 包实现的基石，在intel的CPU中，CAS 通过调用本地方法（JNI）使用cmpxchg指令来实现的非阻塞算法。对比于synchronized阻塞算法，基于 CAS 实现的 juc 在性能上有了很大的提升。\n\nCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。\n\n\n# ABA问题\n\n * 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n\n * ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n\n * 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。",
      "normalizedContent": "# 简述 cas 原理，什么是 aba 问题，怎么解决？\n\n\n# cas实现原子操作\n\ncas理论是 juc 包实现的基石，在intel的cpu中，cas 通过调用本地方法（jni）使用cmpxchg指令来实现的非阻塞算法。对比于synchronized阻塞算法，基于 cas 实现的 juc 在性能上有了很大的提升。\n\ncas 操作包含三个操作数 —— 内存位置（v）、预期原值（a）和新值(b)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。\n\n\n# aba问题\n\n * 因为cas需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是a，变成了b，又变成了a，那么使用cas进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n\n * aba问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么a－b－a 就会变成1a-2b－3a。\n\n * 从java1.5开始jdk的atomic包里提供了一个类atomicstampedreference来解决aba问题。这个类的compareandset方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点",
      "frontmatter": {
        "title": "简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点",
        "date": "2022-04-04T14:33:06.000Z",
        "permalink": "/pages/97245f/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/030.%E7%AE%80%E8%BF%B0%20Synchronized%EF%BC%8CVolatile%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9.html",
      "relativePath": "01.Java相关/20.并发/030.简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点.md",
      "key": "v-35324a50",
      "path": "/pages/97245f/",
      "headers": [
        {
          "level": 2,
          "title": "Java中的内存可见性",
          "slug": "java中的内存可见性",
          "normalizedTitle": "java中的内存可见性",
          "charIndex": 198
        },
        {
          "level": 2,
          "title": "Volatile 的实现原理",
          "slug": "volatile-的实现原理",
          "normalizedTitle": "volatile 的实现原理",
          "charIndex": 404
        },
        {
          "level": 2,
          "title": "Synchronized 的用法",
          "slug": "synchronized-的用法",
          "normalizedTitle": "synchronized 的用法",
          "charIndex": 556
        },
        {
          "level": 2,
          "title": "Synchronized 的锁存储在哪里？",
          "slug": "synchronized-的锁存储在哪里",
          "normalizedTitle": "synchronized 的锁存储在哪里？",
          "charIndex": 837
        },
        {
          "level": 2,
          "title": "为什么Java中每个对象都可以作为锁？",
          "slug": "为什么java中每个对象都可以作为锁",
          "normalizedTitle": "为什么java中每个对象都可以作为锁？",
          "charIndex": 1068
        },
        {
          "level": 2,
          "title": "Synchronized 锁升级",
          "slug": "synchronized-锁升级",
          "normalizedTitle": "synchronized 锁升级",
          "charIndex": 1374
        },
        {
          "level": 3,
          "title": "偏向锁",
          "slug": "偏向锁",
          "normalizedTitle": "偏向锁",
          "charIndex": 1012
        },
        {
          "level": 3,
          "title": "轻量级锁",
          "slug": "轻量级锁",
          "normalizedTitle": "轻量级锁",
          "charIndex": 996
        },
        {
          "level": 3,
          "title": "重量级锁",
          "slug": "重量级锁",
          "normalizedTitle": "重量级锁",
          "charIndex": 1001
        },
        {
          "level": 3,
          "title": "锁升级",
          "slug": "锁升级",
          "normalizedTitle": "锁升级",
          "charIndex": 1387
        },
        {
          "level": 3,
          "title": "锁的优缺点对比",
          "slug": "锁的优缺点对比",
          "normalizedTitle": "锁的优缺点对比",
          "charIndex": 2302
        },
        {
          "level": 2,
          "title": "Java如何实现原子操作",
          "slug": "java如何实现原子操作",
          "normalizedTitle": "java如何实现原子操作",
          "charIndex": 2316
        },
        {
          "level": 3,
          "title": "CAS实现原子操作",
          "slug": "cas实现原子操作",
          "normalizedTitle": "cas实现原子操作",
          "charIndex": 2400
        },
        {
          "level": 3,
          "title": "CAS 存在的三个问题",
          "slug": "cas-存在的三个问题",
          "normalizedTitle": "cas 存在的三个问题",
          "charIndex": 2623
        },
        {
          "level": 3,
          "title": "锁机制实现原子操作",
          "slug": "锁机制实现原子操作",
          "normalizedTitle": "锁机制实现原子操作",
          "charIndex": 3081
        }
      ],
      "headersStr": "Java中的内存可见性 Volatile 的实现原理 Synchronized 的用法 Synchronized 的锁存储在哪里？ 为什么Java中每个对象都可以作为锁？ Synchronized 锁升级 偏向锁 轻量级锁 重量级锁 锁升级 锁的优缺点对比 Java如何实现原子操作 CAS实现原子操作 CAS 存在的三个问题 锁机制实现原子操作",
      "content": "在多线程编程中 Synchronized，Volatile 都扮演着重要角色, 都已用来实现原子操作。 Volatile 是轻量级的 Synchronized ，保证了共享变量的可见性。\n\n\n可见性的意思是：当线程A修改共享变量的值后，线程B能立刻读到这个修改后的值。\n\n\nVolatile 不会引起线程上下文的切换和调度，如果使用的恰当，会比 Synchronized 执行成本更低。\n\n\n# Java中的内存可见性\n\n * 可见性：一个线程对共享变量值的修改，能够及时被其他线程看到。\n\n * 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那这个变量就是这几个线程的共享变量。\n\n * Java内存的规定：\n\n-线程对共享变量的所有操作都必须在自己的工作内存中进行，不可直接从主内存中读写； -不同线程之间无法直接访问其他线程工作内存中的变量，线程间的变量值的传递需要通过主内存。\n\n\n\n\n# Volatile 的实现原理\n\n如果对用 Volatile 修饰的变量写操作，JVM 会向处理器发出一条 Lock 前缀的指令，Lock 前缀的指令在多核处理器下会引发两件事情：\n\n 1. 将当前处理器缓存行的数据写会到系统内存\n\n 2. 这个写会内存的操作会使其他缓存中的该内存地址的数据无效\n\n\n# Synchronized 的用法\n\n 1. 普通同步方法：锁当前实例对象\n\n\npublic synchronized void method() {\n\n}\n\n\n\n1\n2\n3\n4\n5\n\n 2. 静态同步方法：锁当前类的Class对象\n\n\npublic synchronized static void method() {\n\n}\n\n\n\n1\n2\n3\n4\n5\n\n 3. 同步代码块：锁括号里对象\n\n\npublic void method()\n\n{\n\nsynchronized(this) {\n\n}\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Synchronized 的锁存储在哪里？\n\nSynchronized的锁存储在Java的对象头里。\n\n\n\nJava 对象头里的 Mark Word 用于存储对象的 HashCode 、分代年龄和锁标记位。\n\n\n32位虚拟机中， Mark Word 的存储结构如下：\n\n\n\n在运行期， Mark Word 有四种状态：轻量级锁、重量级锁、GC 标记、偏向锁，各状态下的存储结构如下图：\n\n\n\n在64位虚拟机下，Mark Word 的存储结构如下图：\n\n\n\n\n# 为什么Java中每个对象都可以作为锁？\n\n任何对象都有一个 monitor 与之关联，当一个 monitor 被持有后，他将处于锁定状态。monitor 是用 C++ 实现的。\n\n同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\n\nmonitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到同步块的结束处和异常处，JVM 要保证每个 monitorenter 都有 monitorexit 与之配对。\n\n\n# Synchronized 锁升级\n\nSynchronized 一直被称为重量级锁。但是在JDK 1.6之后它已经变得不那么重了。JDK 1.6 对Synchronized 的优化点在于：\n\n * 引入了偏向锁\n\n * 引入了轻量级锁\n\n在JDK 1.6 中，Synchronized 锁有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。\n\n\n这几个状态会随着锁竞争升级，但是不可以降级。\n\n\n# 偏向锁\n\n为什么引入偏向锁?\n\n\n不存锁竞争，或者总是由同一线程多次获得锁的场景，偏向锁的代价更低。\n\n当一个线程访问同步块并获取到锁时，在锁对象头记录该线程的id，以后该线程进入和退出该同步块时不需要CAS来加锁和解锁。\n\n偏向锁何时释放？\n\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n\n\n\n偏向锁一定起到正面作用吗？\n\n\n不是的。\n\n\n偏向锁的适用场景是：不存锁竞争，或者总是由同一线程多次获得锁的场景。\n\n如果你确定你的程序中 锁通常处于竞争状态，可以通过JVM参数关闭偏向锁。关闭后，程序回魔人进入轻量级锁状态。\n\n\n-XX:UseBiasedLocking=false\n\n\n\n1\n2\n3\n\n\n\n# 轻量级锁\n\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。\n\n轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n轻量级锁何时升级为重量级锁?\n\n\n若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。\n\n另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。\n\n\n# 重量级锁\n\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。\n\n重量级锁的获取是释放一般会有线程上下文切换，代价是比较大的，所以说是重量级锁。\n\n\n# 锁升级\n\n\n\n\n# 锁的优缺点对比\n\n\n\n\n# Java如何实现原子操作\n\n原子操作：不可被中断的一个或一系列操作。\n\n\nJava 有两种实现原子操作的方式：CAS（compare and swap）、锁。\n\n\n# CAS实现原子操作\n\nCAS理论是 juc 包实现的基石，在intel的CPU中，CAS 通过调用本地方法（JNI）使用cmpxchg指令来实现的非阻塞算法。对比于synchronized阻塞算法，基于 CAS 实现的 juc 在性能上有了很大的提升。\n\nCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。\n\n\n# CAS 存在的三个问题\n\n 1. ABA问题\n\n * 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n\n * ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n\n * 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\n\n 2. 循环时间长开销大\n\n 3. 只能保证一个共享变量的原子操作\n\n从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。\n\n\n# 锁机制实现原子操作\n\n锁机制保证了只有获得锁的线程才能操作指定的内存区域。除了偏向锁，JVM实现锁的方式都使用了循环CAS。",
      "normalizedContent": "在多线程编程中 synchronized，volatile 都扮演着重要角色, 都已用来实现原子操作。 volatile 是轻量级的 synchronized ，保证了共享变量的可见性。\n\n\n可见性的意思是：当线程a修改共享变量的值后，线程b能立刻读到这个修改后的值。\n\n\nvolatile 不会引起线程上下文的切换和调度，如果使用的恰当，会比 synchronized 执行成本更低。\n\n\n# java中的内存可见性\n\n * 可见性：一个线程对共享变量值的修改，能够及时被其他线程看到。\n\n * 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那这个变量就是这几个线程的共享变量。\n\n * java内存的规定：\n\n-线程对共享变量的所有操作都必须在自己的工作内存中进行，不可直接从主内存中读写； -不同线程之间无法直接访问其他线程工作内存中的变量，线程间的变量值的传递需要通过主内存。\n\n\n\n\n# volatile 的实现原理\n\n如果对用 volatile 修饰的变量写操作，jvm 会向处理器发出一条 lock 前缀的指令，lock 前缀的指令在多核处理器下会引发两件事情：\n\n 1. 将当前处理器缓存行的数据写会到系统内存\n\n 2. 这个写会内存的操作会使其他缓存中的该内存地址的数据无效\n\n\n# synchronized 的用法\n\n 1. 普通同步方法：锁当前实例对象\n\n\npublic synchronized void method() {\n\n}\n\n\n\n1\n2\n3\n4\n5\n\n 2. 静态同步方法：锁当前类的class对象\n\n\npublic synchronized static void method() {\n\n}\n\n\n\n1\n2\n3\n4\n5\n\n 3. 同步代码块：锁括号里对象\n\n\npublic void method()\n\n{\n\nsynchronized(this) {\n\n}\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# synchronized 的锁存储在哪里？\n\nsynchronized的锁存储在java的对象头里。\n\n\n\njava 对象头里的 mark word 用于存储对象的 hashcode 、分代年龄和锁标记位。\n\n\n32位虚拟机中， mark word 的存储结构如下：\n\n\n\n在运行期， mark word 有四种状态：轻量级锁、重量级锁、gc 标记、偏向锁，各状态下的存储结构如下图：\n\n\n\n在64位虚拟机下，mark word 的存储结构如下图：\n\n\n\n\n# 为什么java中每个对象都可以作为锁？\n\n任何对象都有一个 monitor 与之关联，当一个 monitor 被持有后，他将处于锁定状态。monitor 是用 c++ 实现的。\n\n同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\n\nmonitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到同步块的结束处和异常处，jvm 要保证每个 monitorenter 都有 monitorexit 与之配对。\n\n\n# synchronized 锁升级\n\nsynchronized 一直被称为重量级锁。但是在jdk 1.6之后它已经变得不那么重了。jdk 1.6 对synchronized 的优化点在于：\n\n * 引入了偏向锁\n\n * 引入了轻量级锁\n\n在jdk 1.6 中，synchronized 锁有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。\n\n\n这几个状态会随着锁竞争升级，但是不可以降级。\n\n\n# 偏向锁\n\n为什么引入偏向锁?\n\n\n不存锁竞争，或者总是由同一线程多次获得锁的场景，偏向锁的代价更低。\n\n当一个线程访问同步块并获取到锁时，在锁对象头记录该线程的id，以后该线程进入和退出该同步块时不需要cas来加锁和解锁。\n\n偏向锁何时释放？\n\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n\n\n\n偏向锁一定起到正面作用吗？\n\n\n不是的。\n\n\n偏向锁的适用场景是：不存锁竞争，或者总是由同一线程多次获得锁的场景。\n\n如果你确定你的程序中 锁通常处于竞争状态，可以通过jvm参数关闭偏向锁。关闭后，程序回魔人进入轻量级锁状态。\n\n\n-xx:usebiasedlocking=false\n\n\n\n1\n2\n3\n\n\n\n# 轻量级锁\n\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。\n\n轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n轻量级锁何时升级为重量级锁?\n\n\n若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。\n\n另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。\n\n\n# 重量级锁\n\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。\n\n重量级锁的获取是释放一般会有线程上下文切换，代价是比较大的，所以说是重量级锁。\n\n\n# 锁升级\n\n\n\n\n# 锁的优缺点对比\n\n\n\n\n# java如何实现原子操作\n\n原子操作：不可被中断的一个或一系列操作。\n\n\njava 有两种实现原子操作的方式：cas（compare and swap）、锁。\n\n\n# cas实现原子操作\n\ncas理论是 juc 包实现的基石，在intel的cpu中，cas 通过调用本地方法（jni）使用cmpxchg指令来实现的非阻塞算法。对比于synchronized阻塞算法，基于 cas 实现的 juc 在性能上有了很大的提升。\n\ncas 操作包含三个操作数 —— 内存位置（v）、预期原值（a）和新值(b)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。\n\n\n# cas 存在的三个问题\n\n 1. aba问题\n\n * 因为cas需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是a，变成了b，又变成了a，那么使用cas进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n\n * aba问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么a－b－a 就会变成1a-2b－3a。\n\n * 从java1.5开始jdk的atomic包里提供了一个类atomicstampedreference来解决aba问题。这个类的compareandset方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\n\n 2. 循环时间长开销大\n\n 3. 只能保证一个共享变量的原子操作\n\n从java1.5开始jdk提供了atomicreference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行cas操作。\n\n\n# 锁机制实现原子操作\n\n锁机制保证了只有获得锁的线程才能操作指定的内存区域。除了偏向锁，jvm实现锁的方式都使用了循环cas。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Synchronized 与 Lock 相比优缺点分别是什么？",
      "frontmatter": {
        "title": "Synchronized 与 Lock 相比优缺点分别是什么？",
        "date": "2022-04-04T14:33:27.000Z",
        "permalink": "/pages/d5d161/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/040.Synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/040.Synchronized 关键字底层是如何实现的？.md",
      "key": "v-352f36cc",
      "path": "/pages/d5d161/",
      "headers": [
        {
          "level": 2,
          "title": "Lock 接口 VS Synchronized",
          "slug": "lock-接口-vs-synchronized",
          "normalizedTitle": "lock 接口 vs synchronized",
          "charIndex": 286
        },
        {
          "level": 2,
          "title": "Lock 锁的常规用法",
          "slug": "lock-锁的常规用法",
          "normalizedTitle": "lock 锁的常规用法",
          "charIndex": 751
        },
        {
          "level": 2,
          "title": "Lock 锁的API",
          "slug": "lock-锁的api",
          "normalizedTitle": "lock 锁的api",
          "charIndex": 928
        }
      ],
      "headersStr": "Lock 接口 VS Synchronized Lock 锁的常规用法 Lock 锁的API",
      "content": "Lock 实现提供比使用 synchronized 方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition 。\n\n虽然 synchronized 方法和语句的范围机制使得使用监视器锁更容易编程，并且有助于避免涉及锁的许多常见编程错误，但是有时您需要以更灵活的方式处理锁。\n\n例如，您获取节点A的锁定，然后获取节点B，然后释放A并获取C，然后释放B并获得D等。\n\n所述的实施方式中Lock接口通过允许获得并在不同的范围释放的锁，并允许获得并以任何顺序释放多个锁使得能够使用这样的技术。\n\n\n# Lock 接口 VS Synchronized\n\nJava SE 5之后，juc 包中增加了 Lock 接口，在此之前 Java 是靠 Synchronized 关键字来实现锁功能的，二者具有相同的内存同步语义，区别如下：\n\n            SYNCHRONIZED      LOCK接口\n加锁、解锁       隐式的加锁、解锁          显式的加锁、解锁\n是否异常自动释放锁   是                 不是，必须手动unlock来释放锁\n是否支持相应中断    只能等待锁的释放，不能响应中断   等待锁过程中可以用interrupt来中断等待\n适用场景                          比如这种场景：先获得A锁，再获取B锁，获取到B锁释放A锁同时获取C锁，获得C锁后释放B锁在获取D锁。这种场景用Synchronized就不好实现了。\n\nLock 相比于 Synchronized 还有如下特性：\n\n * 尝试非阻塞获取锁\n * 能被中断的获取锁\n * 超时获取锁\n\n\n# Lock 锁的常规用法\n\n    Lock l = ...; \n    l.lock(); \n    try {\n        // access the resource protected by this lock }\n    finally { \n        l.unlock(); \n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Lock 锁的API\n\nLock 接口定义了所得获取和释放的基本操作， Lock的API如下：\n\n方法                                          描述\nvoid lock()                                 获得锁\nvoid lockInterruptibly()                    获取锁定，除非当前线程是 interrupted 。\nCondition newCondition()                    返回一个新Condition绑定到该实例Lock实例。\nboolean tryLock()                           只有在调用时才可以获得锁。\nboolean tryLock(long time, TimeUnit unit)   如果在给定的等待时间内是空闲的，并且当前的线程尚未得到 interrupted，则获取该锁\nvoid unlock()                               释放锁。",
      "normalizedContent": "lock 实现提供比使用 synchronized 方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象condition 。\n\n虽然 synchronized 方法和语句的范围机制使得使用监视器锁更容易编程，并且有助于避免涉及锁的许多常见编程错误，但是有时您需要以更灵活的方式处理锁。\n\n例如，您获取节点a的锁定，然后获取节点b，然后释放a并获取c，然后释放b并获得d等。\n\n所述的实施方式中lock接口通过允许获得并在不同的范围释放的锁，并允许获得并以任何顺序释放多个锁使得能够使用这样的技术。\n\n\n# lock 接口 vs synchronized\n\njava se 5之后，juc 包中增加了 lock 接口，在此之前 java 是靠 synchronized 关键字来实现锁功能的，二者具有相同的内存同步语义，区别如下：\n\n            synchronized      lock接口\n加锁、解锁       隐式的加锁、解锁          显式的加锁、解锁\n是否异常自动释放锁   是                 不是，必须手动unlock来释放锁\n是否支持相应中断    只能等待锁的释放，不能响应中断   等待锁过程中可以用interrupt来中断等待\n适用场景                          比如这种场景：先获得a锁，再获取b锁，获取到b锁释放a锁同时获取c锁，获得c锁后释放b锁在获取d锁。这种场景用synchronized就不好实现了。\n\nlock 相比于 synchronized 还有如下特性：\n\n * 尝试非阻塞获取锁\n * 能被中断的获取锁\n * 超时获取锁\n\n\n# lock 锁的常规用法\n\n    lock l = ...; \n    l.lock(); \n    try {\n        // access the resource protected by this lock }\n    finally { \n        l.unlock(); \n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# lock 锁的api\n\nlock 接口定义了所得获取和释放的基本操作， lock的api如下：\n\n方法                                          描述\nvoid lock()                                 获得锁\nvoid lockinterruptibly()                    获取锁定，除非当前线程是 interrupted 。\ncondition newcondition()                    返回一个新condition绑定到该实例lock实例。\nboolean trylock()                           只有在调用时才可以获得锁。\nboolean trylock(long time, timeunit unit)   如果在给定的等待时间内是空闲的，并且当前的线程尚未得到 interrupted，则获取该锁\nvoid unlock()                               释放锁。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "重入锁是如何实现的？",
      "frontmatter": {
        "title": "重入锁是如何实现的？",
        "date": "2022-04-04T14:33:48.000Z",
        "permalink": "/pages/9b59d1/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/050.%E9%87%8D%E5%85%A5%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/050.重入锁是如何实现的？.md",
      "key": "v-4927c049",
      "path": "/pages/9b59d1/",
      "headers": [
        {
          "level": 2,
          "title": "什么是重入锁？",
          "slug": "什么是重入锁",
          "normalizedTitle": "什么是重入锁？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "ReentrantLock - 重入锁加锁",
          "slug": "reentrantlock-重入锁加锁",
          "normalizedTitle": "reentrantlock - 重入锁加锁",
          "charIndex": 362
        },
        {
          "level": 2,
          "title": "ReentrantLock - 重入锁解锁",
          "slug": "reentrantlock-重入锁解锁",
          "normalizedTitle": "reentrantlock - 重入锁解锁",
          "charIndex": 1186
        }
      ],
      "headersStr": "什么是重入锁？ ReentrantLock - 重入锁加锁 ReentrantLock - 重入锁解锁",
      "content": "# 什么是重入锁？\n\nReentrantLock，重入锁，是JDK5中添加在并发包下的一个高性能的工具。顾名思义，ReentrantLock支持同一个线程在未释放锁的情况下重复获取锁。\n\n既然已经有了元老级的synchronized，而且synchronized也支持重入，为什么Doug Lea还要专门写一个ReentrantLock呢？\n\n这是因为：当存在大量线程竞争锁时，多数情况下ReentrantLock的性能优于synchronized。\n\n因为在JDK6中对synchronized做了优化，在锁竞争不激烈的时候，多数情况下锁会停留在偏向锁和轻量级锁阶段，这两个阶段性能是很好的。当存在大量竞争时，可能会膨胀为重量级锁，性能下降，此时的ReentrantLock应该是优于synchronized的。\n\n\n# ReentrantLock - 重入锁加锁\n\n// acquires的值是1\nfinal boolean nonfairTryAcquire(int acquires) {\n  // 获取当前线程\n  final Thread current = Thread.currentThread();\n  // 获取state的值\n  int c = getState();\n  // 如果state的值等于0，表示当前没有线程持有锁\n  // 尝试将state的值改为1，如果修改成功，则成功获取锁，并设置当前线程为持有锁的线程，返回true\n  if (c == 0) {\n    if (compareAndSetState(0, acquires)) {\n      setExclusiveOwnerThread(current);\n      return true;\n    }\n  }\n  // state的值不等于0，表示已经有其他线程持有锁\n  // 判断当前线程是否等于持有锁的线程，如果等于，将state的值+1，并设置到state上，获取锁成功，返回true\n  // 如果不是当前线程，获取锁失败，返回false\n  else if (current == getExclusiveOwnerThread()) {\n    int nextc = c + acquires;\n    if (nextc < 0) // overflow\n      throw new Error(\"Maximum lock count exceeded\");\n    setState(nextc);\n    return true;\n  }\n  return false;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# ReentrantLock - 重入锁解锁\n\npublic void unlock() {\n    // 调用AQS的release方法释放资源\n    sync.release(1);\n}\n\n\n1\n2\n3\n4\n\n\npublic final boolean release(int arg) {\n    // tryRelease也是模板方法，在Sync中实现\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            // 成功释放锁后，唤醒同步队列中的下一个节点，使之可以重新竞争锁\n            // 注意此时不会唤醒队列第一个节点之后的节点，这些节点此时还是无法竞争锁\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nprotected final boolean tryRelease(int releases) {\n    // 将state的值-1，如果-1之后等于0，释放锁成功\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",
      "normalizedContent": "# 什么是重入锁？\n\nreentrantlock，重入锁，是jdk5中添加在并发包下的一个高性能的工具。顾名思义，reentrantlock支持同一个线程在未释放锁的情况下重复获取锁。\n\n既然已经有了元老级的synchronized，而且synchronized也支持重入，为什么doug lea还要专门写一个reentrantlock呢？\n\n这是因为：当存在大量线程竞争锁时，多数情况下reentrantlock的性能优于synchronized。\n\n因为在jdk6中对synchronized做了优化，在锁竞争不激烈的时候，多数情况下锁会停留在偏向锁和轻量级锁阶段，这两个阶段性能是很好的。当存在大量竞争时，可能会膨胀为重量级锁，性能下降，此时的reentrantlock应该是优于synchronized的。\n\n\n# reentrantlock - 重入锁加锁\n\n// acquires的值是1\nfinal boolean nonfairtryacquire(int acquires) {\n  // 获取当前线程\n  final thread current = thread.currentthread();\n  // 获取state的值\n  int c = getstate();\n  // 如果state的值等于0，表示当前没有线程持有锁\n  // 尝试将state的值改为1，如果修改成功，则成功获取锁，并设置当前线程为持有锁的线程，返回true\n  if (c == 0) {\n    if (compareandsetstate(0, acquires)) {\n      setexclusiveownerthread(current);\n      return true;\n    }\n  }\n  // state的值不等于0，表示已经有其他线程持有锁\n  // 判断当前线程是否等于持有锁的线程，如果等于，将state的值+1，并设置到state上，获取锁成功，返回true\n  // 如果不是当前线程，获取锁失败，返回false\n  else if (current == getexclusiveownerthread()) {\n    int nextc = c + acquires;\n    if (nextc < 0) // overflow\n      throw new error(\"maximum lock count exceeded\");\n    setstate(nextc);\n    return true;\n  }\n  return false;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# reentrantlock - 重入锁解锁\n\npublic void unlock() {\n    // 调用aqs的release方法释放资源\n    sync.release(1);\n}\n\n\n1\n2\n3\n4\n\n\npublic final boolean release(int arg) {\n    // tryrelease也是模板方法，在sync中实现\n    if (tryrelease(arg)) {\n        node h = head;\n        if (h != null && h.waitstatus != 0)\n            // 成功释放锁后，唤醒同步队列中的下一个节点，使之可以重新竞争锁\n            // 注意此时不会唤醒队列第一个节点之后的节点，这些节点此时还是无法竞争锁\n            unparksuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nprotected final boolean tryrelease(int releases) {\n    // 将state的值-1，如果-1之后等于0，释放锁成功\n    int c = getstate() - releases;\n    if (thread.currentthread() != getexclusiveownerthread())\n        throw new illegalmonitorstateexception();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setexclusiveownerthread(null);\n    }\n    setstate(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 Java 锁升级的机制",
      "frontmatter": {
        "title": "简述 Java 锁升级的机制",
        "date": "2022-04-04T14:34:27.000Z",
        "permalink": "/pages/ff0616/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/070.%E7%AE%80%E8%BF%B0%20Java%20%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%9C%BA%E5%88%B6.html",
      "relativePath": "01.Java相关/20.并发/070.简述 Java 锁升级的机制.md",
      "key": "v-1065f7be",
      "path": "/pages/ff0616/",
      "headers": [
        {
          "level": 3,
          "title": "偏向锁",
          "slug": "偏向锁",
          "normalizedTitle": "偏向锁",
          "charIndex": 83
        },
        {
          "level": 3,
          "title": "轻量级锁",
          "slug": "轻量级锁",
          "normalizedTitle": "轻量级锁",
          "charIndex": 94
        },
        {
          "level": 3,
          "title": "重量级锁",
          "slug": "重量级锁",
          "normalizedTitle": "重量级锁",
          "charIndex": 18
        },
        {
          "level": 3,
          "title": "锁升级",
          "slug": "锁升级",
          "normalizedTitle": "锁升级",
          "charIndex": 659
        },
        {
          "level": 3,
          "title": "锁的优缺点对比",
          "slug": "锁的优缺点对比",
          "normalizedTitle": "锁的优缺点对比",
          "charIndex": 910
        }
      ],
      "headersStr": "偏向锁 轻量级锁 重量级锁 锁升级 锁的优缺点对比",
      "content": "Synchronized 一直被称为重量级锁。但是在JDK 1.6之后它已经变得不那么重了。JDK 1.6 对Synchronized 的优化点在于：\n\n * 引入了偏向锁\n\n * 引入了轻量级锁\n\n在JDK 1.6 中，Synchronized 锁有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。\n\n\n这几个状态会随着锁竞争升级，但是不可以降级。\n\n\n# 偏向锁\n\n为什么引入偏向锁?\n\n\n不存锁竞争，或者总是由同一线程多次获得锁的场景，偏向锁的代价更低。\n\n当一个线程访问同步块并获取到锁时，在锁对象头记录该线程的id，以后该线程进入和退出该同步块时不需要CAS来加锁和解锁。\n\n偏向锁何时释放？\n\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n\n\n\n偏向锁一定起到正面作用吗？\n\n\n不是的。\n\n\n偏向锁的适用场景是：不存锁竞争，或者总是由同一线程多次获得锁的场景。\n\n如果你确定你的程序中 锁通常处于竞争状态，可以通过JVM参数关闭偏向锁。关闭后，程序回魔人进入轻量级锁状态。\n\n\n-XX:UseBiasedLocking=false\n\n\n\n1\n2\n3\n\n\n\n# 轻量级锁\n\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。\n\n轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n轻量级锁何时升级为重量级锁?\n\n\n若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。\n\n另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。\n\n\n# 重量级锁\n\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。\n\n重量级锁的获取是释放一般会有线程上下文切换，代价是比较大的，所以说是重量级锁。\n\n\n# 锁升级\n\n\n\n\n# 锁的优缺点对比\n\n",
      "normalizedContent": "synchronized 一直被称为重量级锁。但是在jdk 1.6之后它已经变得不那么重了。jdk 1.6 对synchronized 的优化点在于：\n\n * 引入了偏向锁\n\n * 引入了轻量级锁\n\n在jdk 1.6 中，synchronized 锁有四种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。\n\n\n这几个状态会随着锁竞争升级，但是不可以降级。\n\n\n# 偏向锁\n\n为什么引入偏向锁?\n\n\n不存锁竞争，或者总是由同一线程多次获得锁的场景，偏向锁的代价更低。\n\n当一个线程访问同步块并获取到锁时，在锁对象头记录该线程的id，以后该线程进入和退出该同步块时不需要cas来加锁和解锁。\n\n偏向锁何时释放？\n\n\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。\n\n\n\n偏向锁一定起到正面作用吗？\n\n\n不是的。\n\n\n偏向锁的适用场景是：不存锁竞争，或者总是由同一线程多次获得锁的场景。\n\n如果你确定你的程序中 锁通常处于竞争状态，可以通过jvm参数关闭偏向锁。关闭后，程序回魔人进入轻量级锁状态。\n\n\n-xx:usebiasedlocking=false\n\n\n\n1\n2\n3\n\n\n\n# 轻量级锁\n\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。\n\n轻量级锁的获取主要由两种情况：① 当关闭偏向锁功能时；② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n轻量级锁何时升级为重量级锁?\n\n\n若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。\n\n另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）。\n\n\n# 重量级锁\n\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。\n\n重量级锁的获取是释放一般会有线程上下文切换，代价是比较大的，所以说是重量级锁。\n\n\n# 锁升级\n\n\n\n\n# 锁的优缺点对比\n\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "volatile 关键字解决了什么问题，它的实现原理是什么？",
      "frontmatter": {
        "title": "volatile 关键字解决了什么问题，它的实现原理是什么？",
        "date": "2022-04-04T14:34:07.000Z",
        "permalink": "/pages/383264/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/060.volatile%20%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/060.volatile 关键字解决了什么问题，它的实现原理是什么？.md",
      "key": "v-f5bcd180",
      "path": "/pages/383264/",
      "headers": [
        {
          "level": 2,
          "title": "Java中的内存可见性",
          "slug": "java中的内存可见性",
          "normalizedTitle": "java中的内存可见性",
          "charIndex": 129
        },
        {
          "level": 2,
          "title": "Volatile 的实现原理",
          "slug": "volatile-的实现原理",
          "normalizedTitle": "volatile 的实现原理",
          "charIndex": 335
        }
      ],
      "headersStr": "Java中的内存可见性 Volatile 的实现原理",
      "content": "volatile 能保证 Java 中的内存可见性。 可见性的意思是：当线程A修改共享变量的值后，线程B能立刻读到这个修改后的值。\n\n\nVolatile 不会引起线程上下文的切换和调度，如果使用的恰当，会比 Synchronized 执行成本更低。\n\n\n# Java中的内存可见性\n\n * 可见性：一个线程对共享变量值的修改，能够及时被其他线程看到。\n\n * 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那这个变量就是这几个线程的共享变量。\n\n * Java内存的规定：\n\n-线程对共享变量的所有操作都必须在自己的工作内存中进行，不可直接从主内存中读写； -不同线程之间无法直接访问其他线程工作内存中的变量，线程间的变量值的传递需要通过主内存。\n\n\n\n\n# Volatile 的实现原理\n\n如果对用 Volatile 修饰的变量写操作，JVM 会向处理器发出一条 Lock 前缀的指令，Lock 前缀的指令在多核处理器下会引发两件事情：\n\n 1. 将当前处理器缓存行的数据写会到系统内存\n\n 2. 这个写会内存的操作会使其他缓存中的该内存地址的数据无效",
      "normalizedContent": "volatile 能保证 java 中的内存可见性。 可见性的意思是：当线程a修改共享变量的值后，线程b能立刻读到这个修改后的值。\n\n\nvolatile 不会引起线程上下文的切换和调度，如果使用的恰当，会比 synchronized 执行成本更低。\n\n\n# java中的内存可见性\n\n * 可见性：一个线程对共享变量值的修改，能够及时被其他线程看到。\n\n * 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那这个变量就是这几个线程的共享变量。\n\n * java内存的规定：\n\n-线程对共享变量的所有操作都必须在自己的工作内存中进行，不可直接从主内存中读写； -不同线程之间无法直接访问其他线程工作内存中的变量，线程间的变量值的传递需要通过主内存。\n\n\n\n\n# volatile 的实现原理\n\n如果对用 volatile 修饰的变量写操作，jvm 会向处理器发出一条 lock 前缀的指令，lock 前缀的指令在多核处理器下会引发两件事情：\n\n 1. 将当前处理器缓存行的数据写会到系统内存\n\n 2. 这个写会内存的操作会使其他缓存中的该内存地址的数据无效",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "简述 Java AQS 的原理以及使用场景",
      "frontmatter": {
        "title": "简述 Java AQS 的原理以及使用场景",
        "date": "2022-04-04T14:34:53.000Z",
        "permalink": "/pages/52a687/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/080.%E7%AE%80%E8%BF%B0%20Java%20AQS%20%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",
      "relativePath": "01.Java相关/20.并发/080.简述 Java AQS 的原理以及使用场景.md",
      "key": "v-2dbdb772",
      "path": "/pages/52a687/",
      "headers": [
        {
          "level": 2,
          "title": "简述 Java AQS 的原理以及使用场景",
          "slug": "简述-java-aqs-的原理以及使用场景",
          "normalizedTitle": "简述 java aqs 的原理以及使用场景",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "AbstractQueuedSynchronizer 是什么",
          "slug": "abstractqueuedsynchronizer-是什么",
          "normalizedTitle": "abstractqueuedsynchronizer 是什么",
          "charIndex": 28
        },
        {
          "level": 2,
          "title": "AbstractQueuedSynchronizer 是如何实现的",
          "slug": "abstractqueuedsynchronizer-是如何实现的",
          "normalizedTitle": "abstractqueuedsynchronizer 是如何实现的",
          "charIndex": 480
        },
        {
          "level": 2,
          "title": "如何用 AQS 实现一个排他锁",
          "slug": "如何用-aqs-实现一个排他锁",
          "normalizedTitle": "如何用 aqs 实现一个排他锁",
          "charIndex": 1157
        },
        {
          "level": 2,
          "title": "AQS原理 - 排它锁-加锁",
          "slug": "aqs原理-排它锁-加锁",
          "normalizedTitle": "aqs原理 - 排它锁-加锁",
          "charIndex": 3195
        },
        {
          "level": 3,
          "title": "尝试获取锁 tryAcquire(arg)",
          "slug": "尝试获取锁-tryacquire-arg",
          "normalizedTitle": "尝试获取锁 tryacquire(arg)",
          "charIndex": 3686
        },
        {
          "level": 3,
          "title": "加入sync队列 addWaiter(Node.EXCLUSIVE)",
          "slug": "加入sync队列-addwaiter-node-exclusive",
          "normalizedTitle": "加入sync队列 addwaiter(node.exclusive)",
          "charIndex": 4588
        },
        {
          "level": 3,
          "title": "排队 acquireQueued(Node,arg)",
          "slug": "排队-acquirequeued-node-arg",
          "normalizedTitle": "排队 acquirequeued(node,arg)",
          "charIndex": 5587
        },
        {
          "level": 3,
          "title": "AQS原理 - 获取排它锁流程图",
          "slug": "aqs原理-获取排它锁流程图",
          "normalizedTitle": "aqs原理 - 获取排它锁流程图",
          "charIndex": 8358
        },
        {
          "level": 2,
          "title": "AQS原理 - 排它锁-解锁",
          "slug": "aqs原理-排它锁-解锁",
          "normalizedTitle": "aqs原理 - 排它锁-解锁",
          "charIndex": 8723
        },
        {
          "level": 2,
          "title": "AQS原理 - 共享锁-加锁",
          "slug": "aqs原理-共享锁-加锁",
          "normalizedTitle": "aqs原理 - 共享锁-加锁",
          "charIndex": 9580
        },
        {
          "level": 2,
          "title": "AQS原理 - 共享锁-解锁",
          "slug": "aqs原理-共享锁-解锁",
          "normalizedTitle": "aqs原理 - 共享锁-解锁",
          "charIndex": 10197
        }
      ],
      "headersStr": "简述 Java AQS 的原理以及使用场景 AbstractQueuedSynchronizer 是什么 AbstractQueuedSynchronizer 是如何实现的 如何用 AQS 实现一个排他锁 AQS原理 - 排它锁-加锁 尝试获取锁 tryAcquire(arg) 加入sync队列 addWaiter(Node.EXCLUSIVE) 排队 acquireQueued(Node,arg) AQS原理 - 获取排它锁流程图 AQS原理 - 排它锁-解锁 AQS原理 - 共享锁-加锁 AQS原理 - 共享锁-解锁",
      "content": "# 简述 Java AQS 的原理以及使用场景\n\n\n# AbstractQueuedSynchronizer 是什么\n\nAbstractQueuedSynchronizer（AQS） 提供一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。\n\n该类被设计为大多数类型的同步器的依据，这些同步器依赖于单个原子int值来表示状态。\n\nAQS的子类通过继承并实现它的抽象方法来实现管理同步状态，子类可以通过 AQS 提供的是三个方法来 修改状态值\n\n * getState()\n * setState(int)\n * compareAndSetState(int, int)\n\n因为这三个方法能保证状态的修改是安全的。\n\nAQS采用模板方法，内部实现了获取锁失败后加入等待队列的机制，大大降低了四线一个自定义同步组件的门槛。\n\nCountDownLatch、Semaphore、ReentrantLock等等常见的工具类都是由AQS来实现的。所以不管是面试也好，还是自己研究底层实现也好，AQS类都是必须要重点关注的。\n\n\n# AbstractQueuedSynchronizer 是如何实现的\n\n同步器的开始提到了其实现依赖于一个FIFO队列，那么队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。Node的主要包含以下成员变量：\n\nNode {\n//表示节点的状态。\n    int waitStatus;\n    //前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。\n    Node prev;\n    //后继节点。\n    Node next;\n    //存储condition队列中的后继节点。\n    Node nextWaiter;\n    //入队列时的当前线程。\n    Thread thread;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nwaitStatus取值有5个枚举：\n\n * CANCELLED，值为1，表示当前的线程被取消；\n * SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；\n * CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；\n * PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；\n * 值为0，表示当前节点在sync队列中，等待着获取锁。\n\nAQS（同步器） 和 其持有的FIFO队列的关系如上图，AQS 持有队列的头结点和尾结点，竞争锁失败的线程会被放到队列的后面，排队获取锁。\n\n\n# 如何用 AQS 实现一个排他锁\n\n排他锁的实现，顾名思义，一次只能一个线程获取到锁。 伪代码的获取:\n\nwhile(获取锁) {\n  if (获取到) {\n    退出while循环\n  } else {\n    if(当前线程没有入队列) {\n      那么入队列\n    }\n    阻塞当前线程\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n伪代码的释放:\n\nif (释放成功) {\n  删除头结点\n  激活原头结点的后继节点\n}\n\n\n1\n2\n3\n4\n\n\n通过AQS 实现:\n\nclass Mutex implements Lock, java.io.Serializable {\n   // 内部类，自定义同步器\n   private static class Sync extends AbstractQueuedSynchronizer {\n     // 是否处于占用状态\n     protected boolean isHeldExclusively() {\n       return getState() == 1;\n     }\n     // 当状态为0的时候获取锁\n     public boolean tryAcquire(int acquires) {\n       assert acquires == 1; // Otherwise unused\n       if (compareAndSetState(0, 1)) {\n         setExclusiveOwnerThread(Thread.currentThread());\n         return true;\n       }\n       return false;\n     }\n     // 释放锁，将状态设置为0\n     protected boolean tryRelease(int releases) {\n       assert releases == 1; // Otherwise unused\n       if (getState() == 0) throw new IllegalMonitorStateException();\n       setExclusiveOwnerThread(null);\n       setState(0);\n       return true;\n     }\n     // 返回一个Condition，每个condition都包含了一个condition队列\n     Condition newCondition() { return new ConditionObject(); }\n   }\n   // 仅需要将操作代理到Sync上即可\n   private final Sync sync = new Sync();\n   public void lock()                { sync.acquire(1); }\n   public boolean tryLock()          { return sync.tryAcquire(1); }\n   public void unlock()              { sync.release(1); }\n   public Condition newCondition()   { return sync.newCondition(); }\n   public boolean isLocked()         { return sync.isHeldExclusively(); }\n   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }\n   public void lockInterruptibly() throws InterruptedException {\n     sync.acquireInterruptibly(1);\n   }\n   public boolean tryLock(long timeout, TimeUnit unit)\n       throws InterruptedException {\n     return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n   }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n可以看到Mutex将Lock接口均代理给了同步器的实现。\n\n\n# AQS原理 - 排它锁-加锁\n\nAQS 中的 public final void acquire(int arg)以非阻塞的方式获取排它锁，实现 synchronized 语义，可以说是 AQS 中最重要的方法。\n\npublic final void acquire(int arg) {\n        if (!tryAcquire(arg) &amp;&amp;\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n这段代码逻辑做了三件事情：\n\n 1. 尝试获取锁 ;tryAcquire(arg)\n 2. 加入sync队列。如果获取不到，将当前线程构造成节点Node并加入sync队列；addWaiter(Node.EXCLUSIVE)\n 3. 排队。再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态 ;acquireQueued(Node,arg)\n\n下面我们逐步来看下这三个过程\n\n\n# 尝试获取锁 tryAcquire(arg)\n\n整个方法需要子类实现，比如公平锁、非公平锁就是在这个方法中做的逻辑。 我们来看下公平锁的实现：\n\nprotected final boolean tryAcquire(int acquires) {\n  // 当前线程\n    final Thread current = Thread.currentThread();\n    // 获取state状态，0表示未锁定，大于1表示重入\n    int c = getState();\n    // 0表示没有线程获取锁\n    if (c == 0) {\n    // 没有比当前线程等待更久的线程了，通过CAS的方式修改state\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            // 成功之后，设置当前拥有独占访问权的线程\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    // 独占访问权的线程就是当前线程，重入，此处就是【可重入性】的实现\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error(\"Maximum lock count exceeded\");\n        // 直接修改state\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 加入sync队列 addWaiter(Node.EXCLUSIVE)\n\nprivate Node addWaiter(Node mode) {\n  Node node = new Node(Thread.currentThread(), mode);\n  Node pred = tail;\n    // 如果队列不为空 快速尝试在尾部添加 那么node节点的前继节点是tail\n  if (pred != null) {\n    node.prev = pred;\n        //CAS操作 将node设置为尾结点 （多线程竞争的情况下，这里可能会失败）\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n            //快速尝试在尾部添加成功 返回\n      return node;\n    }\n  }\n    //队列为空 或者 快速尝试在尾部添加失败 程序会走到这里\n  enq(node);\n  return node;\n}\n\n//在循环中 CAS入队列\nprivate Node enq(final Node node) {\n  for (;;) {\n    Node t = tail;\n    if (t == null) { // 如果队列为空 先初始化\n      if (compareAndSetHead(new Node()))\n        tail = head;\n    } else {// 如果队列不为空 CAS入队列\n      node.prev = t;\n      if (compareAndSetTail(t, node)) {\n      t.next = node;\n      return t;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上述逻辑主要包括：\n\n 1. 如果队列不为空 快速尝试在尾部添加,一次CAS\n 2. 队列为空 或者 快速尝试在尾部添加失败 程序进入循环判断3、4步\n 3. 如果队列为空 先初始化\n 4. 如果队列不为空 CAS入队列\n\n\n# 排队 acquireQueued(Node,arg)\n\n线程挂起之前 循环尝试获取锁；\n\nfinal boolean acquireQueued(final Node node, int arg) {\n  boolean failed = true;\n  try {\n    boolean interrupted = false;\n    for (;;) {\n      final Node p = node.predecessor();\n            //如果本线程已经是头结点了 tryAcquire(arg)下 尝试获取锁\n      if (p == head && tryAcquire(arg)) {\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n                //获取到了 退出循环\n        return interrupted;\n      }\n            //没获取到 判断要不要挂起\n      if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n        interrupted = true;\n                }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上述逻辑主要包括：\n\n 1. 如果本线程已经是头结点了 tryAcquire(arg)下 尝试获取锁，获取到了 退出循环，没获取到 判断要不要挂起\n 2. 挂起前，循环执行第一步\n\n如何判断要不要挂起呢，我们再来看下shouldParkAfterFailedAcquire(p, node):\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n// 获取pred前置节点的等待状态\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n/* 前置节点状态是signal，那当前节点可以安全阻塞，因为前置节点承诺执行完之后会通知唤醒当前\n* 节点\n*/\n            return true;\n        if (ws > 0) {\n \n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n// 前置节点如果已经被取消了，则一直往前遍历直到前置节点不是取消状态，与此同时会修改链表关系\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n// 前置节点是0或者propagate状态，这里通过CAS把前置节点状态改成signal\n// 这里不返回true让当前节点阻塞，而是返回false，目的是让调用者再check一下当前线程是否能\n// 成功获取锁，失败的话再阻塞，这里说实话我也不是特别理解这么做的原因\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n这段代码用来检测是否挂起当先线程,分三种情况,\n\n 1. 第一种情况是前驱节点的 ws = singal,表示前驱节点释放同步状态的时候会唤醒当前节点,可以安全挂起当前线程;\n 2. 第二种情况是前驱节点被取消,那就从前驱节点继续往前遍历,直到往前找到第一个ws <= 0 的节点;\n 3. 第三种是前驱节点的 ws = 0,表示前驱节点获取到同步状态,当前线程不能挂起,应该尝试去获取同步状态,前驱节点的同步状态的释放正好可以让当前节点进行获取,所以使用CAS把前驱节点的ws设为singal,另外如果 ws =PROPAGATE,说明正以共享模式进行传播,也需要使用CAS把ws设为singal.\n\n如何挂起线程呢?我们来看下parkAndCheckInterrupt()：\n\nprivate final boolean parkAndCheckInterrupt() {\n        // 阻塞当前线程，监事是当前sync对象\n        LockSupport.park(this);\n        // 阻塞返回后，返回当前线程是否被中断\n        return Thread.interrupted();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# AQS原理 - 获取排它锁流程图\n\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n首先执行tryAcquire方法用于尝试获取锁，成功后就直接返回，失败后就通过addWaiter方法把当前线程封装成一个Node，加到队列的尾部，再通过acquireQueued方法尝试获取同步锁，成功获取锁的线程的Node节点会被移出队列。\n\n如果以上条件都满足，会执行selfInterrupt方法中断当前线程。\n\n最后 我们再用一张流程图来回顾下这整个流程\n\n\n# AQS原理 - 排它锁-解锁\n\n我们已经知道了sync是AQS的实现，所以直接查看AQS中的release方法\n\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n      // 尝试释放锁\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n          // 头节点已经释放，唤醒后继节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ntryRelease 同样是模板方法：\n\nprotected final boolean tryRelease(int releases) {\n  // 计算剩余的重入次数\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    // 是否完全的释放了锁（针对可重入性）\n    boolean free = false;\n    if (c == 0) {\n      // 表示完全释放了锁\n        free = true;\n        // 设置独占锁的持有者为null\n        setExclusiveOwnerThread(null);\n    }\n    // 设置AQS的state\n    setState(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# AQS原理 - 共享锁-加锁\n\nprotected int tryAcquireShared(int acquires) {\n    for (;;) {\n      // 自旋\n        if (hasQueuedPredecessors())\n          // 如果有线程排在自己的前面（公平锁排队），直接返回\n            return -1;\n        // 获取同步状态的值\n        int available = getState();\n        // 可用的（许可）减去申请的，等于剩余的\n        int remaining = available - acquires;\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            // 如果剩余的小于0，或者设置状态成功，就返回，如果设置失败，则进入下一次循环\n            // 如果剩余小于0，返回负数，表示失败\n            // 如果设置状态成功，表示申请许可成功，返回正数\n            return remaining;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# AQS原理 - 共享锁-解锁\n\nreleaseShared()\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ntryReleaseShared()\n\nprotected final boolean tryReleaseShared(int releases) {\n    for (;;) {\n      // 自旋\n      // 获取同步状态的值\n        int current = getState();\n        // 可用的（许可）加上释放的，等于剩余的\n        int next = current + releases;\n        if (next < current) // overflow\n            throw new Error(\"Maximum permit count exceeded\");\n        if (compareAndSetState(current, next))\n          // CAS的方式设置同步状态\n            return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndoReleaseShared()\n\n/**\n * Release action for shared mode -- signals successor and ensures\n * propagation. (Note: For exclusive mode, release just amounts\n * to calling unparkSuccessor of head if it needs signal.)\n */\nprivate void doReleaseShared() {\n    /*\n     * Ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  This proceeds in the usual\n     * way of trying to unparkSuccessor of head if it needs\n     * signal. But if it does not, status is set to PROPAGATE to\n     * ensure that upon release, propagation continues.\n     * Additionally, we must loop in case a new node is added\n     * while we are doing this. Also, unlike other uses of\n     * unparkSuccessor, we need to know if CAS to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n      // 自旋\n      // 记录头节点\n        Node h = head;\n        if (h != null && h != tail) {\n          // 头节点不为null，且不等于尾结点，说明队列中还有节点\n          // 获取头节点等待状态\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n              // 头节点等待状态是SIGNAL\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                  // 如果修改节点等待状态失败，进入下一次循环\n                    continue;            // loop to recheck cases\n                // 修改成功后，唤醒后继节点，unparkSuccessor前文讲过\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n",
      "normalizedContent": "# 简述 java aqs 的原理以及使用场景\n\n\n# abstractqueuedsynchronizer 是什么\n\nabstractqueuedsynchronizer（aqs） 提供一个框架，用于实现依赖先进先出（fifo）等待队列的阻塞锁和相关同步器（信号量，事件等）。\n\n该类被设计为大多数类型的同步器的依据，这些同步器依赖于单个原子int值来表示状态。\n\naqs的子类通过继承并实现它的抽象方法来实现管理同步状态，子类可以通过 aqs 提供的是三个方法来 修改状态值\n\n * getstate()\n * setstate(int)\n * compareandsetstate(int, int)\n\n因为这三个方法能保证状态的修改是安全的。\n\naqs采用模板方法，内部实现了获取锁失败后加入等待队列的机制，大大降低了四线一个自定义同步组件的门槛。\n\ncountdownlatch、semaphore、reentrantlock等等常见的工具类都是由aqs来实现的。所以不管是面试也好，还是自己研究底层实现也好，aqs类都是必须要重点关注的。\n\n\n# abstractqueuedsynchronizer 是如何实现的\n\n同步器的开始提到了其实现依赖于一个fifo队列，那么队列中的元素node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。node的主要包含以下成员变量：\n\nnode {\n//表示节点的状态。\n    int waitstatus;\n    //前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。\n    node prev;\n    //后继节点。\n    node next;\n    //存储condition队列中的后继节点。\n    node nextwaiter;\n    //入队列时的当前线程。\n    thread thread;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nwaitstatus取值有5个枚举：\n\n * cancelled，值为1，表示当前的线程被取消；\n * signal，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；\n * condition，值为-2，表示当前节点在等待condition，也就是在condition队列中；\n * propagate，值为-3，表示当前场景下后续的acquireshared能够得以执行；\n * 值为0，表示当前节点在sync队列中，等待着获取锁。\n\naqs（同步器） 和 其持有的fifo队列的关系如上图，aqs 持有队列的头结点和尾结点，竞争锁失败的线程会被放到队列的后面，排队获取锁。\n\n\n# 如何用 aqs 实现一个排他锁\n\n排他锁的实现，顾名思义，一次只能一个线程获取到锁。 伪代码的获取:\n\nwhile(获取锁) {\n  if (获取到) {\n    退出while循环\n  } else {\n    if(当前线程没有入队列) {\n      那么入队列\n    }\n    阻塞当前线程\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n伪代码的释放:\n\nif (释放成功) {\n  删除头结点\n  激活原头结点的后继节点\n}\n\n\n1\n2\n3\n4\n\n\n通过aqs 实现:\n\nclass mutex implements lock, java.io.serializable {\n   // 内部类，自定义同步器\n   private static class sync extends abstractqueuedsynchronizer {\n     // 是否处于占用状态\n     protected boolean isheldexclusively() {\n       return getstate() == 1;\n     }\n     // 当状态为0的时候获取锁\n     public boolean tryacquire(int acquires) {\n       assert acquires == 1; // otherwise unused\n       if (compareandsetstate(0, 1)) {\n         setexclusiveownerthread(thread.currentthread());\n         return true;\n       }\n       return false;\n     }\n     // 释放锁，将状态设置为0\n     protected boolean tryrelease(int releases) {\n       assert releases == 1; // otherwise unused\n       if (getstate() == 0) throw new illegalmonitorstateexception();\n       setexclusiveownerthread(null);\n       setstate(0);\n       return true;\n     }\n     // 返回一个condition，每个condition都包含了一个condition队列\n     condition newcondition() { return new conditionobject(); }\n   }\n   // 仅需要将操作代理到sync上即可\n   private final sync sync = new sync();\n   public void lock()                { sync.acquire(1); }\n   public boolean trylock()          { return sync.tryacquire(1); }\n   public void unlock()              { sync.release(1); }\n   public condition newcondition()   { return sync.newcondition(); }\n   public boolean islocked()         { return sync.isheldexclusively(); }\n   public boolean hasqueuedthreads() { return sync.hasqueuedthreads(); }\n   public void lockinterruptibly() throws interruptedexception {\n     sync.acquireinterruptibly(1);\n   }\n   public boolean trylock(long timeout, timeunit unit)\n       throws interruptedexception {\n     return sync.tryacquirenanos(1, unit.tonanos(timeout));\n   }\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n可以看到mutex将lock接口均代理给了同步器的实现。\n\n\n# aqs原理 - 排它锁-加锁\n\naqs 中的 public final void acquire(int arg)以非阻塞的方式获取排它锁，实现 synchronized 语义，可以说是 aqs 中最重要的方法。\n\npublic final void acquire(int arg) {\n        if (!tryacquire(arg) &amp;&amp;\n            acquirequeued(addwaiter(node.exclusive), arg))\n            selfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n这段代码逻辑做了三件事情：\n\n 1. 尝试获取锁 ;tryacquire(arg)\n 2. 加入sync队列。如果获取不到，将当前线程构造成节点node并加入sync队列；addwaiter(node.exclusive)\n 3. 排队。再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态 ;acquirequeued(node,arg)\n\n下面我们逐步来看下这三个过程\n\n\n# 尝试获取锁 tryacquire(arg)\n\n整个方法需要子类实现，比如公平锁、非公平锁就是在这个方法中做的逻辑。 我们来看下公平锁的实现：\n\nprotected final boolean tryacquire(int acquires) {\n  // 当前线程\n    final thread current = thread.currentthread();\n    // 获取state状态，0表示未锁定，大于1表示重入\n    int c = getstate();\n    // 0表示没有线程获取锁\n    if (c == 0) {\n    // 没有比当前线程等待更久的线程了，通过cas的方式修改state\n        if (!hasqueuedpredecessors() &&\n            compareandsetstate(0, acquires)) {\n            // 成功之后，设置当前拥有独占访问权的线程\n            setexclusiveownerthread(current);\n            return true;\n        }\n    }\n    // 独占访问权的线程就是当前线程，重入，此处就是【可重入性】的实现\n    else if (current == getexclusiveownerthread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new error(\"maximum lock count exceeded\");\n        // 直接修改state\n        setstate(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 加入sync队列 addwaiter(node.exclusive)\n\nprivate node addwaiter(node mode) {\n  node node = new node(thread.currentthread(), mode);\n  node pred = tail;\n    // 如果队列不为空 快速尝试在尾部添加 那么node节点的前继节点是tail\n  if (pred != null) {\n    node.prev = pred;\n        //cas操作 将node设置为尾结点 （多线程竞争的情况下，这里可能会失败）\n    if (compareandsettail(pred, node)) {\n      pred.next = node;\n            //快速尝试在尾部添加成功 返回\n      return node;\n    }\n  }\n    //队列为空 或者 快速尝试在尾部添加失败 程序会走到这里\n  enq(node);\n  return node;\n}\n\n//在循环中 cas入队列\nprivate node enq(final node node) {\n  for (;;) {\n    node t = tail;\n    if (t == null) { // 如果队列为空 先初始化\n      if (compareandsethead(new node()))\n        tail = head;\n    } else {// 如果队列不为空 cas入队列\n      node.prev = t;\n      if (compareandsettail(t, node)) {\n      t.next = node;\n      return t;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上述逻辑主要包括：\n\n 1. 如果队列不为空 快速尝试在尾部添加,一次cas\n 2. 队列为空 或者 快速尝试在尾部添加失败 程序进入循环判断3、4步\n 3. 如果队列为空 先初始化\n 4. 如果队列不为空 cas入队列\n\n\n# 排队 acquirequeued(node,arg)\n\n线程挂起之前 循环尝试获取锁；\n\nfinal boolean acquirequeued(final node node, int arg) {\n  boolean failed = true;\n  try {\n    boolean interrupted = false;\n    for (;;) {\n      final node p = node.predecessor();\n            //如果本线程已经是头结点了 tryacquire(arg)下 尝试获取锁\n      if (p == head && tryacquire(arg)) {\n        sethead(node);\n        p.next = null; // help gc\n        failed = false;\n                //获取到了 退出循环\n        return interrupted;\n      }\n            //没获取到 判断要不要挂起\n      if (shouldparkafterfailedacquire(p, node) &&\n                    parkandcheckinterrupt())\n        interrupted = true;\n                }\n  } finally {\n    if (failed)\n      cancelacquire(node);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上述逻辑主要包括：\n\n 1. 如果本线程已经是头结点了 tryacquire(arg)下 尝试获取锁，获取到了 退出循环，没获取到 判断要不要挂起\n 2. 挂起前，循环执行第一步\n\n如何判断要不要挂起呢，我们再来看下shouldparkafterfailedacquire(p, node):\n\nprivate static boolean shouldparkafterfailedacquire(node pred, node node) {\n// 获取pred前置节点的等待状态\n        int ws = pred.waitstatus;\n        if (ws == node.signal)\n            /*\n             * this node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n/* 前置节点状态是signal，那当前节点可以安全阻塞，因为前置节点承诺执行完之后会通知唤醒当前\n* 节点\n*/\n            return true;\n        if (ws > 0) {\n \n            /*\n             * predecessor was cancelled. skip over predecessors and\n             * indicate retry.\n             */\n// 前置节点如果已经被取消了，则一直往前遍历直到前置节点不是取消状态，与此同时会修改链表关系\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitstatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitstatus must be 0 or propagate.  indicate that we\n             * need a signal, but don't park yet.  caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n// 前置节点是0或者propagate状态，这里通过cas把前置节点状态改成signal\n// 这里不返回true让当前节点阻塞，而是返回false，目的是让调用者再check一下当前线程是否能\n// 成功获取锁，失败的话再阻塞，这里说实话我也不是特别理解这么做的原因\n            compareandsetwaitstatus(pred, ws, node.signal);\n        }\n        return false;\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n这段代码用来检测是否挂起当先线程,分三种情况,\n\n 1. 第一种情况是前驱节点的 ws = singal,表示前驱节点释放同步状态的时候会唤醒当前节点,可以安全挂起当前线程;\n 2. 第二种情况是前驱节点被取消,那就从前驱节点继续往前遍历,直到往前找到第一个ws <= 0 的节点;\n 3. 第三种是前驱节点的 ws = 0,表示前驱节点获取到同步状态,当前线程不能挂起,应该尝试去获取同步状态,前驱节点的同步状态的释放正好可以让当前节点进行获取,所以使用cas把前驱节点的ws设为singal,另外如果 ws =propagate,说明正以共享模式进行传播,也需要使用cas把ws设为singal.\n\n如何挂起线程呢?我们来看下parkandcheckinterrupt()：\n\nprivate final boolean parkandcheckinterrupt() {\n        // 阻塞当前线程，监事是当前sync对象\n        locksupport.park(this);\n        // 阻塞返回后，返回当前线程是否被中断\n        return thread.interrupted();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# aqs原理 - 获取排它锁流程图\n\npublic final void acquire(int arg) {\n    if (!tryacquire(arg) &&\n        acquirequeued(addwaiter(node.exclusive), arg))\n        selfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n首先执行tryacquire方法用于尝试获取锁，成功后就直接返回，失败后就通过addwaiter方法把当前线程封装成一个node，加到队列的尾部，再通过acquirequeued方法尝试获取同步锁，成功获取锁的线程的node节点会被移出队列。\n\n如果以上条件都满足，会执行selfinterrupt方法中断当前线程。\n\n最后 我们再用一张流程图来回顾下这整个流程\n\n\n# aqs原理 - 排它锁-解锁\n\n我们已经知道了sync是aqs的实现，所以直接查看aqs中的release方法\n\npublic final boolean release(int arg) {\n    if (tryrelease(arg)) {\n      // 尝试释放锁\n        node h = head;\n        if (h != null && h.waitstatus != 0)\n          // 头节点已经释放，唤醒后继节点\n            unparksuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ntryrelease 同样是模板方法：\n\nprotected final boolean tryrelease(int releases) {\n  // 计算剩余的重入次数\n    int c = getstate() - releases;\n    if (thread.currentthread() != getexclusiveownerthread())\n        throw new illegalmonitorstateexception();\n    // 是否完全的释放了锁（针对可重入性）\n    boolean free = false;\n    if (c == 0) {\n      // 表示完全释放了锁\n        free = true;\n        // 设置独占锁的持有者为null\n        setexclusiveownerthread(null);\n    }\n    // 设置aqs的state\n    setstate(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# aqs原理 - 共享锁-加锁\n\nprotected int tryacquireshared(int acquires) {\n    for (;;) {\n      // 自旋\n        if (hasqueuedpredecessors())\n          // 如果有线程排在自己的前面（公平锁排队），直接返回\n            return -1;\n        // 获取同步状态的值\n        int available = getstate();\n        // 可用的（许可）减去申请的，等于剩余的\n        int remaining = available - acquires;\n        if (remaining < 0 ||\n            compareandsetstate(available, remaining))\n            // 如果剩余的小于0，或者设置状态成功，就返回，如果设置失败，则进入下一次循环\n            // 如果剩余小于0，返回负数，表示失败\n            // 如果设置状态成功，表示申请许可成功，返回正数\n            return remaining;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# aqs原理 - 共享锁-解锁\n\nreleaseshared()\n\npublic final boolean releaseshared(int arg) {\n    if (tryreleaseshared(arg)) {\n        doreleaseshared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ntryreleaseshared()\n\nprotected final boolean tryreleaseshared(int releases) {\n    for (;;) {\n      // 自旋\n      // 获取同步状态的值\n        int current = getstate();\n        // 可用的（许可）加上释放的，等于剩余的\n        int next = current + releases;\n        if (next < current) // overflow\n            throw new error(\"maximum permit count exceeded\");\n        if (compareandsetstate(current, next))\n          // cas的方式设置同步状态\n            return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndoreleaseshared()\n\n/**\n * release action for shared mode -- signals successor and ensures\n * propagation. (note: for exclusive mode, release just amounts\n * to calling unparksuccessor of head if it needs signal.)\n */\nprivate void doreleaseshared() {\n    /*\n     * ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  this proceeds in the usual\n     * way of trying to unparksuccessor of head if it needs\n     * signal. but if it does not, status is set to propagate to\n     * ensure that upon release, propagation continues.\n     * additionally, we must loop in case a new node is added\n     * while we are doing this. also, unlike other uses of\n     * unparksuccessor, we need to know if cas to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n      // 自旋\n      // 记录头节点\n        node h = head;\n        if (h != null && h != tail) {\n          // 头节点不为null，且不等于尾结点，说明队列中还有节点\n          // 获取头节点等待状态\n            int ws = h.waitstatus;\n            if (ws == node.signal) {\n              // 头节点等待状态是signal\n                if (!compareandsetwaitstatus(h, node.signal, 0))\n                  // 如果修改节点等待状态失败，进入下一次循环\n                    continue;            // loop to recheck cases\n                // 修改成功后，唤醒后继节点，unparksuccessor前文讲过\n                unparksuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareandsetwaitstatus(h, 0, node.propagate))\n                continue;                // loop on failed cas\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 的线程有哪些状态，转换关系是怎么样的？",
      "frontmatter": {
        "title": "Java 的线程有哪些状态，转换关系是怎么样的？",
        "date": "2022-04-04T14:35:37.000Z",
        "permalink": "/pages/52483b/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/100.Java%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/100.Java 的线程有哪些状态，转换关系是怎么样的？.md",
      "key": "v-03e420c4",
      "path": "/pages/52483b/",
      "headers": [
        {
          "level": 2,
          "title": "Java 的线程有哪些状态，转换关系是怎么样的？",
          "slug": "java-的线程有哪些状态-转换关系是怎么样的",
          "normalizedTitle": "java 的线程有哪些状态，转换关系是怎么样的？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "我的 Java 进程中有哪些线程？他们处于什么状态？",
          "slug": "我的-java-进程中有哪些线程-他们处于什么状态",
          "normalizedTitle": "我的 java 进程中有哪些线程？他们处于什么状态？",
          "charIndex": 855
        },
        {
          "level": 3,
          "title": "jstack 命令",
          "slug": "jstack-命令",
          "normalizedTitle": "jstack 命令",
          "charIndex": 891
        },
        {
          "level": 3,
          "title": "Arthas",
          "slug": "arthas",
          "normalizedTitle": "arthas",
          "charIndex": 901
        }
      ],
      "headersStr": "Java 的线程有哪些状态，转换关系是怎么样的？ 我的 Java 进程中有哪些线程？他们处于什么状态？ jstack 命令 Arthas",
      "content": "# Java 的线程有哪些状态，转换关系是怎么样的？\n\nJava 线程状态转换如下：\n\n * 初始化（NEW）: 调用new Thread()方法后，线程处于初始化状态\n * 运行中（RUNNING）:调用thread.start()方法后，线程处于运行中（RUNNING）状态。运行中（RUNNING）状态的含义是当前线程获得了CPU时间片。\n * 就绪（READY）: 调用thread.yield()方法后，线程处于就绪（READY）状态。thread.yield()方法的含义是当前线程愿意让出CPU时间片给其他线程；当CPU空闲时，操作系统的线程调度程序会在就绪（READY）状态的线程中挑选一个线程运行。\n * 等待（WAITING）: 线程阻塞在进入JUC包下的Lock接口的线程，是等待（WAITING）状态，因为JUC包下的Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法\n * 超时等待（TIMED_WAITING）: 是在等待（WAITING）的基础上增加了超时限制，含义是在超时时间到达后，线程返回就绪（READY）状态。\n * 阻塞（BLOCKED) : 线程阻塞在进入synchronized同步块的线程，是阻塞（BLOCKED) 状态\n * 终止（TERMINATED）:\n\n这里涉及几个与线程同步以及线程调度相关的方法：\n\n * wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\n * sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；\n * notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；\n * notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n\n# 我的 Java 进程中有哪些线程？他们处于什么状态？\n\n这里介绍两个工具jstack 命令、Arthas工具。\n\n\n# jstack 命令\n\nJstack是Jdk自带的线程跟踪工具，用于打印指定Java进程的线程堆栈信息。\n\njstack -l [pid]\n\n\n1\n\n\n[pid] 可以通过 jps 命令查看\n\n举例\n\njstack -l 9008 >jstack.txt\n\n\n1\n\n\n导出jstack.txt文件如下：\n\nFull thread dump Java HotSpot(TM) Client VM (20.45-b01 mixed mode, sharing):\n\n\"Attach Listener\" daemon prio=10 tid=0x08251400 nid=0x11bd runnable [0x00000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n        - None\n\n\"DestroyJavaVM\" prio=10 tid=0xb3a0a800 nid=0xffa waiting on condition [0x00000000]\n   java.lang.Thread.State: RUNNABLE\n\n   Locked ownable synchronizers:\n        - None\n\n\"Query Listener\" prio=10 tid=0xb3a09800 nid=0x1023 runnable [0xb3b72000]\n   java.lang.Thread.State: RUNNABLE\n        at java.net.PlainSocketImpl.socketAccept(Native Method)\n        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:408)\n        - locked <0x70a84430> (a java.net.SocksSocketImpl)\n        at java.net.ServerSocket.implAccept(ServerSocket.java:462)\n        at java.net.ServerSocket.accept(ServerSocket.java:430)\n        at com.sun.tools.hat.internal.server.QueryListener.waitForRequests(QueryListener.java:76)\n        at com.sun.tools.hat.internal.server.QueryListener.run(QueryListener.java:65)\n        at java.lang.Thread.run(Thread.java:662)\nLocked ownable synchronizers:\n        - None\n\n\"d&a-3588\" daemon waiting for monitor entry [0x000000006e5d5000]\n  java.lang.Thread.State: BLOCKED (on object monitor)\n      at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()\n      - waiting to lock <0x0000000602f38e90> (a java.lang.Object)\n      at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()\n\n\n\"Finalizer\" daemon prio=10 tid=0x0820bc00 nid=0xffd in Object.wait() [0xb5075000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n- waiting on <0x7a2b6f50> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)\n        - locked <0x7a2b6f50> (a java.lang.ref.ReferenceQueue$Lock)\n        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:134)\n        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:171)\n\n   Locked ownable synchronizers:\n        - None\n\n\"Reference Handler\" daemon prio=10 tid=0x0820a400 nid=0xffc in Object.wait() [0xb50c7000]\n   java.lang.Thread.State: WAITING (on object monitor)\n        at java.lang.Object.wait(Native Method)\n        - waiting on <0x7a2b6fe0> (a java.lang.ref.Reference$Lock)\n        at java.lang.Object.wait(Object.java:485)\n        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)\n        - locked <0x7a2b6fe0> (a java.lang.ref.Reference$Lock)\n\n   Locked ownable synchronizers:\n        - None\n\n\"VM Thread\" prio=10 tid=0x08200000 nid=0xffb runnable\n\n\"VM Periodic Task Thread\" prio=10 tid=0x08222400 nid=0x1001 waiting on condition\n\nJNI global references: 1317\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# Arthas\n\nArthas中文文档：https://arthas.aliyun.com/doc/\n\nArthas 功能强大 我们如果想查看线程状态，只需要使用命令 dashboard.\n\n$ dashboard\nID     NAME                   GROUP          PRIORI STATE  %CPU    TIME   INTERRU DAEMON\n17     pool-2-thread-1        system         5      WAITIN 67      0:0    false   false\n27     Timer-for-arthas-dashb system         10     RUNNAB 32      0:0    false   true\n11     AsyncAppender-Worker-a system         9      WAITIN 0       0:0    false   true\n9      Attach Listener        system         9      RUNNAB 0       0:0    false   true\n3      Finalizer              system         8      WAITIN 0       0:0    false   true\n2      Reference Handler      system         10     WAITIN 0       0:0    false   true\n4      Signal Dispatcher      system         9      RUNNAB 0       0:0    false   true\n26     as-command-execute-dae system         10     TIMED_ 0       0:0    false   true\n13     job-timeout            system         9      TIMED_ 0       0:0    false   true\n1      main                   main           5      TIMED_ 0       0:0    false   false\n14     nioEventLoopGroup-2-1  system         10     RUNNAB 0       0:0    false   false\n18     nioEventLoopGroup-2-2  system         10     RUNNAB 0       0:0    false   false\n23     nioEventLoopGroup-2-3  system         10     RUNNAB 0       0:0    false   false\n15     nioEventLoopGroup-3-1  system         10     RUNNAB 0       0:0    false   false\nMemory             used   total max    usage GC\nheap               32M    155M  1820M  1.77% gc.ps_scavenge.count  4\nps_eden_space      14M    65M   672M   2.21% gc.ps_scavenge.time(m 166\nps_survivor_space  4M     5M    5M           s)\nps_old_gen         12M    85M   1365M  0.91% gc.ps_marksweep.count 0\nnonheap            20M    23M   -1           gc.ps_marksweep.time( 0\ncode_cache         3M     5M    240M   1.32% ms )\nRuntime\nos.name                Mac OS X\nos.version             10.13.4\njava.version           1.8.0_162\njava.home              /Library/Java/JavaVir\n                       tualMachines/jdk1.8.0\n                       _162.jdk/Contents/Hom\n                       e/jre\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n",
      "normalizedContent": "# java 的线程有哪些状态，转换关系是怎么样的？\n\njava 线程状态转换如下：\n\n * 初始化（new）: 调用new thread()方法后，线程处于初始化状态\n * 运行中（running）:调用thread.start()方法后，线程处于运行中（running）状态。运行中（running）状态的含义是当前线程获得了cpu时间片。\n * 就绪（ready）: 调用thread.yield()方法后，线程处于就绪（ready）状态。thread.yield()方法的含义是当前线程愿意让出cpu时间片给其他线程；当cpu空闲时，操作系统的线程调度程序会在就绪（ready）状态的线程中挑选一个线程运行。\n * 等待（waiting）: 线程阻塞在进入juc包下的lock接口的线程，是等待（waiting）状态，因为juc包下的lock接口对于阻塞的实现均使用了locksupport类中的相关方法\n * 超时等待（timed_waiting）: 是在等待（waiting）的基础上增加了超时限制，含义是在超时时间到达后，线程返回就绪（ready）状态。\n * 阻塞（blocked) : 线程阻塞在进入synchronized同步块的线程，是阻塞（blocked) 状态\n * 终止（terminated）:\n\n这里涉及几个与线程同步以及线程调度相关的方法：\n\n * wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\n * sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理interruptedexception异常；\n * notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由jvm确定唤醒哪个线程，而且与优先级无关；\n * notityall()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n\n# 我的 java 进程中有哪些线程？他们处于什么状态？\n\n这里介绍两个工具jstack 命令、arthas工具。\n\n\n# jstack 命令\n\njstack是jdk自带的线程跟踪工具，用于打印指定java进程的线程堆栈信息。\n\njstack -l [pid]\n\n\n1\n\n\n[pid] 可以通过 jps 命令查看\n\n举例\n\njstack -l 9008 >jstack.txt\n\n\n1\n\n\n导出jstack.txt文件如下：\n\nfull thread dump java hotspot(tm) client vm (20.45-b01 mixed mode, sharing):\n\n\"attach listener\" daemon prio=10 tid=0x08251400 nid=0x11bd runnable [0x00000000]\n   java.lang.thread.state: runnable\n\n   locked ownable synchronizers:\n        - none\n\n\"destroyjavavm\" prio=10 tid=0xb3a0a800 nid=0xffa waiting on condition [0x00000000]\n   java.lang.thread.state: runnable\n\n   locked ownable synchronizers:\n        - none\n\n\"query listener\" prio=10 tid=0xb3a09800 nid=0x1023 runnable [0xb3b72000]\n   java.lang.thread.state: runnable\n        at java.net.plainsocketimpl.socketaccept(native method)\n        at java.net.plainsocketimpl.accept(plainsocketimpl.java:408)\n        - locked <0x70a84430> (a java.net.sockssocketimpl)\n        at java.net.serversocket.implaccept(serversocket.java:462)\n        at java.net.serversocket.accept(serversocket.java:430)\n        at com.sun.tools.hat.internal.server.querylistener.waitforrequests(querylistener.java:76)\n        at com.sun.tools.hat.internal.server.querylistener.run(querylistener.java:65)\n        at java.lang.thread.run(thread.java:662)\nlocked ownable synchronizers:\n        - none\n\n\"d&a-3588\" daemon waiting for monitor entry [0x000000006e5d5000]\n  java.lang.thread.state: blocked (on object monitor)\n      at com.jiuqi.dna.bap.authority.service.userservice$loginhandler.handle()\n      - waiting to lock <0x0000000602f38e90> (a java.lang.object)\n      at com.jiuqi.dna.bap.authority.service.userservice$loginhandler.handle()\n\n\n\"finalizer\" daemon prio=10 tid=0x0820bc00 nid=0xffd in object.wait() [0xb5075000]\n   java.lang.thread.state: waiting (on object monitor)\n        at java.lang.object.wait(native method)\n- waiting on <0x7a2b6f50> (a java.lang.ref.referencequeue$lock)\n        at java.lang.ref.referencequeue.remove(referencequeue.java:118)\n        - locked <0x7a2b6f50> (a java.lang.ref.referencequeue$lock)\n        at java.lang.ref.referencequeue.remove(referencequeue.java:134)\n        at java.lang.ref.finalizer$finalizerthread.run(finalizer.java:171)\n\n   locked ownable synchronizers:\n        - none\n\n\"reference handler\" daemon prio=10 tid=0x0820a400 nid=0xffc in object.wait() [0xb50c7000]\n   java.lang.thread.state: waiting (on object monitor)\n        at java.lang.object.wait(native method)\n        - waiting on <0x7a2b6fe0> (a java.lang.ref.reference$lock)\n        at java.lang.object.wait(object.java:485)\n        at java.lang.ref.reference$referencehandler.run(reference.java:116)\n        - locked <0x7a2b6fe0> (a java.lang.ref.reference$lock)\n\n   locked ownable synchronizers:\n        - none\n\n\"vm thread\" prio=10 tid=0x08200000 nid=0xffb runnable\n\n\"vm periodic task thread\" prio=10 tid=0x08222400 nid=0x1001 waiting on condition\n\njni global references: 1317\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# arthas\n\narthas中文文档：https://arthas.aliyun.com/doc/\n\narthas 功能强大 我们如果想查看线程状态，只需要使用命令 dashboard.\n\n$ dashboard\nid     name                   group          priori state  %cpu    time   interru daemon\n17     pool-2-thread-1        system         5      waitin 67      0:0    false   false\n27     timer-for-arthas-dashb system         10     runnab 32      0:0    false   true\n11     asyncappender-worker-a system         9      waitin 0       0:0    false   true\n9      attach listener        system         9      runnab 0       0:0    false   true\n3      finalizer              system         8      waitin 0       0:0    false   true\n2      reference handler      system         10     waitin 0       0:0    false   true\n4      signal dispatcher      system         9      runnab 0       0:0    false   true\n26     as-command-execute-dae system         10     timed_ 0       0:0    false   true\n13     job-timeout            system         9      timed_ 0       0:0    false   true\n1      main                   main           5      timed_ 0       0:0    false   false\n14     nioeventloopgroup-2-1  system         10     runnab 0       0:0    false   false\n18     nioeventloopgroup-2-2  system         10     runnab 0       0:0    false   false\n23     nioeventloopgroup-2-3  system         10     runnab 0       0:0    false   false\n15     nioeventloopgroup-3-1  system         10     runnab 0       0:0    false   false\nmemory             used   total max    usage gc\nheap               32m    155m  1820m  1.77% gc.ps_scavenge.count  4\nps_eden_space      14m    65m   672m   2.21% gc.ps_scavenge.time(m 166\nps_survivor_space  4m     5m    5m           s)\nps_old_gen         12m    85m   1365m  0.91% gc.ps_marksweep.count 0\nnonheap            20m    23m   -1           gc.ps_marksweep.time( 0\ncode_cache         3m     5m    240m   1.32% ms )\nruntime\nos.name                mac os x\nos.version             10.13.4\njava.version           1.8.0_162\njava.home              /library/java/javavir\n                       tualmachines/jdk1.8.0\n                       _162.jdk/contents/hom\n                       e/jre\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "什么是公平锁？什么是非公平锁？",
      "frontmatter": {
        "title": "什么是公平锁？什么是非公平锁？",
        "date": "2022-04-04T14:35:15.000Z",
        "permalink": "/pages/fd6a59/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/090.%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/090.什么是公平锁？什么是非公平锁？.md",
      "key": "v-134f28dc",
      "path": "/pages/fd6a59/",
      "headers": [
        {
          "level": 2,
          "title": "什么是公平锁？什么是非公平锁？",
          "slug": "什么是公平锁-什么是非公平锁",
          "normalizedTitle": "什么是公平锁？什么是非公平锁？",
          "charIndex": 2
        }
      ],
      "headersStr": "什么是公平锁？什么是非公平锁？",
      "content": "# 什么是公平锁？什么是非公平锁？\n\n其中sync是AbstractQueuedSynchronizer的实现，我们知道，ReentrantLock支持公平锁和非公平锁，其实现类分别是FairSync和NonfairSync，我们看看公平锁和非公平锁分别是怎么实现的\n\n// FairSync 公平锁的实现\nfinal void lock() {\n    acquire(1);\n}\n\n// NonfairSync 非公平锁的实现\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到，非公平锁的实现仅仅是多了一个步骤：通过CAS的方式(compareAndSetState)尝试改变state的状态，修改成功后设置当前线程以独占的方式获取了锁，修改失败执行的逻辑和公平锁一样。\n\n从这段代码中可以看到，独占锁加锁的核心逻辑就是acquire方法，接下来就看看这个方法\n\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个方法是 AQS 的核心代码。",
      "normalizedContent": "# 什么是公平锁？什么是非公平锁？\n\n其中sync是abstractqueuedsynchronizer的实现，我们知道，reentrantlock支持公平锁和非公平锁，其实现类分别是fairsync和nonfairsync，我们看看公平锁和非公平锁分别是怎么实现的\n\n// fairsync 公平锁的实现\nfinal void lock() {\n    acquire(1);\n}\n\n// nonfairsync 非公平锁的实现\nfinal void lock() {\n    if (compareandsetstate(0, 1))\n        setexclusiveownerthread(thread.currentthread());\n    else\n        acquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到，非公平锁的实现仅仅是多了一个步骤：通过cas的方式(compareandsetstate)尝试改变state的状态，修改成功后设置当前线程以独占的方式获取了锁，修改失败执行的逻辑和公平锁一样。\n\n从这段代码中可以看到，独占锁加锁的核心逻辑就是acquire方法，接下来就看看这个方法\n\npublic final void acquire(int arg) {\n    if (!tryacquire(arg) &&\n        acquirequeued(addwaiter(node.exclusive), arg))\n        selfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n这个方法是 aqs 的核心代码。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 是如何实现线程安全的，哪些数据结构是线程安全的？",
      "frontmatter": {
        "title": "Java 是如何实现线程安全的，哪些数据结构是线程安全的？",
        "date": "2022-04-04T14:35:56.000Z",
        "permalink": "/pages/c1f760/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/110.Java%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/110.Java 是如何实现线程安全的，哪些数据结构是线程安全的？.md",
      "key": "v-625fbeda",
      "path": "/pages/c1f760/",
      "headers": [
        {
          "level": 2,
          "title": "Java 是如何实现线程安全的，哪些数据结构是线程安全的？",
          "slug": "java-是如何实现线程安全的-哪些数据结构是线程安全的",
          "normalizedTitle": "java 是如何实现线程安全的，哪些数据结构是线程安全的？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "synchronized 来实现售票场景",
          "slug": "synchronized-来实现售票场景",
          "normalizedTitle": "synchronized 来实现售票场景",
          "charIndex": 167
        },
        {
          "level": 2,
          "title": "Lock 接口来实现售票场景",
          "slug": "lock-接口来实现售票场景",
          "normalizedTitle": "lock 接口来实现售票场景",
          "charIndex": 1352
        },
        {
          "level": 2,
          "title": "哪些数据结构是线程安全的？",
          "slug": "哪些数据结构是线程安全的",
          "normalizedTitle": "哪些数据结构是线程安全的？",
          "charIndex": 18
        }
      ],
      "headersStr": "Java 是如何实现线程安全的，哪些数据结构是线程安全的？ synchronized 来实现售票场景 Lock 接口来实现售票场景 哪些数据结构是线程安全的？",
      "content": "# Java 是如何实现线程安全的，哪些数据结构是线程安全的？\n\n如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。\n\nJava 中实现线程安全的方式有两个：\n\n * synchronized\n * Lock接口\n\n举例一个售票场景：火车站4个窗口同时售票，共有3张票，不能超卖。\n\n\n# synchronized 来实现售票场景\n\npublic class ThreadSynchronizedSecurity {\n \n    static int tickets = 3;\n \n    class SellTickets implements Runnable {\n        @Override\n        public void run() {\n            // 同步代码块\n            synchronized (this) {\n                if (tickets <= 0) {\n                    System.out.println(Thread.currentThread().getName() + \"--->票已售罄！\");\n                    return;\n                }\n                System.out.println(Thread.currentThread().getName() + \"--->售出第：  \" + tickets + \" 张票\");\n                tickets--;\n            }\n        }\n    }\n \n    public static void main(String[] args) {\n        SellTickets sell = new ThreadSynchronizedSecurity().new SellTickets();\n        Thread thread1 = new Thread(sell, \"1号窗口\");\n        Thread thread2 = new Thread(sell, \"2号窗口\");\n        Thread thread3 = new Thread(sell, \"3号窗口\");\n        Thread thread4 = new Thread(sell, \"4号窗口\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n输出：\n\n1号窗口--->售出第： 3 张票\n2号窗口--->售出第： 2 张票\n3号窗口--->售出第： 3 张票\n4号窗口--->票已售罄！\n\n\n1\n2\n3\n4\n\n\n\n# Lock 接口来实现售票场景\n\npackage com.my.annotate.thread;\n \nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \npublic class ThreadLockSecurity {\n    static int tickets = 3;\n \n    class SellTickets implements Runnable {\n        Lock lock = new ReentrantLock();\n        @Override\n        public void run() {\n            // Lock锁机制\n            if (tickets > 0) {\n                try {\n                    lock.lock();\n                    if (tickets <= 0) {\n                        return;\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"--->售出第：  \" + tickets + \" 票\");\n                    tickets--;\n                } catch (Exception e1) {\n                    // TODO Auto-generated catch block\n                    e1.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n            if (tickets <= 0) {\n                System.out.println(Thread.currentThread().getName() + \"--->票已售罄！\");\n            }\n \n        }\n    }\n \n \n    public static void main(String[] args) {\n        SellTickets sell = new ThreadLockSecurity().new SellTickets();\n        Thread thread1 = new Thread(sell, \"1号窗口\");\n        Thread thread2 = new Thread(sell, \"2号窗口\");\n        Thread thread3 = new Thread(sell, \"3号窗口\");\n        Thread thread4 = new Thread(sell, \"4号窗口\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n输出：\n\n1号窗口--->售出第： 3 张票\n2号窗口--->售出第： 2 张票\n3号窗口--->售出第： 3 张票\n4号窗口--->票已售罄！\n\n\n1\n2\n3\n4\n\n\n\n# 哪些数据结构是线程安全的？\n\nJDK已经为大家准备好了一批好用的线程安全容器类，可以大大减少开发工作量，例如HashTable，ConcurrentHashMap，CopyOnWriteArrayList，CopyOnWriteArraySet，ConcurrentLinkedQueue，Vector，StringBuffer等。\n\n 1. HashTable\n\nHashTable实现了Map接口，为此其本身也是一个散列表，它存储的内容是基于key-value的键值对映射。\n\nHashTable中的key、value都不可以为null；具有无序特性；由于其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。\n\nHashTable使用synchronized来修饰方法函数来保证线程安全，但是在多线程运行环境下效率表现非常低下。\n\n因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会粗线阻塞状态。\n\n比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率。\n\n 2. ConcurrentHashMap\n\n我们知道HashMap是线程不安全的，ConcurrentHashMap是HashMap的线程安全版。\n\n但是与HashTable相比，ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。\n\nConcurrentHashMap允许多个修改操作并发运行，其原因在于使用了锁分段技术：首先讲Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。这样就保证了每一把锁只是用于锁住一部分数据，那么当多线程访问Map里的不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率。\n\n上述的处理机制明显区别于HashTable是给整体数据分配了一把锁的处理方法。\n\n为此，在多线程环境下，常用ConcurrentHashMap在需要保证数据安全的场景中去替换HashMap，而不会去使用HashTable，同时在最新版的JDK中已经推荐废弃使用HashTable。\n\n 3. CopyOnWriteArrayList\n\nCopyOnWriteArrayList实现了List接口，提供的数据更新操作都使用了ReentrantLock的lock()方法来加锁，unlock()方法来解锁。\n\n当增加元素的时候，首先使用Arrays.copyOf()来拷贝形成新的副本，在副本上增加元素，然后改变原引用指向副本。读操作不需要加锁，而写操作类实现中对其进行了加锁。因此，CopyOnWriteArrayList类是一个线程安全的List接口的实现，在高并发的情况下，可以提供高性能的并发读取，并且保证读取的内容一定是正确的，这对于读操作远远多于写操作的应用非常适合（注意： 如上述更新操作会带来较大的空间与性能开销，如果更新操太过频繁，反而不太合适使用）。\n\n 4. CopyOnWriteArraySet\n\nCopyOnWriteArraySet是对CopyOnWriteArrayList使用了装饰模式后的具体实现。所以CopyOnWriteArrayList的实现机理适用于CopyOnWriteArraySet，此处不再赘述。\n\nJava里的List和Set的之间的特性比较结论同样适用于CopyOnWriteArrayList与CopyOnWriteArraySet之间的比较；此外，CopyOnWriteArrayList与CopyOnWriteArraySet都是线程安全的。\n\n 5. ConcurrentLinkedQueue\n\nConcurrentLinkedQueue可以被看作是一个线程安全的LinkedList，使用了非阻塞算法实现的一个高效、线程安全的并发队列；其本质是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当添加一个元素时会添加到队列的尾部；当获取一个元素时，会返回队列头部的元素。\n\nConcurrentLinkedQueue应该算是在高并发环境中性能最好的队列，没有之一。\n\n 6. Vector\n\nVector通过数组保存数据，继承了Abstract，实现了List；所以，其本质上是一个队列。\n\n但是和ArrayList不同，Vector中的操作是线程安全的，它是利用synchronized同步锁机制进行实现，其实现方式与HashTable类似。\n\n 7. StringBuffer与StringBuilder\n\n在Java里面，字符串操作应该是最频繁的操作了，为此有必要把StringBuffer与StringBuilder两个方法类比较一下。\n\n首先，对于频繁的字符串拼接操作，是不推荐采用效率低下的“+”操作的。一般是采用StringBuffer与StringBuilder来实现上述功能。但是，这两者也是有区别的：前者线程安全，后者不是线程安全的。\n\nStringBuffer是通过对方法函数进行synchronized修饰实现其线程安全特性，实现方式与HashTable、Vector类似。",
      "normalizedContent": "# java 是如何实现线程安全的，哪些数据结构是线程安全的？\n\n如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。\n\njava 中实现线程安全的方式有两个：\n\n * synchronized\n * lock接口\n\n举例一个售票场景：火车站4个窗口同时售票，共有3张票，不能超卖。\n\n\n# synchronized 来实现售票场景\n\npublic class threadsynchronizedsecurity {\n \n    static int tickets = 3;\n \n    class selltickets implements runnable {\n        @override\n        public void run() {\n            // 同步代码块\n            synchronized (this) {\n                if (tickets <= 0) {\n                    system.out.println(thread.currentthread().getname() + \"--->票已售罄！\");\n                    return;\n                }\n                system.out.println(thread.currentthread().getname() + \"--->售出第：  \" + tickets + \" 张票\");\n                tickets--;\n            }\n        }\n    }\n \n    public static void main(string[] args) {\n        selltickets sell = new threadsynchronizedsecurity().new selltickets();\n        thread thread1 = new thread(sell, \"1号窗口\");\n        thread thread2 = new thread(sell, \"2号窗口\");\n        thread thread3 = new thread(sell, \"3号窗口\");\n        thread thread4 = new thread(sell, \"4号窗口\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n输出：\n\n1号窗口--->售出第： 3 张票\n2号窗口--->售出第： 2 张票\n3号窗口--->售出第： 3 张票\n4号窗口--->票已售罄！\n\n\n1\n2\n3\n4\n\n\n\n# lock 接口来实现售票场景\n\npackage com.my.annotate.thread;\n \nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n \npublic class threadlocksecurity {\n    static int tickets = 3;\n \n    class selltickets implements runnable {\n        lock lock = new reentrantlock();\n        @override\n        public void run() {\n            // lock锁机制\n            if (tickets > 0) {\n                try {\n                    lock.lock();\n                    if (tickets <= 0) {\n                        return;\n                    }\n                    system.out.println(thread.currentthread().getname() + \"--->售出第：  \" + tickets + \" 票\");\n                    tickets--;\n                } catch (exception e1) {\n                    // todo auto-generated catch block\n                    e1.printstacktrace();\n                } finally {\n                    lock.unlock();\n                }\n            }\n            if (tickets <= 0) {\n                system.out.println(thread.currentthread().getname() + \"--->票已售罄！\");\n            }\n \n        }\n    }\n \n \n    public static void main(string[] args) {\n        selltickets sell = new threadlocksecurity().new selltickets();\n        thread thread1 = new thread(sell, \"1号窗口\");\n        thread thread2 = new thread(sell, \"2号窗口\");\n        thread thread3 = new thread(sell, \"3号窗口\");\n        thread thread4 = new thread(sell, \"4号窗口\");\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n输出：\n\n1号窗口--->售出第： 3 张票\n2号窗口--->售出第： 2 张票\n3号窗口--->售出第： 3 张票\n4号窗口--->票已售罄！\n\n\n1\n2\n3\n4\n\n\n\n# 哪些数据结构是线程安全的？\n\njdk已经为大家准备好了一批好用的线程安全容器类，可以大大减少开发工作量，例如hashtable，concurrenthashmap，copyonwritearraylist，copyonwritearrayset，concurrentlinkedqueue，vector，stringbuffer等。\n\n 1. hashtable\n\nhashtable实现了map接口，为此其本身也是一个散列表，它存储的内容是基于key-value的键值对映射。\n\nhashtable中的key、value都不可以为null；具有无序特性；由于其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。\n\nhashtable使用synchronized来修饰方法函数来保证线程安全，但是在多线程运行环境下效率表现非常低下。\n\n因为当一个线程访问hashtable的同步方法时，其他线程也访问同步方法就会粗线阻塞状态。\n\n比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率。\n\n 2. concurrenthashmap\n\n我们知道hashmap是线程不安全的，concurrenthashmap是hashmap的线程安全版。\n\n但是与hashtable相比，concurrenthashmap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。\n\nconcurrenthashmap允许多个修改操作并发运行，其原因在于使用了锁分段技术：首先讲map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。这样就保证了每一把锁只是用于锁住一部分数据，那么当多线程访问map里的不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率。\n\n上述的处理机制明显区别于hashtable是给整体数据分配了一把锁的处理方法。\n\n为此，在多线程环境下，常用concurrenthashmap在需要保证数据安全的场景中去替换hashmap，而不会去使用hashtable，同时在最新版的jdk中已经推荐废弃使用hashtable。\n\n 3. copyonwritearraylist\n\ncopyonwritearraylist实现了list接口，提供的数据更新操作都使用了reentrantlock的lock()方法来加锁，unlock()方法来解锁。\n\n当增加元素的时候，首先使用arrays.copyof()来拷贝形成新的副本，在副本上增加元素，然后改变原引用指向副本。读操作不需要加锁，而写操作类实现中对其进行了加锁。因此，copyonwritearraylist类是一个线程安全的list接口的实现，在高并发的情况下，可以提供高性能的并发读取，并且保证读取的内容一定是正确的，这对于读操作远远多于写操作的应用非常适合（注意： 如上述更新操作会带来较大的空间与性能开销，如果更新操太过频繁，反而不太合适使用）。\n\n 4. copyonwritearrayset\n\ncopyonwritearrayset是对copyonwritearraylist使用了装饰模式后的具体实现。所以copyonwritearraylist的实现机理适用于copyonwritearrayset，此处不再赘述。\n\njava里的list和set的之间的特性比较结论同样适用于copyonwritearraylist与copyonwritearrayset之间的比较；此外，copyonwritearraylist与copyonwritearrayset都是线程安全的。\n\n 5. concurrentlinkedqueue\n\nconcurrentlinkedqueue可以被看作是一个线程安全的linkedlist，使用了非阻塞算法实现的一个高效、线程安全的并发队列；其本质是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当添加一个元素时会添加到队列的尾部；当获取一个元素时，会返回队列头部的元素。\n\nconcurrentlinkedqueue应该算是在高并发环境中性能最好的队列，没有之一。\n\n 6. vector\n\nvector通过数组保存数据，继承了abstract，实现了list；所以，其本质上是一个队列。\n\n但是和arraylist不同，vector中的操作是线程安全的，它是利用synchronized同步锁机制进行实现，其实现方式与hashtable类似。\n\n 7. stringbuffer与stringbuilder\n\n在java里面，字符串操作应该是最频繁的操作了，为此有必要把stringbuffer与stringbuilder两个方法类比较一下。\n\n首先，对于频繁的字符串拼接操作，是不推荐采用效率低下的“+”操作的。一般是采用stringbuffer与stringbuilder来实现上述功能。但是，这两者也是有区别的：前者线程安全，后者不是线程安全的。\n\nstringbuffer是通过对方法函数进行synchronized修饰实现其线程安全特性，实现方式与hashtable、vector类似。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "手写死锁",
      "frontmatter": {
        "title": "手写死锁",
        "date": "2022-04-09T13:51:43.000Z",
        "permalink": "/pages/ce292c/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/115.%E6%89%8B%E5%86%99%E6%AD%BB%E9%94%81.html",
      "relativePath": "01.Java相关/20.并发/115.手写死锁.md",
      "key": "v-7b2a2ed4",
      "path": "/pages/ce292c/",
      "headers": [
        {
          "level": 2,
          "title": "产生死锁的条件",
          "slug": "产生死锁的条件",
          "normalizedTitle": "产生死锁的条件",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "手写死锁例子",
          "slug": "手写死锁例子",
          "normalizedTitle": "手写死锁例子",
          "charIndex": 170
        }
      ],
      "headersStr": "产生死锁的条件 手写死锁例子",
      "content": "# 产生死锁的条件\n\n一般来说，要出现死锁问题需要满足以下条件：\n\n * 互斥条件：一个资源每次只能被一个线程使用。\n * 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n * 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。\n * 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n\n# 手写死锁例子\n\n//可能发生静态锁顺序死锁的代码\nclass StaticLockOrderDeadLock {\n  private final Object lockA = new Object();\n  private final Object lockB = new Object();\n  public void a() {\n    synchronized (lockA) {\n      synchronized (lockB) {\n        System.out.println(\"function a\");\n      }\n    }\n  }\n  \n  public void b() {\n    synchronized (lockB) {\n      synchronized (lockA) {\n        System.out.println(\"function b\");\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * a和b两个方法都需要获得A锁和B锁。一个线程执行a方法且已经获得了A锁，在等待B锁；\n * 另一个线程执行了b方法且已经获得了B锁，在等待A锁。\n\n这种状态，就是发生了静态的锁顺序死锁。\n解决办法： 所有需要多个锁的线程，都要以相同的顺序来获得锁。\n\n\n//正确的代码\nclass StaticLockOrderDeadLock {\n  private final Object lockA = new Object();\n  private final Object lockB = new Object();\n  public void a() {\n    synchronized (lockA) {\n      synchronized (lockB) {\n        System.out.println(\"function a\");\n      }\n    }\n  }\n  \n  public void b() {\n    synchronized (lockA) {\n      synchronized (lockB) {\n        System.out.println(\"function b\");\n      }\n    }\n  }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",
      "normalizedContent": "# 产生死锁的条件\n\n一般来说，要出现死锁问题需要满足以下条件：\n\n * 互斥条件：一个资源每次只能被一个线程使用。\n * 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n * 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。\n * 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n\n# 手写死锁例子\n\n//可能发生静态锁顺序死锁的代码\nclass staticlockorderdeadlock {\n  private final object locka = new object();\n  private final object lockb = new object();\n  public void a() {\n    synchronized (locka) {\n      synchronized (lockb) {\n        system.out.println(\"function a\");\n      }\n    }\n  }\n  \n  public void b() {\n    synchronized (lockb) {\n      synchronized (locka) {\n        system.out.println(\"function b\");\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * a和b两个方法都需要获得a锁和b锁。一个线程执行a方法且已经获得了a锁，在等待b锁；\n * 另一个线程执行了b方法且已经获得了b锁，在等待a锁。\n\n这种状态，就是发生了静态的锁顺序死锁。\n解决办法： 所有需要多个锁的线程，都要以相同的顺序来获得锁。\n\n\n//正确的代码\nclass staticlockorderdeadlock {\n  private final object locka = new object();\n  private final object lockb = new object();\n  public void a() {\n    synchronized (locka) {\n      synchronized (lockb) {\n        system.out.println(\"function a\");\n      }\n    }\n  }\n  \n  public void b() {\n    synchronized (locka) {\n      synchronized (lockb) {\n        system.out.println(\"function b\");\n      }\n    }\n  }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "为什么我们不能直接调用 run() 方法？",
      "frontmatter": {
        "title": "为什么我们不能直接调用 run() 方法？",
        "date": "2022-04-04T14:36:29.000Z",
        "permalink": "/pages/13856f/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/120.%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%20run()%20%E6%96%B9%E6%B3%95%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/120.为什么我们不能直接调用 run() 方法？.md",
      "key": "v-9baaad8e",
      "path": "/pages/13856f/",
      "headers": [
        {
          "level": 2,
          "title": "为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？",
          "slug": "为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法",
          "normalizedTitle": "为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？",
          "charIndex": null
        }
      ],
      "headersStr": "为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？",
      "content": "# 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run()方法？\n\n如果我们直接调用 run() 方法 是不会创建新线程的。\nstart() 源代码：\n\n/**\n     * Causes this thread to begin execution; the Java Virtual Machine\n     * calls the <code>run</code> method of this thread.\n     * <p>线程被执行，JVM调用run方法\n     * The result is that two threads are running concurrently: the\n     * current thread (which returns from the call to the\n     * <code>start</code> method) and the other thread (which executes its\n     * <code>run</code> method).\n     * <p>\n     * It is never legal to start a thread more than once.多次调用start方法启动一个线程是非法的\n     * In particular, a thread may not be restarted once it has completed\n     * execution.\n     *\n     * @exception  IllegalThreadStateException  if the thread was already已经启动的线程再次start，异常\n     *               started.\n     * @see        #run()\n     * @see        #stop()\n     */\n    public synchronized void start() {\n        /**\n         * This method is not invoked for the main method thread or \"system\"\n         * group threads created/set up by the VM. Any new functionality added\n         * to this method in the future may have to also be added to the VM.\n         *\n         * A zero status value corresponds to state \"NEW\".\n         */\n        if (threadStatus != 0)//状态校验  0：NEW 新建状态\n            throw new IllegalThreadStateException();\n\n        /* Notify the group that this thread is about to be started\n         * so that it can be added to the group's list of threads\n         * and the group's unstarted count can be decremented. */\n        group.add(this);//添加进线程组\n\n        boolean started = false;\n        try {\n            start0();//调用native方法执行线程run方法\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadStartFailed(this);//启动失败，从线程组中移除当前前程。\n                }\n            } catch (Throwable ignore) {\n                /* do nothing. If start0 threw a Throwable then\n                  it will be passed up the call stack */\n            }\n        }\n    }\n\n    private native void start0();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n通过源码我们可以看到，在start()中调用了native方法 start0()，在start0()中会创建一个新的线程调用run()。 所以，如果我们直接调用 run() 方法 是不会创建新线程的。",
      "normalizedContent": "# 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run()方法？\n\n如果我们直接调用 run() 方法 是不会创建新线程的。\nstart() 源代码：\n\n/**\n     * causes this thread to begin execution; the java virtual machine\n     * calls the <code>run</code> method of this thread.\n     * <p>线程被执行，jvm调用run方法\n     * the result is that two threads are running concurrently: the\n     * current thread (which returns from the call to the\n     * <code>start</code> method) and the other thread (which executes its\n     * <code>run</code> method).\n     * <p>\n     * it is never legal to start a thread more than once.多次调用start方法启动一个线程是非法的\n     * in particular, a thread may not be restarted once it has completed\n     * execution.\n     *\n     * @exception  illegalthreadstateexception  if the thread was already已经启动的线程再次start，异常\n     *               started.\n     * @see        #run()\n     * @see        #stop()\n     */\n    public synchronized void start() {\n        /**\n         * this method is not invoked for the main method thread or \"system\"\n         * group threads created/set up by the vm. any new functionality added\n         * to this method in the future may have to also be added to the vm.\n         *\n         * a zero status value corresponds to state \"new\".\n         */\n        if (threadstatus != 0)//状态校验  0：new 新建状态\n            throw new illegalthreadstateexception();\n\n        /* notify the group that this thread is about to be started\n         * so that it can be added to the group's list of threads\n         * and the group's unstarted count can be decremented. */\n        group.add(this);//添加进线程组\n\n        boolean started = false;\n        try {\n            start0();//调用native方法执行线程run方法\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadstartfailed(this);//启动失败，从线程组中移除当前前程。\n                }\n            } catch (throwable ignore) {\n                /* do nothing. if start0 threw a throwable then\n                  it will be passed up the call stack */\n            }\n        }\n    }\n\n    private native void start0();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n通过源码我们可以看到，在start()中调用了native方法 start0()，在start0()中会创建一个新的线程调用run()。 所以，如果我们直接调用 run() 方法 是不会创建新线程的。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 线程有哪些常用方法？",
      "frontmatter": {
        "title": "Java 线程有哪些常用方法？",
        "date": "2022-04-04T14:36:48.000Z",
        "permalink": "/pages/a6c84e/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/130.Java%20%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/130.Java 线程有哪些常用方法？.md",
      "key": "v-75c00225",
      "path": "/pages/a6c84e/",
      "headers": [
        {
          "level": 2,
          "title": "Java 线程如何启动？如何终止？",
          "slug": "java-线程如何启动-如何终止",
          "normalizedTitle": "java 线程如何启动？如何终止？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "构造线程",
          "slug": "构造线程",
          "normalizedTitle": "构造线程",
          "charIndex": 97
        },
        {
          "level": 2,
          "title": "启动线程",
          "slug": "启动线程",
          "normalizedTitle": "启动线程",
          "charIndex": 637
        },
        {
          "level": 2,
          "title": "理解中断",
          "slug": "理解中断",
          "normalizedTitle": "理解中断",
          "charIndex": 1259
        },
        {
          "level": 2,
          "title": "已不建议使用的方法：suspend(),resume(),stop()",
          "slug": "已不建议使用的方法-suspend-resume-stop",
          "normalizedTitle": "已不建议使用的方法：suspend(),resume(),stop()",
          "charIndex": 1581
        },
        {
          "level": 2,
          "title": "安全的终止线程",
          "slug": "安全的终止线程",
          "normalizedTitle": "安全的终止线程",
          "charIndex": 1813
        }
      ],
      "headersStr": "Java 线程如何启动？如何终止？ 构造线程 启动线程 理解中断 已不建议使用的方法：suspend(),resume(),stop() 安全的终止线程",
      "content": "# Java 线程如何启动？如何终止？\n\n线程随着start()方法的调用而启动，随着run()方法调用结束而终止。 但是这其中还会涉及到线程的构造、中断、暂停、恢复，我们来一一看下。\n\n\n# 构造线程\n\n在运行一个线程之前 肯定要先构造一个线程对象，构造线程对象需要提供所需属性：如线程所属组，线程优先级，是否deamon等。\n\nprivate void init(ThreadGroup g, Runnable target, String name,\n                  long stackSize, AccessControlContext acc) {\n    //1.设置线程名\n    if (name == null) {\n        throw new NullPointerException(\"name cannot be null\");\n    }\n\n    this.name = name;\n    //2.设置线程的线程组，如果未指定，则此线程的线程组为当前初始化线程的线程组\n    Thread parent = currentThread();\n    ...\n    if (g == null) {\n        //这里有一段注释说，安卓不支持SecurityManager，所以删除了相关代码\n        g = parent.getThreadGroup();\n    }\n\n    //所属线程组未启动线程计数+1\n    g.addUnstarted();\n\n    this.group = g;\n    //3.设置线程的其他属性\n    //线程是否是守护线程以及优先级都继承自当前线程\n    this.daemon = parent.isDaemon();\n    this.priority = parent.getPriority();\n    this.target = target;\n    //4.调用init2 执行剩余初始化操作\n    init2(parent);\n    //5.设置线程的堆栈大小。但是否生效要看虚拟机。那么在art虚拟机上是否生效呢，我们后续再说\n    /* Stash the specified stack size in case the VM cares */\n    this.stackSize = stackSize;\n\n    //6.设置当前线程id\n    tid = nextThreadID();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n到这里为止，我们的thread就已经初始化完毕了。在堆内存中等待这被执行start()方法开始运行。\n\n\n# 启动线程\n\n调用start()方法开始启动线程。\n\n\n# 理解中断\n\n如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立刻结束运行。\n\n中断可以理解为线程的一个标志位属性，调用interrupt()方法中断线程仅仅是把中断标志位置为true，线程可以通过检查自身的标志位来判断是否被中断了。\n\n另外还有两点需要注意的：\n\n * 如果线程处于终结状态，即使线程被中断过，其中断标识位依然是false\n * 许多声明抛出InterruptException的方法（如Thread.sleep(long millis)），在抛出InterruptException之前会将中断标识位置为false。\n\n\n# 已不建议使用的方法：suspend(),resume(),stop()\n\nsuspend(),resume(),stop()完成了线程的暂停、恢复、停止。但是这些方法过期了 不建议继续使用，原因是：\n\n 1. suspend()暂停线程是不会释放资源（比如锁），而是占着资源入睡 ，这样容易引发死锁\n 2. stop() 终止线程时没有给线程清理资源的机会，导致程序运行在不确定状态\n\n取而代之的是wait()和notify()/notifyAll()。\n\n\n# 安全的终止线程\n\n可以通过interrupt()或者标识位来优雅的停止线程。\n\npublic class MyRunner implements Runnable {\n  private volatile boolean on = true;\n    public void run() {\n        while(on){\n          System.out.println(\"Running...\");\n        }\n        System.out.println(\"Stoped!\");\n    }\n\n    public void cancel(){\n      on  = false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n通过标识位来停止线程\n\npublic class ShutdownThread {\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new MyRunner().start();\n          t1.cancel();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过interrupt()来停止线程\n\npublic class ShutdownThread {\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new MyRunner().start();\n          t1.interrupt();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n",
      "normalizedContent": "# java 线程如何启动？如何终止？\n\n线程随着start()方法的调用而启动，随着run()方法调用结束而终止。 但是这其中还会涉及到线程的构造、中断、暂停、恢复，我们来一一看下。\n\n\n# 构造线程\n\n在运行一个线程之前 肯定要先构造一个线程对象，构造线程对象需要提供所需属性：如线程所属组，线程优先级，是否deamon等。\n\nprivate void init(threadgroup g, runnable target, string name,\n                  long stacksize, accesscontrolcontext acc) {\n    //1.设置线程名\n    if (name == null) {\n        throw new nullpointerexception(\"name cannot be null\");\n    }\n\n    this.name = name;\n    //2.设置线程的线程组，如果未指定，则此线程的线程组为当前初始化线程的线程组\n    thread parent = currentthread();\n    ...\n    if (g == null) {\n        //这里有一段注释说，安卓不支持securitymanager，所以删除了相关代码\n        g = parent.getthreadgroup();\n    }\n\n    //所属线程组未启动线程计数+1\n    g.addunstarted();\n\n    this.group = g;\n    //3.设置线程的其他属性\n    //线程是否是守护线程以及优先级都继承自当前线程\n    this.daemon = parent.isdaemon();\n    this.priority = parent.getpriority();\n    this.target = target;\n    //4.调用init2 执行剩余初始化操作\n    init2(parent);\n    //5.设置线程的堆栈大小。但是否生效要看虚拟机。那么在art虚拟机上是否生效呢，我们后续再说\n    /* stash the specified stack size in case the vm cares */\n    this.stacksize = stacksize;\n\n    //6.设置当前线程id\n    tid = nextthreadid();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n到这里为止，我们的thread就已经初始化完毕了。在堆内存中等待这被执行start()方法开始运行。\n\n\n# 启动线程\n\n调用start()方法开始启动线程。\n\n\n# 理解中断\n\n如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立刻结束运行。\n\n中断可以理解为线程的一个标志位属性，调用interrupt()方法中断线程仅仅是把中断标志位置为true，线程可以通过检查自身的标志位来判断是否被中断了。\n\n另外还有两点需要注意的：\n\n * 如果线程处于终结状态，即使线程被中断过，其中断标识位依然是false\n * 许多声明抛出interruptexception的方法（如thread.sleep(long millis)），在抛出interruptexception之前会将中断标识位置为false。\n\n\n# 已不建议使用的方法：suspend(),resume(),stop()\n\nsuspend(),resume(),stop()完成了线程的暂停、恢复、停止。但是这些方法过期了 不建议继续使用，原因是：\n\n 1. suspend()暂停线程是不会释放资源（比如锁），而是占着资源入睡 ，这样容易引发死锁\n 2. stop() 终止线程时没有给线程清理资源的机会，导致程序运行在不确定状态\n\n取而代之的是wait()和notify()/notifyall()。\n\n\n# 安全的终止线程\n\n可以通过interrupt()或者标识位来优雅的停止线程。\n\npublic class myrunner implements runnable {\n  private volatile boolean on = true;\n    public void run() {\n        while(on){\n          system.out.println(\"running...\");\n        }\n        system.out.println(\"stoped!\");\n    }\n\n    public void cancel(){\n      on  = false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n通过标识位来停止线程\n\npublic class shutdownthread {\n\n    public static void main(string[] args) {\n        thread t1 = new thread(new myrunner().start();\n          t1.cancel();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过interrupt()来停止线程\n\npublic class shutdownthread {\n\n    public static void main(string[] args) {\n        thread t1 = new thread(new myrunner().start();\n          t1.interrupt();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "手写生产者消费者模型",
      "frontmatter": {
        "title": "手写生产者消费者模型",
        "date": "2022-04-04T14:37:07.000Z",
        "permalink": "/pages/2b8c6e/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/140.%E6%89%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.html",
      "relativePath": "01.Java相关/20.并发/140.手写生产者消费者模型.md",
      "key": "v-083aef82",
      "path": "/pages/2b8c6e/",
      "headers": [
        {
          "level": 2,
          "title": "生产者消费者模式说明：",
          "slug": "生产者消费者模式说明",
          "normalizedTitle": "生产者消费者模式说明：",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "实现的关键：",
          "slug": "实现的关键",
          "normalizedTitle": "实现的关键：",
          "charIndex": 78
        },
        {
          "level": 2,
          "title": "代码实现：",
          "slug": "代码实现",
          "normalizedTitle": "代码实现：",
          "charIndex": 187
        },
        {
          "level": 3,
          "title": "仓库代码",
          "slug": "仓库代码",
          "normalizedTitle": "仓库代码",
          "charIndex": 226
        },
        {
          "level": 3,
          "title": "产品",
          "slug": "产品",
          "normalizedTitle": "产品",
          "charIndex": 207
        },
        {
          "level": 3,
          "title": "生产者",
          "slug": "生产者",
          "normalizedTitle": "生产者",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "消费者",
          "slug": "消费者",
          "normalizedTitle": "消费者",
          "charIndex": 5
        },
        {
          "level": 3,
          "title": "测试类",
          "slug": "测试类",
          "normalizedTitle": "测试类",
          "charIndex": 218
        },
        {
          "level": 3,
          "title": "测试类",
          "slug": "测试类-2",
          "normalizedTitle": "测试类",
          "charIndex": 218
        },
        {
          "level": 2,
          "title": "代码关键点分析",
          "slug": "代码关键点分析",
          "normalizedTitle": "代码关键点分析",
          "charIndex": 4098
        },
        {
          "level": 3,
          "title": "锁问题",
          "slug": "锁问题",
          "normalizedTitle": "锁问题",
          "charIndex": 4110
        },
        {
          "level": 3,
          "title": "线程的等待与重启",
          "slug": "线程的等待与重启",
          "normalizedTitle": "线程的等待与重启",
          "charIndex": 4299
        },
        {
          "level": 3,
          "title": "循环放置在Producer和Consumer类的run方法中",
          "slug": "循环放置在producer和consumer类的run方法中",
          "normalizedTitle": "循环放置在producer和consumer类的run方法中",
          "charIndex": 4874
        },
        {
          "level": 3,
          "title": "时间延迟问题",
          "slug": "时间延迟问题",
          "normalizedTitle": "时间延迟问题",
          "charIndex": 5171
        }
      ],
      "headersStr": "生产者消费者模式说明： 实现的关键： 代码实现： 仓库代码 产品 生产者 消费者 测试类 测试类 代码关键点分析 锁问题 线程的等待与重启 循环放置在Producer和Consumer类的run方法中 时间延迟问题",
      "content": "# 生产者消费者模式说明：\n\n生产者只在仓库未满时进行生产，仓库满时生产者进程被阻塞； 消费者只在仓库非空时进行消费，仓库为空时消费者进程被阻塞；\n\n\n# 实现的关键：\n\n共享内存中的两个同步方法，及同步方法中wait()方法的调用。\n\nsynchronized 保证了对象只能被一个线程占用。 wait 保证了当线程在等待过程中释放锁，使得其他对象有机会获得锁。\n\n\n# 代码实现：\n\n代码包含这几个部分：仓库、产品、生产者、消费者、测试类\n\n\n# 仓库代码\n\n仓库代码核心方法\n\n * public synchronized void produce(T item):生产商品\n * public synchronized T consume():消费商品\n\n/**\n * 仓库类，用于管理产品的生产、消费和存储。\n */\npublic class Storage<T> {\n    private int index = 0;\n    private static final int MAX = 10;//最大容量\n    private List<T> storages = new ArrayList<T>(MAX);//存储集合\n\n    public synchronized void produce(T item) {\n        while (index >= MAX) {// 判断仓库满了，则等待。\n            try {\n                System.out.println(\"仓库满了，等待中...\");\n                this.wait();\n                System.out.println(\"仓库不满了，开始生产\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"生产>>\" + item.toString());\n        storages.add(item);\n        index++;   //先添加item，在进行加1操作\n        notify();  //生产完 唤醒在此对象监视器上等待的单个线程，即消费者线程\n    }\n\n    public synchronized T consume() {\n        while (index <= 0) {// 判断仓库空了，则等待。\n            try {\n                System.out.println(\"仓库为空，等待中...\");\n                this.wait();\n                System.out.println(\"仓库不为空，开始消费\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        index--;//先进行减1操作，再remove\n        T item = storages.remove(index);\n        System.out.println(\"消费>>\" + item.toString());\n        notify();\n        return item;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 产品\n\npublic class Phone {\n\n    private int id;// 手机编号\n\n    public Phone(int id) {\n        this.id = id;\n    }\n\n    @Override\n    public String toString() {\n        return \"手机编号：\" + id;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 生产者\n\npublic class Producer implements Runnable {\n\n    private Storage<Phone> storage;\n    \n    public Producer(Storage<Phone> storage) {\n        this.storage = storage;\n    }\n\n    public void run() {\n        for(int i = 0;i<20;i++){\n            storage.produce(new Phone(i));\n            \n            try {\n                Thread.sleep(10);//每隔10毫秒生产一个产品\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 消费者\n\npublic class Consumer implements Runnable {\n\n    private Storage<Phone> storage;\n    \n    public Consumer(Storage<Phone> storage) {\n        this.storage = storage;\n    }\n\n    public void run() {\n        for(int i = 0;i<20;i++){\n            storage.consume();\n            try {\n                Thread.sleep(100);//每隔100毫秒消费一个\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 测试类\n\npublic class ProducerAndConsumer {\n\n    public static void main(String[] args) {\n        Storage<Phone> storage = new Storage<Phone>();\n        \n        new Thread(new Producer(storage)).start();\n        new Thread(new Consumer(storage)).start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 测试类\n\n生产>>手机编号：0\n消费>>手机编号：0\n生产>>手机编号：1\n生产>>手机编号：2\n生产>>手机编号：3\n生产>>手机编号：4\n生产>>手机编号：5\n生产>>手机编号：6\n生产>>手机编号：7\n生产>>手机编号：8\n生产>>手机编号：9\n消费>>手机编号：9\n生产>>手机编号：10\n生产>>手机编号：11\n仓库满了，等待中...\n消费>>手机编号：11\n仓库不满了，开始生产\n生产>>手机编号：12\n仓库满了，等待中...\n消费>>手机编号：12\n仓库不满了，开始生产\n生产>>手机编号：13\n仓库满了，等待中...\n消费>>手机编号：13\n仓库不满了，开始生产\n生产>>手机编号：14\n仓库满了，等待中...\n消费>>手机编号：14\n仓库不满了，开始生产\n生产>>手机编号：15\n仓库满了，等待中...\n消费>>手机编号：15\n仓库不满了，开始生产\n生产>>手机编号：16\n仓库满了，等待中...\n消费>>手机编号：16\n仓库不满了，开始生产\n生产>>手机编号：17\n仓库满了，等待中...\n消费>>手机编号：17\n仓库不满了，开始生产\n生产>>手机编号：18\n仓库满了，等待中...\n消费>>手机编号：18\n仓库不满了，开始生产\n生产>>手机编号：19\n消费>>手机编号：19\n消费>>手机编号：10\n消费>>手机编号：8\n消费>>手机编号：7\n消费>>手机编号：6\n消费>>手机编号：5\n消费>>手机编号：4\n消费>>手机编号：3\n消费>>手机编号：2\n消费>>手机编号：1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 代码关键点分析\n\n\n# 锁问题\n\n仓库类 Storage 中 方法produce(T item) 和consume()要使用关键字synchronized修饰。使得变量index在多线程环境下的修改时线程安全的。\n\n * public synchronized void produce(T item):生产商品\n * public synchronized T consume():消费商品\n\n\n# 线程的等待与重启\n\n生产者线程的等待： 在生产时达到仓库的最大值后，要停止生产，此时需要调用 wait()方法。\n\nwhile (index >= MAX) {// 判断仓库满了，则等待。\n            try {\n                System.out.println(\"仓库满了，等待中...\");\n                this.wait();\n                System.out.println(\"仓库不满了，开始生产\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n生产者线程的重启：消费后，调用notify()方法 唤醒 等待当前锁的线程。\n\n        index--;//先进行减1操作，再remove\n        T item = storages.remove(index);\n        System.out.println(\"消费>>\" + item.toString());\n        notify();\n\n\n1\n2\n3\n4\n\n\n\n# 循环放置在Producer和Consumer类的run方法中\n\n模拟多次生产/消费。\n\nfor(int i = 0;i<20;i++){\n            storage.consume();\n            try {\n                Thread.sleep(100);//每隔100毫秒消费一个\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 时间延迟问题\n\nThread.sleep(10);s设置每隔10毫秒生产一个产品， 模拟生产和消费的随机过程，还要设置时间延迟，否则会发生只有生产达到最大值后才会开始消费。\n\npublic void run() {\n        for(int i = 0;i<20;i++){\n            storage.produce(new Phone(i));\n            \n            try {\n                Thread.sleep(10);//每隔10毫秒生产一个产品\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",
      "normalizedContent": "# 生产者消费者模式说明：\n\n生产者只在仓库未满时进行生产，仓库满时生产者进程被阻塞； 消费者只在仓库非空时进行消费，仓库为空时消费者进程被阻塞；\n\n\n# 实现的关键：\n\n共享内存中的两个同步方法，及同步方法中wait()方法的调用。\n\nsynchronized 保证了对象只能被一个线程占用。 wait 保证了当线程在等待过程中释放锁，使得其他对象有机会获得锁。\n\n\n# 代码实现：\n\n代码包含这几个部分：仓库、产品、生产者、消费者、测试类\n\n\n# 仓库代码\n\n仓库代码核心方法\n\n * public synchronized void produce(t item):生产商品\n * public synchronized t consume():消费商品\n\n/**\n * 仓库类，用于管理产品的生产、消费和存储。\n */\npublic class storage<t> {\n    private int index = 0;\n    private static final int max = 10;//最大容量\n    private list<t> storages = new arraylist<t>(max);//存储集合\n\n    public synchronized void produce(t item) {\n        while (index >= max) {// 判断仓库满了，则等待。\n            try {\n                system.out.println(\"仓库满了，等待中...\");\n                this.wait();\n                system.out.println(\"仓库不满了，开始生产\");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n        system.out.println(\"生产>>\" + item.tostring());\n        storages.add(item);\n        index++;   //先添加item，在进行加1操作\n        notify();  //生产完 唤醒在此对象监视器上等待的单个线程，即消费者线程\n    }\n\n    public synchronized t consume() {\n        while (index <= 0) {// 判断仓库空了，则等待。\n            try {\n                system.out.println(\"仓库为空，等待中...\");\n                this.wait();\n                system.out.println(\"仓库不为空，开始消费\");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n\n        index--;//先进行减1操作，再remove\n        t item = storages.remove(index);\n        system.out.println(\"消费>>\" + item.tostring());\n        notify();\n        return item;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 产品\n\npublic class phone {\n\n    private int id;// 手机编号\n\n    public phone(int id) {\n        this.id = id;\n    }\n\n    @override\n    public string tostring() {\n        return \"手机编号：\" + id;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 生产者\n\npublic class producer implements runnable {\n\n    private storage<phone> storage;\n    \n    public producer(storage<phone> storage) {\n        this.storage = storage;\n    }\n\n    public void run() {\n        for(int i = 0;i<20;i++){\n            storage.produce(new phone(i));\n            \n            try {\n                thread.sleep(10);//每隔10毫秒生产一个产品\n            } catch (interruptedexception e) {\n                // todo auto-generated catch block\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 消费者\n\npublic class consumer implements runnable {\n\n    private storage<phone> storage;\n    \n    public consumer(storage<phone> storage) {\n        this.storage = storage;\n    }\n\n    public void run() {\n        for(int i = 0;i<20;i++){\n            storage.consume();\n            try {\n                thread.sleep(100);//每隔100毫秒消费一个\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 测试类\n\npublic class producerandconsumer {\n\n    public static void main(string[] args) {\n        storage<phone> storage = new storage<phone>();\n        \n        new thread(new producer(storage)).start();\n        new thread(new consumer(storage)).start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 测试类\n\n生产>>手机编号：0\n消费>>手机编号：0\n生产>>手机编号：1\n生产>>手机编号：2\n生产>>手机编号：3\n生产>>手机编号：4\n生产>>手机编号：5\n生产>>手机编号：6\n生产>>手机编号：7\n生产>>手机编号：8\n生产>>手机编号：9\n消费>>手机编号：9\n生产>>手机编号：10\n生产>>手机编号：11\n仓库满了，等待中...\n消费>>手机编号：11\n仓库不满了，开始生产\n生产>>手机编号：12\n仓库满了，等待中...\n消费>>手机编号：12\n仓库不满了，开始生产\n生产>>手机编号：13\n仓库满了，等待中...\n消费>>手机编号：13\n仓库不满了，开始生产\n生产>>手机编号：14\n仓库满了，等待中...\n消费>>手机编号：14\n仓库不满了，开始生产\n生产>>手机编号：15\n仓库满了，等待中...\n消费>>手机编号：15\n仓库不满了，开始生产\n生产>>手机编号：16\n仓库满了，等待中...\n消费>>手机编号：16\n仓库不满了，开始生产\n生产>>手机编号：17\n仓库满了，等待中...\n消费>>手机编号：17\n仓库不满了，开始生产\n生产>>手机编号：18\n仓库满了，等待中...\n消费>>手机编号：18\n仓库不满了，开始生产\n生产>>手机编号：19\n消费>>手机编号：19\n消费>>手机编号：10\n消费>>手机编号：8\n消费>>手机编号：7\n消费>>手机编号：6\n消费>>手机编号：5\n消费>>手机编号：4\n消费>>手机编号：3\n消费>>手机编号：2\n消费>>手机编号：1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 代码关键点分析\n\n\n# 锁问题\n\n仓库类 storage 中 方法produce(t item) 和consume()要使用关键字synchronized修饰。使得变量index在多线程环境下的修改时线程安全的。\n\n * public synchronized void produce(t item):生产商品\n * public synchronized t consume():消费商品\n\n\n# 线程的等待与重启\n\n生产者线程的等待： 在生产时达到仓库的最大值后，要停止生产，此时需要调用 wait()方法。\n\nwhile (index >= max) {// 判断仓库满了，则等待。\n            try {\n                system.out.println(\"仓库满了，等待中...\");\n                this.wait();\n                system.out.println(\"仓库不满了，开始生产\");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n生产者线程的重启：消费后，调用notify()方法 唤醒 等待当前锁的线程。\n\n        index--;//先进行减1操作，再remove\n        t item = storages.remove(index);\n        system.out.println(\"消费>>\" + item.tostring());\n        notify();\n\n\n1\n2\n3\n4\n\n\n\n# 循环放置在producer和consumer类的run方法中\n\n模拟多次生产/消费。\n\nfor(int i = 0;i<20;i++){\n            storage.consume();\n            try {\n                thread.sleep(100);//每隔100毫秒消费一个\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 时间延迟问题\n\nthread.sleep(10);s设置每隔10毫秒生产一个产品， 模拟生产和消费的随机过程，还要设置时间延迟，否则会发生只有生产达到最大值后才会开始消费。\n\npublic void run() {\n        for(int i = 0;i<20;i++){\n            storage.produce(new phone(i));\n            \n            try {\n                thread.sleep(10);//每隔10毫秒生产一个产品\n            } catch (interruptedexception e) {\n                // todo auto-generated catch block\n                e.printstacktrace();\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "ThreadLocal 实现原理是什么？为什么要使用弱引用？",
      "frontmatter": {
        "title": "ThreadLocal 实现原理是什么？为什么要使用弱引用？",
        "date": "2022-03-11T00:45:50.000Z",
        "permalink": "/pages/b3e720/",
        "categories": [
          "Java相关",
          "并发"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/20.%E5%B9%B6%E5%8F%91/150.ThreadLocal%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F.html",
      "relativePath": "01.Java相关/20.并发/150.ThreadLocal 实现原理是什么？为什么要使用弱引用？.md",
      "key": "v-f406b4e6",
      "path": "/pages/b3e720/",
      "headers": [
        {
          "level": 2,
          "title": "ThreadLocal 实现原理是什么？为什么要使用弱引用？",
          "slug": "threadlocal-实现原理是什么-为什么要使用弱引用",
          "normalizedTitle": "threadlocal 实现原理是什么？为什么要使用弱引用？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "ThreadLocal解决什么问题？",
          "slug": "threadlocal解决什么问题",
          "normalizedTitle": "threadlocal解决什么问题？",
          "charIndex": 57
        },
        {
          "level": 2,
          "title": "ThreadLocal底层是什么数据结构？",
          "slug": "threadlocal底层是什么数据结构",
          "normalizedTitle": "threadlocal底层是什么数据结构？",
          "charIndex": 382
        },
        {
          "level": 2,
          "title": "ThreadLocal有什么应用场景？",
          "slug": "threadlocal有什么应用场景",
          "normalizedTitle": "threadlocal有什么应用场景？",
          "charIndex": 1520
        },
        {
          "level": 2,
          "title": "为什么要使用弱引用？",
          "slug": "为什么要使用弱引用",
          "normalizedTitle": "为什么要使用弱引用？",
          "charIndex": 22
        },
        {
          "level": 2,
          "title": "子线程可以从父线程继承 ThreadLocal 吗？",
          "slug": "子线程可以从父线程继承-threadlocal-吗",
          "normalizedTitle": "子线程可以从父线程继承 threadlocal 吗？",
          "charIndex": 109
        },
        {
          "level": 2,
          "title": "ThreadLocal使用不当会有内存泄漏是怎么回事？",
          "slug": "threadlocal使用不当会有内存泄漏是怎么回事",
          "normalizedTitle": "threadlocal使用不当会有内存泄漏是怎么回事？",
          "charIndex": 135
        },
        {
          "level": 2,
          "title": "使用 ThreadLocal 如何防止内存泄漏 ？",
          "slug": "使用-threadlocal-如何防止内存泄漏",
          "normalizedTitle": "使用 threadlocal 如何防止内存泄漏 ？",
          "charIndex": 3009
        },
        {
          "level": 2,
          "title": "Netty 的FastThreadLocal fast在哪里？",
          "slug": "netty-的fastthreadlocal-fast在哪里",
          "normalizedTitle": "netty 的fastthreadlocal fast在哪里？",
          "charIndex": 171
        },
        {
          "level": 2,
          "title": "FastThreadLocal 性能 比 ThreadLocal 高多少？",
          "slug": "fastthreadlocal-性能-比-threadlocal-高多少",
          "normalizedTitle": "fastthreadlocal 性能 比 threadlocal 高多少？",
          "charIndex": 4196
        }
      ],
      "headersStr": "ThreadLocal 实现原理是什么？为什么要使用弱引用？ ThreadLocal解决什么问题？ ThreadLocal底层是什么数据结构？ ThreadLocal有什么应用场景？ 为什么要使用弱引用？ 子线程可以从父线程继承 ThreadLocal 吗？ ThreadLocal使用不当会有内存泄漏是怎么回事？ 使用 ThreadLocal 如何防止内存泄漏 ？ Netty 的FastThreadLocal fast在哪里？ FastThreadLocal 性能 比 ThreadLocal 高多少？",
      "content": "# ThreadLocal 实现原理是什么？为什么要使用弱引用？\n\nThreadLocal可以问的点有很多，比如：ThreadLocal解决什么问题？底层结构是什么？实现原理是什么？有什么应用场景？为什么要使用弱引用？子线程可以从父线程继承 ThreadLocal 吗？ThreadLocal使用不当会有内存泄漏是怎么回事？正确的使用姿势是？Netty 的FastThreadLocal fast在哪里？\n下面我们一个个来看下这些问题。\n\n\n\n# ThreadLocal解决什么问题？\n\n\n通常情况下，我们创建的变量任何线程来读取读到的都是同一个值，如果想实现每一个线程都有自己的专属值该如何解决呢\n？JDK中提供的ThreadLocal类正是为了解决这样的问题。\n比如SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本\n\n\n\n# ThreadLocal底层是什么数据结构？\n\n\n实际上是Map，Key为ThreadLocal变量、value为值。\n\n\n\n\n我们先看下Thread类的源码\n\npublic class Thread implements Runnable {\n ......\n//与此线程有关的ThreadLocal值。由ThreadLocal类维护\nThreadLocal.ThreadLocalMap threadLocals = null;\n\n/*\n * InheritableThreadLocal，自父线程集成而来的ThreadLocalMap，\n * 主要用于父子线程间ThreadLocal变量的传递\n * 本文主要讨论的就是这个ThreadLocalMap\n */\nThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们可以把 ThreadLocal.ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap. 我们再来看下 ThreadLocal 类的源码\n\n    //调用Thread.set 实际上是往当前线程的 ThreadLocalMap 里面put一个键值对\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n    //调用Thread.getMap 可以获取到当前线程的 ThreadLocalMap\n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n\n    //ThreadLocalMap可以存储以ThreadLocal为key ，Object 对象为 value的键值对。\n    ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n        ......\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# ThreadLocal有什么应用场景？\n\n\n * 非线程安全的工具类，需要每个线程持有一个副本，比如 SimpleDateFormat\n * 异步传递traceId\n\n\n# 为什么要使用弱引用？\n\n\nThreadLocalMap的内部类Entry被设计为实现了WeakReference，Entry用来存放数据。\n\n\n弱引用简单理解就是当垃圾回收时，该对象只被WeakReference对象的弱引用字段所引用，而未被任何强类型的对象引用，那么，该弱引用的对象就会被回收。\n注意：WeakReference引用本身是强引用，它内部的（T reference）才是真正的弱引用字段，WeakReference就是一个装弱引用的容器而已。\n那 为什么要使用弱引用呢？\n这是因为：ThreadLocalMap本身并没有为外界提供取出和存放数据的API，我们所能获得数据的方式只有通过ThreadLocal类提供的API来间接的从ThreadLocalMap取出数据，所以，当我们用不了key（ThreadLocal对象）的API也就无法从ThreadLocalMap里取出指定的数据。\n\n一般我们new 一个ThreadLocal对象的时候，它一定会有强引用，在ThreadLocalMap中也一定会有它的弱引用\n当强引用不在的时候一定是我们的程序不再需要这个ThreadLocal对象了 为什么这么说？\n比如我定义了一个 ThreadLocal 变量 formatter，formatter 对 ThreadLocal 变量的强引用关系不存在的一个case 是getDate()方法执行完了，那么当然ThreadLocal 变量是可以回收的。\n\n\npublic void getDate(){\n\n    ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat(\"yyyyMMdd HHmm\"));\n    ......\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 子线程可以从父线程继承 ThreadLocal 吗？\n\n\nThreadLocal 不可以。InheritableThreadLocals 是可以的，它重写了ThreadLocal的三个方法。childValue，createMap，getMap。\n\n\nInheritableThreadLocal 不能和线程池搭配使用\n因为线程池中的线程是复用的，并没有重新初始化线程，InheritableThreadLocal之所以起作用是因为在Thread类中最终会调用init()方法去把InheritableThreadLocal的map复制到子线程中。\n由于线程池复用了已有线程，所以没有调用init()方法这个过程，也就不能将父线程中的InheritableThreadLocal值传给子线程。\n\n\n# ThreadLocal使用不当会有内存泄漏是怎么回事？\n\n\nThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。\n所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\n这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。\n\n\n\n# 使用 ThreadLocal 如何防止内存泄漏 ？\n\n\n使用完 ThreadLocal 手动调用remove方法。 看下 ThreadLocal 的 remove() 会清理 ThreadLocalMap 中 key 为 null的键值对。\n\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n\n\n1\n2\n3\n4\n5\n\n\nThreadLocal 的 get() 有清除操作，那我们是不是不用手动调用 remove() 了？\n不是的。因为 get() 中清除操作 只会检测本次get的 ThreadLocal 变量是否需要清理 。而 remove() 会检测 ThreadLocalMap 中的所有键值对。\n\n\n所以，手动调用remove() 才是最保险的。\n\n\n\n# Netty 的FastThreadLocal fast在哪里？\n\n\n既然jdk已经有ThreadLocal，为何netty还要自己造个FastThreadLocal？FastThreadLocal快在哪里？\n这需要从jdk ThreadLocal的本身说起。如下图：\n在java线程中，每个线程都有一个ThreadLocalMap实例变量（如果不使用ThreadLocal，不会创建这个Map，一个线程第一次访问某个ThreadLocal变量时，才会创建）。该Map是使用线性探测的方式解决hash冲突的问题，如果没有找到空闲的slot，就不断往后尝试，直到找到一个空闲的位置，插入entry，这种方式在经常遇到hash冲突时，影响效率。\n\nFastThreadLocal(下文简称ftl)直接使用数组避免了hash冲突的发生，具体做法是：每一个FastThreadLocal实例创建时，分配一个下标index；分配index使用AtomicInteger实现，每个FastThreadLocal都能获取到一个不重复的下标。当调用ftl.get()方法获取值时，直接从数组获取返回，如return array[index]，如下图：\n\nFastThreadLocal 底层结构代码\n\nstatic final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();\nstatic final AtomicInteger nextIndex = new AtomicInteger();\nObject[] indexedVariables;\n\n\n1\n2\n3\n\n\n\n# FastThreadLocal 性能 比 ThreadLocal 高多少？\n\n\n远高于。\nFastThreadLocal 对 ThreadLocal 的优化点在于，将元素放入 ThreadLocalMap 采用数组结构随机访问代替 原来的 线性探测。 所以我们测试场景为：单线程访问多 FastThreadLocal/ThreadLocal 变量:\n\n/**\n * 单线程访问多个ThreadLocal\n */\npublic static void testThreadLocalWithMultipleThreadLocal() {\n    ThreadLocal<String> threadLocal[] = new ThreadLocal[count];\n    for (int i = 0; i < count; i++) {\n        threadLocal[i] = new ThreadLocal<String>();\n    }\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            long start = System.currentTimeMillis();\n            for (int i = 0; i < count; i++) {\n                threadLocal[i].set(\"value\" + i);\n            }\n            long middle = System.currentTimeMillis();\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < count; j++) {\n                    threadLocal[i].get();\n                }\n            }\n            long end = System.currentTimeMillis();\n            System.out.println(\"testThreadLocalWithMultipleThreadLocal set:\" + (middle - start) + \",get:\" + (end - middle));\n        }\n    }).start();\n}\n\n/**\n * 单线程访问多个FastThreadLocal\n */\npublic static void testFastThreadLocalWithMultipleFastThreadLocal() {\n    FastThreadLocal<String> threadLocal[] = new FastThreadLocal[count];\n    for (int i = 0; i < count; i++) {\n        threadLocal[i] = new FastThreadLocal<String>();\n    }\n    new FastThreadLocalThread(new Runnable() {\n        @Override\n        public void run() {\n            long start = System.currentTimeMillis();\n            for (int i = 0; i < count; i++) {\n                threadLocal[i].set(\"value\" + i);\n            }\n            long middle = System.currentTimeMillis();\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < count; j++) {\n                    threadLocal[i].get();\n                }\n            }\n            long end = System.currentTimeMillis();\n            System.out.println(\"testFastThreadLocalWithMultipleFastThreadLocal set:\" + (middle - start) + \",get:\" + (end - middle));\n        }\n    }).start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n输出:\n\ntestThreadLocalWithMultipleThreadLocal set:68,get:21492\ntestFastThreadLocalWithMultipleFastThreadLocal set:61,get:8\n\n\n\n\n1\n2\n3\n4\n\n\n有结果可知，FastThreadLocal 性能远高于 ThreadLocal。",
      "normalizedContent": "# threadlocal 实现原理是什么？为什么要使用弱引用？\n\nthreadlocal可以问的点有很多，比如：threadlocal解决什么问题？底层结构是什么？实现原理是什么？有什么应用场景？为什么要使用弱引用？子线程可以从父线程继承 threadlocal 吗？threadlocal使用不当会有内存泄漏是怎么回事？正确的使用姿势是？netty 的fastthreadlocal fast在哪里？\n下面我们一个个来看下这些问题。\n\n\n\n# threadlocal解决什么问题？\n\n\n通常情况下，我们创建的变量任何线程来读取读到的都是同一个值，如果想实现每一个线程都有自己的专属值该如何解决呢\n？jdk中提供的threadlocal类正是为了解决这样的问题。\n比如simpledateformat 不是线程安全的，所以每个线程都要有自己独立的副本\n\n\n\n# threadlocal底层是什么数据结构？\n\n\n实际上是map，key为threadlocal变量、value为值。\n\n\n\n\n我们先看下thread类的源码\n\npublic class thread implements runnable {\n ......\n//与此线程有关的threadlocal值。由threadlocal类维护\nthreadlocal.threadlocalmap threadlocals = null;\n\n/*\n * inheritablethreadlocal，自父线程集成而来的threadlocalmap，\n * 主要用于父子线程间threadlocal变量的传递\n * 本文主要讨论的就是这个threadlocalmap\n */\nthreadlocal.threadlocalmap inheritablethreadlocals = null;\n ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们可以把 threadlocal.threadlocalmap 理解为threadlocal 类实现的定制化的 hashmap. 我们再来看下 threadlocal 类的源码\n\n    //调用thread.set 实际上是往当前线程的 threadlocalmap 里面put一个键值对\n    public void set(t value) {\n        thread t = thread.currentthread();\n        threadlocalmap map = getmap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createmap(t, value);\n    }\n\n    //调用thread.getmap 可以获取到当前线程的 threadlocalmap\n    threadlocalmap getmap(thread t) {\n        return t.threadlocals;\n    }\n\n    //threadlocalmap可以存储以threadlocal为key ，object 对象为 value的键值对。\n    threadlocalmap(threadlocal<?> firstkey, object firstvalue) {\n        ......\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# threadlocal有什么应用场景？\n\n\n * 非线程安全的工具类，需要每个线程持有一个副本，比如 simpledateformat\n * 异步传递traceid\n\n\n# 为什么要使用弱引用？\n\n\nthreadlocalmap的内部类entry被设计为实现了weakreference，entry用来存放数据。\n\n\n弱引用简单理解就是当垃圾回收时，该对象只被weakreference对象的弱引用字段所引用，而未被任何强类型的对象引用，那么，该弱引用的对象就会被回收。\n注意：weakreference引用本身是强引用，它内部的（t reference）才是真正的弱引用字段，weakreference就是一个装弱引用的容器而已。\n那 为什么要使用弱引用呢？\n这是因为：threadlocalmap本身并没有为外界提供取出和存放数据的api，我们所能获得数据的方式只有通过threadlocal类提供的api来间接的从threadlocalmap取出数据，所以，当我们用不了key（threadlocal对象）的api也就无法从threadlocalmap里取出指定的数据。\n\n一般我们new 一个threadlocal对象的时候，它一定会有强引用，在threadlocalmap中也一定会有它的弱引用\n当强引用不在的时候一定是我们的程序不再需要这个threadlocal对象了 为什么这么说？\n比如我定义了一个 threadlocal 变量 formatter，formatter 对 threadlocal 变量的强引用关系不存在的一个case 是getdate()方法执行完了，那么当然threadlocal 变量是可以回收的。\n\n\npublic void getdate(){\n\n    threadlocal<simpledateformat> formatter = threadlocal.withinitial(() -> new simpledateformat(\"yyyymmdd hhmm\"));\n    ......\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 子线程可以从父线程继承 threadlocal 吗？\n\n\nthreadlocal 不可以。inheritablethreadlocals 是可以的，它重写了threadlocal的三个方法。childvalue，createmap，getmap。\n\n\ninheritablethreadlocal 不能和线程池搭配使用\n因为线程池中的线程是复用的，并没有重新初始化线程，inheritablethreadlocal之所以起作用是因为在thread类中最终会调用init()方法去把inheritablethreadlocal的map复制到子线程中。\n由于线程池复用了已有线程，所以没有调用init()方法这个过程，也就不能将父线程中的inheritablethreadlocal值传给子线程。\n\n\n# threadlocal使用不当会有内存泄漏是怎么回事？\n\n\nthreadlocalmap 中使用的 key 为 threadlocal 的弱引用,而 value 是强引用。\n所以，如果 threadlocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\n这样一来，threadlocalmap 中就会出现key为null的entry。假如我们不做任何措施的话，value 永远无法被gc 回收，这个时候就可能会产生内存泄露。\n\n\n\n# 使用 threadlocal 如何防止内存泄漏 ？\n\n\n使用完 threadlocal 手动调用remove方法。 看下 threadlocal 的 remove() 会清理 threadlocalmap 中 key 为 null的键值对。\n\npublic void remove() {\n    threadlocalmap m = getmap(thread.currentthread());\n    if (m != null)\n        m.remove(this);\n}\n\n\n1\n2\n3\n4\n5\n\n\nthreadlocal 的 get() 有清除操作，那我们是不是不用手动调用 remove() 了？\n不是的。因为 get() 中清除操作 只会检测本次get的 threadlocal 变量是否需要清理 。而 remove() 会检测 threadlocalmap 中的所有键值对。\n\n\n所以，手动调用remove() 才是最保险的。\n\n\n\n# netty 的fastthreadlocal fast在哪里？\n\n\n既然jdk已经有threadlocal，为何netty还要自己造个fastthreadlocal？fastthreadlocal快在哪里？\n这需要从jdk threadlocal的本身说起。如下图：\n在java线程中，每个线程都有一个threadlocalmap实例变量（如果不使用threadlocal，不会创建这个map，一个线程第一次访问某个threadlocal变量时，才会创建）。该map是使用线性探测的方式解决hash冲突的问题，如果没有找到空闲的slot，就不断往后尝试，直到找到一个空闲的位置，插入entry，这种方式在经常遇到hash冲突时，影响效率。\n\nfastthreadlocal(下文简称ftl)直接使用数组避免了hash冲突的发生，具体做法是：每一个fastthreadlocal实例创建时，分配一个下标index；分配index使用atomicinteger实现，每个fastthreadlocal都能获取到一个不重复的下标。当调用ftl.get()方法获取值时，直接从数组获取返回，如return array[index]，如下图：\n\nfastthreadlocal 底层结构代码\n\nstatic final threadlocal<internalthreadlocalmap> slowthreadlocalmap = new threadlocal<internalthreadlocalmap>();\nstatic final atomicinteger nextindex = new atomicinteger();\nobject[] indexedvariables;\n\n\n1\n2\n3\n\n\n\n# fastthreadlocal 性能 比 threadlocal 高多少？\n\n\n远高于。\nfastthreadlocal 对 threadlocal 的优化点在于，将元素放入 threadlocalmap 采用数组结构随机访问代替 原来的 线性探测。 所以我们测试场景为：单线程访问多 fastthreadlocal/threadlocal 变量:\n\n/**\n * 单线程访问多个threadlocal\n */\npublic static void testthreadlocalwithmultiplethreadlocal() {\n    threadlocal<string> threadlocal[] = new threadlocal[count];\n    for (int i = 0; i < count; i++) {\n        threadlocal[i] = new threadlocal<string>();\n    }\n    new thread(new runnable() {\n        @override\n        public void run() {\n            long start = system.currenttimemillis();\n            for (int i = 0; i < count; i++) {\n                threadlocal[i].set(\"value\" + i);\n            }\n            long middle = system.currenttimemillis();\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < count; j++) {\n                    threadlocal[i].get();\n                }\n            }\n            long end = system.currenttimemillis();\n            system.out.println(\"testthreadlocalwithmultiplethreadlocal set:\" + (middle - start) + \",get:\" + (end - middle));\n        }\n    }).start();\n}\n\n/**\n * 单线程访问多个fastthreadlocal\n */\npublic static void testfastthreadlocalwithmultiplefastthreadlocal() {\n    fastthreadlocal<string> threadlocal[] = new fastthreadlocal[count];\n    for (int i = 0; i < count; i++) {\n        threadlocal[i] = new fastthreadlocal<string>();\n    }\n    new fastthreadlocalthread(new runnable() {\n        @override\n        public void run() {\n            long start = system.currenttimemillis();\n            for (int i = 0; i < count; i++) {\n                threadlocal[i].set(\"value\" + i);\n            }\n            long middle = system.currenttimemillis();\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < count; j++) {\n                    threadlocal[i].get();\n                }\n            }\n            long end = system.currenttimemillis();\n            system.out.println(\"testfastthreadlocalwithmultiplefastthreadlocal set:\" + (middle - start) + \",get:\" + (end - middle));\n        }\n    }).start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n输出:\n\ntestthreadlocalwithmultiplethreadlocal set:68,get:21492\ntestfastthreadlocalwithmultiplefastthreadlocal set:61,get:8\n\n\n\n\n1\n2\n3\n4\n\n\n有结果可知，fastthreadlocal 性能远高于 threadlocal。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？",
      "frontmatter": {
        "title": "Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？",
        "date": "2022-05-21T17:31:41.000Z",
        "permalink": "/pages/948850/",
        "categories": [
          "Java相关",
          "JVM"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/30.JVM/001.Java%20%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6%EF%BC%9F%E5%B8%B8%E8%A7%81%E7%9A%84%20GC%20%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.html",
      "relativePath": "01.Java相关/30.JVM/001.Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？.md",
      "key": "v-64652416",
      "path": "/pages/948850/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "JMM 中内存模型是怎样的？什么是指令序列重排序？",
      "frontmatter": {
        "title": "JMM 中内存模型是怎样的？什么是指令序列重排序？",
        "date": "2022-05-21T17:32:49.000Z",
        "permalink": "/pages/c8e6cb/",
        "categories": [
          "Java相关",
          "JVM"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/30.JVM/030.JMM%20%E4%B8%AD%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F.html",
      "relativePath": "01.Java相关/30.JVM/030.JMM 中内存模型是怎样的？什么是指令序列重排序？.md",
      "key": "v-0970cd54",
      "path": "/pages/c8e6cb/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Java 中如何进行 GC 调优？",
      "frontmatter": {
        "title": "Java 中如何进行 GC 调优？",
        "date": "2022-05-21T17:31:53.000Z",
        "permalink": "/pages/07a030/",
        "categories": [
          "Java相关",
          "JVM"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/30.JVM/020.Java%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%20GC%20%E8%B0%83%E4%BC%98%EF%BC%9F.html",
      "relativePath": "01.Java相关/30.JVM/020.Java 中如何进行 GC 调优？.md",
      "key": "v-5474bec0",
      "path": "/pages/07a030/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "JVM 内存是如何对应到操作系统内存的？",
      "frontmatter": {
        "title": "JVM 内存是如何对应到操作系统内存的？",
        "date": "2022-05-21T17:33:05.000Z",
        "permalink": "/pages/da65e7/",
        "categories": [
          "Java相关",
          "JVM"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/30.JVM/040.JVM%20%E5%86%85%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BA%94%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F.html",
      "relativePath": "01.Java相关/30.JVM/040.JVM 内存是如何对应到操作系统内存的？.md",
      "key": "v-2de19204",
      "path": "/pages/da65e7/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "JVM 是怎么去调优的？了解哪些参数和指令？",
      "frontmatter": {
        "title": "JVM 是怎么去调优的？了解哪些参数和指令？",
        "date": "2022-05-21T17:33:16.000Z",
        "permalink": "/pages/d730dd/",
        "categories": [
          "Java相关",
          "JVM"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/30.JVM/050.JVM%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%8E%BB%E8%B0%83%E4%BC%98%E7%9A%84%EF%BC%9F%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%87%E4%BB%A4%EF%BC%9F.html",
      "relativePath": "01.Java相关/30.JVM/050.JVM 是怎么去调优的？了解哪些参数和指令？.md",
      "key": "v-37fcb440",
      "path": "/pages/d730dd/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "什么是内存泄漏，怎么确定内存泄漏？",
      "frontmatter": {
        "title": "什么是内存泄漏，怎么确定内存泄漏？",
        "date": "2022-05-21T17:33:27.000Z",
        "permalink": "/pages/3ab5f5/",
        "categories": [
          "Java相关",
          "JVM"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/30.JVM/060.%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F.html",
      "relativePath": "01.Java相关/30.JVM/060.什么是内存泄漏，怎么确定内存泄漏？.md",
      "key": "v-15fba8f1",
      "path": "/pages/3ab5f5/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 CMS 与 G1 机制的区别",
      "frontmatter": {
        "title": "简述 CMS 与 G1 机制的区别",
        "date": "2022-05-21T17:33:40.000Z",
        "permalink": "/pages/be69af/",
        "categories": [
          "Java相关",
          "JVM"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/30.JVM/070.%E7%AE%80%E8%BF%B0%20CMS%20%E4%B8%8E%20G1%20%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB.html",
      "relativePath": "01.Java相关/30.JVM/070.简述 CMS 与 G1 机制的区别.md",
      "key": "v-28c1d6d9",
      "path": "/pages/be69af/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "实现单例设计模式（懒汉，饿汉）",
      "frontmatter": {
        "title": "实现单例设计模式（懒汉，饿汉）",
        "date": "2022-05-21T17:26:00.000Z",
        "permalink": "/pages/b37ad7/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/002.%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%87%92%E6%B1%89%EF%BC%8C%E9%A5%BF%E6%B1%89%EF%BC%89.html",
      "relativePath": "01.Java相关/40.设计模式/002.实现单例设计模式（懒汉，饿汉）.md",
      "key": "v-ba94c306",
      "path": "/pages/b37ad7/",
      "headers": [
        {
          "level": 2,
          "title": "饿汉式",
          "slug": "饿汉式",
          "normalizedTitle": "饿汉式",
          "charIndex": 311
        }
      ],
      "headersStr": "饿汉式",
      "content": "> 面试官：带笔了吧，那写两种单例模式的实现方法吧 沙沙沙刷刷刷~~~ 写好了 面试官：怎样防止new 对象出来？\n\n有一些对象我们确实只需要一个，比如，线程池、数据库连接、缓存、日志对象等，如果有多个的话，会造成程序的行为异常，资源使用过量或者不一致的问题。你也许会说，这种我用全局变量不也能实现吗，还整个单例模式，好像你很流弊的样子，如果将对象赋值给一个全局变量，那程序启动就会创建好对象，万一这个对象很耗资源，我们还可能在某些时候用不到，这就造成了资源的浪费，不合理，所以就有了单例模式。\n\n#单例模式的定义 单例模式确保一个类只有一个实例，并提供一个全局唯一访问点\n\n#单例模式的类图\n\n#单例模式的实现\n\n\n# 饿汉式\n\nstatic 变量在类装载的时候进行初始化 多个实例的 static 变量会共享同一块内存区域 用这两个知识点写出的单例类就是饿汉式了，初始化类的时候就创建，饥不择食，饿汉\n\npublic class Singleton {\n\n    //构造私有化，防止直接new\n    private Singleton(){}\n\n    //静态初始化器（static initializer）中创建实例，保证线程安全\n    private static Singleton instance = new Singleton();\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n饿汉式是线程安全的，JVM在加载类时马上创建唯一的实例对象，且只会装载一次。\n\nJava 实现的单例是一个虚拟机的范围，因为装载类的功能是虚拟机的，所以一个虚拟机通过自己的ClassLoader 装载饿汉式实现单例类的时候就会创建一个类实例。（如果一个虚拟机里有多个ClassLoader的话，就会有多个实例）\n\n##懒汉式 懒汉式，就是实例在用到的时候才去创建，比较“懒”\n\n单例模式的懒汉式实现方式体现了延迟加载的思想（延迟加载也称懒加载Lazy Load，就是一开始不要加载资源或数据，等到要使用的时候才加载）\n\n同步方法\n\npublic class Singleton {\n    private static Singleton singleton;\n\n    private Singleton(){}\n\n  \t//解决了线程不安全问题，但是效率太低了，每个线程想获得类的实例的时候，都需要同步方法，不推荐\n    public static synchronized Singleton getInstance(){\n        if(singleton == null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n双重检查加锁\n\npublic class Singleton {\n\n  \t//volatitle关键词确保，多线程正确处理singleton\n    private static volatile Singleton singleton;\n  \n    private Singleton(){}\n  \n    public static Singleton getInstance(){\n        if(singleton ==null){\n            synchronized (Singleton.class){\n                if(singleton == null){\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nDouble-Check 概念（进行两次检查）是多线程开发中经常使用的，为什么需要双重检查锁呢？因为第一次检查是确保之前是一个空对象，而非空对象就不需要同步了，空对象的线程然后进入同步代码块，如果不加第二次空对象检查，两个线程同时获取同步代码块，一个线程进入同步代码块，另一个线程就会等待，而这两个线程就会创建两个实例化对象，所以需要在线程进入同步代码块后再次进行空对象检查，才能确保只创建一个实例化对象。\n\n双重检查加锁（double checked locking）线程安全、延迟加载、效率比较高\n\nvolatile：volatile一般用于多线程的可见性，这里用来防止指令重排（防止new Singleton时指令重排序导致其他线程获取到未初始化完的对象）。被volatile 修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。\n\n指令重排\n\n指令重排是指在程序执行过程中, 为了性能考虑, 编译器和CPU可能会对指令重新排序。\n\nJava中创建一个对象，往往包含三个过程。对于singleton = new Singleton()，这不是一个原子操作，在 JVM 中包含如下三个过程。\n\n给 singleton 分配内存\n\n调用 Singleton 的构造函数来初始化成员变量，形成实例\n\n将 singleton 对象指向分配的内存空间（执行完这步 singleton才是非 null 了）\n\n但是，由于JVM会进行指令重排序，所以上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3，也可能是 1-3-2。\n\n如果是 1-3-2，则在 3 执行完毕，2 未执行之前，被另一个线程抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以这个线程会直接返回 instance，然后使用，那肯定就会报错了，所以要加入 volatile关键字。\n\n##静态内部类\n\npublic class Singleton {\n\n    private Singleton(){}\n\n    private static class SingletonInstance{\n        private static final Singleton INSTANCE = new Singleton();\n    }\n  \n    public static Singleton getInstance(){\n        return SingletonInstance.INSTANCE;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n采用类加载的机制来保证初始化实例时只有一个线程；\n\n静态内部类方式在Singleton 类被装载的时候并不会立即实例化，而是在调用getInstance的时候，才去装载内部类SingletonInstance ,从而完成Singleton的实例化\n\n类的静态属性只会在第一次加载类的时候初始化，所以，JVM帮我们保证了线程的安全性，在类初始化时，其他线程无法进入\n\n优点：线程安全，利用静态内部类实现延迟加载，效率较高，推荐使用\n\n##枚举\n\nenum Singleton{\n  INSTANCE;\n  public void method(){}\n}\n\n\n1\n2\n3\n4\n\n\n借助JDK5 添加的枚举实现单例，不仅可以避免多线程同步问题，还能防止反序列化重新创建新的对象，但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。不过，由于Java1.5中才加入enum特性，所以使用的人并不多。\n\n这种方式是《Effective Java》 作者Josh Bloch 提倡的方式。\n\n#单例模式在JDK 中的源码分析 JDK 中，java.lang.Runtime 就是经典的单例模式（饿汉式）\n\n#单例模式注意事项和细节 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使 用new 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等)",
      "normalizedContent": "> 面试官：带笔了吧，那写两种单例模式的实现方法吧 沙沙沙刷刷刷~~~ 写好了 面试官：怎样防止new 对象出来？\n\n有一些对象我们确实只需要一个，比如，线程池、数据库连接、缓存、日志对象等，如果有多个的话，会造成程序的行为异常，资源使用过量或者不一致的问题。你也许会说，这种我用全局变量不也能实现吗，还整个单例模式，好像你很流弊的样子，如果将对象赋值给一个全局变量，那程序启动就会创建好对象，万一这个对象很耗资源，我们还可能在某些时候用不到，这就造成了资源的浪费，不合理，所以就有了单例模式。\n\n#单例模式的定义 单例模式确保一个类只有一个实例，并提供一个全局唯一访问点\n\n#单例模式的类图\n\n#单例模式的实现\n\n\n# 饿汉式\n\nstatic 变量在类装载的时候进行初始化 多个实例的 static 变量会共享同一块内存区域 用这两个知识点写出的单例类就是饿汉式了，初始化类的时候就创建，饥不择食，饿汉\n\npublic class singleton {\n\n    //构造私有化，防止直接new\n    private singleton(){}\n\n    //静态初始化器（static initializer）中创建实例，保证线程安全\n    private static singleton instance = new singleton();\n\n    public static singleton getinstance(){\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n饿汉式是线程安全的，jvm在加载类时马上创建唯一的实例对象，且只会装载一次。\n\njava 实现的单例是一个虚拟机的范围，因为装载类的功能是虚拟机的，所以一个虚拟机通过自己的classloader 装载饿汉式实现单例类的时候就会创建一个类实例。（如果一个虚拟机里有多个classloader的话，就会有多个实例）\n\n##懒汉式 懒汉式，就是实例在用到的时候才去创建，比较“懒”\n\n单例模式的懒汉式实现方式体现了延迟加载的思想（延迟加载也称懒加载lazy load，就是一开始不要加载资源或数据，等到要使用的时候才加载）\n\n同步方法\n\npublic class singleton {\n    private static singleton singleton;\n\n    private singleton(){}\n\n  \t//解决了线程不安全问题，但是效率太低了，每个线程想获得类的实例的时候，都需要同步方法，不推荐\n    public static synchronized singleton getinstance(){\n        if(singleton == null){\n            singleton = new singleton();\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n双重检查加锁\n\npublic class singleton {\n\n  \t//volatitle关键词确保，多线程正确处理singleton\n    private static volatile singleton singleton;\n  \n    private singleton(){}\n  \n    public static singleton getinstance(){\n        if(singleton ==null){\n            synchronized (singleton.class){\n                if(singleton == null){\n                    singleton = new singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ndouble-check 概念（进行两次检查）是多线程开发中经常使用的，为什么需要双重检查锁呢？因为第一次检查是确保之前是一个空对象，而非空对象就不需要同步了，空对象的线程然后进入同步代码块，如果不加第二次空对象检查，两个线程同时获取同步代码块，一个线程进入同步代码块，另一个线程就会等待，而这两个线程就会创建两个实例化对象，所以需要在线程进入同步代码块后再次进行空对象检查，才能确保只创建一个实例化对象。\n\n双重检查加锁（double checked locking）线程安全、延迟加载、效率比较高\n\nvolatile：volatile一般用于多线程的可见性，这里用来防止指令重排（防止new singleton时指令重排序导致其他线程获取到未初始化完的对象）。被volatile 修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。\n\n指令重排\n\n指令重排是指在程序执行过程中, 为了性能考虑, 编译器和cpu可能会对指令重新排序。\n\njava中创建一个对象，往往包含三个过程。对于singleton = new singleton()，这不是一个原子操作，在 jvm 中包含如下三个过程。\n\n给 singleton 分配内存\n\n调用 singleton 的构造函数来初始化成员变量，形成实例\n\n将 singleton 对象指向分配的内存空间（执行完这步 singleton才是非 null 了）\n\n但是，由于jvm会进行指令重排序，所以上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3，也可能是 1-3-2。\n\n如果是 1-3-2，则在 3 执行完毕，2 未执行之前，被另一个线程抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以这个线程会直接返回 instance，然后使用，那肯定就会报错了，所以要加入 volatile关键字。\n\n##静态内部类\n\npublic class singleton {\n\n    private singleton(){}\n\n    private static class singletoninstance{\n        private static final singleton instance = new singleton();\n    }\n  \n    public static singleton getinstance(){\n        return singletoninstance.instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n采用类加载的机制来保证初始化实例时只有一个线程；\n\n静态内部类方式在singleton 类被装载的时候并不会立即实例化，而是在调用getinstance的时候，才去装载内部类singletoninstance ,从而完成singleton的实例化\n\n类的静态属性只会在第一次加载类的时候初始化，所以，jvm帮我们保证了线程的安全性，在类初始化时，其他线程无法进入\n\n优点：线程安全，利用静态内部类实现延迟加载，效率较高，推荐使用\n\n##枚举\n\nenum singleton{\n  instance;\n  public void method(){}\n}\n\n\n1\n2\n3\n4\n\n\n借助jdk5 添加的枚举实现单例，不仅可以避免多线程同步问题，还能防止反序列化重新创建新的对象，但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。不过，由于java1.5中才加入enum特性，所以使用的人并不多。\n\n这种方式是《effective java》 作者josh bloch 提倡的方式。\n\n#单例模式在jdk 中的源码分析 jdk 中，java.lang.runtime 就是经典的单例模式（饿汉式）\n\n#单例模式注意事项和细节 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使 用new 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等)",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "什么是设计模式，描述几个常用的设计模式",
      "frontmatter": {
        "title": "什么是设计模式，描述几个常用的设计模式",
        "date": "2022-05-21T17:26:19.000Z",
        "permalink": "/pages/3d768c/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/003.%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%8F%8F%E8%BF%B0%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20.html",
      "relativePath": "01.Java相关/40.设计模式/003.什么是设计模式，描述几个常用的设计模式 .md",
      "key": "v-504a5213",
      "path": "/pages/3d768c/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "工厂模式使用场景 能举个例子吗",
      "frontmatter": {
        "title": "工厂模式使用场景 能举个例子吗",
        "date": "2022-05-21T17:26:32.000Z",
        "permalink": "/pages/f15489/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/004.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%20%E8%83%BD%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%90%97.html",
      "relativePath": "01.Java相关/40.设计模式/004.工厂模式使用场景 能举个例子吗.md",
      "key": "v-2d6ed001",
      "path": "/pages/f15489/",
      "headers": [
        {
          "level": 2,
          "title": "模式动机",
          "slug": "模式动机",
          "normalizedTitle": "模式动机",
          "charIndex": 192
        },
        {
          "level": 2,
          "title": "模式定义",
          "slug": "模式定义",
          "normalizedTitle": "模式定义",
          "charIndex": 403
        },
        {
          "level": 2,
          "title": "模式结构",
          "slug": "模式结构",
          "normalizedTitle": "模式结构",
          "charIndex": 559
        },
        {
          "level": 2,
          "title": "模式分析",
          "slug": "模式分析",
          "normalizedTitle": "模式分析",
          "charIndex": 737
        },
        {
          "level": 2,
          "title": "定义",
          "slug": "定义",
          "normalizedTitle": "定义",
          "charIndex": 405
        },
        {
          "level": 2,
          "title": "简单工厂模式实现方式",
          "slug": "简单工厂模式实现方式",
          "normalizedTitle": "简单工厂模式实现方式",
          "charIndex": 3742
        },
        {
          "level": 2,
          "title": "简单工厂模式存在的问题",
          "slug": "简单工厂模式存在的问题",
          "normalizedTitle": "简单工厂模式存在的问题",
          "charIndex": 5167
        },
        {
          "level": 2,
          "title": "简单工厂模式总结",
          "slug": "简单工厂模式总结",
          "normalizedTitle": "简单工厂模式总结",
          "charIndex": 5373
        },
        {
          "level": 2,
          "title": "2.1 定义",
          "slug": "_2-1-定义",
          "normalizedTitle": "2.1 定义",
          "charIndex": 5803
        }
      ],
      "headersStr": "模式动机 模式定义 模式结构 模式分析 定义 简单工厂模式实现方式 简单工厂模式存在的问题 简单工厂模式总结 2.1 定义",
      "content": "> 3年工作经验是吧？ 你知道工厂模式分为几类吗？能举例子吗？ 那你说说你们项目中是怎么使用工厂模式的？\n\n#工厂模式 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n\n\n# 模式动机\n\n考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。\n\n\n# 模式定义\n\n简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n\n\n# 模式结构\n\n简单工厂模式包含如下角色：\n\nFactory：工厂角色\n工厂角色负责实现创建所有实例的内部逻辑 Product：抽象产品角色\n抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色\n具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 1.4. 时序图\n\n\n# 模式分析\n\n将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。\n\n在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可.\n\n在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。\n\n简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\n#工厂模式可以分为三类： 简单工厂模式（Simple Factory） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 简单工厂其实不是一个标准的的设计模式。GOF 23种设计模式中只有「工厂方法模式」与「抽象工厂模式」。简单工厂模式可以看为工厂方法模式的一种特例，为了统一整理学习，就都归为工厂模式。\n\n这三种工厂模式在设计模式的分类中都属于创建型模式，三种模式从上到下逐步抽象。\n\n创建型模式 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。\n\n创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。\n\n创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。\n\n工厂模式是创建型模式中比较重要的。工厂模式的主要功能就是帮助我们实例化对象。之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。\n\n工厂模式优点 可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。 对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。 降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。 适用场景 不管是简单工厂模式，工厂方法模式还是抽象工厂模式，他们具有类似的特性，所以他们的适用场景也是类似的。\n\n首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。\n\n再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n#一、简单工厂模式 在介绍简单工厂模式之前，我们尝试解决以下问题：\n\n现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。我们一般会这么写：\n\n// 计算类的基类 @Setter @Getter public abstract class Operation { private double value1 = 0; private double value2 = 0; protected abstract double getResule(); }\n\n//加法 public class OperationAdd extends Operation { @Override protected double getResule() { return getValue1() + getValue2(); } } //减法 public class OperationSub extends Operation { @Override protected double getResule() { return getValue1() - getValue2(); } } //乘法 public class OperationMul extends Operation { @Override protected double getResule() { return getValue1() * getValue2(); } } //除法 public class OperationDiv extends Operation { @Override protected double getResule() { if (getValue2() != 0) { return getValue1() / getValue2(); } throw new IllegalArgumentException(\"除数不能为零\"); } } 当我们要使用这个计算器的时候，又会这么写：\n\npublic static void main(String[] args) { //计算两数之和 OperationAdd operationAdd = new OperationAdd(); operationAdd.setValue1(1); operationAdd.setValue2(2); System.out.println(\"sum:\"+operationAdd.getResule()); //计算两数乘积 OperationMul operationMul = new OperationMul(); operationMul.setValue1(3); operationMul.setValue2(5); System.out.println(\"multiply:\"+operationMul.getResule()); //计算两数之差。。。 } 想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。那么这种重复的创建类的工作其实可以放到一个统一的类中去管理。这样的方法我们就叫做「简单工厂模式」，在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为「静态工厂方法」模式。。简单工厂模式有以下优点：\n\n一个调用者想创建一个对象，只要知道其名称就可以了。 屏蔽产品的具体实现，调用者只关心产品的接口。\n\n\n# 定义\n\n提供一个创建对象实例的功能，而无需关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。\n\n\n# 简单工厂模式实现方式\n\n没骗你，简单工厂模式，真是因为简单才被叫做简单工厂模式的。\n\n简单工厂模式包含 3 个角色（要素）：\n\nFactory：即工厂类， 简单工厂模式的核心部分，负责实现创建所有产品的内部逻辑；工厂类可以被外界直接调用，创建所需对象 Product：抽象类产品， 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象 ConcreteProduct：具体产品， 它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。它要实现抽象产品中声明的抽象方法 #UML类图\n\n#实例 现在我们定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n\n//工厂类\npublic class OperationFactory {\n\n    public static Operation createOperation(String operation) {\n        Operation oper = null;\n        switch (operation) {\n            case \"add\":\n                oper = new OperationAdd();\n                break;\n            case \"sub\":\n                oper = new OperationSub();\n                break;\n            case \"mul\":\n                oper = new OperationMul();\n                break;\n\n            case \"div\":\n                oper = new OperationDiv();\n                break;\n            default:\n                throw new UnsupportedOperationException(\"不支持该操作\");\n        }\n        return oper;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n有了工厂类之后，可以使用工厂创建对象：\n\npublic static void main(String[] args) {\n  Operation operationAdd = OperationFactory.createOperation(\"add\");\n  operationAdd.setValue1(1);\n  operationAdd.setValue2(2)\n  System.out.println(operationAdd.getResule());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，只要知道该类对应的参数\"add\"就可以了。这就体现了之前提到的工厂模式的优点。\n\n\n# 简单工厂模式存在的问题\n\n当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承Operation类，其中实现平方的代码。除此之外我们还要修改 OperationFactory 类的代码，增加一个 case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。\n\n我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。\n\n\n# 简单工厂模式总结\n\n工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。\n\n但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。\n\n当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；\n\n为了解决这些缺点，就有了工厂方法模式。\n\n#二、工厂方法模式 我们常说的工厂模式，就是指「工厂方法模式」，也叫「虚拟构造器模式」或「多态工厂模式」。\n\n\n# 2.1 定义\n\n定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。\n\n##2.2 工厂方法模式实现方式 工厂方法模式包含 4 个角色（要素）：\n\nProduct：抽象产品，定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口 ConcreteProduct：具体产品，具体的Product接口的实现对象 Factory：工厂接口，也可以叫 Creator(创建器)，申明工厂方法，通常返回一个 Product 类型的实例对象 ConcreteFactory：工厂实现，或者叫 ConcreteCreator(创建器对象)，覆盖 Factory 定义的工厂方法，返回具体的 Product 实例 #UML类图\n\n#实例 从 UML 类图可以看出，每种产品实现，我们都要增加一个继承于工厂接口 IFactory 的工厂类 Factory ，修改简单工厂模式代码中的工厂类如下：\n\n//工厂接口\npublic interface IFactory {\n    Operation CreateOption();\n}\n\n//加法类工厂\npublic class AddFactory implements IFactory {\n    public Operation CreateOption() {\n        return new OperationAdd();\n    }\n}\n\n//减法类工厂\npublic class SubFactory implements IFactory {\n    public Operation CreateOption() {\n        return new OperationSub();\n    }\n}\n\n//乘法类工厂\npublic class MulFactory implements IFactory {\n    public Operation CreateOption() {\n        return new OperationMul();\n    }\n}\n\n//除法类工厂\npublic class DivFactory implements IFactory {\n    public Operation CreateOption() {\n        return new OperationDiv();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这时，我们使用计算器的时候，要为每种运算方法增加一个工厂对象\n\npublic class Client {\n    public static void main(String[] args) {\n      //减法\n      IFactory subFactory = new SubFactory();\n      Operation operationSub =  subFactory.CreateOption();\n      operationSub.setValue1(22);\n      operationSub.setValue2(20);\n      System.out.println(\"sub:\"+operationSub.getResult());\n      //除法\n      IFactory Divfactory = new DivFactory();\n      Operation operationDiv =  Divfactory.CreateOption();\n      operationDiv.setValue1(99);\n      operationDiv.setValue2(33);\n      System.out.println(\"div:\"+operationSub.getResult());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n纳尼，这不是更复杂了吗，每个产品对应一个工厂，我又不是按代码量赚钱的。。。\n\n##2.3 工厂方法模式适用场景 工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合“开闭原则”。\n\n在以下情况下可以使用工厂方法模式：\n\n一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 使用场景 日志记录器：日志可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口。 比如 Hibernate 换数据库只需换方言和驱动就可以 ##2.4 工厂方法模式总结 工厂方法模式是简单工厂模式的进一步抽象和推广。\n\n由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\n\n在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。\n\n优点：\n\n一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：\n\n每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n\n#三、抽象工厂模式 工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。\n\n##3.1 定义 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。\n\n抽象工厂(Abstract Factory)模式，又称工具箱(Kit 或Toolkit)模式。\n\n##3.2 抽象工厂模式实现方式 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。\n\n在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。\n\n也没骗你，抽象工厂模式确实是抽象。\n\n抽象工厂模式包含的角色（要素）：\n\nAbstractFactory：抽象工厂，用于声明生成抽象产品的方法 ConcreteFactory：具体工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建 AbstractProduct：抽象产品，定义一类产品对象的接口 ConcreteProduct：具体产品，通常在具体工厂里，会选择具体的产品实现，来创建符合抽象工厂定义的方法返回的产品类型的对象。 Client：客户端，使用抽象工厂来获取一系列所需要的产品对象 #UML类图\n\n#实例 我把维基百科的例子改下用于理解，假设我们要生产两种产品，键盘（Keyboard）和鼠标（Mouse） ，每一种产品都支持多种系列，比如 Mac 系列和 Windows 系列。这样每个系列的产品分别是 MacKeyboard WinKeyboard, MacMouse, WinMouse 。为了可以在运行时刻创建一个系列的产品族，我们可以为每个系列的产品族创建一个工厂 MacFactory 和 WinFactory 。每个工厂都有两个方法 CreateMouse 和 CreateKeyboard 并返回对应的产品，可以将这两个方法抽象成一个接口 HardWare 。这样在运行时刻我们可以选择创建需要的产品系列。\n\n抽象产品\n\npublic interface Keyboard { void input(); } public interface Mouse { void click(); } 具体产品\n\n//具体产品 public class MacKeyboard implements Keyboard { @Override public void input() { System.out.println(\"Mac 专用键盘\"); } }\n\npublic class MacMouse implements Mouse { @Override public void click() { System.out.println(\"Mac 专用鼠标\"); } }\n\npublic class WinKeyboard implements Keyboard { @Override public void input() { System.out.println(\"Win 专用键盘\"); } }\n\npublic class WinMouse implements Mouse { @Override public void click() { System.out.println(\"win 专用鼠标\"); } } 抽象工厂\n\npublic interface Hardware { Keyboard createKyeBoard(); Mouse createMouse(); } 具体的工厂类\n\npublic class MacFactory implements Hardware{ @Override public Keyboard createKyeBoard() { return new MacKeyboard(); }\n\n@Override\npublic Mouse createMouse() {\n    return new MacMouse();\n}\n\n\n}\n\npublic class WinFactory implements Hardware{ @Override public Keyboard createKyeBoard() { return new WinKeyboard(); }\n\n@Override\npublic Mouse createMouse() {\n    return new WinMouse();\n}\n\n\n} 使用\n\npublic class Client { public static void main(String[] args) { Hardware macFactory = new MacFactory(); Keyboard keyboard = macFactory.createKyeBoard(); keyboard.input(); //Mac 专用键盘\n\nHardware winFactory = new WinFactory();\nMouse mouse = winFactory.createMouse();\nmouse.click();  //win 专用鼠标\n\n\n} } #3.3 抽象工厂模式适用场景 抽象工厂模式和工厂方法模式一样，都符合开闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。\n\n在以下情况下可以使用抽象工厂模式：\n\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 系统结构稳定，不会频繁的增加对象。 “开闭原则”的倾斜性\n\n在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为**“开闭原则”的倾斜性**。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：\n\n增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。 正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。\n\n#3.4 抽象工厂模式总结 抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。\n\n优点：\n\n抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点：\n\n增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。\n\n#工厂模式的退化 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n\n#四、我们身边的工厂模式 工厂模式在Java码农身边真是无处不在，不信打开你的项目，搜索 Factory\n\n我们最常用的 Spring 就是一个最大的 Bean 工厂，IOC 通过BeanFactory对Bean 进行管理。\n\n我们使用的日志门面框架slf4j，点进去就可以看到熟悉的味道\n\nprivate final static Logger logger = LoggerFactory.getLogger(HelloWord.class); JDK 的 Calendar 使用了简单工厂模式\n\n Calendar calendar = Calendar.getInstance();\n\n\n1\n\n\n> 参考\n> https://javakeeper.starfish.ink/design-pattern/Factory-Pattern.html",
      "normalizedContent": "> 3年工作经验是吧？ 你知道工厂模式分为几类吗？能举例子吗？ 那你说说你们项目中是怎么使用工厂模式的？\n\n#工厂模式 工厂模式（factory pattern）是 java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n\n\n# 模式动机\n\n考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。\n\n\n# 模式定义\n\n简单工厂模式(simple factory pattern)：又称为静态工厂方法(static factory method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n\n\n# 模式结构\n\n简单工厂模式包含如下角色：\n\nfactory：工厂角色\n工厂角色负责实现创建所有实例的内部逻辑 product：抽象产品角色\n抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 concreteproduct：具体产品角色\n具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 1.4. 时序图\n\n\n# 模式分析\n\n将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。\n\n在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可.\n\n在实际开发中，还可以在调用时将所传入的参数保存在xml等格式的配置文件中，修改参数时无须修改任何源代码。\n\n简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\n#工厂模式可以分为三类： 简单工厂模式（simple factory） 工厂方法模式（factory method） 抽象工厂模式（abstract factory） 简单工厂其实不是一个标准的的设计模式。gof 23种设计模式中只有「工厂方法模式」与「抽象工厂模式」。简单工厂模式可以看为工厂方法模式的一种特例，为了统一整理学习，就都归为工厂模式。\n\n这三种工厂模式在设计模式的分类中都属于创建型模式，三种模式从上到下逐步抽象。\n\n创建型模式 创建型模式(creational pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。\n\n创建型模式在创建什么(what)，由谁创建(who)，何时创建(when)等方面都为软件设计者提供了尽可能大的灵活性。\n\n创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。\n\n工厂模式是创建型模式中比较重要的。工厂模式的主要功能就是帮助我们实例化对象。之所以名字中包含工厂模式四个字，是因为对象的实例化过程是通过工厂实现的，是用工厂代替new操作的。\n\n工厂模式优点 可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。 对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。 降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。 适用场景 不管是简单工厂模式，工厂方法模式还是抽象工厂模式，他们具有类似的特性，所以他们的适用场景也是类似的。\n\n首先，作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n\n其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度。\n\n再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n#一、简单工厂模式 在介绍简单工厂模式之前，我们尝试解决以下问题：\n\n现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。我们一般会这么写：\n\n// 计算类的基类 @setter @getter public abstract class operation { private double value1 = 0; private double value2 = 0; protected abstract double getresule(); }\n\n//加法 public class operationadd extends operation { @override protected double getresule() { return getvalue1() + getvalue2(); } } //减法 public class operationsub extends operation { @override protected double getresule() { return getvalue1() - getvalue2(); } } //乘法 public class operationmul extends operation { @override protected double getresule() { return getvalue1() * getvalue2(); } } //除法 public class operationdiv extends operation { @override protected double getresule() { if (getvalue2() != 0) { return getvalue1() / getvalue2(); } throw new illegalargumentexception(\"除数不能为零\"); } } 当我们要使用这个计算器的时候，又会这么写：\n\npublic static void main(string[] args) { //计算两数之和 operationadd operationadd = new operationadd(); operationadd.setvalue1(1); operationadd.setvalue2(2); system.out.println(\"sum:\"+operationadd.getresule()); //计算两数乘积 operationmul operationmul = new operationmul(); operationmul.setvalue1(3); operationmul.setvalue2(5); system.out.println(\"multiply:\"+operationmul.getresule()); //计算两数之差。。。 } 想要使用不同的运算的时候就要创建不同的类，并且要明确知道该类的名字。那么这种重复的创建类的工作其实可以放到一个统一的类中去管理。这样的方法我们就叫做「简单工厂模式」，在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为「静态工厂方法」模式。。简单工厂模式有以下优点：\n\n一个调用者想创建一个对象，只要知道其名称就可以了。 屏蔽产品的具体实现，调用者只关心产品的接口。\n\n\n# 定义\n\n提供一个创建对象实例的功能，而无需关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。\n\n\n# 简单工厂模式实现方式\n\n没骗你，简单工厂模式，真是因为简单才被叫做简单工厂模式的。\n\n简单工厂模式包含 3 个角色（要素）：\n\nfactory：即工厂类， 简单工厂模式的核心部分，负责实现创建所有产品的内部逻辑；工厂类可以被外界直接调用，创建所需对象 product：抽象类产品， 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象 concreteproduct：具体产品， 它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。它要实现抽象产品中声明的抽象方法 #uml类图\n\n#实例 现在我们定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n\n//工厂类\npublic class operationfactory {\n\n    public static operation createoperation(string operation) {\n        operation oper = null;\n        switch (operation) {\n            case \"add\":\n                oper = new operationadd();\n                break;\n            case \"sub\":\n                oper = new operationsub();\n                break;\n            case \"mul\":\n                oper = new operationmul();\n                break;\n\n            case \"div\":\n                oper = new operationdiv();\n                break;\n            default:\n                throw new unsupportedoperationexception(\"不支持该操作\");\n        }\n        return oper;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n有了工厂类之后，可以使用工厂创建对象：\n\npublic static void main(string[] args) {\n  operation operationadd = operationfactory.createoperation(\"add\");\n  operationadd.setvalue1(1);\n  operationadd.setvalue2(2)\n  system.out.println(operationadd.getresule());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，只要知道该类对应的参数\"add\"就可以了。这就体现了之前提到的工厂模式的优点。\n\n\n# 简单工厂模式存在的问题\n\n当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承operation类，其中实现平方的代码。除此之外我们还要修改 operationfactory 类的代码，增加一个 case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。\n\n我们举的例子是最简单的情况。而在实际应用中，很可能产品是一个多层次的树状结构。 简单工厂可能就不太适用了。\n\n\n# 简单工厂模式总结\n\n工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。\n\n但是由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。\n\n当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；\n\n为了解决这些缺点，就有了工厂方法模式。\n\n#二、工厂方法模式 我们常说的工厂模式，就是指「工厂方法模式」，也叫「虚拟构造器模式」或「多态工厂模式」。\n\n\n# 2.1 定义\n\n定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。\n\n##2.2 工厂方法模式实现方式 工厂方法模式包含 4 个角色（要素）：\n\nproduct：抽象产品，定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口 concreteproduct：具体产品，具体的product接口的实现对象 factory：工厂接口，也可以叫 creator(创建器)，申明工厂方法，通常返回一个 product 类型的实例对象 concretefactory：工厂实现，或者叫 concretecreator(创建器对象)，覆盖 factory 定义的工厂方法，返回具体的 product 实例 #uml类图\n\n#实例 从 uml 类图可以看出，每种产品实现，我们都要增加一个继承于工厂接口 ifactory 的工厂类 factory ，修改简单工厂模式代码中的工厂类如下：\n\n//工厂接口\npublic interface ifactory {\n    operation createoption();\n}\n\n//加法类工厂\npublic class addfactory implements ifactory {\n    public operation createoption() {\n        return new operationadd();\n    }\n}\n\n//减法类工厂\npublic class subfactory implements ifactory {\n    public operation createoption() {\n        return new operationsub();\n    }\n}\n\n//乘法类工厂\npublic class mulfactory implements ifactory {\n    public operation createoption() {\n        return new operationmul();\n    }\n}\n\n//除法类工厂\npublic class divfactory implements ifactory {\n    public operation createoption() {\n        return new operationdiv();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这时，我们使用计算器的时候，要为每种运算方法增加一个工厂对象\n\npublic class client {\n    public static void main(string[] args) {\n      //减法\n      ifactory subfactory = new subfactory();\n      operation operationsub =  subfactory.createoption();\n      operationsub.setvalue1(22);\n      operationsub.setvalue2(20);\n      system.out.println(\"sub:\"+operationsub.getresult());\n      //除法\n      ifactory divfactory = new divfactory();\n      operation operationdiv =  divfactory.createoption();\n      operationdiv.setvalue1(99);\n      operationdiv.setvalue2(33);\n      system.out.println(\"div:\"+operationsub.getresult());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n纳尼，这不是更复杂了吗，每个产品对应一个工厂，我又不是按代码量赚钱的。。。\n\n##2.3 工厂方法模式适用场景 工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合“开闭原则”。\n\n在以下情况下可以使用工厂方法模式：\n\n一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 使用场景 日志记录器：日志可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，\"pop3\"、\"imap\"、\"http\"，可以把这三个作为产品类，共同实现一个接口。 比如 hibernate 换数据库只需换方言和驱动就可以 ##2.4 工厂方法模式总结 工厂方法模式是简单工厂模式的进一步抽象和推广。\n\n由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\n\n在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。\n\n优点：\n\n一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：\n\n每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n\n#三、抽象工厂模式 工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。\n\n##3.1 定义 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。\n\n抽象工厂(abstract factory)模式，又称工具箱(kit 或toolkit)模式。\n\n##3.2 抽象工厂模式实现方式 抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。\n\n在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。\n\n也没骗你，抽象工厂模式确实是抽象。\n\n抽象工厂模式包含的角色（要素）：\n\nabstractfactory：抽象工厂，用于声明生成抽象产品的方法 concretefactory：具体工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建 abstractproduct：抽象产品，定义一类产品对象的接口 concreteproduct：具体产品，通常在具体工厂里，会选择具体的产品实现，来创建符合抽象工厂定义的方法返回的产品类型的对象。 client：客户端，使用抽象工厂来获取一系列所需要的产品对象 #uml类图\n\n#实例 我把维基百科的例子改下用于理解，假设我们要生产两种产品，键盘（keyboard）和鼠标（mouse） ，每一种产品都支持多种系列，比如 mac 系列和 windows 系列。这样每个系列的产品分别是 mackeyboard winkeyboard, macmouse, winmouse 。为了可以在运行时刻创建一个系列的产品族，我们可以为每个系列的产品族创建一个工厂 macfactory 和 winfactory 。每个工厂都有两个方法 createmouse 和 createkeyboard 并返回对应的产品，可以将这两个方法抽象成一个接口 hardware 。这样在运行时刻我们可以选择创建需要的产品系列。\n\n抽象产品\n\npublic interface keyboard { void input(); } public interface mouse { void click(); } 具体产品\n\n//具体产品 public class mackeyboard implements keyboard { @override public void input() { system.out.println(\"mac 专用键盘\"); } }\n\npublic class macmouse implements mouse { @override public void click() { system.out.println(\"mac 专用鼠标\"); } }\n\npublic class winkeyboard implements keyboard { @override public void input() { system.out.println(\"win 专用键盘\"); } }\n\npublic class winmouse implements mouse { @override public void click() { system.out.println(\"win 专用鼠标\"); } } 抽象工厂\n\npublic interface hardware { keyboard createkyeboard(); mouse createmouse(); } 具体的工厂类\n\npublic class macfactory implements hardware{ @override public keyboard createkyeboard() { return new mackeyboard(); }\n\n@override\npublic mouse createmouse() {\n    return new macmouse();\n}\n\n\n}\n\npublic class winfactory implements hardware{ @override public keyboard createkyeboard() { return new winkeyboard(); }\n\n@override\npublic mouse createmouse() {\n    return new winmouse();\n}\n\n\n} 使用\n\npublic class client { public static void main(string[] args) { hardware macfactory = new macfactory(); keyboard keyboard = macfactory.createkyeboard(); keyboard.input(); //mac 专用键盘\n\nhardware winfactory = new winfactory();\nmouse mouse = winfactory.createmouse();\nmouse.click();  //win 专用鼠标\n\n\n} } #3.3 抽象工厂模式适用场景 抽象工厂模式和工厂方法模式一样，都符合开闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。\n\n在以下情况下可以使用抽象工厂模式：\n\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 系统结构稳定，不会频繁的增加对象。 “开闭原则”的倾斜性\n\n在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为**“开闭原则”的倾斜性**。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：\n\n增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。 正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。\n\n#3.4 抽象工厂模式总结 抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和api类库的设计中，例如在java语言的awt（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。\n\n优点：\n\n抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点：\n\n增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。\n\n#工厂模式的退化 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n\n#四、我们身边的工厂模式 工厂模式在java码农身边真是无处不在，不信打开你的项目，搜索 factory\n\n我们最常用的 spring 就是一个最大的 bean 工厂，ioc 通过beanfactory对bean 进行管理。\n\n我们使用的日志门面框架slf4j，点进去就可以看到熟悉的味道\n\nprivate final static logger logger = loggerfactory.getlogger(helloword.class); jdk 的 calendar 使用了简单工厂模式\n\n calendar calendar = calendar.getinstance();\n\n\n1\n\n\n> 参考\n> https://javakeeper.starfish.ink/design-pattern/factory-pattern.html",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "适配器模式",
      "frontmatter": {
        "title": "适配器模式",
        "date": "2022-05-21T17:28:10.000Z",
        "permalink": "/pages/827fc4/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/010.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/010.适配器模式.md",
      "key": "v-31509c80",
      "path": "/pages/827fc4/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述装饰者模式以及适配器模式",
      "frontmatter": {
        "title": "简述装饰者模式以及适配器模式",
        "date": "2022-05-21T17:26:42.000Z",
        "permalink": "/pages/47a4e3/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/005.%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/005.装饰者模式.md",
      "key": "v-22a9eaef",
      "path": "/pages/47a4e3/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "代理模式",
      "frontmatter": {
        "title": "代理模式",
        "date": "2022-05-21T17:28:27.000Z",
        "permalink": "/pages/dd3a6f/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/020.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/020.代理模式.md",
      "key": "v-0564ba27",
      "path": "/pages/dd3a6f/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "责任链模式",
      "frontmatter": {
        "title": "责任链模式",
        "date": "2022-05-21T17:28:46.000Z",
        "permalink": "/pages/d3ff35/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/030.%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/030.责任链模式.md",
      "key": "v-34f8aaa2",
      "path": "/pages/d3ff35/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "模板方法模式",
      "frontmatter": {
        "title": "模板方法模式",
        "date": "2022-05-21T17:29:10.000Z",
        "permalink": "/pages/43b656/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/040.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/040.模板方法模式.md",
      "key": "v-28deb9da",
      "path": "/pages/43b656/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "策略模式",
      "frontmatter": {
        "title": "策略模式",
        "date": "2022-05-21T17:29:26.000Z",
        "permalink": "/pages/78c7aa/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/050.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/050.策略模式.md",
      "key": "v-5b0157cf",
      "path": "/pages/78c7aa/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "观察模式",
      "frontmatter": {
        "title": "观察模式",
        "date": "2022-05-21T17:29:45.000Z",
        "permalink": "/pages/cbff3c/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/060.%E8%A7%82%E5%AF%9F%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/060.观察模式.md",
      "key": "v-64f1031c",
      "path": "/pages/cbff3c/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "建造者模式",
      "frontmatter": {
        "title": "建造者模式",
        "date": "2022-05-21T17:30:20.000Z",
        "permalink": "/pages/c332ae/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/080.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/080.建造者模式.md",
      "key": "v-dd5f4440",
      "path": "/pages/c332ae/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "代理模式",
      "frontmatter": {
        "title": "代理模式",
        "date": "2022-05-21T17:30:05.000Z",
        "permalink": "/pages/a3c735/",
        "categories": [
          "Java相关",
          "设计模式"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/01.Java%E7%9B%B8%E5%85%B3/40.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/070.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "01.Java相关/40.设计模式/070.代理模式.md",
      "key": "v-2279e49d",
      "path": "/pages/a3c735/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "操作系统",
      "frontmatter": {
        "title": "操作系统",
        "date": "2022-03-11T00:51:48.000Z",
        "permalink": "/pages/e5f2d7/",
        "categories": [
          "计算机基础",
          "CSS"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/20.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.CSS/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",
      "relativePath": "02.计算机基础/20.操作系统.CSS/01.操作系统.md",
      "key": "v-03328512",
      "path": "/pages/e5f2d7/",
      "headers": [
        {
          "level": 2,
          "title": "进程间有哪些通信方式？",
          "slug": "进程间有哪些通信方式",
          "normalizedTitle": "进程间有哪些通信方式？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "简述自旋锁与互斥锁的使用场景",
          "slug": "简述自旋锁与互斥锁的使用场景",
          "normalizedTitle": "简述自旋锁与互斥锁的使用场景",
          "charIndex": 18
        },
        {
          "level": 2,
          "title": "进程和线程之间有什么区别？",
          "slug": "进程和线程之间有什么区别",
          "normalizedTitle": "进程和线程之间有什么区别？",
          "charIndex": 37
        },
        {
          "level": 2,
          "title": "简述几个常用的 Linux 命令以及他们的功能",
          "slug": "简述几个常用的-linux-命令以及他们的功能",
          "normalizedTitle": "简述几个常用的 linux 命令以及他们的功能",
          "charIndex": 55
        },
        {
          "level": 2,
          "title": "创建线程有多少种方式？",
          "slug": "创建线程有多少种方式",
          "normalizedTitle": "创建线程有多少种方式？",
          "charIndex": 83
        },
        {
          "level": 2,
          "title": "线程有多少种状态，状态之间如何转换",
          "slug": "线程有多少种状态-状态之间如何转换",
          "normalizedTitle": "线程有多少种状态，状态之间如何转换",
          "charIndex": 99
        },
        {
          "level": 2,
          "title": "进程有多少种状态？",
          "slug": "进程有多少种状态",
          "normalizedTitle": "进程有多少种状态？",
          "charIndex": 121
        },
        {
          "level": 2,
          "title": "简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？",
          "slug": "简述-select-poll-epoll-的使用场景以及区别-epoll-中水平触发以及边缘触发有什么不同",
          "normalizedTitle": "简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？",
          "charIndex": 135
        },
        {
          "level": 2,
          "title": "Linux 下如何排查 CPU 以及 内存占用过多？",
          "slug": "linux-下如何排查-cpu-以及-内存占用过多",
          "normalizedTitle": "linux 下如何排查 cpu 以及 内存占用过多？",
          "charIndex": 196
        },
        {
          "level": 2,
          "title": "进程通信中的管道实现原理是什么？",
          "slug": "进程通信中的管道实现原理是什么",
          "normalizedTitle": "进程通信中的管道实现原理是什么？",
          "charIndex": 227
        },
        {
          "level": 2,
          "title": "Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？",
          "slug": "linux-下如何查看-cpu-荷载-正在运行的进程-某个端口对应的进程",
          "normalizedTitle": "linux 下如何查看 cpu 荷载，正在运行的进程，某个端口对应的进程？",
          "charIndex": 248
        },
        {
          "level": 2,
          "title": "如何调试服务器内存占用过高的问题？",
          "slug": "如何调试服务器内存占用过高的问题",
          "normalizedTitle": "如何调试服务器内存占用过高的问题？",
          "charIndex": 290
        },
        {
          "level": 2,
          "title": "Linux 如何查看实时的滚动日志？",
          "slug": "linux-如何查看实时的滚动日志",
          "normalizedTitle": "linux 如何查看实时的滚动日志？",
          "charIndex": 312
        },
        {
          "level": 2,
          "title": "简述 Linux 零拷贝的原理",
          "slug": "简述-linux-零拷贝的原理",
          "normalizedTitle": "简述 linux 零拷贝的原理",
          "charIndex": 335
        },
        {
          "level": 2,
          "title": "为什么进程切换慢，线程切换快？",
          "slug": "为什么进程切换慢-线程切换快",
          "normalizedTitle": "为什么进程切换慢，线程切换快？",
          "charIndex": 355
        },
        {
          "level": 2,
          "title": "简述创建进程的流程",
          "slug": "简述创建进程的流程",
          "normalizedTitle": "简述创建进程的流程",
          "charIndex": 375
        },
        {
          "level": 2,
          "title": "简述 Linux 虚拟内存的页面置换算法",
          "slug": "简述-linux-虚拟内存的页面置换算法",
          "normalizedTitle": "简述 linux 虚拟内存的页面置换算法",
          "charIndex": 389
        },
        {
          "level": 2,
          "title": "简述 Linux 进程调度的算法",
          "slug": "简述-linux-进程调度的算法",
          "normalizedTitle": "简述 linux 进程调度的算法",
          "charIndex": 414
        },
        {
          "level": 2,
          "title": "什么时候会由用户态陷入内核态？",
          "slug": "什么时候会由用户态陷入内核态",
          "normalizedTitle": "什么时候会由用户态陷入内核态？",
          "charIndex": 435
        },
        {
          "level": 2,
          "title": "Linux 下如何查看端口被哪个进程占用？",
          "slug": "linux-下如何查看端口被哪个进程占用",
          "normalizedTitle": "linux 下如何查看端口被哪个进程占用？",
          "charIndex": 455
        },
        {
          "level": 2,
          "title": "Linux 中虚拟内存和物理内存有什么区别？有什么优点？",
          "slug": "linux-中虚拟内存和物理内存有什么区别-有什么优点",
          "normalizedTitle": "linux 中虚拟内存和物理内存有什么区别？有什么优点？",
          "charIndex": 481
        },
        {
          "level": 2,
          "title": "简述 traceroute 命令的原理",
          "slug": "简述-traceroute-命令的原理",
          "normalizedTitle": "简述 traceroute 命令的原理",
          "charIndex": 514
        }
      ],
      "headersStr": "进程间有哪些通信方式？ 简述自旋锁与互斥锁的使用场景 进程和线程之间有什么区别？ 简述几个常用的 Linux 命令以及他们的功能 创建线程有多少种方式？ 线程有多少种状态，状态之间如何转换 进程有多少种状态？ 简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？ Linux 下如何排查 CPU 以及 内存占用过多？ 进程通信中的管道实现原理是什么？ Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？ 如何调试服务器内存占用过高的问题？ Linux 如何查看实时的滚动日志？ 简述 Linux 零拷贝的原理 为什么进程切换慢，线程切换快？ 简述创建进程的流程 简述 Linux 虚拟内存的页面置换算法 简述 Linux 进程调度的算法 什么时候会由用户态陷入内核态？ Linux 下如何查看端口被哪个进程占用？ Linux 中虚拟内存和物理内存有什么区别？有什么优点？ 简述 traceroute 命令的原理",
      "content": "# 进程间有哪些通信方式？\n\n\n# 简述自旋锁与互斥锁的使用场景\n\n\n# 进程和线程之间有什么区别？\n\n\n# 简述几个常用的 Linux 命令以及他们的功能\n\n\n# 创建线程有多少种方式？\n\n\n# 线程有多少种状态，状态之间如何转换\n\n\n# 进程有多少种状态？\n\n\n# 简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？\n\n\n# Linux 下如何排查 CPU 以及 内存占用过多？\n\n\n# 进程通信中的管道实现原理是什么？\n\n\n# Linux 下如何查看 CPU 荷载，正在运行的进程，某个端口对应的进程？\n\n\n# 如何调试服务器内存占用过高的问题？\n\n\n# Linux 如何查看实时的滚动日志？\n\n\n# 简述 Linux 零拷贝的原理\n\n\n# 为什么进程切换慢，线程切换快？\n\n\n# 简述创建进程的流程\n\n\n# 简述 Linux 虚拟内存的页面置换算法\n\n\n# 简述 Linux 进程调度的算法\n\n\n# 什么时候会由用户态陷入内核态？\n\n\n# Linux 下如何查看端口被哪个进程占用？\n\n\n# Linux 中虚拟内存和物理内存有什么区别？有什么优点？\n\n\n# 简述 traceroute 命令的原理",
      "normalizedContent": "# 进程间有哪些通信方式？\n\n\n# 简述自旋锁与互斥锁的使用场景\n\n\n# 进程和线程之间有什么区别？\n\n\n# 简述几个常用的 linux 命令以及他们的功能\n\n\n# 创建线程有多少种方式？\n\n\n# 线程有多少种状态，状态之间如何转换\n\n\n# 进程有多少种状态？\n\n\n# 简述 select, poll, epoll 的使用场景以及区别，epoll 中水平触发以及边缘触发有什么不同？\n\n\n# linux 下如何排查 cpu 以及 内存占用过多？\n\n\n# 进程通信中的管道实现原理是什么？\n\n\n# linux 下如何查看 cpu 荷载，正在运行的进程，某个端口对应的进程？\n\n\n# 如何调试服务器内存占用过高的问题？\n\n\n# linux 如何查看实时的滚动日志？\n\n\n# 简述 linux 零拷贝的原理\n\n\n# 为什么进程切换慢，线程切换快？\n\n\n# 简述创建进程的流程\n\n\n# 简述 linux 虚拟内存的页面置换算法\n\n\n# 简述 linux 进程调度的算法\n\n\n# 什么时候会由用户态陷入内核态？\n\n\n# linux 下如何查看端口被哪个进程占用？\n\n\n# linux 中虚拟内存和物理内存有什么区别？有什么优点？\n\n\n# 简述 traceroute 命令的原理",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "数据结构",
      "frontmatter": {
        "title": "数据结构",
        "date": "2022-03-11T00:38:43.000Z",
        "permalink": "/pages/a25c3a/",
        "categories": [
          "计算机基础",
          "CSS"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.CSS/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",
      "relativePath": "02.计算机基础/30.数据结构.CSS/01.数据结构.md",
      "key": "v-10288186",
      "path": "/pages/a25c3a/",
      "headers": [
        {
          "level": 2,
          "title": "简单的数据结构",
          "slug": "简单的数据结构",
          "normalizedTitle": "简单的数据结构",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "树",
          "slug": "树",
          "normalizedTitle": "树",
          "charIndex": 96
        },
        {
          "level": 2,
          "title": "堆",
          "slug": "堆",
          "normalizedTitle": "堆",
          "charIndex": 164
        },
        {
          "level": 2,
          "title": "图",
          "slug": "图",
          "normalizedTitle": "图",
          "charIndex": 185
        },
        {
          "level": 2,
          "title": "稳定的排序算法",
          "slug": "稳定的排序算法",
          "normalizedTitle": "稳定的排序算法",
          "charIndex": 212
        },
        {
          "level": 2,
          "title": "不稳定的排序算法",
          "slug": "不稳定的排序算法",
          "normalizedTitle": "不稳定的排序算法",
          "charIndex": 322
        },
        {
          "level": 2,
          "title": "各种排序算法和时间复杂度",
          "slug": "各种排序算法和时间复杂度",
          "normalizedTitle": "各种排序算法和时间复杂度",
          "charIndex": 404
        },
        {
          "level": 2,
          "title": "深度优先和广度优先搜索",
          "slug": "深度优先和广度优先搜索",
          "normalizedTitle": "深度优先和广度优先搜索",
          "charIndex": 421
        }
      ],
      "headersStr": "简单的数据结构 树 堆 图 稳定的排序算法 不稳定的排序算法 各种排序算法和时间复杂度 深度优先和广度优先搜索",
      "content": "# 简单的数据结构\n\n* 栈\n* 队列\n\n* 链表\n\n* 数组\n\n* 哈希表\n\n* 栈和队列的相同和不同之处\n\n* 栈通常采用的两种存储结构\n\n* 两个栈实现队列，和两个队列实现栈\n\n\n\n# 树\n\n* 二叉树\n\n* 字典树\n\n* 平衡树\n\n* 排序树\n\n* B树\n\n* B+树\n\n* R树\n\n* 多路树\n\n* 红黑树\n\n\n\n# 堆\n\n* 大根堆\n\n* 小根堆\n\n\n\n# 图\n\n* 有向图\n\n* 无向图\n\n* 拓扑\n\n\n\n# 稳定的排序算法\n\n* 冒泡排序\n* 插入排序\n* 鸡尾酒排序\n* 桶排序\n* 计数排序\n* 归并排序\n* 原地归并排序\n* 二叉排序树排序\n* 鸽巢排序\n* 基数排序\n* 侏儒排序\n* 图书馆排序\n* 块排序\n\n\n\n# 不稳定的排序算法\n\n* 选择排序\n* 希尔排序\n* Clover排序算法\n* 梳排序\n* 堆排序\n* 平滑排序\n* 快速排序\n* 内省排序\n* 耐心排序\n\n\n\n# 各种排序算法和时间复杂度\n\n\n# 深度优先和广度优先搜索",
      "normalizedContent": "# 简单的数据结构\n\n* 栈\n* 队列\n\n* 链表\n\n* 数组\n\n* 哈希表\n\n* 栈和队列的相同和不同之处\n\n* 栈通常采用的两种存储结构\n\n* 两个栈实现队列，和两个队列实现栈\n\n\n\n# 树\n\n* 二叉树\n\n* 字典树\n\n* 平衡树\n\n* 排序树\n\n* b树\n\n* b+树\n\n* r树\n\n* 多路树\n\n* 红黑树\n\n\n\n# 堆\n\n* 大根堆\n\n* 小根堆\n\n\n\n# 图\n\n* 有向图\n\n* 无向图\n\n* 拓扑\n\n\n\n# 稳定的排序算法\n\n* 冒泡排序\n* 插入排序\n* 鸡尾酒排序\n* 桶排序\n* 计数排序\n* 归并排序\n* 原地归并排序\n* 二叉排序树排序\n* 鸽巢排序\n* 基数排序\n* 侏儒排序\n* 图书馆排序\n* 块排序\n\n\n\n# 不稳定的排序算法\n\n* 选择排序\n* 希尔排序\n* clover排序算法\n* 梳排序\n* 堆排序\n* 平滑排序\n* 快速排序\n* 内省排序\n* 耐心排序\n\n\n\n# 各种排序算法和时间复杂度\n\n\n# 深度优先和广度优先搜索",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "计算机网络",
      "frontmatter": {
        "title": "计算机网络",
        "date": "2022-03-11T00:51:01.000Z",
        "permalink": "/pages/e00207/",
        "categories": [
          "计算机基础",
          "HTML"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.HTML/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html",
      "relativePath": "02.计算机基础/10.计算机网络.HTML/01.计算机网络.md",
      "key": "v-222b02f4",
      "path": "/pages/e00207/",
      "headers": [
        {
          "level": 2,
          "title": "简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？",
          "slug": "简述-tcp-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手",
          "normalizedTitle": "简述 tcp 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "简述常见的 HTTP 状态码的含义（301，304，401，403）",
          "slug": "简述常见的-http-状态码的含义-301-304-401-403",
          "normalizedTitle": "简述常见的 http 状态码的含义（301，304，401，403）",
          "charIndex": 44
        },
        {
          "level": 2,
          "title": "从输入 URL 到展现页面的全过程",
          "slug": "从输入-url-到展现页面的全过程",
          "normalizedTitle": "从输入 url 到展现页面的全过程",
          "charIndex": 83
        },
        {
          "level": 2,
          "title": "HTTP 中 GET 和 POST 区别",
          "slug": "http-中-get-和-post-区别",
          "normalizedTitle": "http 中 get 和 post 区别",
          "charIndex": 105
        },
        {
          "level": 2,
          "title": "TCP 怎么保证可靠传输",
          "slug": "tcp-怎么保证可靠传输",
          "normalizedTitle": "tcp 怎么保证可靠传输",
          "charIndex": 130
        },
        {
          "level": 2,
          "title": "什么是 TCP 粘包和拆包？",
          "slug": "什么是-tcp-粘包和拆包",
          "normalizedTitle": "什么是 tcp 粘包和拆包？",
          "charIndex": 147
        },
        {
          "level": 2,
          "title": "简述 HTTPS 的加密与认证过程",
          "slug": "简述-https-的加密与认证过程",
          "normalizedTitle": "简述 https 的加密与认证过程",
          "charIndex": 166
        },
        {
          "level": 2,
          "title": "简述对称与非对称加密的概念",
          "slug": "简述对称与非对称加密的概念",
          "normalizedTitle": "简述对称与非对称加密的概念",
          "charIndex": 188
        },
        {
          "level": 2,
          "title": "TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？",
          "slug": "tcp-与-udp-在网络协议中的哪一层-他们之间有什么区别",
          "normalizedTitle": "tcp 与 udp 在网络协议中的哪一层，他们之间有什么区别？",
          "charIndex": 206
        },
        {
          "level": 2,
          "title": "如何解决 TCP 传输丢包问题？",
          "slug": "如何解决-tcp-传输丢包问题",
          "normalizedTitle": "如何解决 tcp 传输丢包问题？",
          "charIndex": 242
        },
        {
          "level": 2,
          "title": "TCP 长连接和短连接有那么不同的使用场景？",
          "slug": "tcp-长连接和短连接有那么不同的使用场景",
          "normalizedTitle": "tcp 长连接和短连接有那么不同的使用场景？",
          "charIndex": 263
        },
        {
          "level": 2,
          "title": "TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？",
          "slug": "tcp-的-keepalive-了解吗-说一说它和-http-的-keepalive-的区别",
          "normalizedTitle": "tcp 的 keepalive 了解吗？说一说它和 http 的 keepalive 的区别？",
          "charIndex": 290
        },
        {
          "level": 2,
          "title": "HTTP 与 HTTPS 有哪些区别？",
          "slug": "http-与-https-有哪些区别",
          "normalizedTitle": "http 与 https 有哪些区别？",
          "charIndex": 342
        },
        {
          "level": 2,
          "title": "TCP 中常见的拥塞控制算法有哪些？",
          "slug": "tcp-中常见的拥塞控制算法有哪些",
          "normalizedTitle": "tcp 中常见的拥塞控制算法有哪些？",
          "charIndex": 366
        },
        {
          "level": 2,
          "title": "简述 HTTP 1.0，1.1，2.0 的主要区别",
          "slug": "简述-http-1-0-1-1-2-0-的主要区别",
          "normalizedTitle": "简述 http 1.0，1.1，2.0 的主要区别",
          "charIndex": 389
        },
        {
          "level": 2,
          "title": "从系统层面上，UDP如何保证尽量可靠？",
          "slug": "从系统层面上-udp如何保证尽量可靠",
          "normalizedTitle": "从系统层面上，udp如何保证尽量可靠？",
          "charIndex": 419
        },
        {
          "level": 2,
          "title": "TCP 挥手时出现大量 CLOSEWAIT 或 TIMEWAIT 怎么解决？",
          "slug": "tcp-挥手时出现大量-close-wait-或-time-wait-怎么解决",
          "normalizedTitle": "tcp 挥手时出现大量 closewait 或 timewait 怎么解决？",
          "charIndex": null
        },
        {
          "level": 2,
          "title": "简述 TCP 滑动窗口以及重传机制",
          "slug": "简述-tcp-滑动窗口以及重传机制",
          "normalizedTitle": "简述 tcp 滑动窗口以及重传机制",
          "charIndex": 488
        },
        {
          "level": 2,
          "title": "简述 JWT 的原理和校验机制",
          "slug": "简述-jwt-的原理和校验机制",
          "normalizedTitle": "简述 jwt 的原理和校验机制",
          "charIndex": 510
        },
        {
          "level": 2,
          "title": "为什么需要序列化？有什么序列化的方式？",
          "slug": "为什么需要序列化-有什么序列化的方式",
          "normalizedTitle": "为什么需要序列化？有什么序列化的方式？",
          "charIndex": 530
        },
        {
          "level": 2,
          "title": "简述 iPv4 和 iPv6 的区别",
          "slug": "简述-ipv4-和-ipv6-的区别",
          "normalizedTitle": "简述 ipv4 和 ipv6 的区别",
          "charIndex": 554
        },
        {
          "level": 2,
          "title": "TCP 中 SYN 攻击是什么？如何防止？",
          "slug": "tcp-中-syn-攻击是什么-如何防止",
          "normalizedTitle": "tcp 中 syn 攻击是什么？如何防止？",
          "charIndex": 577
        },
        {
          "level": 2,
          "title": "简述 DDOS 攻击原理，如何防范它？",
          "slug": "简述-ddos-攻击原理-如何防范它",
          "normalizedTitle": "简述 ddos 攻击原理，如何防范它？",
          "charIndex": 603
        },
        {
          "level": 2,
          "title": "什么是 ARP 协议？简述其使用场景",
          "slug": "什么是-arp-协议-简述其使用场景",
          "normalizedTitle": "什么是 arp 协议？简述其使用场景",
          "charIndex": 627
        },
        {
          "level": 2,
          "title": "什么是跨域，什么情况下会发生跨域请求？",
          "slug": "什么是跨域-什么情况下会发生跨域请求",
          "normalizedTitle": "什么是跨域，什么情况下会发生跨域请求？",
          "charIndex": 650
        },
        {
          "level": 2,
          "title": "Cookie 和 Session 的关系和区别是什么？",
          "slug": "cookie-和-session-的关系和区别是什么",
          "normalizedTitle": "cookie 和 session 的关系和区别是什么？",
          "charIndex": 674
        },
        {
          "level": 2,
          "title": "简述 WebSocket 是如何进行传输的",
          "slug": "简述-websocket-是如何进行传输的",
          "normalizedTitle": "简述 websocket 是如何进行传输的",
          "charIndex": 706
        },
        {
          "level": 2,
          "title": "DNS 查询服务器的基本流程是什么？DNS 劫持是什么？",
          "slug": "dns-查询服务器的基本流程是什么-dns-劫持是什么",
          "normalizedTitle": "dns 查询服务器的基本流程是什么？dns 劫持是什么？",
          "charIndex": 732
        },
        {
          "level": 2,
          "title": "RestFul 是什么？RestFul 请求的 URL 有什么特点？",
          "slug": "restful-是什么-restful-请求的-url-有什么特点",
          "normalizedTitle": "restful 是什么？restful 请求的 url 有什么特点？",
          "charIndex": 765
        },
        {
          "level": 2,
          "title": "简述 HTTP 报文头部的组成结构",
          "slug": "简述-http-报文头部的组成结构",
          "normalizedTitle": "简述 http 报文头部的组成结构",
          "charIndex": 804
        },
        {
          "level": 2,
          "title": "什么是 SYN flood，如何防止这类攻击？",
          "slug": "什么是-syn-flood-如何防止这类攻击",
          "normalizedTitle": "什么是 syn flood，如何防止这类攻击？",
          "charIndex": 826
        }
      ],
      "headersStr": "简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？ 简述常见的 HTTP 状态码的含义（301，304，401，403） 从输入 URL 到展现页面的全过程 HTTP 中 GET 和 POST 区别 TCP 怎么保证可靠传输 什么是 TCP 粘包和拆包？ 简述 HTTPS 的加密与认证过程 简述对称与非对称加密的概念 TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？ 如何解决 TCP 传输丢包问题？ TCP 长连接和短连接有那么不同的使用场景？ TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？ HTTP 与 HTTPS 有哪些区别？ TCP 中常见的拥塞控制算法有哪些？ 简述 HTTP 1.0，1.1，2.0 的主要区别 从系统层面上，UDP如何保证尽量可靠？ TCP 挥手时出现大量 CLOSEWAIT 或 TIMEWAIT 怎么解决？ 简述 TCP 滑动窗口以及重传机制 简述 JWT 的原理和校验机制 为什么需要序列化？有什么序列化的方式？ 简述 iPv4 和 iPv6 的区别 TCP 中 SYN 攻击是什么？如何防止？ 简述 DDOS 攻击原理，如何防范它？ 什么是 ARP 协议？简述其使用场景 什么是跨域，什么情况下会发生跨域请求？ Cookie 和 Session 的关系和区别是什么？ 简述 WebSocket 是如何进行传输的 DNS 查询服务器的基本流程是什么？DNS 劫持是什么？ RestFul 是什么？RestFul 请求的 URL 有什么特点？ 简述 HTTP 报文头部的组成结构 什么是 SYN flood，如何防止这类攻击？",
      "content": "# 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？\n\n\n# 简述常见的 HTTP 状态码的含义（301，304，401，403）\n\n\n# 从输入 URL 到展现页面的全过程\n\n\n# HTTP 中 GET 和 POST 区别\n\n\n# TCP 怎么保证可靠传输\n\n\n# 什么是 TCP 粘包和拆包？\n\n\n# 简述 HTTPS 的加密与认证过程\n\n\n# 简述对称与非对称加密的概念\n\n\n# TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？\n\n\n# 如何解决 TCP 传输丢包问题？\n\n\n# TCP 长连接和短连接有那么不同的使用场景？\n\n\n# TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？\n\n\n# HTTP 与 HTTPS 有哪些区别？\n\n\n# TCP 中常见的拥塞控制算法有哪些？\n\n\n# 简述 HTTP 1.0，1.1，2.0 的主要区别\n\n\n# 从系统层面上，UDP如何保证尽量可靠？\n\n\n# TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？\n\n\n# 简述 TCP 滑动窗口以及重传机制\n\n\n# 简述 JWT 的原理和校验机制\n\n\n# 为什么需要序列化？有什么序列化的方式？\n\n\n# 简述 iPv4 和 iPv6 的区别\n\n\n# TCP 中 SYN 攻击是什么？如何防止？\n\n\n# 简述 DDOS 攻击原理，如何防范它？\n\n\n# 什么是 ARP 协议？简述其使用场景\n\n\n# 什么是跨域，什么情况下会发生跨域请求？\n\n\n# Cookie 和 Session 的关系和区别是什么？\n\n\n# 简述 WebSocket 是如何进行传输的\n\n\n# DNS 查询服务器的基本流程是什么？DNS 劫持是什么？\n\n\n# RestFul 是什么？RestFul 请求的 URL 有什么特点？\n\n\n# 简述 HTTP 报文头部的组成结构\n\n\n# 什么是 SYN flood，如何防止这类攻击？",
      "normalizedContent": "# 简述 tcp 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？\n\n\n# 简述常见的 http 状态码的含义（301，304，401，403）\n\n\n# 从输入 url 到展现页面的全过程\n\n\n# http 中 get 和 post 区别\n\n\n# tcp 怎么保证可靠传输\n\n\n# 什么是 tcp 粘包和拆包？\n\n\n# 简述 https 的加密与认证过程\n\n\n# 简述对称与非对称加密的概念\n\n\n# tcp 与 udp 在网络协议中的哪一层，他们之间有什么区别？\n\n\n# 如何解决 tcp 传输丢包问题？\n\n\n# tcp 长连接和短连接有那么不同的使用场景？\n\n\n# tcp 的 keepalive 了解吗？说一说它和 http 的 keepalive 的区别？\n\n\n# http 与 https 有哪些区别？\n\n\n# tcp 中常见的拥塞控制算法有哪些？\n\n\n# 简述 http 1.0，1.1，2.0 的主要区别\n\n\n# 从系统层面上，udp如何保证尽量可靠？\n\n\n# tcp 挥手时出现大量 close_wait 或 time_wait 怎么解决？\n\n\n# 简述 tcp 滑动窗口以及重传机制\n\n\n# 简述 jwt 的原理和校验机制\n\n\n# 为什么需要序列化？有什么序列化的方式？\n\n\n# 简述 ipv4 和 ipv6 的区别\n\n\n# tcp 中 syn 攻击是什么？如何防止？\n\n\n# 简述 ddos 攻击原理，如何防范它？\n\n\n# 什么是 arp 协议？简述其使用场景\n\n\n# 什么是跨域，什么情况下会发生跨域请求？\n\n\n# cookie 和 session 的关系和区别是什么？\n\n\n# 简述 websocket 是如何进行传输的\n\n\n# dns 查询服务器的基本流程是什么？dns 劫持是什么？\n\n\n# restful 是什么？restful 请求的 url 有什么特点？\n\n\n# 简述 http 报文头部的组成结构\n\n\n# 什么是 syn flood，如何防止这类攻击？",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "算法",
      "frontmatter": {
        "title": "算法",
        "date": "2022-03-11T00:38:43.000Z",
        "permalink": "/pages/92288a/",
        "categories": [
          "计算机基础",
          "CSS"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/40.%E7%AE%97%E6%B3%95.CSS/01.%E7%AE%97%E6%B3%95.html",
      "relativePath": "02.计算机基础/40.算法.CSS/01.算法.md",
      "key": "v-64aede7c",
      "path": "/pages/92288a/",
      "headers": [
        {
          "level": 2,
          "title": "数据结构与算法知识",
          "slug": "数据结构与算法知识",
          "normalizedTitle": "数据结构与算法知识",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "全排列",
          "slug": "全排列",
          "normalizedTitle": "全排列",
          "charIndex": 16
        },
        {
          "level": 2,
          "title": "贪心算法",
          "slug": "贪心算法",
          "normalizedTitle": "贪心算法",
          "charIndex": 24
        },
        {
          "level": 2,
          "title": "KMP算法",
          "slug": "kmp算法",
          "normalizedTitle": "kmp算法",
          "charIndex": 33
        },
        {
          "level": 2,
          "title": "hash算法",
          "slug": "hash算法",
          "normalizedTitle": "hash算法",
          "charIndex": 43
        },
        {
          "level": 2,
          "title": "海量数据处理",
          "slug": "海量数据处理",
          "normalizedTitle": "海量数据处理",
          "charIndex": 54
        }
      ],
      "headersStr": "数据结构与算法知识 全排列 贪心算法 KMP算法 hash算法 海量数据处理",
      "content": "# 数据结构与算法知识\n\n\n# 全排列\n\n\n# 贪心算法\n\n\n# KMP算法\n\n\n# hash算法\n\n\n# 海量数据处理\n\n* 分治\n* hash映射\n* 堆排序\n* 双层桶划分\n* Bloom Filter\n* bitmap\n* 数据库索引\n* mapreduce等。",
      "normalizedContent": "# 数据结构与算法知识\n\n\n# 全排列\n\n\n# 贪心算法\n\n\n# kmp算法\n\n\n# hash算法\n\n\n# 海量数据处理\n\n* 分治\n* hash映射\n* 堆排序\n* 双层桶划分\n* bloom filter\n* bitmap\n* 数据库索引\n* mapreduce等。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "MySQL中 InnoDB 和 MylSAM 的区别是什么？",
      "frontmatter": {
        "title": "MySQL中 InnoDB 和 MylSAM 的区别是什么？",
        "date": "2022-05-21T17:07:47.000Z",
        "permalink": "/pages/3a8659/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/001.MySQL%E4%B8%AD%20InnoDB%20%E5%92%8C%20MylSAM%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/001.MySQL中 InnoDB 和 MylSAM 的区别是什么？.md",
      "key": "v-674454ac",
      "path": "/pages/3a8659/",
      "headers": [
        {
          "level": 2,
          "title": "区别",
          "slug": "区别",
          "normalizedTitle": "区别",
          "charIndex": 37
        },
        {
          "level": 2,
          "title": "场景选择",
          "slug": "场景选择",
          "normalizedTitle": "场景选择",
          "charIndex": 253
        }
      ],
      "headersStr": "区别 场景选择",
      "content": "MySQL5.5版本开始Innodb已经成为Mysql的默认引擎\n\n\n# 区别\n\n * InnoDB 支持事务，MyISAM 不支持事务。 这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一\n * MyISAM锁的粒度是表级的，而InnoDB支持行级锁\n * MyISAM支持全文类型索引，而InnoDB不支持全文索引\n * MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM\n * MyISAM表保存成文件形式，跨平台使用更加方便\n\n\n# 场景选择\n\nMyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB",
      "normalizedContent": "mysql5.5版本开始innodb已经成为mysql的默认引擎\n\n\n# 区别\n\n * innodb 支持事务，myisam 不支持事务。 这是 mysql 将默认存储引擎从 myisam 变成 innodb 的重要原因之一\n * myisam锁的粒度是表级的，而innodb支持行级锁\n * myisam支持全文类型索引，而innodb不支持全文索引\n * myisam相对简单，效率上要优于innodb，小型应用可以考虑使用myisam\n * myisam表保存成文件形式，跨平台使用更加方便\n\n\n# 场景选择\n\nmyisam管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择myisam innodb用于事务处理，具有acid事务支持等特性，如果在应用中执行大量insert和update操作，应该选择innodb",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "聚簇索引和非聚簇索引有什么区别？",
      "frontmatter": {
        "title": "聚簇索引和非聚簇索引有什么区别？",
        "date": "2022-05-21T17:08:04.000Z",
        "permalink": "/pages/a5adb0/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/006.%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/006.聚簇索引和非聚簇索引有什么区别？.md",
      "key": "v-f0f711c4",
      "path": "/pages/a5adb0/",
      "headers": [
        {
          "level": 2,
          "title": "聚簇索引",
          "slug": "聚簇索引",
          "normalizedTitle": "聚簇索引",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "非聚簇索引",
          "slug": "非聚簇索引",
          "normalizedTitle": "非聚簇索引",
          "charIndex": 119
        }
      ],
      "headersStr": "聚簇索引 非聚簇索引",
      "content": "# 聚簇索引\n\n * 对应Innodb引擎中的主键索引\n * 索引的叶节点就是数据节点 -正式聚簇索引的顺序就是数据的物理存储顺序，所以一个表最多只能有一个聚簇索引，因为物理存储只能有一个顺序。正因为一个表最多只能有一个聚簇索引\n\n\n# 非聚簇索引\n\n * 对应MyISAM\n * 非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n\n",
      "normalizedContent": "# 聚簇索引\n\n * 对应innodb引擎中的主键索引\n * 索引的叶节点就是数据节点 -正式聚簇索引的顺序就是数据的物理存储顺序，所以一个表最多只能有一个聚簇索引，因为物理存储只能有一个顺序。正因为一个表最多只能有一个聚簇索引\n\n\n# 非聚簇索引\n\n * 对应myisam\n * 非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 MySQL 常见索引类型，介绍一下覆盖索引",
      "frontmatter": {
        "title": "简述 MySQL 常见索引类型，介绍一下覆盖索引",
        "date": "2022-05-21T17:08:24.000Z",
        "permalink": "/pages/17b014/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/007.%E7%AE%80%E8%BF%B0%20MySQL%20%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.html",
      "relativePath": "03.数据库/01.MYSQL相关/007.简述 MySQL 常见索引类型，介绍一下覆盖索引.md",
      "key": "v-824b776c",
      "path": "/pages/17b014/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述Mysql的事务隔离级别",
      "frontmatter": {
        "title": "简述Mysql的事务隔离级别",
        "date": "2022-05-20T11:35:30.000Z",
        "permalink": "/pages/9f2936/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/010.%E7%AE%80%E8%BF%B0Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html",
      "relativePath": "03.数据库/01.MYSQL相关/010.简述Mysql的事务隔离级别.md",
      "key": "v-7e02c4a1",
      "path": "/pages/9f2936/",
      "headers": [
        {
          "level": 2,
          "title": "READ UNCOMMITTED (未提交读)",
          "slug": "read-uncommitted-未提交读",
          "normalizedTitle": "read uncommitted (未提交读)",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "READ COMMITTED (提交读)",
          "slug": "read-committed-提交读",
          "normalizedTitle": "read committed (提交读)",
          "charIndex": 55
        },
        {
          "level": 2,
          "title": "REPEATABLE READ (可重复读)",
          "slug": "repeatable-read-可重复读",
          "normalizedTitle": "repeatable read (可重复读)",
          "charIndex": 117
        },
        {
          "level": 2,
          "title": "SERIALIZABLE (可串行化)",
          "slug": "serializable-可串行化",
          "normalizedTitle": "serializable (可串行化)",
          "charIndex": 168
        }
      ],
      "headersStr": "READ UNCOMMITTED (未提交读) READ COMMITTED (提交读) REPEATABLE READ (可重复读) SERIALIZABLE (可串行化)",
      "content": "# READ UNCOMMITTED (未提交读)\n\n存在脏读问题 存在不可重复读问题 存在幻读问题\n\n\n# READ COMMITTED (提交读)\n\n只读已经事物提交的数据，不存在脏读。 存在不可重复读问题 存在幻读问题\n\n\n# REPEATABLE READ (可重复读)\n\n是mysql默认的隔离级别 mvcc解决幻读\n\n\n# SERIALIZABLE (可串行化)\n\n读写串行化，效率太低，没人使用。",
      "normalizedContent": "# read uncommitted (未提交读)\n\n存在脏读问题 存在不可重复读问题 存在幻读问题\n\n\n# read committed (提交读)\n\n只读已经事物提交的数据，不存在脏读。 存在不可重复读问题 存在幻读问题\n\n\n# repeatable read (可重复读)\n\n是mysql默认的隔离级别 mvcc解决幻读\n\n\n# serializable (可串行化)\n\n读写串行化，效率太低，没人使用。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么",
      "frontmatter": {
        "title": "MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么",
        "date": "2022-05-21T17:05:11.000Z",
        "permalink": "/pages/bc5538/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/020.MySQL%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20B+%20%E6%A0%91%E6%9D%A5%E4%BD%9C%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%AF%B9%E6%AF%94%20B%20%E6%A0%91%E5%AE%83%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88.html",
      "relativePath": "03.数据库/01.MYSQL相关/020.MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么.md",
      "key": "v-6c681639",
      "path": "/pages/bc5538/",
      "headers": [
        {
          "level": 2,
          "title": "磁盘存取原理",
          "slug": "磁盘存取原理",
          "normalizedTitle": "磁盘存取原理",
          "charIndex": 59
        },
        {
          "level": 2,
          "title": "B-/+Tree索引的性能分析",
          "slug": "b-tree索引的性能分析",
          "normalizedTitle": "b-/+tree索引的性能分析",
          "charIndex": 246
        }
      ],
      "headersStr": "磁盘存取原理 B-/+Tree索引的性能分析",
      "content": "> 索引本身也是以文件的形式存储在磁盘上，索引查找过程中存在I/O消耗，采用B tree结构可以减少I/O。\n\n\n# 磁盘存取原理\n\n> 局部性原理与磁盘预读：当一个数据被用到时，其附近的数据也很快会被用到。 预读的长度一般为页的整数倍，主存和磁盘以页为单位交换数据。\n\n磁盘和磁头构成了存取物理结构。同心圆环是磁道，磁道被划分成一个个段，叫扇区，扇区是最小存储单元。 i/o读取数据的过程：磁盘旋转到指定扇区，磁头移动到指定磁道。 所以减少磁盘旋转或者减少磁头移动就能减少i/o。\n\n\n# B-/+Tree索引的性能分析\n\nB Tree利用局部性原理可减少i/o次数。 根据B Tree定义可知，检索一次最多需要访问h个节点，h-1次i/o，h是树高，mysql设计者巧妙的将一个节点大小设置为等于一个页大小，每次新建节点都申请一个页的空间，这样就保证一个节点物理上也存储在一个页，这样每个节点只需要一次i/o就可以完全载入。",
      "normalizedContent": "> 索引本身也是以文件的形式存储在磁盘上，索引查找过程中存在i/o消耗，采用b tree结构可以减少i/o。\n\n\n# 磁盘存取原理\n\n> 局部性原理与磁盘预读：当一个数据被用到时，其附近的数据也很快会被用到。 预读的长度一般为页的整数倍，主存和磁盘以页为单位交换数据。\n\n磁盘和磁头构成了存取物理结构。同心圆环是磁道，磁道被划分成一个个段，叫扇区，扇区是最小存储单元。 i/o读取数据的过程：磁盘旋转到指定扇区，磁头移动到指定磁道。 所以减少磁盘旋转或者减少磁头移动就能减少i/o。\n\n\n# b-/+tree索引的性能分析\n\nb tree利用局部性原理可减少i/o次数。 根据b tree定义可知，检索一次最多需要访问h个节点，h-1次i/o，h是树高，mysql设计者巧妙的将一个节点大小设置为等于一个页大小，每次新建节点都申请一个页的空间，这样就保证一个节点物理上也存储在一个页，这样每个节点只需要一次i/o就可以完全载入。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "说一下Mysql锁",
      "frontmatter": {
        "title": "说一下Mysql锁",
        "date": "2022-05-21T22:59:15.000Z",
        "permalink": "/pages/b17e88/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/015.%E8%AF%B4%E4%B8%80%E4%B8%8BMysql%E9%94%81.html",
      "relativePath": "03.数据库/01.MYSQL相关/015.说一下Mysql锁.md",
      "key": "v-5b0e09c6",
      "path": "/pages/b17e88/",
      "headers": [
        {
          "level": 2,
          "title": "锁类型",
          "slug": "锁类型",
          "normalizedTitle": "锁类型",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "Record lock、gap lock、next-key lock",
          "slug": "record-lock、gap-lock、next-key-lock",
          "normalizedTitle": "record lock、gap lock、next-key lock",
          "charIndex": 1049
        },
        {
          "level": 2,
          "title": "锁都加在哪些资源上",
          "slug": "锁都加在哪些资源上",
          "normalizedTitle": "锁都加在哪些资源上",
          "charIndex": 1599
        },
        {
          "level": 2,
          "title": "4.4 各种条件下的加锁",
          "slug": "_4-4-各种条件下的加锁",
          "normalizedTitle": "4.4 各种条件下的加锁",
          "charIndex": 1867
        }
      ],
      "headersStr": "锁类型 Record lock、gap lock、next-key lock 锁都加在哪些资源上 4.4 各种条件下的加锁",
      "content": "# 锁类型\n\n * 共享锁（S）:锁住一行，阻止其他事物获得相同数据集的排他锁\n * 排他锁（X）:锁住一行，阻止其他事物获得相同数据集的共享锁和排他锁\n\n为了实现表锁和行锁共存，InnoDB内部还使用了意向锁，这两种意向锁都是表锁。\n\n * 意向共享锁（IS）:获得数据行的S锁前要先获得表的IS锁\n * 意向排他锁（IX）:获得数据行的X锁前要先获得表的IX锁\n\n兼容矩阵\n\n项目   X    IX   S    IS\nX    冲突   冲突   冲突   冲突\nIX   冲突        冲突   \nS    冲突   冲突        \nIS   冲突             \n\n为什么要使用意向锁？ 在没有意向锁情况下，事物T1申请了行排他锁，如果事物T2要申请表排他锁，就要遍历表的所有锁看有没有行排他锁，这是耗费性能的。有了意向锁，判断是否有意向排他锁就可以了。\n\n意向共享锁可以多个并存，意向排他锁只能有一个。\n\n在兼容矩阵中，为什么IX和IX是兼容的？ 因为IX存在的条件是表中有行拍他锁，IX存在的目的是阻止其他事物申请表排他锁，但是不组织其他事物申请行排他锁。 所以，当表中存在IX锁，在申请行排他锁时，会先申请IX锁并且申请成功 但是如果申请表排他锁则申请失败。\n\n什么SQL加什么锁？ 意向锁是InnoDB自动加的，无需用户干预。 update、delete、insert，InnoDB自动加排他锁。 非显式加锁的select，InnoDB不会加锁。\n\nselect加锁： 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。\n\ninsert加锁： insert会在insert所在行加排他锁，这是一个record lock。 不过，在insert之前会先加一种锁，官方称为insertion intention gap lock，也就是意向gap锁。意向gap锁可以同时存在多个，两个事物可以给相同的gap加意向gap锁，只要插入的记录唯一键不同，两个事物的insert都会成功。 为什么需要意向gap锁？ （个人理解）如果没有意向gap锁，insert时需要对比所有未提交的insert记录，看是不是唯一键冲突。有gap锁，则只需要和获得这个gap锁的事务比较唯一键。\n\n\n# Record lock、gap lock、next-key lock\n\n三种类型的排他锁，锁定数据范围不同： Record lock:只锁一行数据，按唯一键加锁 gap lock：锁住两个索引之间的间隙，但不包含记录本身 只有两种情况才有单纯的gap锁： next-key lock：Record lock+gap lock。\n\n举个例子来看这三种排他锁.如下表，id为PK。\n\nID   NAME\n10   a\n20   b\n50   c\n\nRecord Lock：select * from tab where id = 10 for update; //对id=10单行进行加锁 Gap Lock锁范围：（- ∞，10）（10，20）（20，50）（50，+∞） Next-Key Lock锁范围：（- ∞，10）[10，20）[20，50）[50，+∞）\n\n只有两种场景会有单纯的gap lock:\n\n * update t set name ='d' where id > 60; 锁定 (60,+∞),这里只有gap锁，没有索引本身的锁。\n * update t set name ='d' where id < 1; 锁定 (- ∞,1),这里只有gap锁，没有索引本身的锁。\n\n\n# 锁都加在哪些资源上\n\n * 表\n * 索引（主键索引、唯一索引、普通索引）\n * 索引之间的gap\n\n为什么任何session都insert不进去？ 可能是，表数据少，有一个事物在执行update时全表扫描，把表锁住了。\n\n这种逻辑：先select再update，有什么问题？ select是快照读，update是当前读，可能会出现幻读导致数据不一致。 解决办法：\n\n * 乐观锁 update set version=v+1 where version=v\n * 悲观锁 select * from t for update\n\n\n# 4.4 各种条件下的加锁\n\n给定SQL：delete from t1 where id = 10; 那么，当前的事物隔离级别RC、RR。id的索引情况。有如下讨论：\n\n-      RC                                                                                                                                         RR\n主键索引   [外链图片转存中...(img-vkCidSBQ-1653142673824)]只需要将主键上，id =                                                                                       [外链图片转存中...(img-IznzsLkw-1653142673825)]只需要将主键上，id =\n       10的记录加上X锁即可                                                                                                                                10的记录加上X锁即可\n唯一索引   [外链图片转存中...(img-I8ESnpgb-1653142673825)]此组合中，id是unique索引，而主键是name列。首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name   [外链图片转存中...(img-ULIYfRJG-1653142673826)]此组合中，id是unique索引，而主键是name列。首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name\n       = ‘d’ 对应的主键索引项加X锁。                                                                                                                         = ‘d’ 对应的主键索引项加X锁。\n普通索引   [外链图片转存中...(img-LMDZXlly-1653142673826)]id列索引上，满足id =                                                                                      [外链图片转存中...(img-KS9pBMEu-1653142673827)]与左图的唯一不同在于：在主键上加了gap锁。\n       10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁\n非索引    [外链图片转存中...(img-RmaEu3Nd-1653142673827)]进行全部扫描。聚簇索引上所有的记录，都被加上了X锁                                                                          [外链图片转存中...(img-cffdiN3C-1653142673827)]全表记录加X锁，聚簇索引的每个gap都加gap锁",
      "normalizedContent": "# 锁类型\n\n * 共享锁（s）:锁住一行，阻止其他事物获得相同数据集的排他锁\n * 排他锁（x）:锁住一行，阻止其他事物获得相同数据集的共享锁和排他锁\n\n为了实现表锁和行锁共存，innodb内部还使用了意向锁，这两种意向锁都是表锁。\n\n * 意向共享锁（is）:获得数据行的s锁前要先获得表的is锁\n * 意向排他锁（ix）:获得数据行的x锁前要先获得表的ix锁\n\n兼容矩阵\n\n项目   x    ix   s    is\nx    冲突   冲突   冲突   冲突\nix   冲突        冲突   \ns    冲突   冲突        \nis   冲突             \n\n为什么要使用意向锁？ 在没有意向锁情况下，事物t1申请了行排他锁，如果事物t2要申请表排他锁，就要遍历表的所有锁看有没有行排他锁，这是耗费性能的。有了意向锁，判断是否有意向排他锁就可以了。\n\n意向共享锁可以多个并存，意向排他锁只能有一个。\n\n在兼容矩阵中，为什么ix和ix是兼容的？ 因为ix存在的条件是表中有行拍他锁，ix存在的目的是阻止其他事物申请表排他锁，但是不组织其他事物申请行排他锁。 所以，当表中存在ix锁，在申请行排他锁时，会先申请ix锁并且申请成功 但是如果申请表排他锁则申请失败。\n\n什么sql加什么锁？ 意向锁是innodb自动加的，无需用户干预。 update、delete、insert，innodb自动加排他锁。 非显式加锁的select，innodb不会加锁。\n\nselect加锁： 共享锁（s）：select * from table_name where ... lock in share mode。 排他锁（x)：select * from table_name where ... for update。\n\ninsert加锁： insert会在insert所在行加排他锁，这是一个record lock。 不过，在insert之前会先加一种锁，官方称为insertion intention gap lock，也就是意向gap锁。意向gap锁可以同时存在多个，两个事物可以给相同的gap加意向gap锁，只要插入的记录唯一键不同，两个事物的insert都会成功。 为什么需要意向gap锁？ （个人理解）如果没有意向gap锁，insert时需要对比所有未提交的insert记录，看是不是唯一键冲突。有gap锁，则只需要和获得这个gap锁的事务比较唯一键。\n\n\n# record lock、gap lock、next-key lock\n\n三种类型的排他锁，锁定数据范围不同： record lock:只锁一行数据，按唯一键加锁 gap lock：锁住两个索引之间的间隙，但不包含记录本身 只有两种情况才有单纯的gap锁： next-key lock：record lock+gap lock。\n\n举个例子来看这三种排他锁.如下表，id为pk。\n\nid   name\n10   a\n20   b\n50   c\n\nrecord lock：select * from tab where id = 10 for update; //对id=10单行进行加锁 gap lock锁范围：（- ∞，10）（10，20）（20，50）（50，+∞） next-key lock锁范围：（- ∞，10）[10，20）[20，50）[50，+∞）\n\n只有两种场景会有单纯的gap lock:\n\n * update t set name ='d' where id > 60; 锁定 (60,+∞),这里只有gap锁，没有索引本身的锁。\n * update t set name ='d' where id < 1; 锁定 (- ∞,1),这里只有gap锁，没有索引本身的锁。\n\n\n# 锁都加在哪些资源上\n\n * 表\n * 索引（主键索引、唯一索引、普通索引）\n * 索引之间的gap\n\n为什么任何session都insert不进去？ 可能是，表数据少，有一个事物在执行update时全表扫描，把表锁住了。\n\n这种逻辑：先select再update，有什么问题？ select是快照读，update是当前读，可能会出现幻读导致数据不一致。 解决办法：\n\n * 乐观锁 update set version=v+1 where version=v\n * 悲观锁 select * from t for update\n\n\n# 4.4 各种条件下的加锁\n\n给定sql：delete from t1 where id = 10; 那么，当前的事物隔离级别rc、rr。id的索引情况。有如下讨论：\n\n-      rc                                                                                                                                         rr\n主键索引   [外链图片转存中...(img-vkcidsbq-1653142673824)]只需要将主键上，id =                                                                                       [外链图片转存中...(img-iznzslkw-1653142673825)]只需要将主键上，id =\n       10的记录加上x锁即可                                                                                                                                10的记录加上x锁即可\n唯一索引   [外链图片转存中...(img-i8esnpgb-1653142673825)]此组合中，id是unique索引，而主键是name列。首先会将unique索引上的id=10索引记录加上x锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name   [外链图片转存中...(img-uliyfrjg-1653142673826)]此组合中，id是unique索引，而主键是name列。首先会将unique索引上的id=10索引记录加上x锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name\n       = ‘d’ 对应的主键索引项加x锁。                                                                                                                         = ‘d’ 对应的主键索引项加x锁。\n普通索引   [外链图片转存中...(img-lmdzxlly-1653142673826)]id列索引上，满足id =                                                                                      [外链图片转存中...(img-ks9pbmeu-1653142673827)]与左图的唯一不同在于：在主键上加了gap锁。\n       10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁\n非索引    [外链图片转存中...(img-rmaeu3nd-1653142673827)]进行全部扫描。聚簇索引上所有的记录，都被加上了x锁                                                                          [外链图片转存中...(img-cffdin3c-1653142673827)]全表记录加x锁，聚簇索引的每个gap都加gap锁",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述乐观锁以及悲观锁的区别以及使用场景",
      "frontmatter": {
        "title": "简述乐观锁以及悲观锁的区别以及使用场景",
        "date": "2022-05-21T17:05:33.000Z",
        "permalink": "/pages/57561d/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/030.%E7%AE%80%E8%BF%B0%E4%B9%90%E8%A7%82%E9%94%81%E4%BB%A5%E5%8F%8A%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",
      "relativePath": "03.数据库/01.MYSQL相关/030.简述乐观锁以及悲观锁的区别以及使用场景.md",
      "key": "v-c39c4fe2",
      "path": "/pages/57561d/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述什么是最左匹配原则",
      "frontmatter": {
        "title": "简述什么是最左匹配原则",
        "date": "2022-05-21T17:06:10.000Z",
        "permalink": "/pages/7a1f1e/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/050.%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99.html",
      "relativePath": "03.数据库/01.MYSQL相关/050.简述什么是最左匹配原则.md",
      "key": "v-4ecddbec",
      "path": "/pages/7a1f1e/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？",
      "frontmatter": {
        "title": "简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？",
        "date": "2022-05-21T17:05:55.000Z",
        "permalink": "/pages/36672c/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/040.%E7%AE%80%E8%BF%B0%E8%84%8F%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8F%91%E7%94%9F%E5%9C%BA%E6%99%AF%EF%BC%8CInnoDB%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/040.简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？.md",
      "key": "v-689e142a",
      "path": "/pages/36672c/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "MySQL 联合索引底层原理是什么？",
      "frontmatter": {
        "title": "MySQL 联合索引底层原理是什么？",
        "date": "2022-05-21T17:06:26.000Z",
        "permalink": "/pages/52773a/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/060.MySQL%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/060.MySQL 联合索引底层原理是什么？.md",
      "key": "v-505fbe2e",
      "path": "/pages/52773a/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述常见的负载均衡算法",
      "frontmatter": {
        "title": "简述常见的负载均衡算法",
        "date": "2022-05-21T17:07:07.000Z",
        "permalink": "/pages/f2dbbe/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/080.%E7%AE%80%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95.html",
      "relativePath": "03.数据库/01.MYSQL相关/080.简述常见的负载均衡算法.md",
      "key": "v-53bcbb7a",
      "path": "/pages/f2dbbe/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "产生死锁的必要条件有哪些？如何解决死锁？",
      "frontmatter": {
        "title": "产生死锁的必要条件有哪些？如何解决死锁？",
        "date": "2022-05-21T17:06:48.000Z",
        "permalink": "/pages/f4cf50/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/070.%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/070.产生死锁的必要条件有哪些？如何解决死锁？.md",
      "key": "v-0dd47f09",
      "path": "/pages/f4cf50/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 MySQL 的主从同步机制，如果同步失败会怎么样？",
      "frontmatter": {
        "title": "简述 MySQL 的主从同步机制，如果同步失败会怎么样？",
        "date": "2022-05-21T17:07:22.000Z",
        "permalink": "/pages/1ac30e/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/090.%E7%AE%80%E8%BF%B0%20MySQL%20%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%90%8C%E6%AD%A5%E5%A4%B1%E8%B4%A5%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/090.简述 MySQL 的主从同步机制，如果同步失败会怎么样？.md",
      "key": "v-c383b96e",
      "path": "/pages/1ac30e/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述数据库中什么情况下进行分库，什么情况下进行分表？",
      "frontmatter": {
        "title": "简述数据库中什么情况下进行分库，什么情况下进行分表？",
        "date": "2022-05-21T17:08:52.000Z",
        "permalink": "/pages/ac0bb8/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/110.%E7%AE%80%E8%BF%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%88%86%E8%A1%A8%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/110.简述数据库中什么情况下进行分库，什么情况下进行分表？.md",
      "key": "v-ed0c93b8",
      "path": "/pages/ac0bb8/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "如何设计数据库压测方案？",
      "frontmatter": {
        "title": "如何设计数据库压测方案？",
        "date": "2022-05-21T17:08:40.000Z",
        "permalink": "/pages/a8eb47/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/100.%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%A1%88%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/100.如何设计数据库压测方案？.md",
      "key": "v-4cef944a",
      "path": "/pages/a8eb47/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "数据库的读写分离的作用是什么？如何实现？",
      "frontmatter": {
        "title": "数据库的读写分离的作用是什么？如何实现？",
        "date": "2022-05-21T17:09:05.000Z",
        "permalink": "/pages/f62359/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/120.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/120.数据库的读写分离的作用是什么？如何实现？.md",
      "key": "v-d6bc240a",
      "path": "/pages/f62359/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 undo log 和 redo log 的作用",
      "frontmatter": {
        "title": "简述 undo log 和 redo log 的作用",
        "date": "2022-05-21T17:09:29.000Z",
        "permalink": "/pages/7bbbf6/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          "binlog",
          "redo log"
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/130.%E7%AE%80%E8%BF%B0%20undo%20log%20%E5%92%8C%20redo%20log%20%E7%9A%84%E4%BD%9C%E7%94%A8.html",
      "relativePath": "03.数据库/01.MYSQL相关/130.简述 undo log 和 redo log 的作用.md",
      "key": "v-f3acaa1a",
      "path": "/pages/7bbbf6/",
      "headers": [
        {
          "level": 2,
          "title": "redo log 的写入机制",
          "slug": "redo-log-的写入机制",
          "normalizedTitle": "redo log 的写入机制",
          "charIndex": 456
        },
        {
          "level": 2,
          "title": "binlog 的写入机制",
          "slug": "binlog-的写入机制",
          "normalizedTitle": "binlog 的写入机制",
          "charIndex": 711
        },
        {
          "level": 2,
          "title": "组提交机制（group commit）",
          "slug": "组提交机制-group-commit",
          "normalizedTitle": "组提交机制（group commit）",
          "charIndex": 971
        }
      ],
      "headersStr": "redo log 的写入机制 binlog 的写入机制 组提交机制（group commit）",
      "content": "# binlog和redo log是什么，有什么用\n\n这两个日志都可以用于数据库的备份和恢复，以及主从复制。区别在于\n\nBINLOG            REDO LOG               备注\n在sql 层产生          在innoDB存储引擎层产生         \n记录数据行修改           记录数据页修改                \n先提交事务，再产生binlog   先产生redo log再提交事务       \n用于主从复制            在在mysql崩溃时，恢复未提交事务数据   \n                                         \n\n\n# binlog和redo log写入机制\n\n先说共性，这两个log的写入都要走这个过程： 先写入mysql server的buffer，再写入os buffer，再写入磁盘。 两个buffer之间的写入是内存操作，很快的，耗费io的操作是调用fsync写入磁盘的操作。\n\n\n# redo log 的写入机制\n\ninnodb_flush_log_at_trx_commit的值有三种0、1、2。控制log写入磁盘的频率。 innodb_flush_log_at_trx_commit的值 | 写入策略\n\n-------- | ----- 1 |事务commit后马上将log buffer写入os buffer并且调用fsync写入磁盘 0 | 每秒写入os buffer并立刻调用fsync写入磁盘 2 | commit后立即写入os buffer，然后每秒调用fsync写磁盘\n\n\n# binlog 的写入机制\n\n每个线程一个binlog缓存，因为binlog写入要求事务的完整性，即一个事务完成才能把事务binlog完整的写入。\n\nSYNC_BINLOG的值   写入策略\n1               事务commit后马上将log buffer写入os buffer并且调用fsync写入磁盘\n0               每秒写入os buffer并立刻调用fsync写入磁盘\nN(N>1)          commit后立即写入os buffer，积累N个事务调用fsync写磁盘\n\n\n# 组提交机制（group commit）\n\n> 双1配置是说将sync_binlog和innodb_flush_log_at_trx_commit都设置为1.那是不是说每次commit都要两次刷盘？但是是否定的。用组提交机制来实现。\n\n如果你想提升 binlog 组提交的效果，可以通过设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count实现：\n\nBINLOG_GROUP_COMMIT_SYNC_DELAY   BINLOG_GROUP_COMMIT_SYNC_NO_DELAY_COUNT\n调用多少微妙后再调用fsync                  积累多少次后调用fsync\n\n\n# 应对IO性能瓶颈\n\n如果IO出现性能瓶颈，可以考虑以下三个解决办法\n\n * 调大binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count，后果是可能增加sql执行时间，但是数据不会丢失。\n * sync_binlog设置大于1的数，风险是，断电后悔丢掉binlog日志\n * innodb_flush_log_at_trx_commit设置为2，风险是，断电后会丢失数据。",
      "normalizedContent": "# binlog和redo log是什么，有什么用\n\n这两个日志都可以用于数据库的备份和恢复，以及主从复制。区别在于\n\nbinlog            redo log               备注\n在sql 层产生          在innodb存储引擎层产生         \n记录数据行修改           记录数据页修改                \n先提交事务，再产生binlog   先产生redo log再提交事务       \n用于主从复制            在在mysql崩溃时，恢复未提交事务数据   \n                                         \n\n\n# binlog和redo log写入机制\n\n先说共性，这两个log的写入都要走这个过程： 先写入mysql server的buffer，再写入os buffer，再写入磁盘。 两个buffer之间的写入是内存操作，很快的，耗费io的操作是调用fsync写入磁盘的操作。\n\n\n# redo log 的写入机制\n\ninnodb_flush_log_at_trx_commit的值有三种0、1、2。控制log写入磁盘的频率。 innodb_flush_log_at_trx_commit的值 | 写入策略\n\n-------- | ----- 1 |事务commit后马上将log buffer写入os buffer并且调用fsync写入磁盘 0 | 每秒写入os buffer并立刻调用fsync写入磁盘 2 | commit后立即写入os buffer，然后每秒调用fsync写磁盘\n\n\n# binlog 的写入机制\n\n每个线程一个binlog缓存，因为binlog写入要求事务的完整性，即一个事务完成才能把事务binlog完整的写入。\n\nsync_binlog的值   写入策略\n1               事务commit后马上将log buffer写入os buffer并且调用fsync写入磁盘\n0               每秒写入os buffer并立刻调用fsync写入磁盘\nn(n>1)          commit后立即写入os buffer，积累n个事务调用fsync写磁盘\n\n\n# 组提交机制（group commit）\n\n> 双1配置是说将sync_binlog和innodb_flush_log_at_trx_commit都设置为1.那是不是说每次commit都要两次刷盘？但是是否定的。用组提交机制来实现。\n\n如果你想提升 binlog 组提交的效果，可以通过设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count实现：\n\nbinlog_group_commit_sync_delay   binlog_group_commit_sync_no_delay_count\n调用多少微妙后再调用fsync                  积累多少次后调用fsync\n\n\n# 应对io性能瓶颈\n\n如果io出现性能瓶颈，可以考虑以下三个解决办法\n\n * 调大binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count，后果是可能增加sql执行时间，但是数据不会丢失。\n * sync_binlog设置大于1的数，风险是，断电后悔丢掉binlog日志\n * innodb_flush_log_at_trx_commit设置为2，风险是，断电后会丢失数据。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "什么是 SQL 注入攻击？如何防止这类攻击？",
      "frontmatter": {
        "title": "什么是 SQL 注入攻击？如何防止这类攻击？",
        "date": "2022-05-21T17:09:41.000Z",
        "permalink": "/pages/b4338e/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/140.%E4%BB%80%E4%B9%88%E6%98%AF%20SQL%20%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%BF%99%E7%B1%BB%E6%94%BB%E5%87%BB%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/140.什么是 SQL 注入攻击？如何防止这类攻击？.md",
      "key": "v-ceed6ba6",
      "path": "/pages/b4338e/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "MySQL 中 join 与 left join 的区别是什么？",
      "frontmatter": {
        "title": "MySQL 中 join 与 left join 的区别是什么？",
        "date": "2022-05-21T17:09:52.000Z",
        "permalink": "/pages/429100/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/150.MySQL%20%E4%B8%AD%20join%20%E4%B8%8E%20left%20join%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/150.MySQL 中 join 与 left join 的区别是什么？.md",
      "key": "v-77790024",
      "path": "/pages/429100/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 MySQL MVCC 的实现原理",
      "frontmatter": {
        "title": "简述 MySQL MVCC 的实现原理",
        "date": "2022-05-21T17:10:09.000Z",
        "permalink": "/pages/1656d8/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/160.%E7%AE%80%E8%BF%B0%20MySQL%20MVCC%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%20.html",
      "relativePath": "03.数据库/01.MYSQL相关/160.简述 MySQL MVCC 的实现原理 .md",
      "key": "v-76f5e79a",
      "path": "/pages/1656d8/",
      "headers": [
        {
          "level": 2,
          "title": "什么是MVCC？",
          "slug": "什么是mvcc",
          "normalizedTitle": "什么是mvcc？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "Innodb MVCC实现的核心知识点",
          "slug": "innodb-mvcc实现的核心知识点",
          "normalizedTitle": "innodb mvcc实现的核心知识点",
          "charIndex": 398
        },
        {
          "level": 3,
          "title": "事务版本号",
          "slug": "事务版本号",
          "normalizedTitle": "事务版本号",
          "charIndex": 422
        },
        {
          "level": 3,
          "title": "表的隐藏列。",
          "slug": "表的隐藏列。",
          "normalizedTitle": "表的隐藏列。",
          "charIndex": 479
        },
        {
          "level": 3,
          "title": "undo log",
          "slug": "undo-log",
          "normalizedTitle": "undo log",
          "charIndex": 644
        },
        {
          "level": 3,
          "title": "read view",
          "slug": "read-view",
          "normalizedTitle": "read view",
          "charIndex": 993
        },
        {
          "level": 3,
          "title": "Read view 的几个重要属性",
          "slug": "read-view-的几个重要属性",
          "normalizedTitle": "read view 的几个重要属性",
          "charIndex": 1120
        },
        {
          "level": 3,
          "title": "Read view 匹配条件",
          "slug": "read-view-匹配条件",
          "normalizedTitle": "read view 匹配条件",
          "charIndex": 1303
        },
        {
          "level": 3,
          "title": "版本链",
          "slug": "版本链",
          "normalizedTitle": "版本链",
          "charIndex": 215
        },
        {
          "level": 2,
          "title": "MVCC原理",
          "slug": "mvcc原理",
          "normalizedTitle": "mvcc原理",
          "charIndex": 2244
        },
        {
          "level": 2,
          "title": "举例说明",
          "slug": "举例说明",
          "normalizedTitle": "举例说明",
          "charIndex": 2725
        },
        {
          "level": 2,
          "title": "MVCC不存在幻读问题（RR级别的情况下）",
          "slug": "mvcc不存在幻读问题-rr级别的情况下",
          "normalizedTitle": "mvcc不存在幻读问题（rr级别的情况下）",
          "charIndex": 3024
        }
      ],
      "headersStr": "什么是MVCC？ Innodb MVCC实现的核心知识点 事务版本号 表的隐藏列。 undo log read view Read view 的几个重要属性 Read view 匹配条件 版本链 MVCC原理 举例说明 MVCC不存在幻读问题（RR级别的情况下）",
      "content": "# 什么是MVCC？\n\nMVCC是在并发访问数据库时，通过对数据做多版本管理，避免因为写锁的阻塞而造成读数据的并发阻塞问题。\n\n通俗的讲就是MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。\n\n在MySQL中，MVCC只在读取已提交（Read Committed）和可重复读（Repeatable Read）两个事务级别下有效。其是通过Undo日志中的版本链和ReadView一致性视图来实现的。\n\nMVCC就是在多个事务同时存在时，SELECT语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。\n\n * mvcc特性：读不加锁，读写不冲突。\n * MVCC只在READ COMMITTED (提交读)、REPEATABLE READ (可重复读)下工作。不兼容其他隔离级别。\n\n\n# Innodb MVCC实现的核心知识点\n\n\n# 事务版本号\n\n每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。\n\n\n# 表的隐藏列。\n\n在数据表后加三个隐藏列，事物版本（DB_TRX_ID），回滚指针（DB_ROLL_PTR）、隐藏ID（DB_ROW_ID）。每开启一个事物版本号自增1；\n\n * DB_TRX_ID: 事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID；\n * DB_ROLL_PTR：指向上一个版本数据在undo log 里的位置指针，回滚指针，通过它可以将不同的版本串联起来，形成版本链。\n * DB_ROW_ID: 隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;\n\n\n# undo log\n\nUndo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。\n\nUndo log 的用途\n\n * 保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。\n\n * 用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。\n\n\n# read view\n\n在innodb 中每个事务开启后都会得到一个read_view。\n\n副本主要保存了当前数据库系统中正处于活跃（没有commit）的事务的ID号，其实简单的说这个副本中保存的是系统中当前不应该被本事务看到的其他事务id列表。\n\n\n# Read view 的几个重要属性\n\ntrx_ids: 当前系统活跃(未提交)事务版本号集合。\n\nlow_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。\n\nup_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”\n\ncreator_trx_id: 创建当前read view的事务版本号；\n\n\n# Read view 匹配条件\n\n 1. 数据事务ID <up_limit_id 则显示 如果数据事务ID小于read view中的最小活跃事务ID，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。\n 2. 数据事务ID>=low_limit_id 则不显示 如果数据事务ID大于read view 中的当前系统的最大事务ID，则说明该数据是在当前read view 创建之后才产生的，所以数据不予显示。\n 3. p_limit_id <=数据事务ID<low_limit_id 则与活跃事务集合trx_ids里匹配 如果数据的事务ID大于最小的活跃事务ID,同时又小于等于系统最大的事务ID，这种情况就说明这个数据有可能是在当前事务开始的时候还没有提交的。 所以这时候我们需要把数据的事务ID与当前read view 中的活跃事务集合trx_ids 匹配:\n    1. 如果事务ID不存在于trx_ids 集合（则说明read view产生的时候事务已经commit了），这种情况数据则可以显示。\n    2. 如果事务ID存在trx_ids则说明read view产生的时候数据还没有提交，但是如果数据的事务ID等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。\n    3. 如果事务ID既存在trx_ids而且又不等于creator_trx_id那就说明read view产生的时候数据还没有提交，又不是自己生成的，所以这种情况下此数据不能显示。\n 4. 不满足read view条件时候，从undo log里面获取数据\n\n当数据的事务ID不满足read view条件时候，从undo log里面获取数据的历史版本，然后数据历史版本事务号回头再来和read view 条件匹配 ，直到找到一条满足条件的历史数据，或者找不到则返回空结果；\n\n\n# 版本链\n\n所有版本的数据都只会存一份，然后通过回滚指针连接起来，之后就是通过一定的规则找到具体是哪个版本上的数据就行了。\n\n假设现在有一张account表，其中有id和name两个字段，那么版本链的示意图如下：\n\n\n# MVCC原理\n\n\n\n * 如果落在绿色区间（DB_TRX_ID < min_id）：这个版本比min_id还小（事务ID是从小往大顺序生成的），说明这个版本在SELECT之前就已经提交了，所以这个数据是可见的。或者（这里是短路或，前面条件不满足才会判断后面这个条件）这个版本的事务本身就是当前SELECT语句所在事务的话，也是一样可见的；\n\n * 如果落在红色区间（DB_TRX_ID > max_id）：表示这个版本是由将来启动的事务来生成的，当前还未开始，那么是不可见的；\n\n * 果落在黄色区间（min_id <= DB_TRX_ID <= max_id）：这个时候就需要再判断两种情况： 如果这个版本的事务ID在ReadView的未提交事务数组中，表示这个版本是由还未提交的事务生成的，那么就是不可见的；\n\n * 如果这个版本的事务ID不在ReadView的未提交事务数组中，表示这个版本是已经提交了的事务生成的，那么是可见的。\n\n * 如果在上述的判断中发现当前版本是不可见的，那么就继续从版本链中通过回滚指针拿取下一个版本来进行上述的判断。\n\n\n# 举例说明\n\n假设当前事物版本为current_version\n\n** select: ** 查询会自动加where条件 and current_version>=def_create_version and (DB_TRX_ID = 'undefined' or DB_TRX_ID>current_version ) delete: DB_ROW_ID = current_version update: 先执行delete再执行insert insert: 插入数据并且默认DB_TRX_ID = current_version and DB_ROW_ID = 'undefined'\n\n\n# MVCC不存在幻读问题（RR级别的情况下）\n\n首先确认一点MVCC属于快照读的，在进行快照读的情况下是不会对数据进行加锁，而是基于事务版本号和undo历史版本读取数据，其实上面的文章已经说得很清楚了，我们根据上面的MVCC流程来推导，无论如何在MVCC的情况下都是不会出现幻读的问题的，如下图。\n\n1、开启事务1，获得事务ID为1。\n\n2、事务1执行查询，得到readview。\n\n3、开始事务2。\n\n4、执行insert。\n\n5、提交事务2。\n\n6、执行事务1的第二次查询 (因为这里是RR级别，所以不会再去获得readview,还是使用第一次获得的readview)\n\n7、最后得到的结果是，插入的数据不会显示，因为插入的数据事务ID大于等于 readview里的最大活跃事务ID。",
      "normalizedContent": "# 什么是mvcc？\n\nmvcc是在并发访问数据库时，通过对数据做多版本管理，避免因为写锁的阻塞而造成读数据的并发阻塞问题。\n\n通俗的讲就是mvcc通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果。\n\n在mysql中，mvcc只在读取已提交（read committed）和可重复读（repeatable read）两个事务级别下有效。其是通过undo日志中的版本链和readview一致性视图来实现的。\n\nmvcc就是在多个事务同时存在时，select语句找寻到具体是版本链上的哪个版本，然后在找到的版本上返回其中所记录的数据的过程。\n\n * mvcc特性：读不加锁，读写不冲突。\n * mvcc只在read committed (提交读)、repeatable read (可重复读)下工作。不兼容其他隔离级别。\n\n\n# innodb mvcc实现的核心知识点\n\n\n# 事务版本号\n\n每次事务开启前都会从数据库获得一个自增长的事务id，可以从事务id判断事务的执行先后顺序。\n\n\n# 表的隐藏列。\n\n在数据表后加三个隐藏列，事物版本（db_trx_id），回滚指针（db_roll_ptr）、隐藏id（db_row_id）。每开启一个事物版本号自增1；\n\n * db_trx_id: 事务id，记录的是当前事务在做insert或update语句操作时的事务id；\n * db_roll_ptr：指向上一个版本数据在undo log 里的位置指针，回滚指针，通过它可以将不同的版本串联起来，形成版本链。\n * db_row_id: 隐藏id ，当创建表没有合适的索引作为聚集索引时，会用该隐藏id创建聚集索引;\n\n\n# undo log\n\nundo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。\n\nundo log 的用途\n\n * 保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。\n\n * 用于mvcc快照读的数据，在mvcc多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。\n\n\n# read view\n\n在innodb 中每个事务开启后都会得到一个read_view。\n\n副本主要保存了当前数据库系统中正处于活跃（没有commit）的事务的id号，其实简单的说这个副本中保存的是系统中当前不应该被本事务看到的其他事务id列表。\n\n\n# read view 的几个重要属性\n\ntrx_ids: 当前系统活跃(未提交)事务版本号集合。\n\nlow_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。\n\nup_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”\n\ncreator_trx_id: 创建当前read view的事务版本号；\n\n\n# read view 匹配条件\n\n 1. 数据事务id <up_limit_id 则显示 如果数据事务id小于read view中的最小活跃事务id，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。\n 2. 数据事务id>=low_limit_id 则不显示 如果数据事务id大于read view 中的当前系统的最大事务id，则说明该数据是在当前read view 创建之后才产生的，所以数据不予显示。\n 3. p_limit_id <=数据事务id<low_limit_id 则与活跃事务集合trx_ids里匹配 如果数据的事务id大于最小的活跃事务id,同时又小于等于系统最大的事务id，这种情况就说明这个数据有可能是在当前事务开始的时候还没有提交的。 所以这时候我们需要把数据的事务id与当前read view 中的活跃事务集合trx_ids 匹配:\n    1. 如果事务id不存在于trx_ids 集合（则说明read view产生的时候事务已经commit了），这种情况数据则可以显示。\n    2. 如果事务id存在trx_ids则说明read view产生的时候数据还没有提交，但是如果数据的事务id等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。\n    3. 如果事务id既存在trx_ids而且又不等于creator_trx_id那就说明read view产生的时候数据还没有提交，又不是自己生成的，所以这种情况下此数据不能显示。\n 4. 不满足read view条件时候，从undo log里面获取数据\n\n当数据的事务id不满足read view条件时候，从undo log里面获取数据的历史版本，然后数据历史版本事务号回头再来和read view 条件匹配 ，直到找到一条满足条件的历史数据，或者找不到则返回空结果；\n\n\n# 版本链\n\n所有版本的数据都只会存一份，然后通过回滚指针连接起来，之后就是通过一定的规则找到具体是哪个版本上的数据就行了。\n\n假设现在有一张account表，其中有id和name两个字段，那么版本链的示意图如下：\n\n\n# mvcc原理\n\n\n\n * 如果落在绿色区间（db_trx_id < min_id）：这个版本比min_id还小（事务id是从小往大顺序生成的），说明这个版本在select之前就已经提交了，所以这个数据是可见的。或者（这里是短路或，前面条件不满足才会判断后面这个条件）这个版本的事务本身就是当前select语句所在事务的话，也是一样可见的；\n\n * 如果落在红色区间（db_trx_id > max_id）：表示这个版本是由将来启动的事务来生成的，当前还未开始，那么是不可见的；\n\n * 果落在黄色区间（min_id <= db_trx_id <= max_id）：这个时候就需要再判断两种情况： 如果这个版本的事务id在readview的未提交事务数组中，表示这个版本是由还未提交的事务生成的，那么就是不可见的；\n\n * 如果这个版本的事务id不在readview的未提交事务数组中，表示这个版本是已经提交了的事务生成的，那么是可见的。\n\n * 如果在上述的判断中发现当前版本是不可见的，那么就继续从版本链中通过回滚指针拿取下一个版本来进行上述的判断。\n\n\n# 举例说明\n\n假设当前事物版本为current_version\n\n** select: ** 查询会自动加where条件 and current_version>=def_create_version and (db_trx_id = 'undefined' or db_trx_id>current_version ) delete: db_row_id = current_version update: 先执行delete再执行insert insert: 插入数据并且默认db_trx_id = current_version and db_row_id = 'undefined'\n\n\n# mvcc不存在幻读问题（rr级别的情况下）\n\n首先确认一点mvcc属于快照读的，在进行快照读的情况下是不会对数据进行加锁，而是基于事务版本号和undo历史版本读取数据，其实上面的文章已经说得很清楚了，我们根据上面的mvcc流程来推导，无论如何在mvcc的情况下都是不会出现幻读的问题的，如下图。\n\n1、开启事务1，获得事务id为1。\n\n2、事务1执行查询，得到readview。\n\n3、开始事务2。\n\n4、执行insert。\n\n5、提交事务2。\n\n6、执行事务1的第二次查询 (因为这里是rr级别，所以不会再去获得readview,还是使用第一次获得的readview)\n\n7、最后得到的结果是，插入的数据不会显示，因为插入的数据事务id大于等于 readview里的最大活跃事务id。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "MySQL 中 varchar 和 char 的区别是什么？",
      "frontmatter": {
        "title": "MySQL 中 varchar 和 char 的区别是什么？",
        "date": "2022-05-21T17:10:21.000Z",
        "permalink": "/pages/d97948/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/170.MySQL%20%E4%B8%AD%20varchar%20%E5%92%8C%20char%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/170.MySQL 中 varchar 和 char 的区别是什么？.md",
      "key": "v-0a7e6416",
      "path": "/pages/d97948/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "模糊查询是如何实现的？",
      "frontmatter": {
        "title": "模糊查询是如何实现的？",
        "date": "2022-05-21T17:10:36.000Z",
        "permalink": "/pages/32696d/",
        "categories": [
          "数据库",
          "MYSQL相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MYSQL%E7%9B%B8%E5%85%B3/180.%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",
      "relativePath": "03.数据库/01.MYSQL相关/180.模糊查询是如何实现的？.md",
      "key": "v-6b967a6e",
      "path": "/pages/32696d/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Redis 有几种数据结构？Zset 是如何实现的？",
      "frontmatter": {
        "title": "Redis 有几种数据结构？Zset 是如何实现的？",
        "date": "2022-05-21T17:21:14.000Z",
        "permalink": "/pages/d70c1f/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/001.Redis%20%E6%9C%89%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9FZset%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.html",
      "relativePath": "03.数据库/02.REDIS相关/001.Redis 有几种数据结构？Zset 是如何实现的？.md",
      "key": "v-d804fba0",
      "path": "/pages/d70c1f/",
      "headers": [
        {
          "level": 2,
          "title": "字符串",
          "slug": "字符串",
          "normalizedTitle": "字符串",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "链表",
          "slug": "链表",
          "normalizedTitle": "链表",
          "charIndex": 396
        },
        {
          "level": 2,
          "title": "hash",
          "slug": "hash",
          "normalizedTitle": "hash",
          "charIndex": 26
        },
        {
          "level": 2,
          "title": "跳跃表",
          "slug": "跳跃表",
          "normalizedTitle": "跳跃表",
          "charIndex": 2338
        },
        {
          "level": 2,
          "title": "整数集合",
          "slug": "整数集合",
          "normalizedTitle": "整数集合",
          "charIndex": 3010
        },
        {
          "level": 2,
          "title": "压缩列表",
          "slug": "压缩列表",
          "normalizedTitle": "压缩列表",
          "charIndex": 3402
        },
        {
          "level": 2,
          "title": "RedisObject",
          "slug": "redisobject",
          "normalizedTitle": "redisobject",
          "charIndex": 4119
        }
      ],
      "headersStr": "字符串 链表 hash 跳跃表 整数集合 压缩列表 RedisObject",
      "content": "> 字符串（String）、列表（list）、字典（hash）、集合（set）、有序集合（sortSet）.\n\n\n# 字符串\n\n 1. 源码\n\n/*\n- 保存字符串对象的结构\n*/\nstruct sdshdr {\n\n   // buf 中已占用空间的长度\n   int len;\n\n   // buf 中剩余可用空间的长度\n   int free;\n\n   // 数据空间\n   char buf[];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 2. sds与c字符串的区别\n\n * sds获取字符串长度的复杂度为O(1),c的是O(n)\n * c的api是不安全的，可能造成缓冲区溢出，sds的是安全的。\n * 修改N次字符串，c需要N次内存分配。sds最多需要N次分配。sds有空间预分配和惰性回收。\n * sds可以使用部分c的字符串库。\n\n\n# 链表\n\n 1. 源码\n\n/*\n* 双端链表节点\n*/\ntypedef struct listNode {\n\n  // 前置节点\n  struct listNode *prev;\n\n  // 后置节点\n  struct listNode *next;\n\n  // 节点的值\n  void *value;\n\n} listNode;\n\n/*\n* 双端链表结构\n*/\ntypedef struct list {\n\n  // 表头节点\n  listNode *head;\n\n  // 表尾节点\n  listNode *tail;\n\n  // 节点值复制函数\n  void *(*dup)(void *ptr);\n\n  // 节点值释放函数\n  void (*free)(void *ptr);\n\n  // 节点值对比函数\n  int (*match)(void *ptr, void *key);\n\n  // 链表所包含的节点数量\n  unsigned long len;\n\n} list;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n[外链图片转存中...(img-ua4uHhOc-1653145947289)]\n\n\n# hash\n\n 1. 源码\n\n/*\n* 哈希表节点\n*/\ntypedef struct dictEntry {\n  \n  // 键\n  void *key;\n\n  // 值\n  union {\n      void *val;\n      uint64_t u64;\n      int64_t s64;\n  } v;\n\n  // 指向下个哈希表节点，形成链表\n  struct dictEntry *next;\n\n} dictEntry;\n\n/*\n* 哈希表\n*\n* 每个字典都使用两个哈希表，从而实现渐进式 rehash 。\n*/\ntypedef struct dictht {\n  \n  // 哈希表数组\n  dictEntry **table;\n\n  // 哈希表大小\n  unsigned long size;\n  \n  // 哈希表大小掩码，用于计算索引值\n  // 总是等于 size - 1\n  unsigned long sizemask;\n\n  // 该哈希表已有节点的数量\n  unsigned long used;\n\n} dictht;\n\n/*\n* 字典\n*/\ntypedef struct dict {\n\n  // 类型特定函数\n  dictType *type;\n\n  // 私有数据\n  void *privdata;\n\n  // 哈希表\n  dictht ht[2];\n\n  // rehash 索引\n  // 当 rehash 不在进行时，值为 -1\n  int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n\n  // 目前正在运行的安全迭代器的数量\n  int iterators; /* number of iterators currently running */\n\n} dict;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n[外链图片转存中...(img-3IEt2xy5-1653145947290)] 2. reHash\n\n> 扩容场景： 有BGSAVE或者BGREWRITEAOF时，负载因子超过5. 无BGSAVE或者BGREWRITEAOF时，负载因子超过1. 扩容为第一个大于等于ht[0].used*2的2的幂\n\n> 缩容场景： 负载因子小于0.1 缩容为第一个大于等于ht[0].used的2的幂\n\n> 负载因子：ht[0].used/ht[0].size\n\n> 渐进式rehash: rehashidx指向正在hash的索引。rehashidx=-1表示未进行rehash 每次访问dict结构时rehash一个索引\n\n[外链图片转存中...(img-A0e54HI9-1653145947290)]\n\n\n# 跳跃表\n\n 1. 源码\n\n/*\n* 跳跃表节点\n*/\ntypedef struct zskiplistNode {\n\n   // 成员对象\n   robj *obj;\n\n   // 分值\n   double score;\n\n   // 后退指针\n   struct zskiplistNode *backward;\n\n   // 层\n   struct zskiplistLevel {\n\n       // 前进指针\n       struct zskiplistNode *forward;\n\n       // 跨度\n       unsigned int span;\n\n   } level[];\n\n} zskiplistNode;\n\n/*\n* 跳跃表\n*/\ntypedef struct zskiplist {\n\n   // 表头节点和表尾节点\n   struct zskiplistNode *header, *tail;\n\n   // 表中节点的数量\n   unsigned long length;\n\n   // 表中层数最大的节点的层数\n   int level;\n\n} zskiplist;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n[外链图片转存中...(img-MbZS62dp-1653145947291)]\n\n\n# 整数集合\n\n 1. 源码\n\ntypedef struct intset {\n   \n   // 编码方式\n   uint32_t encoding;\n\n   // 集合包含的元素数量\n   uint32_t length;\n\n   // 保存元素的数组\n   int8_t contents[];\n\n} intset;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n[外链图片转存中...(img-hdTbZZhS-1653145947291)] 2. 编码升级 添加一个元素可能导致编码升级。编码升级需要做三件事\n\n * 扩展空间\n * 转变现有元素的类型并发至在合适的位置上。保证原有顺序防止\n * 防止新加入的元素。新加入的元素一定是最大或最小的，所以放在最前或者最后\n\n[外链图片转存中...(img-0R00I0BO-1653145947291)]\n\n\n# 压缩列表\n\n> 压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。 一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值\n\n 1. 源码\n\n/*\n* 保存 ziplist 节点信息的结构\n*/\ntypedef struct zlentry {\n\n   // prevrawlen ：前置节点的长度\n   // prevrawlensize ：编码 prevrawlen 所需的字节大小\n   unsigned int prevrawlensize, prevrawlen;\n\n   // len ：当前节点值的长度\n   // lensize ：编码 len 所需的字节大小\n   unsigned int lensize, len;\n\n   // 当前节点 header 的大小\n   // 等于 prevrawlensize + lensize\n   unsigned int headersize;\n\n   // 当前节点值所使用的编码类型\n   unsigned char encoding;\n\n   // 指向当前节点的指针\n   unsigned char *p;\n\n} zlentry;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 2. 示意图 [外链图片转存中...(img-NMDF8Bnt-1653145947292)] [外链图片转存中...(img-5KdqaS0e-1653145947292)]\n\n\n# RedisObject\n\n> Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。\n\n 1. 源码\n\ntypedef struct redisObject {\n\n   // 类型\n   unsigned type:4;\n\n   // 编码\n   unsigned encoding:4;\n\n   // 对象最后一次被访问的时间\n   unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n\n   // 引用计数\n   int refcount;\n\n   // 指向实际值的指针\n   void *ptr;\n\n} robj;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n[外链图片转存中...(img-uT4NW4Ki-1653145947292)] 2. 类型和编码的对应关系 [外链图片转存中...(img-jkooRnC4-1653145947293)] 3. 字符串对象\n\n值                           编码\n可以用long保存的整形                int\n可以用long，double保存的浮点         embstr或row\n长度太长，不可以用long，double保存的浮点   embstr或row\n小于39字节的字符串                  embstr\n大于39字节的字符串                  row\n\n> row要两次申请内存，两次释放内存。为这俩对象RedisObject、SdsStr。embstr申请一次释放一次，而且申请的是连续的内存空间，能更好的利用缓存。\n\n 4. 链表对象\n\n> inkedList和zipList的转换临界值:每个元素长度都小于64、元素个数小于512。满足以上两个条件才能用zipList\n\n 5. hash对象\n\n> hashtable和zipList的转换临界值:每个元素长度都小于64、元素个数小于512。满足以上两个条件才能用zipList\n\n 6. 集合对象\n\n> hashtable和intset的转换临界值:每个元素都是int、元素个数小于512。满足以上两个条件才能用intset\n\n 7. 内存回收\n\n> redis是用C实现的，C没有自动回收内存的机制。RedisObject中的refCount记录对象的引用个数，当refCount=0的时候自动释放内存。\n\n 8. 对象共享\n\n> 0- 9999这1w个整数是共享对象。字符串不做共享对象，因为对比匹配太复杂",
      "normalizedContent": "> 字符串（string）、列表（list）、字典（hash）、集合（set）、有序集合（sortset）.\n\n\n# 字符串\n\n 1. 源码\n\n/*\n- 保存字符串对象的结构\n*/\nstruct sdshdr {\n\n   // buf 中已占用空间的长度\n   int len;\n\n   // buf 中剩余可用空间的长度\n   int free;\n\n   // 数据空间\n   char buf[];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 2. sds与c字符串的区别\n\n * sds获取字符串长度的复杂度为o(1),c的是o(n)\n * c的api是不安全的，可能造成缓冲区溢出，sds的是安全的。\n * 修改n次字符串，c需要n次内存分配。sds最多需要n次分配。sds有空间预分配和惰性回收。\n * sds可以使用部分c的字符串库。\n\n\n# 链表\n\n 1. 源码\n\n/*\n* 双端链表节点\n*/\ntypedef struct listnode {\n\n  // 前置节点\n  struct listnode *prev;\n\n  // 后置节点\n  struct listnode *next;\n\n  // 节点的值\n  void *value;\n\n} listnode;\n\n/*\n* 双端链表结构\n*/\ntypedef struct list {\n\n  // 表头节点\n  listnode *head;\n\n  // 表尾节点\n  listnode *tail;\n\n  // 节点值复制函数\n  void *(*dup)(void *ptr);\n\n  // 节点值释放函数\n  void (*free)(void *ptr);\n\n  // 节点值对比函数\n  int (*match)(void *ptr, void *key);\n\n  // 链表所包含的节点数量\n  unsigned long len;\n\n} list;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n[外链图片转存中...(img-ua4uhhoc-1653145947289)]\n\n\n# hash\n\n 1. 源码\n\n/*\n* 哈希表节点\n*/\ntypedef struct dictentry {\n  \n  // 键\n  void *key;\n\n  // 值\n  union {\n      void *val;\n      uint64_t u64;\n      int64_t s64;\n  } v;\n\n  // 指向下个哈希表节点，形成链表\n  struct dictentry *next;\n\n} dictentry;\n\n/*\n* 哈希表\n*\n* 每个字典都使用两个哈希表，从而实现渐进式 rehash 。\n*/\ntypedef struct dictht {\n  \n  // 哈希表数组\n  dictentry **table;\n\n  // 哈希表大小\n  unsigned long size;\n  \n  // 哈希表大小掩码，用于计算索引值\n  // 总是等于 size - 1\n  unsigned long sizemask;\n\n  // 该哈希表已有节点的数量\n  unsigned long used;\n\n} dictht;\n\n/*\n* 字典\n*/\ntypedef struct dict {\n\n  // 类型特定函数\n  dicttype *type;\n\n  // 私有数据\n  void *privdata;\n\n  // 哈希表\n  dictht ht[2];\n\n  // rehash 索引\n  // 当 rehash 不在进行时，值为 -1\n  int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n\n  // 目前正在运行的安全迭代器的数量\n  int iterators; /* number of iterators currently running */\n\n} dict;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n[外链图片转存中...(img-3iet2xy5-1653145947290)] 2. rehash\n\n> 扩容场景： 有bgsave或者bgrewriteaof时，负载因子超过5. 无bgsave或者bgrewriteaof时，负载因子超过1. 扩容为第一个大于等于ht[0].used*2的2的幂\n\n> 缩容场景： 负载因子小于0.1 缩容为第一个大于等于ht[0].used的2的幂\n\n> 负载因子：ht[0].used/ht[0].size\n\n> 渐进式rehash: rehashidx指向正在hash的索引。rehashidx=-1表示未进行rehash 每次访问dict结构时rehash一个索引\n\n[外链图片转存中...(img-a0e54hi9-1653145947290)]\n\n\n# 跳跃表\n\n 1. 源码\n\n/*\n* 跳跃表节点\n*/\ntypedef struct zskiplistnode {\n\n   // 成员对象\n   robj *obj;\n\n   // 分值\n   double score;\n\n   // 后退指针\n   struct zskiplistnode *backward;\n\n   // 层\n   struct zskiplistlevel {\n\n       // 前进指针\n       struct zskiplistnode *forward;\n\n       // 跨度\n       unsigned int span;\n\n   } level[];\n\n} zskiplistnode;\n\n/*\n* 跳跃表\n*/\ntypedef struct zskiplist {\n\n   // 表头节点和表尾节点\n   struct zskiplistnode *header, *tail;\n\n   // 表中节点的数量\n   unsigned long length;\n\n   // 表中层数最大的节点的层数\n   int level;\n\n} zskiplist;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n[外链图片转存中...(img-mbzs62dp-1653145947291)]\n\n\n# 整数集合\n\n 1. 源码\n\ntypedef struct intset {\n   \n   // 编码方式\n   uint32_t encoding;\n\n   // 集合包含的元素数量\n   uint32_t length;\n\n   // 保存元素的数组\n   int8_t contents[];\n\n} intset;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n[外链图片转存中...(img-hdtbzzhs-1653145947291)] 2. 编码升级 添加一个元素可能导致编码升级。编码升级需要做三件事\n\n * 扩展空间\n * 转变现有元素的类型并发至在合适的位置上。保证原有顺序防止\n * 防止新加入的元素。新加入的元素一定是最大或最小的，所以放在最前或者最后\n\n[外链图片转存中...(img-0r00i0bo-1653145947291)]\n\n\n# 压缩列表\n\n> 压缩列表是 redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。 一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值\n\n 1. 源码\n\n/*\n* 保存 ziplist 节点信息的结构\n*/\ntypedef struct zlentry {\n\n   // prevrawlen ：前置节点的长度\n   // prevrawlensize ：编码 prevrawlen 所需的字节大小\n   unsigned int prevrawlensize, prevrawlen;\n\n   // len ：当前节点值的长度\n   // lensize ：编码 len 所需的字节大小\n   unsigned int lensize, len;\n\n   // 当前节点 header 的大小\n   // 等于 prevrawlensize + lensize\n   unsigned int headersize;\n\n   // 当前节点值所使用的编码类型\n   unsigned char encoding;\n\n   // 指向当前节点的指针\n   unsigned char *p;\n\n} zlentry;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n 2. 示意图 [外链图片转存中...(img-nmdf8bnt-1653145947292)] [外链图片转存中...(img-5kdqas0e-1653145947292)]\n\n\n# redisobject\n\n> redis 使用对象来表示数据库中的键和值， 每次当我们在 redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。\n\n 1. 源码\n\ntypedef struct redisobject {\n\n   // 类型\n   unsigned type:4;\n\n   // 编码\n   unsigned encoding:4;\n\n   // 对象最后一次被访问的时间\n   unsigned lru:redis_lru_bits; /* lru time (relative to server.lruclock) */\n\n   // 引用计数\n   int refcount;\n\n   // 指向实际值的指针\n   void *ptr;\n\n} robj;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n[外链图片转存中...(img-ut4nw4ki-1653145947292)] 2. 类型和编码的对应关系 [外链图片转存中...(img-jkoornc4-1653145947293)] 3. 字符串对象\n\n值                           编码\n可以用long保存的整形                int\n可以用long，double保存的浮点         embstr或row\n长度太长，不可以用long，double保存的浮点   embstr或row\n小于39字节的字符串                  embstr\n大于39字节的字符串                  row\n\n> row要两次申请内存，两次释放内存。为这俩对象redisobject、sdsstr。embstr申请一次释放一次，而且申请的是连续的内存空间，能更好的利用缓存。\n\n 4. 链表对象\n\n> inkedlist和ziplist的转换临界值:每个元素长度都小于64、元素个数小于512。满足以上两个条件才能用ziplist\n\n 5. hash对象\n\n> hashtable和ziplist的转换临界值:每个元素长度都小于64、元素个数小于512。满足以上两个条件才能用ziplist\n\n 6. 集合对象\n\n> hashtable和intset的转换临界值:每个元素都是int、元素个数小于512。满足以上两个条件才能用intset\n\n 7. 内存回收\n\n> redis是用c实现的，c没有自动回收内存的机制。redisobject中的refcount记录对象的引用个数，当refcount=0的时候自动释放内存。\n\n 8. 对象共享\n\n> 0- 9999这1w个整数是共享对象。字符串不做共享对象，因为对比匹配太复杂",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "为什么 Redis 在单线程下能如此快？",
      "frontmatter": {
        "title": "为什么 Redis 在单线程下能如此快？",
        "date": "2022-05-21T17:20:12.000Z",
        "permalink": "/pages/d66211/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/002.%E4%B8%BA%E4%BB%80%E4%B9%88%20Redis%20%E5%9C%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%83%BD%E5%A6%82%E6%AD%A4%E5%BF%AB%EF%BC%9F.html",
      "relativePath": "03.数据库/02.REDIS相关/002.为什么 Redis 在单线程下能如此快？.md",
      "key": "v-cb742458",
      "path": "/pages/d66211/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 Redis 字符串的底层结构",
      "frontmatter": {
        "title": "简述 Redis 字符串的底层结构",
        "date": "2022-05-21T17:20:49.000Z",
        "permalink": "/pages/34aec2/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/005.%E7%AE%80%E8%BF%B0%20Redis%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.html",
      "relativePath": "03.数据库/02.REDIS相关/005.简述 Redis 字符串的底层结构.md",
      "key": "v-3e917471",
      "path": "/pages/34aec2/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Redis的缓存淘汰策略有哪些？",
      "frontmatter": {
        "title": "Redis的缓存淘汰策略有哪些？",
        "date": "2022-05-21T17:20:33.000Z",
        "permalink": "/pages/9326cc/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/010.Redis%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F.html",
      "relativePath": "03.数据库/02.REDIS相关/010.Redis的缓存淘汰策略有哪些？.md",
      "key": "v-c0bc7b7a",
      "path": "/pages/9326cc/",
      "headers": [
        {
          "level": 2,
          "title": "过期键",
          "slug": "过期键",
          "normalizedTitle": "过期键",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "内存淘汰策略（内存不足时)",
          "slug": "内存淘汰策略-内存不足时",
          "normalizedTitle": "内存淘汰策略（内存不足时)",
          "charIndex": 235
        }
      ],
      "headersStr": "过期键 内存淘汰策略（内存不足时)",
      "content": "# 过期键\n\n * 删除过期键的策略\n   \n   * 定时：对内存友好，对cpu不友好\n   * 惰性：对内存不友好，对cpu友好\n   * 定期：是定时和惰性的折中方案。执行时长和频率是衡量一个定期策略好坏的标准。\n\n * rdb再说生成和加载过程中过滤掉过期的键\n\n * aof模式下，过期的键只有真正del的时候才会记录在aof文件。重写aof文件不会包含过期的键。\n\n * 主从复制：从服务器遇到过期键不会del，接收到主服务器的del命令才会删除。\n\n\n# 内存淘汰策略（内存不足时)\n\n * noeviction：抛异常\n * allkeys-lru：在所有的key中按lru淘汰\n * allkeys-random:在所有的key中随机淘汰\n * volatile-lru：在设置了过期时间的key中lru淘汰\n * volatile-random:在设置了过期时间的key中随机淘汰\n * volatile-ttl：删除快过期的key",
      "normalizedContent": "# 过期键\n\n * 删除过期键的策略\n   \n   * 定时：对内存友好，对cpu不友好\n   * 惰性：对内存不友好，对cpu友好\n   * 定期：是定时和惰性的折中方案。执行时长和频率是衡量一个定期策略好坏的标准。\n\n * rdb再说生成和加载过程中过滤掉过期的键\n\n * aof模式下，过期的键只有真正del的时候才会记录在aof文件。重写aof文件不会包含过期的键。\n\n * 主从复制：从服务器遇到过期键不会del，接收到主服务器的del命令才会删除。\n\n\n# 内存淘汰策略（内存不足时)\n\n * noeviction：抛异常\n * allkeys-lru：在所有的key中按lru淘汰\n * allkeys-random:在所有的key中随机淘汰\n * volatile-lru：在设置了过期时间的key中lru淘汰\n * volatile-random:在设置了过期时间的key中随机淘汰\n * volatile-ttl：删除快过期的key",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点",
      "frontmatter": {
        "title": "简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点",
        "date": "2022-05-21T17:21:43.000Z",
        "permalink": "/pages/7e708d/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/020.%E7%AE%80%E8%BF%B0%20Redis%20%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%AD%20RDB%20%E4%BB%A5%E5%8F%8A%20AOF%20%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.html",
      "relativePath": "03.数据库/02.REDIS相关/020.简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点.md",
      "key": "v-7c214d00",
      "path": "/pages/7e708d/",
      "headers": [
        {
          "level": 2,
          "title": "RDB持久化",
          "slug": "rdb持久化",
          "normalizedTitle": "rdb持久化",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "AOF持久化",
          "slug": "aof持久化",
          "normalizedTitle": "aof持久化",
          "charIndex": 1345
        }
      ],
      "headersStr": "RDB持久化 AOF持久化",
      "content": "# RDB持久化\n\n 1. save和bgsave源码\n\nvoid saveCommand(redisClient *c) {\n\n   // BGSAVE 已经在执行中，不能再执行 SAVE\n   // 否则将产生竞争条件\n   if (server.rdb_child_pid != -1) {\n       addReplyError(c,\"Background save already in progress\");\n       return;\n   }\n\n   // 执行 \n   if (rdbSave(server.rdb_filename) == REDIS_OK) {\n       addReply(c,shared.ok);\n   } else {\n       addReply(c,shared.err);\n   }\n}\n\nvoid bgsaveCommand(redisClient *c) {\n\n   // 不能重复执行 BGSAVE\n   if (server.rdb_child_pid != -1) {\n       addReplyError(c,\"Background save already in progress\");\n\n   // 不能在 BGREWRITEAOF 正在运行时执行\n   } else if (server.aof_child_pid != -1) {\n       addReplyError(c,\"Can't BGSAVE while AOF log rewriting is in progress\");\n\n   // 执行 BGSAVE\n   } else if (rdbSaveBackground(server.rdb_filename) == REDIS_OK) {\n       addReplyStatus(c,\"Background saving started\");\n\n   } else {\n       addReply(c,shared.err);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n 2. 自动间隔性保存\n\n> 服务器间隔性检车saveparams中的任意一个条件是否得到满足，如果得到满足，执行bgsave.saveparams[0]表示距离上次bgsave900s内,至少有一次数据库变化。\n\n[外链图片转存中...(img-SwAqAX8z-1653145947293)]\n\n 3. rdb文件结构 [外链图片转存中...(img-Prs54pGE-1653145947294)] 其中database结构如下： [外链图片转存中...(img-rn1gUv6w-1653145947294)] 其中ksy_value_pairs结构如下 [外链图片转存中...(img-B62S2gV5-1653145947295)]\n\n> type指定了value的类型。value的编码方式不同期存储结构也不同。\n\n\n# AOF持久化\n\n 1. aof的实现 命令追加：所有客户端命令都会被存到redis_server的aof_buf缓冲区。 文件写入：操作系统在写入文件的时候，先写入缓存，缓存满了才写入文件。 文件同步：flushAppendOnlyFile()负责将aof_buf写入文件aof。\n\n> flushAppendOnlyFile中配置的appendfsync决定同步策略。appendfsync有三个取值：always(每次写入都同步)、everysec(每次事件都写入但不同步，每秒同步)、 no(每次事件都写入但不同步，操作系统决定同步)；\n\n 2. aof的载入与还原 [外链图片转存中...(img-pNMyXRLJ-1653145947295)]\n 3. AOF重写 [外链图片转存中...(img-i1nhwgNs-1653145947295)]",
      "normalizedContent": "# rdb持久化\n\n 1. save和bgsave源码\n\nvoid savecommand(redisclient *c) {\n\n   // bgsave 已经在执行中，不能再执行 save\n   // 否则将产生竞争条件\n   if (server.rdb_child_pid != -1) {\n       addreplyerror(c,\"background save already in progress\");\n       return;\n   }\n\n   // 执行 \n   if (rdbsave(server.rdb_filename) == redis_ok) {\n       addreply(c,shared.ok);\n   } else {\n       addreply(c,shared.err);\n   }\n}\n\nvoid bgsavecommand(redisclient *c) {\n\n   // 不能重复执行 bgsave\n   if (server.rdb_child_pid != -1) {\n       addreplyerror(c,\"background save already in progress\");\n\n   // 不能在 bgrewriteaof 正在运行时执行\n   } else if (server.aof_child_pid != -1) {\n       addreplyerror(c,\"can't bgsave while aof log rewriting is in progress\");\n\n   // 执行 bgsave\n   } else if (rdbsavebackground(server.rdb_filename) == redis_ok) {\n       addreplystatus(c,\"background saving started\");\n\n   } else {\n       addreply(c,shared.err);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n 2. 自动间隔性保存\n\n> 服务器间隔性检车saveparams中的任意一个条件是否得到满足，如果得到满足，执行bgsave.saveparams[0]表示距离上次bgsave900s内,至少有一次数据库变化。\n\n[外链图片转存中...(img-swaqax8z-1653145947293)]\n\n 3. rdb文件结构 [外链图片转存中...(img-prs54pge-1653145947294)] 其中database结构如下： [外链图片转存中...(img-rn1guv6w-1653145947294)] 其中ksy_value_pairs结构如下 [外链图片转存中...(img-b62s2gv5-1653145947295)]\n\n> type指定了value的类型。value的编码方式不同期存储结构也不同。\n\n\n# aof持久化\n\n 1. aof的实现 命令追加：所有客户端命令都会被存到redis_server的aof_buf缓冲区。 文件写入：操作系统在写入文件的时候，先写入缓存，缓存满了才写入文件。 文件同步：flushappendonlyfile()负责将aof_buf写入文件aof。\n\n> flushappendonlyfile中配置的appendfsync决定同步策略。appendfsync有三个取值：always(每次写入都同步)、everysec(每次事件都写入但不同步，每秒同步)、 no(每次事件都写入但不同步，操作系统决定同步)；\n\n 2. aof的载入与还原 [外链图片转存中...(img-pnmyxrlj-1653145947295)]\n 3. aof重写 [外链图片转存中...(img-i1nhwgns-1653145947295)]",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 Redis 中跳表的应用以及优缺点",
      "frontmatter": {
        "title": "简述 Redis 中跳表的应用以及优缺点",
        "date": "2022-05-21T17:22:09.000Z",
        "permalink": "/pages/a42826/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/050.%E7%AE%80%E8%BF%B0%20Redis%20%E4%B8%AD%E8%B7%B3%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9.html",
      "relativePath": "03.数据库/02.REDIS相关/050.简述 Redis 中跳表的应用以及优缺点.md",
      "key": "v-18b427a0",
      "path": "/pages/a42826/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Redis 中，sentinel 和 cluster 的区别和适用场景是什么？",
      "frontmatter": {
        "title": "Redis 中，sentinel 和 cluster 的区别和适用场景是什么？",
        "date": "2022-05-21T17:22:27.000Z",
        "permalink": "/pages/e2e910/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/060.Redis%20%E4%B8%AD%EF%BC%8Csentinel%20%E5%92%8C%20cluster%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.html",
      "relativePath": "03.数据库/02.REDIS相关/060.Redis 中，sentinel 和 cluster 的区别和适用场景是什么？.md",
      "key": "v-6a45f68d",
      "path": "/pages/e2e910/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 Redis 集群配置以及基础原理",
      "frontmatter": {
        "title": "简述 Redis 集群配置以及基础原理",
        "date": "2022-05-21T17:21:55.000Z",
        "permalink": "/pages/338e30/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/040.%E7%AE%80%E8%BF%B0%20Redis%20%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86.html",
      "relativePath": "03.数据库/02.REDIS相关/040.简述 Redis 集群配置以及基础原理.md",
      "key": "v-3d2fdd6a",
      "path": "/pages/338e30/",
      "headers": [
        {
          "level": 2,
          "title": "复制",
          "slug": "复制",
          "normalizedTitle": "复制",
          "charIndex": 39
        }
      ],
      "headersStr": "复制",
      "content": "# 集群\n\n> 集群是redis的分布式数据库方案。通过分片实现数据共享。提供复制和故障转移功能。\n\n// 保存连接节点所需的有关信息\ntypedef struct clusterLink {\n\n    // 连接的创建时间\n    mstime_t ctime;             /* Link creation time */\n\n    // TCP 套接字描述符\n    int fd;                     /* TCP socket file descriptor */\n\n    // 输出缓冲区，保存着等待发送给其他节点的消息（message）。\n    sds sndbuf;                 /* Packet send buffer */\n\n    // 输入缓冲区，保存着从其他节点接收到的消息。\n    sds rcvbuf;                 /* Packet reception buffer */\n\n    // 与这个连接相关联的节点，如果没有的话就为 NULL\n    struct clusterNode *node;   /* Node related to this link if any, or NULL */\n\n} clusterLink;\n\n// 节点状态\nstruct clusterNode {\n\n    // 创建节点的时间\n    mstime_t ctime; /* Node object creation time. */\n\n    // 节点的名字，由 40 个十六进制字符组成\n    // 例如 68eef66df23420a5862208ef5b1a7005b806f2ff\n    char name[REDIS_CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */\n\n    // 节点标识\n    // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），\n    // 以及节点目前所处的状态（比如在线或者下线）。\n    int flags;      /* REDIS_NODE_... */\n\n    // 节点当前的配置纪元，用于实现故障转移\n    uint64_t configEpoch; /* Last configEpoch observed for this node */\n\n    // 由这个节点负责处理的槽\n    // 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长\n    // 每个字节的每个位记录了一个槽的保存状态\n    // 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理\n    // 比如 slots[0] 的第一个位保存了槽 0 的保存情况\n    // slots[0] 的第二个位保存了槽 1 的保存情况，以此类推\n    unsigned char slots[REDIS_CLUSTER_SLOTS/8]; /* slots handled by this node */\n\n    // 该节点负责处理的槽数量\n    int numslots;   /* Number of slots handled by this node */\n\n    // 如果本节点是主节点，那么用这个属性记录从节点的数量\n    int numslaves;  /* Number of slave nodes, if this is a master */\n\n    // 指针数组，指向各个从节点\n    struct clusterNode **slaves; /* pointers to slave nodes */\n\n    // 如果这是一个从节点，那么指向主节点\n    struct clusterNode *slaveof; /* pointer to the master node */\n\n    // 最后一次发送 PING 命令的时间\n    mstime_t ping_sent;      /* Unix time we sent latest ping */\n\n    // 最后一次接收 PONG 回复的时间戳\n    mstime_t pong_received;  /* Unix time we received the pong */\n\n    // 最后一次被设置为 FAIL 状态的时间\n    mstime_t fail_time;      /* Unix time when FAIL flag was set */\n\n    // 最后一次给某个从节点投票的时间\n    mstime_t voted_time;     /* Last time we voted for a slave of this master */\n\n    // 最后一次从这个节点接收到复制偏移量的时间\n    mstime_t repl_offset_time;  /* Unix time we received offset for this node */\n\n    // 这个节点的复制偏移量\n    long long repl_offset;      /* Last known repl offset for this node. */\n\n    // 节点的 IP 地址\n    char ip[REDIS_IP_STR_LEN];  /* Latest known IP address of this node */\n\n    // 节点的端口号\n    int port;                   /* Latest known port of this node */\n\n    // 保存连接节点所需的有关信息\n    clusterLink *link;          /* TCP/IP link with this node */\n\n    // 一个链表，记录了所有其他节点对该节点的下线报告\n    list *fail_reports;         /* List of nodes signaling this as failing */\n\n};\ntypedef struct clusterNode clusterNode;\n\n\n// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。\n// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，\n// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count \n// 也被放到了这个结构里面。\ntypedef struct clusterState {\n\n    // 指向当前节点的指针\n    clusterNode *myself;  /* This node */\n\n    // 集群当前的配置纪元，用于实现故障转移\n    uint64_t currentEpoch;\n\n    // 集群当前的状态：是在线还是下线\n    int state;            /* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */\n\n    // 集群中至少处理着一个槽的节点的数量。\n    int size;             /* Num of master nodes with at least one slot */\n\n    // 集群节点名单（包括 myself 节点）\n    // 字典的键为节点的名字，字典的值为 clusterNode 结构\n    dict *nodes;          /* Hash table of name -> clusterNode structures */\n\n    // 节点黑名单，用于 CLUSTER FORGET 命令\n    // 防止被 FORGET 的命令重新被添加到集群里面\n    // （不过现在似乎没有在使用的样子，已废弃？还是尚未实现？）\n    dict *nodes_black_list; /* Nodes we don't re-add for a few seconds. */\n\n    // 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点\n    // migrating_slots_to[i] = NULL 表示槽 i 未被迁移\n    // migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A\n    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];\n\n    // 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点\n    // importing_slots_from[i] = NULL 表示槽 i 未进行导入\n    // importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i\n    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];\n\n    // 负责处理各个槽的节点\n    // 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理\n    clusterNode *slots[REDIS_CLUSTER_SLOTS];\n\n    // 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序\n    // 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便\n    // 具体操作定义在 db.c 里面\n    zskiplist *slots_to_keys;\n\n    /* The following fields are used to take the slave state on elections. */\n    // 以下这些域被用于进行故障转移选举\n\n    // 上次执行选举或者下次执行选举的时间\n    mstime_t failover_auth_time; /* Time of previous or next election. */\n\n    // 节点获得的投票数量\n    int failover_auth_count;    /* Number of votes received so far. */\n\n    // 如果值为 1 ，表示本节点已经向其他节点发送了投票请求\n    int failover_auth_sent;     /* True if we already asked for votes. */\n\n    int failover_auth_rank;     /* This slave rank for current auth request. */\n\n    uint64_t failover_auth_epoch; /* Epoch of the current election. */\n\n    /* Manual failover state in common. */\n    /* 共用的手动故障转移状态 */\n\n    // 手动故障转移执行的时间限制\n    mstime_t mf_end;            /* Manual failover time limit (ms unixtime).\n                                   It is zero if there is no MF in progress. */\n    /* Manual failover state of master. */\n    /* 主服务器的手动故障转移状态 */\n    clusterNode *mf_slave;      /* Slave performing the manual failover. */\n    /* Manual failover state of slave. */\n    /* 从服务器的手动故障转移状态 */\n    long long mf_master_offset; /* Master offset the slave needs to start MF\n                                   or zero if stil not received. */\n    // 指示手动故障转移是否可以开始的标志值\n    // 值为非 0 时表示各个主服务器可以开始投票\n    int mf_can_start;           /* If non-zero signal that the manual failover\n                                   can start requesting masters vote. */\n\n    /* The followign fields are uesd by masters to take state on elections. */\n    /* 以下这些域由主服务器使用，用于记录选举时的状态 */\n\n    // 集群最后一次进行投票的纪元\n    uint64_t lastVoteEpoch;     /* Epoch of the last vote granted. */\n\n    // 在进入下个事件循环之前要做的事情，以各个 flag 来记录\n    int todo_before_sleep; /* Things to do in clusterBeforeSleep(). */\n\n    // 通过 cluster 连接发送的消息数量\n    long long stats_bus_messages_sent;  /* Num of msg sent via cluster bus. */\n\n    // 通过 cluster 接收到的消息数量\n    long long stats_bus_messages_received; /* Num of msg rcvd via cluster bus.*/\n\n} clusterState;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n\n\n[外链图片转存中...(img-pyfo5Uy7-1653145947299)]\n\n 2. cluster meet命令\n\n> 客户端向节点A发送meet命令，指定节点B的ip和端口。将B加入到A的集群。\n\n * 向A发命令cluster meet B.\n * A为B创建一个clusterNode结构并保存在dict中\n * A向B发一个meet消息\n * B为A创建一个clusterNode结构并保存在dict中\n * B返回A一个PONG消息\n * A收到PONG返回一个PING\n * B收到PING，握手结束 [外链图片转存中...(img-MJB1V7if-1653145947300)]\n\n 3. 槽指派\n\n> redis通过分片的方式保存键值对，集群的整个数据库被分成16384个槽。每个节点处理一定数量的槽，每个key一定属于其中一个槽。\n\n * 向节点指派槽的命令：cluster addslots 1 2 3 4\n * clusterNode中Slots数组保存当前节点所有槽信息。Slots是二进制数组。\n * 传播节点的槽指派信息：集群节点会相互发送自己被指派的槽，节点收到其他几点的槽信息会更新相应的dict中的clusterNode结构。\n * clusterState中Slots数组保存所有槽信息。 [外链图片转存中...(img-p5szUZKB-1653145947300)]\n * cluster addslots 1 2 3 4的实现：首先遍历clusterState的Slots判断命令中的槽还没有被指派。然后遍历命令中的槽，设置clusterState的Slots和clusterNode的slots。\n\n 4. 集群中执行命令\n\n * 接收命令的节点计算命令要处理的数据库属于哪个槽，如果是指派给自己的就直接执行；如果不是就向客户端返回一个moved错误指引客户端至正确节点执行。\n * 计算给定key的槽：任何一个key通过这个算法就可以得出一个介于0-16383之间的槽。crc16(key)&16383\n * 集群中的节点只能使用0号数据库。\n\n 5. 重新分片 集群管理软件redis-trib负责执行。\n\n * redis-trib向目标节点发送导入命令，并将slot指向目标节点\n * redis-trib向源节点发送导出命令\n * redis-trib从源节点获取导出slot的键，导入到目标节点\n * 键迁移结束。向集群中任意节点发送消息，slot已指向目标节点。 [外链图片转存中...(img-dezJf9DD-1653145947300)]\n\n 6. ask错误\n\n * ask错误：正在被转移的key被查询时，会发生查询转移\n * Cluster setslot importing命令：clusterState的Importing_lots_from记录着导入的槽\n * Cluster setslot migrating命令:clusterState的migrating_slots_to记录着正在导出的槽。ask错误的实现\n\n 7. publish的实现\n\n> 不是直接向所有节点广播，而是通过一个节点向所有节点广播。因为redis中有一个潜规则：各节点通过消息通信。\n\ntypedef struct {\n\n    // 频道名长度\n    uint32_t channel_len;\n\n    // 消息长度\n    uint32_t message_len;\n\n    // 消息内容，格式为 频道名+消息\n    // bulk_data[0:channel_len-1] 为频道名\n    // bulk_data[channel_len:channel_len+message_len-1] 为消息\n    unsigned char bulk_data[8]; /* defined as 8 just for alignment concerns. */\n\n} clusterMsgDataPublish;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 复制\n\n 1. 复制的步骤\n\n * redis的复制分为两个步骤，同步（sync）和命令传播(commond propogate)。\n * 同步：从服务器向主服务器发送sync命令，主服务器生成rdb文件，并将生成rdb期间的数据库修改命令保存在缓冲区，然后都传给从服务器。同步浪费资源体现在：a.生成rdb耗费cpu，内存，i/o;b.传输rdb耗费网络资源；c.载入rdb会阻塞服务器。\n * 命令传播：主服务器收到的修改命令也发给从服务器执行。\n * redis2.8以前的复制缺陷：缺陷场景：主从断线之后的重新复制。实现方式：断线之后，主从重新走一遍同步和命令传播。缺陷原因：同步是很浪费资源的操作，应该尽量避免。\n * redis2.8以后用psync代替sync;psync支持完全重同步和部分重同步。\n * 部分重同步的实现：偏移量（同步的字节量），复制积压缓冲区(固定长度的队列)，服务器运行id（判断是不是向同一个服务器发送的同步命令）。 [外链图片转存中...(img-PHS6g12W-1653145947297)]\n\n 2. 复制的实现\n\n * 设置主服务器地址和端口。Slaveof 127.0.0.1 6379。从服务器保存主服务器地址和端口。\n * 建立套接字。从服务器根据保存的主服务器地址和端口号，建立套接字。\n * 从服务器发送ping命令。超时或者错误则重新建立套接字重试；返回“PONG”说明网络连接正常。\n * 身份验证。主从都没有设置身份验证或者设置一致才可以通过身份验证。\n * 从服务器发送监听端口，主服务器将其保存在redisClient的slave_listening_port;\n * 同步。从服务器向主服务发送psync命令。 [外链图片转存中...(img-JbQvVK4o-1653145947297)]\n\n 3. 心跳检测\n\n> 从服务器每秒发送命令给主服务器，replconf ack offset,有三个作用\n\n * 检测链接状况\n * 辅助实现min-slaves选项。min-slaves-to-write 3，min-slaves-max-lag 10。表示从服务器少于3个，或者从服务延迟都大于等于10，主服务器将终止写命令。\n * 检测命令丢失",
      "normalizedContent": "# 集群\n\n> 集群是redis的分布式数据库方案。通过分片实现数据共享。提供复制和故障转移功能。\n\n// 保存连接节点所需的有关信息\ntypedef struct clusterlink {\n\n    // 连接的创建时间\n    mstime_t ctime;             /* link creation time */\n\n    // tcp 套接字描述符\n    int fd;                     /* tcp socket file descriptor */\n\n    // 输出缓冲区，保存着等待发送给其他节点的消息（message）。\n    sds sndbuf;                 /* packet send buffer */\n\n    // 输入缓冲区，保存着从其他节点接收到的消息。\n    sds rcvbuf;                 /* packet reception buffer */\n\n    // 与这个连接相关联的节点，如果没有的话就为 null\n    struct clusternode *node;   /* node related to this link if any, or null */\n\n} clusterlink;\n\n// 节点状态\nstruct clusternode {\n\n    // 创建节点的时间\n    mstime_t ctime; /* node object creation time. */\n\n    // 节点的名字，由 40 个十六进制字符组成\n    // 例如 68eef66df23420a5862208ef5b1a7005b806f2ff\n    char name[redis_cluster_namelen]; /* node name, hex string, sha1-size */\n\n    // 节点标识\n    // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），\n    // 以及节点目前所处的状态（比如在线或者下线）。\n    int flags;      /* redis_node_... */\n\n    // 节点当前的配置纪元，用于实现故障转移\n    uint64_t configepoch; /* last configepoch observed for this node */\n\n    // 由这个节点负责处理的槽\n    // 一共有 redis_cluster_slots / 8 个字节长\n    // 每个字节的每个位记录了一个槽的保存状态\n    // 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理\n    // 比如 slots[0] 的第一个位保存了槽 0 的保存情况\n    // slots[0] 的第二个位保存了槽 1 的保存情况，以此类推\n    unsigned char slots[redis_cluster_slots/8]; /* slots handled by this node */\n\n    // 该节点负责处理的槽数量\n    int numslots;   /* number of slots handled by this node */\n\n    // 如果本节点是主节点，那么用这个属性记录从节点的数量\n    int numslaves;  /* number of slave nodes, if this is a master */\n\n    // 指针数组，指向各个从节点\n    struct clusternode **slaves; /* pointers to slave nodes */\n\n    // 如果这是一个从节点，那么指向主节点\n    struct clusternode *slaveof; /* pointer to the master node */\n\n    // 最后一次发送 ping 命令的时间\n    mstime_t ping_sent;      /* unix time we sent latest ping */\n\n    // 最后一次接收 pong 回复的时间戳\n    mstime_t pong_received;  /* unix time we received the pong */\n\n    // 最后一次被设置为 fail 状态的时间\n    mstime_t fail_time;      /* unix time when fail flag was set */\n\n    // 最后一次给某个从节点投票的时间\n    mstime_t voted_time;     /* last time we voted for a slave of this master */\n\n    // 最后一次从这个节点接收到复制偏移量的时间\n    mstime_t repl_offset_time;  /* unix time we received offset for this node */\n\n    // 这个节点的复制偏移量\n    long long repl_offset;      /* last known repl offset for this node. */\n\n    // 节点的 ip 地址\n    char ip[redis_ip_str_len];  /* latest known ip address of this node */\n\n    // 节点的端口号\n    int port;                   /* latest known port of this node */\n\n    // 保存连接节点所需的有关信息\n    clusterlink *link;          /* tcp/ip link with this node */\n\n    // 一个链表，记录了所有其他节点对该节点的下线报告\n    list *fail_reports;         /* list of nodes signaling this as failing */\n\n};\ntypedef struct clusternode clusternode;\n\n\n// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。\n// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，\n// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count \n// 也被放到了这个结构里面。\ntypedef struct clusterstate {\n\n    // 指向当前节点的指针\n    clusternode *myself;  /* this node */\n\n    // 集群当前的配置纪元，用于实现故障转移\n    uint64_t currentepoch;\n\n    // 集群当前的状态：是在线还是下线\n    int state;            /* redis_cluster_ok, redis_cluster_fail, ... */\n\n    // 集群中至少处理着一个槽的节点的数量。\n    int size;             /* num of master nodes with at least one slot */\n\n    // 集群节点名单（包括 myself 节点）\n    // 字典的键为节点的名字，字典的值为 clusternode 结构\n    dict *nodes;          /* hash table of name -> clusternode structures */\n\n    // 节点黑名单，用于 cluster forget 命令\n    // 防止被 forget 的命令重新被添加到集群里面\n    // （不过现在似乎没有在使用的样子，已废弃？还是尚未实现？）\n    dict *nodes_black_list; /* nodes we don't re-add for a few seconds. */\n\n    // 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点\n    // migrating_slots_to[i] = null 表示槽 i 未被迁移\n    // migrating_slots_to[i] = clusternode_a 表示槽 i 要从本节点迁移至节点 a\n    clusternode *migrating_slots_to[redis_cluster_slots];\n\n    // 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点\n    // importing_slots_from[i] = null 表示槽 i 未进行导入\n    // importing_slots_from[i] = clusternode_a 表示正从节点 a 中导入槽 i\n    clusternode *importing_slots_from[redis_cluster_slots];\n\n    // 负责处理各个槽的节点\n    // 例如 slots[i] = clusternode_a 表示槽 i 由节点 a 处理\n    clusternode *slots[redis_cluster_slots];\n\n    // 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序\n    // 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便\n    // 具体操作定义在 db.c 里面\n    zskiplist *slots_to_keys;\n\n    /* the following fields are used to take the slave state on elections. */\n    // 以下这些域被用于进行故障转移选举\n\n    // 上次执行选举或者下次执行选举的时间\n    mstime_t failover_auth_time; /* time of previous or next election. */\n\n    // 节点获得的投票数量\n    int failover_auth_count;    /* number of votes received so far. */\n\n    // 如果值为 1 ，表示本节点已经向其他节点发送了投票请求\n    int failover_auth_sent;     /* true if we already asked for votes. */\n\n    int failover_auth_rank;     /* this slave rank for current auth request. */\n\n    uint64_t failover_auth_epoch; /* epoch of the current election. */\n\n    /* manual failover state in common. */\n    /* 共用的手动故障转移状态 */\n\n    // 手动故障转移执行的时间限制\n    mstime_t mf_end;            /* manual failover time limit (ms unixtime).\n                                   it is zero if there is no mf in progress. */\n    /* manual failover state of master. */\n    /* 主服务器的手动故障转移状态 */\n    clusternode *mf_slave;      /* slave performing the manual failover. */\n    /* manual failover state of slave. */\n    /* 从服务器的手动故障转移状态 */\n    long long mf_master_offset; /* master offset the slave needs to start mf\n                                   or zero if stil not received. */\n    // 指示手动故障转移是否可以开始的标志值\n    // 值为非 0 时表示各个主服务器可以开始投票\n    int mf_can_start;           /* if non-zero signal that the manual failover\n                                   can start requesting masters vote. */\n\n    /* the followign fields are uesd by masters to take state on elections. */\n    /* 以下这些域由主服务器使用，用于记录选举时的状态 */\n\n    // 集群最后一次进行投票的纪元\n    uint64_t lastvoteepoch;     /* epoch of the last vote granted. */\n\n    // 在进入下个事件循环之前要做的事情，以各个 flag 来记录\n    int todo_before_sleep; /* things to do in clusterbeforesleep(). */\n\n    // 通过 cluster 连接发送的消息数量\n    long long stats_bus_messages_sent;  /* num of msg sent via cluster bus. */\n\n    // 通过 cluster 接收到的消息数量\n    long long stats_bus_messages_received; /* num of msg rcvd via cluster bus.*/\n\n} clusterstate;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n\n\n[外链图片转存中...(img-pyfo5uy7-1653145947299)]\n\n 2. cluster meet命令\n\n> 客户端向节点a发送meet命令，指定节点b的ip和端口。将b加入到a的集群。\n\n * 向a发命令cluster meet b.\n * a为b创建一个clusternode结构并保存在dict中\n * a向b发一个meet消息\n * b为a创建一个clusternode结构并保存在dict中\n * b返回a一个pong消息\n * a收到pong返回一个ping\n * b收到ping，握手结束 [外链图片转存中...(img-mjb1v7if-1653145947300)]\n\n 3. 槽指派\n\n> redis通过分片的方式保存键值对，集群的整个数据库被分成16384个槽。每个节点处理一定数量的槽，每个key一定属于其中一个槽。\n\n * 向节点指派槽的命令：cluster addslots 1 2 3 4\n * clusternode中slots数组保存当前节点所有槽信息。slots是二进制数组。\n * 传播节点的槽指派信息：集群节点会相互发送自己被指派的槽，节点收到其他几点的槽信息会更新相应的dict中的clusternode结构。\n * clusterstate中slots数组保存所有槽信息。 [外链图片转存中...(img-p5szuzkb-1653145947300)]\n * cluster addslots 1 2 3 4的实现：首先遍历clusterstate的slots判断命令中的槽还没有被指派。然后遍历命令中的槽，设置clusterstate的slots和clusternode的slots。\n\n 4. 集群中执行命令\n\n * 接收命令的节点计算命令要处理的数据库属于哪个槽，如果是指派给自己的就直接执行；如果不是就向客户端返回一个moved错误指引客户端至正确节点执行。\n * 计算给定key的槽：任何一个key通过这个算法就可以得出一个介于0-16383之间的槽。crc16(key)&16383\n * 集群中的节点只能使用0号数据库。\n\n 5. 重新分片 集群管理软件redis-trib负责执行。\n\n * redis-trib向目标节点发送导入命令，并将slot指向目标节点\n * redis-trib向源节点发送导出命令\n * redis-trib从源节点获取导出slot的键，导入到目标节点\n * 键迁移结束。向集群中任意节点发送消息，slot已指向目标节点。 [外链图片转存中...(img-dezjf9dd-1653145947300)]\n\n 6. ask错误\n\n * ask错误：正在被转移的key被查询时，会发生查询转移\n * cluster setslot importing命令：clusterstate的importing_lots_from记录着导入的槽\n * cluster setslot migrating命令:clusterstate的migrating_slots_to记录着正在导出的槽。ask错误的实现\n\n 7. publish的实现\n\n> 不是直接向所有节点广播，而是通过一个节点向所有节点广播。因为redis中有一个潜规则：各节点通过消息通信。\n\ntypedef struct {\n\n    // 频道名长度\n    uint32_t channel_len;\n\n    // 消息长度\n    uint32_t message_len;\n\n    // 消息内容，格式为 频道名+消息\n    // bulk_data[0:channel_len-1] 为频道名\n    // bulk_data[channel_len:channel_len+message_len-1] 为消息\n    unsigned char bulk_data[8]; /* defined as 8 just for alignment concerns. */\n\n} clustermsgdatapublish;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 复制\n\n 1. 复制的步骤\n\n * redis的复制分为两个步骤，同步（sync）和命令传播(commond propogate)。\n * 同步：从服务器向主服务器发送sync命令，主服务器生成rdb文件，并将生成rdb期间的数据库修改命令保存在缓冲区，然后都传给从服务器。同步浪费资源体现在：a.生成rdb耗费cpu，内存，i/o;b.传输rdb耗费网络资源；c.载入rdb会阻塞服务器。\n * 命令传播：主服务器收到的修改命令也发给从服务器执行。\n * redis2.8以前的复制缺陷：缺陷场景：主从断线之后的重新复制。实现方式：断线之后，主从重新走一遍同步和命令传播。缺陷原因：同步是很浪费资源的操作，应该尽量避免。\n * redis2.8以后用psync代替sync;psync支持完全重同步和部分重同步。\n * 部分重同步的实现：偏移量（同步的字节量），复制积压缓冲区(固定长度的队列)，服务器运行id（判断是不是向同一个服务器发送的同步命令）。 [外链图片转存中...(img-phs6g12w-1653145947297)]\n\n 2. 复制的实现\n\n * 设置主服务器地址和端口。slaveof 127.0.0.1 6379。从服务器保存主服务器地址和端口。\n * 建立套接字。从服务器根据保存的主服务器地址和端口号，建立套接字。\n * 从服务器发送ping命令。超时或者错误则重新建立套接字重试；返回“pong”说明网络连接正常。\n * 身份验证。主从都没有设置身份验证或者设置一致才可以通过身份验证。\n * 从服务器发送监听端口，主服务器将其保存在redisclient的slave_listening_port;\n * 同步。从服务器向主服务发送psync命令。 [外链图片转存中...(img-jbqvvk4o-1653145947297)]\n\n 3. 心跳检测\n\n> 从服务器每秒发送命令给主服务器，replconf ack offset,有三个作用\n\n * 检测链接状况\n * 辅助实现min-slaves选项。min-slaves-to-write 3，min-slaves-max-lag 10。表示从服务器少于3个，或者从服务延迟都大于等于10，主服务器将终止写命令。\n * 检测命令丢失",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 Redis 中如何防止缓存雪崩和缓存击穿",
      "frontmatter": {
        "title": "简述 Redis 中如何防止缓存雪崩和缓存击穿",
        "date": "2022-05-21T17:22:52.000Z",
        "permalink": "/pages/03cd25/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/070.%E7%AE%80%E8%BF%B0%20Redis%20%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.html",
      "relativePath": "03.数据库/02.REDIS相关/070.简述 Redis 中如何防止缓存雪崩和缓存击穿.md",
      "key": "v-c2fe5e1a",
      "path": "/pages/03cd25/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 Redis 的线程模型以及底层架构设计",
      "frontmatter": {
        "title": "简述 Redis 的线程模型以及底层架构设计",
        "date": "2022-05-21T17:23:08.000Z",
        "permalink": "/pages/9c28c9/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/080.%E7%AE%80%E8%BF%B0%20Redis%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",
      "relativePath": "03.数据库/02.REDIS相关/080.简述 Redis 的线程模型以及底层架构设计.md",
      "key": "v-35718f4e",
      "path": "/pages/9c28c9/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Redis 序列化有哪些方式？",
      "frontmatter": {
        "title": "Redis 序列化有哪些方式？",
        "date": "2022-05-21T17:23:58.000Z",
        "permalink": "/pages/0d3c6b/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/120.Redis%20%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F.html",
      "relativePath": "03.数据库/02.REDIS相关/120.Redis 序列化有哪些方式？.md",
      "key": "v-02ea33c3",
      "path": "/pages/0d3c6b/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 Redis 的哨兵机制",
      "frontmatter": {
        "title": "简述 Redis 的哨兵机制",
        "date": "2022-05-21T17:23:24.000Z",
        "permalink": "/pages/cc8507/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/100.%E7%AE%80%E8%BF%B0%20Redis%20%E7%9A%84%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6.html",
      "relativePath": "03.数据库/02.REDIS相关/100.简述 Redis 的哨兵机制.md",
      "key": "v-57957421",
      "path": "/pages/cc8507/",
      "headers": [
        {
          "level": 2,
          "title": "sentinel",
          "slug": "sentinel",
          "normalizedTitle": "sentinel",
          "charIndex": 2
        }
      ],
      "headersStr": "sentinel",
      "content": "# sentinel\n\n> 负责redis高可用，检测主服务器下线，然后选举一个从服务器成为新的主服务器。\n\n 1. 源码\n\n// Sentinel 会为每个被监视的 Redis 实例创建相应的 sentinelRedisInstance 实例\n// （被监视的实例可以是主服务器、从服务器、或者其他 Sentinel ）\ntypedef struct sentinelRedisInstance {\n    \n    // 标识值，记录了实例的类型，以及该实例的当前状态\n    int flags;      /* See SRI_... defines */\n    \n    // 实例的名字\n    // 主服务器的名字由用户在配置文件中设置\n    // 从服务器以及 Sentinel 的名字由 Sentinel 自动设置\n    // 格式为 ip:port ，例如 \"127.0.0.1:26379\"\n    char *name;     /* Master name from the point of view of this sentinel. */\n\n    // 实例的运行 ID\n    char *runid;    /* run ID of this instance. */\n\n    // 配置纪元，用于实现故障转移\n    uint64_t config_epoch;  /* Configuration epoch. */\n\n    // 实例的地址\n    sentinelAddr *addr; /* Master host. */\n\n    // 用于发送命令的异步连接\n    redisAsyncContext *cc; /* Hiredis context for commands. */\n\n    // 用于执行 SUBSCRIBE 命令、接收频道信息的异步连接\n    // 仅在实例为主服务器时使用\n    redisAsyncContext *pc; /* Hiredis context for Pub / Sub. */\n\n    // 已发送但尚未回复的命令数量\n    int pending_commands;   /* Number of commands sent waiting for a reply. */\n\n    // cc 连接的创建时间\n    mstime_t cc_conn_time; /* cc connection time. */\n    \n    // pc 连接的创建时间\n    mstime_t pc_conn_time; /* pc connection time. */\n\n    // 最后一次从这个实例接收信息的时间\n    mstime_t pc_last_activity; /* Last time we received any message. */\n\n    // 实例最后一次返回正确的 PING 命令回复的时间\n    mstime_t last_avail_time; /* Last time the instance replied to ping with\n                                 a reply we consider valid. */\n    // 实例最后一次发送 PING 命令的时间\n    mstime_t last_ping_time;  /* Last time a pending ping was sent in the\n                                 context of the current command connection\n                                 with the instance. 0 if still not sent or\n                                 if pong already received. */\n    // 实例最后一次返回 PING 命令的时间，无论内容正确与否\n    mstime_t last_pong_time;  /* Last time the instance replied to ping,\n                                 whatever the reply was. That's used to check\n                                 if the link is idle and must be reconnected. */\n\n    // 最后一次向频道发送问候信息的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_pub_time;   /* Last time we sent hello via Pub/Sub. */\n\n    // 最后一次接收到这个 sentinel 发来的问候信息的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_hello_time; /* Only used if SRI_SENTINEL is set. Last time\n                                 we received a hello from this Sentinel\n                                 via Pub/Sub. */\n\n    // 最后一次回复 SENTINEL is-master-down-by-addr 命令的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_master_down_reply_time; /* Time of last reply to\n                                             SENTINEL is-master-down command. */\n\n    // 实例被判断为 SDOWN 状态的时间\n    mstime_t s_down_since_time; /* Subjectively down since time. */\n\n    // 实例被判断为 ODOWN 状态的时间\n    mstime_t o_down_since_time; /* Objectively down since time. */\n\n    // SENTINEL down-after-milliseconds 选项所设定的值\n    // 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）\n    mstime_t down_after_period; /* Consider it down after that period. */\n\n    // 从实例获取 INFO 命令的回复的时间\n    mstime_t info_refresh;  /* Time at which we received INFO output from it. */\n\n    /* Role and the first time we observed it.\n     * This is useful in order to delay replacing what the instance reports\n     * with our own configuration. We need to always wait some time in order\n     * to give a chance to the leader to report the new configuration before\n     * we do silly things. */\n    // 实例的角色\n    int role_reported;\n    // 角色的更新时间\n    mstime_t role_reported_time;\n\n    // 最后一次从服务器的主服务器地址变更的时间\n    mstime_t slave_conf_change_time; /* Last time slave master addr changed. */\n\n    /* Master specific. */\n    /* 主服务器实例特有的属性 -------------------------------------------------------------*/\n\n    // 其他同样监控这个主服务器的所有 sentinel\n    dict *sentinels;    /* Other sentinels monitoring the same master. */\n\n    // 如果这个实例代表的是一个主服务器\n    // 那么这个字典保存着主服务器属下的从服务器\n    // 字典的键是从服务器的名字，字典的值是从服务器对应的 sentinelRedisInstance 结构\n    dict *slaves;       /* Slaves for this master instance. */\n\n    // SENTINEL monitor <master-name> <IP> <port> <quorum> 选项中的 quorum 参数\n    // 判断这个实例为客观下线（objectively down）所需的支持投票数量\n    int quorum;         /* Number of sentinels that need to agree on failure. */\n\n    // SENTINEL parallel-syncs <master-name> <number> 选项的值\n    // 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量\n    int parallel_syncs; /* How many slaves to reconfigure at same time. */\n\n    // 连接主服务器和从服务器所需的密码\n    char *auth_pass;    /* Password to use for AUTH against master & slaves. */\n\n    /* Slave specific. */\n    /* 从服务器实例特有的属性 -------------------------------------------------------------*/\n\n    // 主从服务器连接断开的时间\n    mstime_t master_link_down_time; /* Slave replication link down time. */\n\n    // 从服务器优先级\n    int slave_priority; /* Slave priority according to its INFO output. */\n\n    // 执行故障转移操作时，从服务器发送 SLAVEOF <new-master> 命令的时间\n    mstime_t slave_reconf_sent_time; /* Time at which we sent SLAVE OF <new> */\n\n    // 主服务器的实例（在本实例为从服务器时使用）\n    struct sentinelRedisInstance *master; /* Master instance if it's slave. */\n\n    // INFO 命令的回复中记录的主服务器 IP\n    char *slave_master_host;    /* Master host as reported by INFO */\n    \n    // INFO 命令的回复中记录的主服务器端口号\n    int slave_master_port;      /* Master port as reported by INFO */\n\n    // INFO 命令的回复中记录的主从服务器连接状态\n    int slave_master_link_status; /* Master link status as reported by INFO */\n\n    // 从服务器的复制偏移量\n    unsigned long long slave_repl_offset; /* Slave replication offset. */\n\n    /* Failover */\n    /* 故障转移相关属性 -------------------------------------------------------------------*/\n\n\n    // 如果这是一个主服务器实例，那么 leader 将是负责进行故障转移的 Sentinel 的运行 ID 。\n    // 如果这是一个 Sentinel 实例，那么 leader 就是被选举出来的领头 Sentinel 。\n    // 这个域只在 Sentinel 实例的 flags 属性的 SRI_MASTER_DOWN 标志处于打开状态时才有效。\n    char *leader;       /* If this is a master instance, this is the runid of\n                           the Sentinel that should perform the failover. If\n                           this is a Sentinel, this is the runid of the Sentinel\n                           that this Sentinel voted as leader. */\n    // 领头的纪元\n    uint64_t leader_epoch; /* Epoch of the 'leader' field. */\n    // 当前执行中的故障转移的纪元\n    uint64_t failover_epoch; /* Epoch of the currently started failover. */\n    // 故障转移操作的当前状态\n    int failover_state; /* See SENTINEL_FAILOVER_STATE_* defines. */\n\n    // 状态改变的时间\n    mstime_t failover_state_change_time;\n\n    // 最后一次进行故障迁移的时间\n    mstime_t failover_start_time;   /* Last failover attempt start time. */\n\n    // SENTINEL failover-timeout <master-name> <ms> 选项的值\n    // 刷新故障迁移状态的最大时限\n    mstime_t failover_timeout;      /* Max time to refresh failover state. */\n\n    mstime_t failover_delay_logged; /* For what failover_start_time value we\n                                       logged the failover delay. */\n    // 指向被提升为新主服务器的从服务器的指针\n    struct sentinelRedisInstance *promoted_slave; /* Promoted slave instance. */\n\n    /* Scripts executed to notify admin or reconfigure clients: when they\n     * are set to NULL no script is executed. */\n    // 一个文件路径，保存着 WARNING 级别的事件发生时执行的，\n    // 用于通知管理员的脚本的地址\n    char *notification_script;\n\n    // 一个文件路径，保存着故障转移执行之前、之后、或者被中止时，\n    // 需要执行的脚本的地址\n    char *client_reconfig_script;\n\n} sentinelRedisInstance;\n\n/* Main state. */\n/* Sentinel 的状态结构 */\nstruct sentinelState {\n\n    // 当前纪元\n    uint64_t current_epoch;     /* Current epoch. */\n\n    // 保存了所有被这个 sentinel 监视的主服务器\n    // 字典的键是主服务器的名字\n    // 字典的值则是一个指向 sentinelRedisInstance 结构的指针\n    dict *masters;      /* Dictionary of master sentinelRedisInstances.\n                           Key is the instance name, value is the\n                           sentinelRedisInstance structure pointer. */\n\n    // 是否进入了 TILT 模式？\n    int tilt;           /* Are we in TILT mode? */\n\n    // 目前正在执行的脚本的数量\n    int running_scripts;    /* Number of scripts in execution right now. */\n\n    // 进入 TILT 模式的时间\n    mstime_t tilt_start_time;   /* When TITL started. */\n\n    // 最后一次执行时间处理器的时间\n    mstime_t previous_time;     /* Last time we ran the time handler. */\n\n    // 一个 FIFO 队列，包含了所有需要执行的用户脚本\n    list *scripts_queue;    /* Queue of user scripts to execute. */\n\n} sentinel;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n\n 2. 启动并初始化sentinel\n\n * 启动命令：Redis-sentinel /path/sentinel.conf\n * 初始化服务器\n * 使用sentinel专用代码\n * 初始化sentinel状态。sentinelState{}\n * 初始化masters属性。根据配置文件来生成。 [外链图片转存中...(img-gEx8X9Le-1653145947298)]\n * 创建两个链接主服务器的异步网络：一个命令链接；一个订阅链接。\n * 获取服务器信息。10s/次向主服务器发送info命令。获取主从信息。更新主从信息。从信息的保存结构如下： [外链图片转存中...(img-aBn6piJg-1653145947298)]\n * 获取从服务器信息。获取从服务器信息。sentinel发现主服务器有从服务器时，保存从服务器并创建两个异步链接：命令链接和订阅链接。10s/次向从服务器发送命令获取信息更新本地存储。\n * 向主从发送信息。2s/次通过命令连接发送信息。发送频道_sentinel_:hello\n * 接收信息。接收频道 sentinel:hello（用于发现新的sentinel）\n * 更新sentinel字典。sentinelResidInstance结构中的sentinels保存这个主服务器的所有sentinel。接收到_sentinel_:hello频道的消息时，更新sentinel.\n * 创建sentinel之间的连接。(不创建订阅链接)\n\n 3. 检测主观下线状态\n\n> sentinel每秒向它连接的实例发送ping命令。返回+pong、-loading、-masterdown是有效回复。其他回复或者指定时间没回复则认为无效。配置项down-after-milliseconds指定了sentinel判断主观下线时间长度。如果一个实例在down-after-milliseconds时间内连续向sentinel返回无效，则认为主观下线。\n\n * sentinelRedisInstance中的master属性有主观下线标识。\n * down-after-milliseconds是master下线的标准，也是master下slaves下线的标准，也是其他sentinel判断master下线的标准。\n * 多个sentinel设置同一个msater的down-after-milliseconds可能不同\n\n 4. 客观下线\n\n> sentinel判断一个master已经主观下线，会询问其他sentinel，如果一定数量 的都认为这个master已经主观下线，则判定这个master客观下线。然后做故障转移。\n\n * 发送sentinel is-master-down-by-addr命令询问其他sentinel\n * sentinel配置中的quorum参数决定有几个sentinel判断下线才能算是下线\n * 当一个msater被判定为客观下线时，监视这个master的各个sentinel之间会选举一个为领头sentinel，做故障转移。\n * 故障转移：选一个先master、slaves同步新的master、旧的master成为新master的slave\n\n 5. 选举领头sentinel\n\n> 当一个主服务器下线后，在监管这个主服务器的sentinel中选举一个领头sentinel。用于故障转移\n\n[外链图片转存中...(img-5XFvVtzH-1653145947298)] 6. 故障转移 领头sentinel完成故障转移需要三个步骤：\n\n * 在从服务器中选一个成为新的主服务器。sentinel在从服务器中选举一个，向其发送命令slaveof no one,使之成为主服务器。发送slaveof no one明后后每秒发送info命令观察role是不是变成了master。\n * 让从服务器同步新的主服务器. [外链图片转存中...(img-jz4GYou9-1653145947299)]\n * 让旧的主服务器成为新的主服务器的从服务器，当其上线时，成为从服务器。",
      "normalizedContent": "# sentinel\n\n> 负责redis高可用，检测主服务器下线，然后选举一个从服务器成为新的主服务器。\n\n 1. 源码\n\n// sentinel 会为每个被监视的 redis 实例创建相应的 sentinelredisinstance 实例\n// （被监视的实例可以是主服务器、从服务器、或者其他 sentinel ）\ntypedef struct sentinelredisinstance {\n    \n    // 标识值，记录了实例的类型，以及该实例的当前状态\n    int flags;      /* see sri_... defines */\n    \n    // 实例的名字\n    // 主服务器的名字由用户在配置文件中设置\n    // 从服务器以及 sentinel 的名字由 sentinel 自动设置\n    // 格式为 ip:port ，例如 \"127.0.0.1:26379\"\n    char *name;     /* master name from the point of view of this sentinel. */\n\n    // 实例的运行 id\n    char *runid;    /* run id of this instance. */\n\n    // 配置纪元，用于实现故障转移\n    uint64_t config_epoch;  /* configuration epoch. */\n\n    // 实例的地址\n    sentineladdr *addr; /* master host. */\n\n    // 用于发送命令的异步连接\n    redisasynccontext *cc; /* hiredis context for commands. */\n\n    // 用于执行 subscribe 命令、接收频道信息的异步连接\n    // 仅在实例为主服务器时使用\n    redisasynccontext *pc; /* hiredis context for pub / sub. */\n\n    // 已发送但尚未回复的命令数量\n    int pending_commands;   /* number of commands sent waiting for a reply. */\n\n    // cc 连接的创建时间\n    mstime_t cc_conn_time; /* cc connection time. */\n    \n    // pc 连接的创建时间\n    mstime_t pc_conn_time; /* pc connection time. */\n\n    // 最后一次从这个实例接收信息的时间\n    mstime_t pc_last_activity; /* last time we received any message. */\n\n    // 实例最后一次返回正确的 ping 命令回复的时间\n    mstime_t last_avail_time; /* last time the instance replied to ping with\n                                 a reply we consider valid. */\n    // 实例最后一次发送 ping 命令的时间\n    mstime_t last_ping_time;  /* last time a pending ping was sent in the\n                                 context of the current command connection\n                                 with the instance. 0 if still not sent or\n                                 if pong already received. */\n    // 实例最后一次返回 ping 命令的时间，无论内容正确与否\n    mstime_t last_pong_time;  /* last time the instance replied to ping,\n                                 whatever the reply was. that's used to check\n                                 if the link is idle and must be reconnected. */\n\n    // 最后一次向频道发送问候信息的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_pub_time;   /* last time we sent hello via pub/sub. */\n\n    // 最后一次接收到这个 sentinel 发来的问候信息的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_hello_time; /* only used if sri_sentinel is set. last time\n                                 we received a hello from this sentinel\n                                 via pub/sub. */\n\n    // 最后一次回复 sentinel is-master-down-by-addr 命令的时间\n    // 只在当前实例为 sentinel 时使用\n    mstime_t last_master_down_reply_time; /* time of last reply to\n                                             sentinel is-master-down command. */\n\n    // 实例被判断为 sdown 状态的时间\n    mstime_t s_down_since_time; /* subjectively down since time. */\n\n    // 实例被判断为 odown 状态的时间\n    mstime_t o_down_since_time; /* objectively down since time. */\n\n    // sentinel down-after-milliseconds 选项所设定的值\n    // 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）\n    mstime_t down_after_period; /* consider it down after that period. */\n\n    // 从实例获取 info 命令的回复的时间\n    mstime_t info_refresh;  /* time at which we received info output from it. */\n\n    /* role and the first time we observed it.\n     * this is useful in order to delay replacing what the instance reports\n     * with our own configuration. we need to always wait some time in order\n     * to give a chance to the leader to report the new configuration before\n     * we do silly things. */\n    // 实例的角色\n    int role_reported;\n    // 角色的更新时间\n    mstime_t role_reported_time;\n\n    // 最后一次从服务器的主服务器地址变更的时间\n    mstime_t slave_conf_change_time; /* last time slave master addr changed. */\n\n    /* master specific. */\n    /* 主服务器实例特有的属性 -------------------------------------------------------------*/\n\n    // 其他同样监控这个主服务器的所有 sentinel\n    dict *sentinels;    /* other sentinels monitoring the same master. */\n\n    // 如果这个实例代表的是一个主服务器\n    // 那么这个字典保存着主服务器属下的从服务器\n    // 字典的键是从服务器的名字，字典的值是从服务器对应的 sentinelredisinstance 结构\n    dict *slaves;       /* slaves for this master instance. */\n\n    // sentinel monitor <master-name> <ip> <port> <quorum> 选项中的 quorum 参数\n    // 判断这个实例为客观下线（objectively down）所需的支持投票数量\n    int quorum;         /* number of sentinels that need to agree on failure. */\n\n    // sentinel parallel-syncs <master-name> <number> 选项的值\n    // 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量\n    int parallel_syncs; /* how many slaves to reconfigure at same time. */\n\n    // 连接主服务器和从服务器所需的密码\n    char *auth_pass;    /* password to use for auth against master & slaves. */\n\n    /* slave specific. */\n    /* 从服务器实例特有的属性 -------------------------------------------------------------*/\n\n    // 主从服务器连接断开的时间\n    mstime_t master_link_down_time; /* slave replication link down time. */\n\n    // 从服务器优先级\n    int slave_priority; /* slave priority according to its info output. */\n\n    // 执行故障转移操作时，从服务器发送 slaveof <new-master> 命令的时间\n    mstime_t slave_reconf_sent_time; /* time at which we sent slave of <new> */\n\n    // 主服务器的实例（在本实例为从服务器时使用）\n    struct sentinelredisinstance *master; /* master instance if it's slave. */\n\n    // info 命令的回复中记录的主服务器 ip\n    char *slave_master_host;    /* master host as reported by info */\n    \n    // info 命令的回复中记录的主服务器端口号\n    int slave_master_port;      /* master port as reported by info */\n\n    // info 命令的回复中记录的主从服务器连接状态\n    int slave_master_link_status; /* master link status as reported by info */\n\n    // 从服务器的复制偏移量\n    unsigned long long slave_repl_offset; /* slave replication offset. */\n\n    /* failover */\n    /* 故障转移相关属性 -------------------------------------------------------------------*/\n\n\n    // 如果这是一个主服务器实例，那么 leader 将是负责进行故障转移的 sentinel 的运行 id 。\n    // 如果这是一个 sentinel 实例，那么 leader 就是被选举出来的领头 sentinel 。\n    // 这个域只在 sentinel 实例的 flags 属性的 sri_master_down 标志处于打开状态时才有效。\n    char *leader;       /* if this is a master instance, this is the runid of\n                           the sentinel that should perform the failover. if\n                           this is a sentinel, this is the runid of the sentinel\n                           that this sentinel voted as leader. */\n    // 领头的纪元\n    uint64_t leader_epoch; /* epoch of the 'leader' field. */\n    // 当前执行中的故障转移的纪元\n    uint64_t failover_epoch; /* epoch of the currently started failover. */\n    // 故障转移操作的当前状态\n    int failover_state; /* see sentinel_failover_state_* defines. */\n\n    // 状态改变的时间\n    mstime_t failover_state_change_time;\n\n    // 最后一次进行故障迁移的时间\n    mstime_t failover_start_time;   /* last failover attempt start time. */\n\n    // sentinel failover-timeout <master-name> <ms> 选项的值\n    // 刷新故障迁移状态的最大时限\n    mstime_t failover_timeout;      /* max time to refresh failover state. */\n\n    mstime_t failover_delay_logged; /* for what failover_start_time value we\n                                       logged the failover delay. */\n    // 指向被提升为新主服务器的从服务器的指针\n    struct sentinelredisinstance *promoted_slave; /* promoted slave instance. */\n\n    /* scripts executed to notify admin or reconfigure clients: when they\n     * are set to null no script is executed. */\n    // 一个文件路径，保存着 warning 级别的事件发生时执行的，\n    // 用于通知管理员的脚本的地址\n    char *notification_script;\n\n    // 一个文件路径，保存着故障转移执行之前、之后、或者被中止时，\n    // 需要执行的脚本的地址\n    char *client_reconfig_script;\n\n} sentinelredisinstance;\n\n/* main state. */\n/* sentinel 的状态结构 */\nstruct sentinelstate {\n\n    // 当前纪元\n    uint64_t current_epoch;     /* current epoch. */\n\n    // 保存了所有被这个 sentinel 监视的主服务器\n    // 字典的键是主服务器的名字\n    // 字典的值则是一个指向 sentinelredisinstance 结构的指针\n    dict *masters;      /* dictionary of master sentinelredisinstances.\n                           key is the instance name, value is the\n                           sentinelredisinstance structure pointer. */\n\n    // 是否进入了 tilt 模式？\n    int tilt;           /* are we in tilt mode? */\n\n    // 目前正在执行的脚本的数量\n    int running_scripts;    /* number of scripts in execution right now. */\n\n    // 进入 tilt 模式的时间\n    mstime_t tilt_start_time;   /* when titl started. */\n\n    // 最后一次执行时间处理器的时间\n    mstime_t previous_time;     /* last time we ran the time handler. */\n\n    // 一个 fifo 队列，包含了所有需要执行的用户脚本\n    list *scripts_queue;    /* queue of user scripts to execute. */\n\n} sentinel;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n\n 2. 启动并初始化sentinel\n\n * 启动命令：redis-sentinel /path/sentinel.conf\n * 初始化服务器\n * 使用sentinel专用代码\n * 初始化sentinel状态。sentinelstate{}\n * 初始化masters属性。根据配置文件来生成。 [外链图片转存中...(img-gex8x9le-1653145947298)]\n * 创建两个链接主服务器的异步网络：一个命令链接；一个订阅链接。\n * 获取服务器信息。10s/次向主服务器发送info命令。获取主从信息。更新主从信息。从信息的保存结构如下： [外链图片转存中...(img-abn6pijg-1653145947298)]\n * 获取从服务器信息。获取从服务器信息。sentinel发现主服务器有从服务器时，保存从服务器并创建两个异步链接：命令链接和订阅链接。10s/次向从服务器发送命令获取信息更新本地存储。\n * 向主从发送信息。2s/次通过命令连接发送信息。发送频道_sentinel_:hello\n * 接收信息。接收频道 sentinel:hello（用于发现新的sentinel）\n * 更新sentinel字典。sentinelresidinstance结构中的sentinels保存这个主服务器的所有sentinel。接收到_sentinel_:hello频道的消息时，更新sentinel.\n * 创建sentinel之间的连接。(不创建订阅链接)\n\n 3. 检测主观下线状态\n\n> sentinel每秒向它连接的实例发送ping命令。返回+pong、-loading、-masterdown是有效回复。其他回复或者指定时间没回复则认为无效。配置项down-after-milliseconds指定了sentinel判断主观下线时间长度。如果一个实例在down-after-milliseconds时间内连续向sentinel返回无效，则认为主观下线。\n\n * sentinelredisinstance中的master属性有主观下线标识。\n * down-after-milliseconds是master下线的标准，也是master下slaves下线的标准，也是其他sentinel判断master下线的标准。\n * 多个sentinel设置同一个msater的down-after-milliseconds可能不同\n\n 4. 客观下线\n\n> sentinel判断一个master已经主观下线，会询问其他sentinel，如果一定数量 的都认为这个master已经主观下线，则判定这个master客观下线。然后做故障转移。\n\n * 发送sentinel is-master-down-by-addr命令询问其他sentinel\n * sentinel配置中的quorum参数决定有几个sentinel判断下线才能算是下线\n * 当一个msater被判定为客观下线时，监视这个master的各个sentinel之间会选举一个为领头sentinel，做故障转移。\n * 故障转移：选一个先master、slaves同步新的master、旧的master成为新master的slave\n\n 5. 选举领头sentinel\n\n> 当一个主服务器下线后，在监管这个主服务器的sentinel中选举一个领头sentinel。用于故障转移\n\n[外链图片转存中...(img-5xfvvtzh-1653145947298)] 6. 故障转移 领头sentinel完成故障转移需要三个步骤：\n\n * 在从服务器中选一个成为新的主服务器。sentinel在从服务器中选举一个，向其发送命令slaveof no one,使之成为主服务器。发送slaveof no one明后后每秒发送info命令观察role是不是变成了master。\n * 让从服务器同步新的主服务器. [外链图片转存中...(img-jz4gyou9-1653145947299)]\n * 让旧的主服务器成为新的主服务器的从服务器，当其上线时，成为从服务器。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Netty",
      "frontmatter": {
        "title": "Netty",
        "date": "2020-05-21T21:50:26.000Z",
        "permalink": "/pages/40f3c9/",
        "categories": [
          "中间件",
          "Netty"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/001.%E4%BD%A0%E7%86%9F%E6%82%89%E5%93%AA%E4%BA%9BIO%E6%A8%A1%E5%9E%8B%EF%BC%9F.html",
      "relativePath": "04.中间件/10.Netty/001.你熟悉哪些IO模型？.md",
      "key": "v-be02b3c0",
      "path": "/pages/40f3c9/",
      "headers": [
        {
          "level": 2,
          "title": "1.1 I/O基础入门",
          "slug": "_1-1-i-o基础入门",
          "normalizedTitle": "1.1 i/o基础入门",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "1.1.1 linux网络I/O模型简介",
          "slug": "_1-1-1-linux网络i-o模型简介",
          "normalizedTitle": "1.1.1 linux网络i/o模型简介",
          "charIndex": 141
        },
        {
          "level": 3,
          "title": "I/O多路复用技术",
          "slug": "i-o多路复用技术",
          "normalizedTitle": "i/o多路复用技术",
          "charIndex": 425
        },
        {
          "level": 2,
          "title": "1.2 Java的IO演进",
          "slug": "_1-2-java的io演进",
          "normalizedTitle": "1.2 java的io演进",
          "charIndex": 531
        },
        {
          "level": 2,
          "title": "2.1 传统的BIO编程",
          "slug": "_2-1-传统的bio编程",
          "normalizedTitle": "2.1 传统的bio编程",
          "charIndex": 595
        },
        {
          "level": 3,
          "title": "2.1.1 BIO通信模型图",
          "slug": "_2-1-1-bio通信模型图",
          "normalizedTitle": "2.1.1 bio通信模型图",
          "charIndex": 692
        },
        {
          "level": 2,
          "title": "2.2 伪异步IO模型",
          "slug": "_2-2-伪异步io模型",
          "normalizedTitle": "2.2 伪异步io模型",
          "charIndex": 767
        },
        {
          "level": 2,
          "title": "2.3 NIO模型",
          "slug": "_2-3-nio模型",
          "normalizedTitle": "2.3 nio模型",
          "charIndex": 877
        },
        {
          "level": 2,
          "title": "2.3.1 NIO简介",
          "slug": "_2-3-1-nio简介",
          "normalizedTitle": "2.3.1 nio简介",
          "charIndex": 891
        },
        {
          "level": 2,
          "title": "2.3.2 NIO服务序列图",
          "slug": "_2-3-2-nio服务序列图",
          "normalizedTitle": "2.3.2 nio服务序列图",
          "charIndex": 1035
        },
        {
          "level": 2,
          "title": "2.4 AIO",
          "slug": "_2-4-aio",
          "normalizedTitle": "2.4 aio",
          "charIndex": 1056
        }
      ],
      "headersStr": "1.1 I/O基础入门 1.1.1 linux网络I/O模型简介 I/O多路复用技术 1.2 Java的IO演进 2.1 传统的BIO编程 2.1.1 BIO通信模型图 2.2 伪异步IO模型 2.3 NIO模型 2.3.1 NIO简介 2.3.2 NIO服务序列图 2.4 AIO",
      "content": "# 1.1 I/O基础入门\n\nJava1.4之前对I/O的支持并不完善，给开发带来的问题有：\n\n * 没有数据缓冲区，I/O性能存在问题\n * 没有C/C++中channel的概念，只有输入输出流\n * BIO会导致通信被长时间阻塞\n * 支持的字符集优先，硬件移植性不好\n\n\n# 1.1.1 linux网络I/O模型简介\n\nlinux中所有的外部设备都是一个文件，socket也是一个文件，有文件描述符（fd）指向它。 UNIX提供5中I/O模型：\n\n * BIO模型：在进程空间调用recvfrom,直到有数据才返回。\n * NIO模型：轮训调用recvfrom。\n * I/O复用：linux提供select/poll，其支持多个fd的NIO，但是select/poll本身是阻塞的。epoll采用事件驱动的方式代替顺序扫描，其性能更高。\n * 信号驱动I/O模型：\n * 异步I/O:通知内核某个操作，并整个操作完成的时候通知我们。\n\n\n# I/O多路复用技术\n\nepoll优点：\n\n * 支持一个进程打开的fd不受限制\n * IO效率不会随着fd数量增加而下降\n * 使用mmap加速内核和用户空间的消息传递\n * epoll API更加简单\n\n\n# 1.2 Java的IO演进\n\n2011年JDK7发布：\n\n * 提供了能批量获取文件属性的API\n * 提供AIO功能\n\n\n# 2.1 传统的BIO编程\n\nCLient/Server模型中，Server负责绑定IP,启动监听端口；Client发起链接请求，经过三次握手建立连接，通过输入输出流进行同步阻塞式通信。\n\n\n# 2.1.1 BIO通信模型图\n\n通过Acceptor处理多个client连接请求，处理完成后销毁线程。 该模型的问题就是支持的线程数量有限。\n\n\n# 2.2 伪异步IO模型\n\n伪异步是为了解决BIO一个链路需要一个线程的问题。 通过一个线程池处理多个客户端的请求接入\n\n * 线程的数量不会大量膨胀导致资源耗尽\n * 问题是：没有解决同步IO导致的线程阻塞问题\n\n\n# 2.3 NIO模型\n\n\n# 2.3.1 NIO简介\n\n缓冲区buf 本质是一个字节数组（ByteBuff），同时提供数据的结构化访问以及维护读写位置。\n\n通道 channel channel是全双工的。 流是单向的。 多路复用 selector selector简单来说就是轮训注册在其上的channel,\n\n\n# 2.3.2 NIO服务序列图\n\n\n\n\n# 2.4 AIO",
      "normalizedContent": "# 1.1 i/o基础入门\n\njava1.4之前对i/o的支持并不完善，给开发带来的问题有：\n\n * 没有数据缓冲区，i/o性能存在问题\n * 没有c/c++中channel的概念，只有输入输出流\n * bio会导致通信被长时间阻塞\n * 支持的字符集优先，硬件移植性不好\n\n\n# 1.1.1 linux网络i/o模型简介\n\nlinux中所有的外部设备都是一个文件，socket也是一个文件，有文件描述符（fd）指向它。 unix提供5中i/o模型：\n\n * bio模型：在进程空间调用recvfrom,直到有数据才返回。\n * nio模型：轮训调用recvfrom。\n * i/o复用：linux提供select/poll，其支持多个fd的nio，但是select/poll本身是阻塞的。epoll采用事件驱动的方式代替顺序扫描，其性能更高。\n * 信号驱动i/o模型：\n * 异步i/o:通知内核某个操作，并整个操作完成的时候通知我们。\n\n\n# i/o多路复用技术\n\nepoll优点：\n\n * 支持一个进程打开的fd不受限制\n * io效率不会随着fd数量增加而下降\n * 使用mmap加速内核和用户空间的消息传递\n * epoll api更加简单\n\n\n# 1.2 java的io演进\n\n2011年jdk7发布：\n\n * 提供了能批量获取文件属性的api\n * 提供aio功能\n\n\n# 2.1 传统的bio编程\n\nclient/server模型中，server负责绑定ip,启动监听端口；client发起链接请求，经过三次握手建立连接，通过输入输出流进行同步阻塞式通信。\n\n\n# 2.1.1 bio通信模型图\n\n通过acceptor处理多个client连接请求，处理完成后销毁线程。 该模型的问题就是支持的线程数量有限。\n\n\n# 2.2 伪异步io模型\n\n伪异步是为了解决bio一个链路需要一个线程的问题。 通过一个线程池处理多个客户端的请求接入\n\n * 线程的数量不会大量膨胀导致资源耗尽\n * 问题是：没有解决同步io导致的线程阻塞问题\n\n\n# 2.3 nio模型\n\n\n# 2.3.1 nio简介\n\n缓冲区buf 本质是一个字节数组（bytebuff），同时提供数据的结构化访问以及维护读写位置。\n\n通道 channel channel是全双工的。 流是单向的。 多路复用 selector selector简单来说就是轮训注册在其上的channel,\n\n\n# 2.3.2 nio服务序列图\n\n\n\n\n# 2.4 aio",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述 Redis 如何处理热点 key 访问",
      "frontmatter": {
        "title": "简述 Redis 如何处理热点 key 访问",
        "date": "2022-05-21T17:23:43.000Z",
        "permalink": "/pages/795c09/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/110.%E7%AE%80%E8%BF%B0%20Redis%20%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%83%AD%E7%82%B9%20key%20%E8%AE%BF%E9%97%AE.html",
      "relativePath": "03.数据库/02.REDIS相关/110.简述 Redis 如何处理热点 key 访问.md",
      "key": "v-37f158ba",
      "path": "/pages/795c09/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Netty中有哪些解码器？",
      "frontmatter": {
        "title": "Netty中有哪些解码器？",
        "date": "2022-05-21T23:33:34.000Z",
        "permalink": "/pages/59089d/",
        "categories": [
          "中间件",
          "Netty"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/015.Netty%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E7%A0%81%E5%99%A8%EF%BC%9F.html",
      "relativePath": "04.中间件/10.Netty/015.Netty中有哪些解码器？.md",
      "key": "v-073f22cd",
      "path": "/pages/59089d/",
      "headers": [
        {
          "level": 2,
          "title": "5.1 DelimiterBasedFrameDecoder",
          "slug": "_5-1-delimiterbasedframedecoder",
          "normalizedTitle": "5.1 delimiterbasedframedecoder",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "5.2 FixedLengthFrameDecoder",
          "slug": "_5-2-fixedlengthframedecoder",
          "normalizedTitle": "5.2 fixedlengthframedecoder",
          "charIndex": 83
        }
      ],
      "headersStr": "5.1 DelimiterBasedFrameDecoder 5.2 FixedLengthFrameDecoder",
      "content": "# 5.1 DelimiterBasedFrameDecoder\n\n支持任意字符为分隔符 支持设置单条消息最大长度，如果找了最大长度还没找到分隔符就抛出异常\n\n\n# 5.2 FixedLengthFrameDecoder\n\n使用简单，指定包长渡就ok。",
      "normalizedContent": "# 5.1 delimiterbasedframedecoder\n\n支持任意字符为分隔符 支持设置单条消息最大长度，如果找了最大长度还没找到分隔符就抛出异常\n\n\n# 5.2 fixedlengthframedecoder\n\n使用简单，指定包长渡就ok。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "TCP粘包拆包问题的解决之道",
      "frontmatter": {
        "title": "TCP粘包拆包问题的解决之道",
        "date": "2022-05-21T23:32:33.000Z",
        "permalink": "/pages/3db019/",
        "categories": [
          "中间件",
          "Netty"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/010.TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93.html",
      "relativePath": "04.中间件/10.Netty/010.TCP粘包拆包问题的解决之道.md",
      "key": "v-5acdab4d",
      "path": "/pages/3db019/",
      "headers": [
        {
          "level": 2,
          "title": "4.1 TCP粘包/拆包",
          "slug": "_4-1-tcp粘包-拆包",
          "normalizedTitle": "4.1 tcp粘包/拆包",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "4.1.1 TCP粘包/拆包问题说明",
          "slug": "_4-1-1-tcp粘包-拆包问题说明",
          "normalizedTitle": "4.1.1 tcp粘包/拆包问题说明",
          "charIndex": 19
        },
        {
          "level": 3,
          "title": "4.1.2 TCP粘包/拆包发生的原因",
          "slug": "_4-1-2-tcp粘包-拆包发生的原因",
          "normalizedTitle": "4.1.2 tcp粘包/拆包发生的原因",
          "charIndex": 111
        },
        {
          "level": 3,
          "title": "4.1.3 TCP粘包/拆包问题的解决策略",
          "slug": "_4-1-3-tcp粘包-拆包问题的解决策略",
          "normalizedTitle": "4.1.3 tcp粘包/拆包问题的解决策略",
          "charIndex": 181
        },
        {
          "level": 2,
          "title": "4.3 Netty解决tcp粘包问题",
          "slug": "_4-3-netty解决tcp粘包问题",
          "normalizedTitle": "4.3 netty解决tcp粘包问题",
          "charIndex": 322
        }
      ],
      "headersStr": "4.1 TCP粘包/拆包 4.1.1 TCP粘包/拆包问题说明 4.1.2 TCP粘包/拆包发生的原因 4.1.3 TCP粘包/拆包问题的解决策略 4.3 Netty解决tcp粘包问题",
      "content": "# 4.1 TCP粘包/拆包\n\n\n# 4.1.1 TCP粘包/拆包问题说明\n\nTCP协议是”流“协议，流是没有间隔的。tcp会根据缓存大小将业务上的大包划分成多个小包发送出去、也可能多个小包合成一个大包发送出去。\n\n\n# 4.1.2 TCP粘包/拆包发生的原因\n\n * 应用层：大于套接字接口缓冲区大小\n * TCP层：MSS\n * IP层：MTU\n\n\n\n\n# 4.1.3 TCP粘包/拆包问题的解决策略\n\n * 消息定长len，例如每个报文固定200字节。那么读取到定长len后就重置计数器开始读取下一个包。\n * 包尾加换行符分割，如ftp。\n * 消息头+消息体。消息头包含消息长度信息。\n * 更复杂的应用协议，如netty.\n\n\n# 4.3 Netty解决tcp粘包问题\n\n * LineBasedFrameDecoder：原理是遍历ByteBuf中字节，以换行符分割\n * StringDecoder:将接收的byte对象转换为字符串，然后调用后面的handler 如果发送的消息不是以换行符结束的，netty也有其他解码器支持。",
      "normalizedContent": "# 4.1 tcp粘包/拆包\n\n\n# 4.1.1 tcp粘包/拆包问题说明\n\ntcp协议是”流“协议，流是没有间隔的。tcp会根据缓存大小将业务上的大包划分成多个小包发送出去、也可能多个小包合成一个大包发送出去。\n\n\n# 4.1.2 tcp粘包/拆包发生的原因\n\n * 应用层：大于套接字接口缓冲区大小\n * tcp层：mss\n * ip层：mtu\n\n\n\n\n# 4.1.3 tcp粘包/拆包问题的解决策略\n\n * 消息定长len，例如每个报文固定200字节。那么读取到定长len后就重置计数器开始读取下一个包。\n * 包尾加换行符分割，如ftp。\n * 消息头+消息体。消息头包含消息长度信息。\n * 更复杂的应用协议，如netty.\n\n\n# 4.3 netty解决tcp粘包问题\n\n * linebasedframedecoder：原理是遍历bytebuf中字节，以换行符分割\n * stringdecoder:将接收的byte对象转换为字符串，然后调用后面的handler 如果发送的消息不是以换行符结束的，netty也有其他解码器支持。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Redis 如何实现分布式锁？",
      "frontmatter": {
        "title": "Redis 如何实现分布式锁？",
        "date": "2022-05-21T17:21:32.000Z",
        "permalink": "/pages/656f46/",
        "categories": [
          "数据库",
          "REDIS相关"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.REDIS%E7%9B%B8%E5%85%B3/030.Redis%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F.html",
      "relativePath": "03.数据库/02.REDIS相关/030.Redis 如何实现分布式锁？.md",
      "key": "v-2c6b511c",
      "path": "/pages/656f46/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "为什么Netty要自己写一个ByteBuf",
      "frontmatter": {
        "title": "为什么Netty要自己写一个ByteBuf",
        "date": "2022-05-21T23:35:32.000Z",
        "permalink": "/pages/ef17ee/",
        "categories": [
          "中间件",
          "Netty"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/020.%E4%B8%BA%E4%BB%80%E4%B9%88Netty%E8%A6%81%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAByteBuf.html",
      "relativePath": "04.中间件/10.Netty/020.为什么Netty要自己写一个ByteBuf.md",
      "key": "v-bbcf6e5a",
      "path": "/pages/ef17ee/",
      "headers": [
        {
          "level": 2,
          "title": "15.2 ByteBuf源码分析",
          "slug": "_15-2-bytebuf源码分析",
          "normalizedTitle": "15.2 bytebuf源码分析",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "15.3 ByteBuffer相关辅助类",
          "slug": "_15-3-bytebuffer相关辅助类",
          "normalizedTitle": "15.3 bytebuffer相关辅助类",
          "charIndex": 8055
        }
      ],
      "headersStr": "15.2 ByteBuf源码分析 15.3 ByteBuffer相关辅助类",
      "content": "# 15.2 ByteBuf源码分析\n\n继承关系 从内存分配的角度看，byteBuf分为两类：\n\n * 堆内存缓冲区：优点是内存的分配和回收快。缺点是进行IO读写时需要一次内存复制，用户空间和内核空间的复制。\n * 直接内存缓冲区：优缺点和堆内存缓冲区整好相反。 经验表明ByteBuf的最佳实践是在IO通信线程的读写缓冲区使用DirectByteBuf,后端业务的编解码模块使用HeapByteBuf，这样的组合可以达到性能最优。 从内存回收的角度看、ByteBuf分两类，基于对象池的ByteBuf和普通ByteBuf。使用内存池后的Netty在高并发和高负载环境下内存和GC更加平稳。 15.2.1 AbstractByteBuf源码分析 实现ByteBuf的一些公共属性和功能。 主要成员变量\n\n    static final ResourceLeakDetector<ByteBuf> leakDetector =\n            ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);//用于对象是否泄漏，定义为static，意味着所有byteBuf共享\n\n    int readerIndex;//读索引\n    int writerIndex;//写索引\n    private int markedReaderIndex;//读mark\n    private int markedWriterIndex;//写mark\n    private int maxCapacity;//最大容量\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nByte数组不在这里，因为AbstractByteBuf无法确定使用直接内存还是堆内存。 readBytes(ByteBuf dst, int dstIndex, int length)\n\npublic ByteBuf readBytes(ByteBuf dst, int dstIndex, int length) {\n       checkReadableBytes(length);//校验可读性\n       getBytes(readerIndex, dst, dstIndex, length);//读取。从readerIndex开始读取length个字节到目标数组中\n       readerIndex += length;//移动读指针\n       return this;\n   }\n\n\n1\n2\n3\n4\n5\n6\n\n\n再看一下checkReadableBytes():\n\n/**\n     * Throws an {@link IndexOutOfBoundsException} if the current\n     * {@linkplain #readableBytes() readable bytes} of this buffer is less\n     * than the specified value.\n     */\n    protected final void checkReadableBytes(int minimumReadableBytes) {\n        if (minimumReadableBytes < 0) {\n            throw new IllegalArgumentException(\"minimumReadableBytes: \" + minimumReadableBytes + \" (expected: >= 0)\");\n        }\n        checkReadableBytes0(minimumReadableBytes);\n    }\n    \nprivate void checkReadableBytes0(int minimumReadableBytes) {\n        ensureAccessible();\n        if (readerIndex > writerIndex - minimumReadableBytes) {\n            throw new IndexOutOfBoundsException(String.format(\n                    \"readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s\",\n                    readerIndex, minimumReadableBytes, writerIndex, this));\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nwriteBytes(byte[] src, int srcIndex, int length)\n\npublic ByteBuf writeBytes(byte[] src, int srcIndex, int length) {\n        ensureWritable(length);//可写校验和扩容\n        setBytes(writerIndex, src, srcIndex, length);//从writerIndex开始写length长度\n        writerIndex += length;//移动写指针\n        return this;\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\nensureWritable(int minWritableBytes)\n\npublic ByteBuf ensureWritable(int minWritableBytes) {\n        if (minWritableBytes < 0) {\n            throw new IllegalArgumentException(String.format(\n                    \"minWritableBytes: %d (expected: >= 0)\", minWritableBytes));\n        }\n        ensureWritable0(minWritableBytes);\n        return this;\n    }\n    \nfinal void ensureWritable0(int minWritableBytes) {\n        ensureAccessible();//检查这个buf是否还有引用（如果已经没有引用那就没必要在写了）\n        if (minWritableBytes <= writableBytes()) {//写入的字节小于可写字节，校验通过\n            return;\n        }\n\n        if (minWritableBytes > maxCapacity - writerIndex) {//写入的字节大于最大可写入字节，抛异常\n            throw new IndexOutOfBoundsException(String.format(\n                    \"writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s\",\n                    writerIndex, minWritableBytes, maxCapacity, this));\n        }\n\n        // Normalize the current capacity to the power of 2.\n        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);\n\n        // Adjust to the new capacity.\n        capacity(newCapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n重用缓冲区\n\npublic ByteBuf discardReadBytes() {\n        ensureAccessible();\n        if (readerIndex == 0) {\n            return this;\n        }\n\n        if (readerIndex != writerIndex) {\n            setBytes(0, this, readerIndex, writerIndex - readerIndex);//复制缓冲区\n            writerIndex -= readerIndex;//重置写指针\n            adjustMarkers(readerIndex);//调整mark指针\n            readerIndex = 0;//重置读指针\n        } else {\n            adjustMarkers(readerIndex);\n            writerIndex = readerIndex = 0;\n        }\n        return this;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n15.2.2 AbstractReferenceCountedByteBuf源码分析\n\npublic abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {\n\n    private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater =\n            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, \"refCnt\");//通过原子的方式对成员变量进行更新，消除锁\n\n    private volatile int refCnt;//跟踪对象的引用次数，采用CAS对其自增1，默认值为1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n15.2.2 UnPooledHeapByteBuf源码分析 非池化的基于堆内存，频繁的大块内存分配和回收会对性能造成影响，但是相比对外内存的申请和释放，成本还是低一些。 相比HeapByteBuf， UnPooledHeapByteBuf的实现更加加单，也不容易出现内存管理方面的问题，因此在满足性能的条件下，推荐使用UnPooledHeapByteBuf。\n\npublic class UnpooledHeapByteBuf extends AbstractReferenceCountedByteBuf {\nprivate final ByteBufAllocator alloc;\n    byte[] array;//这里直接使用JDK的ByteBuffer也可以，之所以使用Byte数组是因为性能和便捷的位操作\n    private ByteBuffer tmpNioBuf;//用于实现将netty的byteBuf转换为JDK的ByteBuffer\n }\n\n\n1\n2\n3\n4\n5\n\n\n转换JDK Buffer netty基于byte数组实现 jdk的nio buf提供wrap方法，可直接实现 转换 看下转换方法\n\npublic ByteBuffer nioBuffer(int index, int length) {\n        ensureAccessible();\n        return ByteBuffer.wrap(array, index, length).slice();\n    }\npublic ByteBuffer slice() {\n        return new HeapByteBuffer(hb,//仍然使用的是原buffer的全局数组，只是改变了position和limit的位置，所以新buf和原buf内容是相互影响的\n                                        -1,\n                                        0,\n                                        this.remaining(),\n                                        this.remaining(),\n                                        this.position() + offset);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nslice方法的作用：copy position到limit之间的内容， 15.2.3 pooledByteBuf内存池原理分析 PoolArena是netty的内存池显现类。 为了集中管理内存，提供内存申请是释放的效率，很多框架会申请一大块内存，提供相应的接口分配和释放内存，这样就不再频繁的使用系统调用来使用内存，可以提高性能。预先申请的那块内存就叫Memory Arena。PoolArena是netty对Memory Arena的实现。 Netty的PoolArena由多个chunk组成，每个chunk由多个Page组成。 PoolArena源码：\n\nabstract class PoolArena<T> implements PoolArenaMetric {\n    static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();\n\n    enum SizeClass {\n        Tiny,\n        Small,\n        Normal\n    }\n\n    static final int numTinySubpagePools = 512 >>> 4;\n\n    final PooledByteBufAllocator parent;\n\n    private final int maxOrder;\n    final int pageSize;\n    final int pageShifts;\n    final int chunkSize;\n    final int subpageOverflowMask;\n    final int numSmallSubpagePools;\n    final int directMemoryCacheAlignment;\n    final int directMemoryCacheAlignmentMask;\n    private final PoolSubpage<T>[] tinySubpagePools;\n    private final PoolSubpage<T>[] smallSubpagePools;\n\n    private final PoolChunkList<T> q050;\n    private final PoolChunkList<T> q025;\n    private final PoolChunkList<T> q000;\n    private final PoolChunkList<T> qInit;\n    private final PoolChunkList<T> q075;\n    private final PoolChunkList<T> q100;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nPoolChunk的实现 PoolChunk负责多个Page的内存管理，PoolChunk将其负责的多个Page构建成一棵二叉树。 假设一个chunk由16个page组成，则其组织形式： Page大小是4字节，chunk大小是64字节。 每个节点都记录自己在整个Memory Arena中的偏移地址，一旦被分配，则该节点及其子节点在接下来的内存分配过程中会被忽略。 举例来说，我们申请16个字节空间，则第三层的某个节点会被标记为已分配，则再次分配内存的时候会从其他三个节点中分配。 分配内存时对树采用深度优先算法，但是从哪棵子树开始深度遍历是随机的。 PoolSubPage的实现 申请内存小于一个page，则内存分配在page中完成，每个page会被分为大小相等的多个块。 被分的单位块大小等于第一次申请的内存大小，例如一个Page8字节，第一次申请2字节，则该page被切分成4块，每块2字节。而且这个page以后只能用于分配2字节的内存申请，如果再来一个4字节的内存申请，只能在另一个Page中申请。 Page使用标识位来表示内存块是否可用。维护一个long数组，每个位表示一个块的使用情况。 例如page为128字节，第一次申请内存为1字节，则该page被分为128块，则long数组中有2个元素，（每个long64位，两个long可以表示128位）。0、1表示该块是否可用。 15.2.4 PooledDirectByteBuf内存池原理分析 创建字节缓冲区 由于采用内存池实现，所以创建PooledDirectByteBuf对象不能new一个实例，而是从内存池获取。然后设置引用计数器。\n\nstatic PooledDirectByteBuf newInstance(int maxCapacity) {\n        PooledDirectByteBuf buf = RECYCLER.get();\n        buf.reuse(maxCapacity);\n        return buf;\n    }\nfinal void reuse(int maxCapacity) {\n        maxCapacity(maxCapacity);\n        setRefCnt(1);\n        setIndex0(0, 0);\n        discardMarks();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复制字节缓冲区 会从内存池中获取一个新的buffer而不是new一个。\n\n\n# 15.3 ByteBuffer相关辅助类\n\n15.3.1 ByteBufHolder 对消息体进行包装和抽象，不同的子类有不同的实现。 实现ByteBufHolder的子类可以自己实现一些实用的方法。 Netty也有一些子类继承自ByteBufHolder。 15.3.2 ByteBufAllocator 字节缓冲区分配器，其实现类有两种：基于池的和普通的。 其API: 15.3.3 CompositeByteBuf 允许将多个ByteBuf组装到一起。 使用场景：如某协议包含消息头和消息体，当对消息进行编码的时候需要进行整合。 这种场景有两种实现方式：\n\n * 将一个buf复制到另一个buf。或者创建一个新的buf将两个buf都放到新的buf。\n * 通过List或其他集合容器，将两个buf都放入容器统一维护和处理。\n\n看下源码：\n\npublic class CompositeByteBuf extends AbstractReferenceCountedByteBuf implements Iterable<ByteBuf> {\n\n   private static final ByteBuffer EMPTY_NIO_BUFFER = Unpooled.EMPTY_BUFFER.nioBuffer();\n   private static final Iterator<ByteBuf> EMPTY_ITERATOR = Collections.<ByteBuf>emptyList().iterator();\n\n   private final ByteBufAllocator alloc;\n   private final boolean direct;\n   private final ComponentList components;//维护buf的容器\n   private final int maxNumComponents;\n\n   private boolean freed;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n再看下ComponentList：\n\nprivate static final class ComponentList extends ArrayList<Component> {\n\n        ComponentList(int initialCapacity) {\n            super(initialCapacity);\n        }\n\n        // Expose this methods so we not need to create a new subList just to remove a range of elements.\n        @Override\n        public void removeRange(int fromIndex, int toIndex) {\n            super.removeRange(fromIndex, toIndex);\n        }\n    }\n\nprivate static final class Component {\n        final ByteBuf buf;\n        final int length;\n        int offset;//在集合中的位置偏移\n        int endOffset;\n\n        Component(ByteBuf buf) {\n            this.buf = buf;\n            length = buf.readableBytes();\n        }\n\n        void freeIfNecessary() {\n            buf.release(); // We should not get a NPE here. If so, it must be a bug.\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n15.3.4 ByteBufUtil 几个常用的工具方法：\n\n * encodeString\n * decodeString\n * hexDump",
      "normalizedContent": "# 15.2 bytebuf源码分析\n\n继承关系 从内存分配的角度看，bytebuf分为两类：\n\n * 堆内存缓冲区：优点是内存的分配和回收快。缺点是进行io读写时需要一次内存复制，用户空间和内核空间的复制。\n * 直接内存缓冲区：优缺点和堆内存缓冲区整好相反。 经验表明bytebuf的最佳实践是在io通信线程的读写缓冲区使用directbytebuf,后端业务的编解码模块使用heapbytebuf，这样的组合可以达到性能最优。 从内存回收的角度看、bytebuf分两类，基于对象池的bytebuf和普通bytebuf。使用内存池后的netty在高并发和高负载环境下内存和gc更加平稳。 15.2.1 abstractbytebuf源码分析 实现bytebuf的一些公共属性和功能。 主要成员变量\n\n    static final resourceleakdetector<bytebuf> leakdetector =\n            resourceleakdetectorfactory.instance().newresourceleakdetector(bytebuf.class);//用于对象是否泄漏，定义为static，意味着所有bytebuf共享\n\n    int readerindex;//读索引\n    int writerindex;//写索引\n    private int markedreaderindex;//读mark\n    private int markedwriterindex;//写mark\n    private int maxcapacity;//最大容量\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nbyte数组不在这里，因为abstractbytebuf无法确定使用直接内存还是堆内存。 readbytes(bytebuf dst, int dstindex, int length)\n\npublic bytebuf readbytes(bytebuf dst, int dstindex, int length) {\n       checkreadablebytes(length);//校验可读性\n       getbytes(readerindex, dst, dstindex, length);//读取。从readerindex开始读取length个字节到目标数组中\n       readerindex += length;//移动读指针\n       return this;\n   }\n\n\n1\n2\n3\n4\n5\n6\n\n\n再看一下checkreadablebytes():\n\n/**\n     * throws an {@link indexoutofboundsexception} if the current\n     * {@linkplain #readablebytes() readable bytes} of this buffer is less\n     * than the specified value.\n     */\n    protected final void checkreadablebytes(int minimumreadablebytes) {\n        if (minimumreadablebytes < 0) {\n            throw new illegalargumentexception(\"minimumreadablebytes: \" + minimumreadablebytes + \" (expected: >= 0)\");\n        }\n        checkreadablebytes0(minimumreadablebytes);\n    }\n    \nprivate void checkreadablebytes0(int minimumreadablebytes) {\n        ensureaccessible();\n        if (readerindex > writerindex - minimumreadablebytes) {\n            throw new indexoutofboundsexception(string.format(\n                    \"readerindex(%d) + length(%d) exceeds writerindex(%d): %s\",\n                    readerindex, minimumreadablebytes, writerindex, this));\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nwritebytes(byte[] src, int srcindex, int length)\n\npublic bytebuf writebytes(byte[] src, int srcindex, int length) {\n        ensurewritable(length);//可写校验和扩容\n        setbytes(writerindex, src, srcindex, length);//从writerindex开始写length长度\n        writerindex += length;//移动写指针\n        return this;\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\nensurewritable(int minwritablebytes)\n\npublic bytebuf ensurewritable(int minwritablebytes) {\n        if (minwritablebytes < 0) {\n            throw new illegalargumentexception(string.format(\n                    \"minwritablebytes: %d (expected: >= 0)\", minwritablebytes));\n        }\n        ensurewritable0(minwritablebytes);\n        return this;\n    }\n    \nfinal void ensurewritable0(int minwritablebytes) {\n        ensureaccessible();//检查这个buf是否还有引用（如果已经没有引用那就没必要在写了）\n        if (minwritablebytes <= writablebytes()) {//写入的字节小于可写字节，校验通过\n            return;\n        }\n\n        if (minwritablebytes > maxcapacity - writerindex) {//写入的字节大于最大可写入字节，抛异常\n            throw new indexoutofboundsexception(string.format(\n                    \"writerindex(%d) + minwritablebytes(%d) exceeds maxcapacity(%d): %s\",\n                    writerindex, minwritablebytes, maxcapacity, this));\n        }\n\n        // normalize the current capacity to the power of 2.\n        int newcapacity = alloc().calculatenewcapacity(writerindex + minwritablebytes, maxcapacity);\n\n        // adjust to the new capacity.\n        capacity(newcapacity);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n重用缓冲区\n\npublic bytebuf discardreadbytes() {\n        ensureaccessible();\n        if (readerindex == 0) {\n            return this;\n        }\n\n        if (readerindex != writerindex) {\n            setbytes(0, this, readerindex, writerindex - readerindex);//复制缓冲区\n            writerindex -= readerindex;//重置写指针\n            adjustmarkers(readerindex);//调整mark指针\n            readerindex = 0;//重置读指针\n        } else {\n            adjustmarkers(readerindex);\n            writerindex = readerindex = 0;\n        }\n        return this;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n15.2.2 abstractreferencecountedbytebuf源码分析\n\npublic abstract class abstractreferencecountedbytebuf extends abstractbytebuf {\n\n    private static final atomicintegerfieldupdater<abstractreferencecountedbytebuf> refcntupdater =\n            atomicintegerfieldupdater.newupdater(abstractreferencecountedbytebuf.class, \"refcnt\");//通过原子的方式对成员变量进行更新，消除锁\n\n    private volatile int refcnt;//跟踪对象的引用次数，采用cas对其自增1，默认值为1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n15.2.2 unpooledheapbytebuf源码分析 非池化的基于堆内存，频繁的大块内存分配和回收会对性能造成影响，但是相比对外内存的申请和释放，成本还是低一些。 相比heapbytebuf， unpooledheapbytebuf的实现更加加单，也不容易出现内存管理方面的问题，因此在满足性能的条件下，推荐使用unpooledheapbytebuf。\n\npublic class unpooledheapbytebuf extends abstractreferencecountedbytebuf {\nprivate final bytebufallocator alloc;\n    byte[] array;//这里直接使用jdk的bytebuffer也可以，之所以使用byte数组是因为性能和便捷的位操作\n    private bytebuffer tmpniobuf;//用于实现将netty的bytebuf转换为jdk的bytebuffer\n }\n\n\n1\n2\n3\n4\n5\n\n\n转换jdk buffer netty基于byte数组实现 jdk的nio buf提供wrap方法，可直接实现 转换 看下转换方法\n\npublic bytebuffer niobuffer(int index, int length) {\n        ensureaccessible();\n        return bytebuffer.wrap(array, index, length).slice();\n    }\npublic bytebuffer slice() {\n        return new heapbytebuffer(hb,//仍然使用的是原buffer的全局数组，只是改变了position和limit的位置，所以新buf和原buf内容是相互影响的\n                                        -1,\n                                        0,\n                                        this.remaining(),\n                                        this.remaining(),\n                                        this.position() + offset);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nslice方法的作用：copy position到limit之间的内容， 15.2.3 pooledbytebuf内存池原理分析 poolarena是netty的内存池显现类。 为了集中管理内存，提供内存申请是释放的效率，很多框架会申请一大块内存，提供相应的接口分配和释放内存，这样就不再频繁的使用系统调用来使用内存，可以提高性能。预先申请的那块内存就叫memory arena。poolarena是netty对memory arena的实现。 netty的poolarena由多个chunk组成，每个chunk由多个page组成。 poolarena源码：\n\nabstract class poolarena<t> implements poolarenametric {\n    static final boolean has_unsafe = platformdependent.hasunsafe();\n\n    enum sizeclass {\n        tiny,\n        small,\n        normal\n    }\n\n    static final int numtinysubpagepools = 512 >>> 4;\n\n    final pooledbytebufallocator parent;\n\n    private final int maxorder;\n    final int pagesize;\n    final int pageshifts;\n    final int chunksize;\n    final int subpageoverflowmask;\n    final int numsmallsubpagepools;\n    final int directmemorycachealignment;\n    final int directmemorycachealignmentmask;\n    private final poolsubpage<t>[] tinysubpagepools;\n    private final poolsubpage<t>[] smallsubpagepools;\n\n    private final poolchunklist<t> q050;\n    private final poolchunklist<t> q025;\n    private final poolchunklist<t> q000;\n    private final poolchunklist<t> qinit;\n    private final poolchunklist<t> q075;\n    private final poolchunklist<t> q100;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\npoolchunk的实现 poolchunk负责多个page的内存管理，poolchunk将其负责的多个page构建成一棵二叉树。 假设一个chunk由16个page组成，则其组织形式： page大小是4字节，chunk大小是64字节。 每个节点都记录自己在整个memory arena中的偏移地址，一旦被分配，则该节点及其子节点在接下来的内存分配过程中会被忽略。 举例来说，我们申请16个字节空间，则第三层的某个节点会被标记为已分配，则再次分配内存的时候会从其他三个节点中分配。 分配内存时对树采用深度优先算法，但是从哪棵子树开始深度遍历是随机的。 poolsubpage的实现 申请内存小于一个page，则内存分配在page中完成，每个page会被分为大小相等的多个块。 被分的单位块大小等于第一次申请的内存大小，例如一个page8字节，第一次申请2字节，则该page被切分成4块，每块2字节。而且这个page以后只能用于分配2字节的内存申请，如果再来一个4字节的内存申请，只能在另一个page中申请。 page使用标识位来表示内存块是否可用。维护一个long数组，每个位表示一个块的使用情况。 例如page为128字节，第一次申请内存为1字节，则该page被分为128块，则long数组中有2个元素，（每个long64位，两个long可以表示128位）。0、1表示该块是否可用。 15.2.4 pooleddirectbytebuf内存池原理分析 创建字节缓冲区 由于采用内存池实现，所以创建pooleddirectbytebuf对象不能new一个实例，而是从内存池获取。然后设置引用计数器。\n\nstatic pooleddirectbytebuf newinstance(int maxcapacity) {\n        pooleddirectbytebuf buf = recycler.get();\n        buf.reuse(maxcapacity);\n        return buf;\n    }\nfinal void reuse(int maxcapacity) {\n        maxcapacity(maxcapacity);\n        setrefcnt(1);\n        setindex0(0, 0);\n        discardmarks();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复制字节缓冲区 会从内存池中获取一个新的buffer而不是new一个。\n\n\n# 15.3 bytebuffer相关辅助类\n\n15.3.1 bytebufholder 对消息体进行包装和抽象，不同的子类有不同的实现。 实现bytebufholder的子类可以自己实现一些实用的方法。 netty也有一些子类继承自bytebufholder。 15.3.2 bytebufallocator 字节缓冲区分配器，其实现类有两种：基于池的和普通的。 其api: 15.3.3 compositebytebuf 允许将多个bytebuf组装到一起。 使用场景：如某协议包含消息头和消息体，当对消息进行编码的时候需要进行整合。 这种场景有两种实现方式：\n\n * 将一个buf复制到另一个buf。或者创建一个新的buf将两个buf都放到新的buf。\n * 通过list或其他集合容器，将两个buf都放入容器统一维护和处理。\n\n看下源码：\n\npublic class compositebytebuf extends abstractreferencecountedbytebuf implements iterable<bytebuf> {\n\n   private static final bytebuffer empty_nio_buffer = unpooled.empty_buffer.niobuffer();\n   private static final iterator<bytebuf> empty_iterator = collections.<bytebuf>emptylist().iterator();\n\n   private final bytebufallocator alloc;\n   private final boolean direct;\n   private final componentlist components;//维护buf的容器\n   private final int maxnumcomponents;\n\n   private boolean freed;\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n再看下componentlist：\n\nprivate static final class componentlist extends arraylist<component> {\n\n        componentlist(int initialcapacity) {\n            super(initialcapacity);\n        }\n\n        // expose this methods so we not need to create a new sublist just to remove a range of elements.\n        @override\n        public void removerange(int fromindex, int toindex) {\n            super.removerange(fromindex, toindex);\n        }\n    }\n\nprivate static final class component {\n        final bytebuf buf;\n        final int length;\n        int offset;//在集合中的位置偏移\n        int endoffset;\n\n        component(bytebuf buf) {\n            this.buf = buf;\n            length = buf.readablebytes();\n        }\n\n        void freeifnecessary() {\n            buf.release(); // we should not get a npe here. if so, it must be a bug.\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n15.3.4 bytebufutil 几个常用的工具方法：\n\n * encodestring\n * decodestring\n * hexdump",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "ChannelPipeline和ChannelHandler",
      "frontmatter": {
        "title": "ChannelPipeline和ChannelHandler",
        "date": "2022-05-21T23:36:46.000Z",
        "permalink": "/pages/f851b6/",
        "categories": [
          "中间件",
          "Netty"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/030.ChannelPipeline%E5%92%8CChannelHandler.html",
      "relativePath": "04.中间件/10.Netty/030.ChannelPipeline和ChannelHandler.md",
      "key": "v-5157927c",
      "path": "/pages/f851b6/",
      "headers": [
        {
          "level": 2,
          "title": "ChannelPipeline和ChannelHandler",
          "slug": "channelpipeline和channelhandler",
          "normalizedTitle": "channelpipeline和channelhandler",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "17.1 ChannelPipeline的功能说明",
          "slug": "_17-1-channelpipeline的功能说明",
          "normalizedTitle": "17.1 channelpipeline的功能说明",
          "charIndex": 170
        },
        {
          "level": 2,
          "title": "17.1 ChannelPipeline源码",
          "slug": "_17-1-channelpipeline源码",
          "normalizedTitle": "17.1 channelpipeline源码",
          "charIndex": 641
        }
      ],
      "headersStr": "ChannelPipeline和ChannelHandler 17.1 ChannelPipeline的功能说明 17.1 ChannelPipeline源码",
      "content": "# ChannelPipeline和ChannelHandler\n\nChannelPipeline是对Channel的封装，ChannelPipeline持有时间拦截器ChannelHandler的链表，由ChannelHandler对I/O事件拦截和处理，可以通过新增和删除ChannelHandler来实现不同业务的逻辑定制。\n\n\n# 17.1 ChannelPipeline的功能说明\n\nChannelPipeline是ChannelHandler的容器，负责ChannelHandler的管理和事件拦截 17.1.1 ChannelPipeline的事件处理 Netty中的事件分为inbound和outbound事件 inbound事件通常由IO线程触发，如tcp连接建立、断开、异常通知等 outbound事件通常是由用户主动发起的网络IO操作，如用户发起的绑定本地地址，发送消息等 17.1.2 自定义拦截器 通常ChannelHandler只需要继承ChannelHandlerAdapter类覆盖自己关心的方法即可。 17.1.3 ChannelPipeline的主要特性 ChannelPipeline支持动态添加或者删除ChannelHandler。使用场景（业务高峰期加入拥塞保护ChannelHandler，高峰过后删掉ChannelHandler）。 ChannelPipeline是线程安全的，但是ChannelHandler不是线程安全的。\n\n\n# 17.1 ChannelPipeline源码\n\n实际上是ChannelHandler 的容器，内部维护了一个ChannelHandler链表和迭代器。",
      "normalizedContent": "# channelpipeline和channelhandler\n\nchannelpipeline是对channel的封装，channelpipeline持有时间拦截器channelhandler的链表，由channelhandler对i/o事件拦截和处理，可以通过新增和删除channelhandler来实现不同业务的逻辑定制。\n\n\n# 17.1 channelpipeline的功能说明\n\nchannelpipeline是channelhandler的容器，负责channelhandler的管理和事件拦截 17.1.1 channelpipeline的事件处理 netty中的事件分为inbound和outbound事件 inbound事件通常由io线程触发，如tcp连接建立、断开、异常通知等 outbound事件通常是由用户主动发起的网络io操作，如用户发起的绑定本地地址，发送消息等 17.1.2 自定义拦截器 通常channelhandler只需要继承channelhandleradapter类覆盖自己关心的方法即可。 17.1.3 channelpipeline的主要特性 channelpipeline支持动态添加或者删除channelhandler。使用场景（业务高峰期加入拥塞保护channelhandler，高峰过后删掉channelhandler）。 channelpipeline是线程安全的，但是channelhandler不是线程安全的。\n\n\n# 17.1 channelpipeline源码\n\n实际上是channelhandler 的容器，内部维护了一个channelhandler链表和迭代器。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "EventLoop和EventLoopGroup",
      "frontmatter": {
        "title": "EventLoop和EventLoopGroup",
        "date": "2022-05-21T23:37:23.000Z",
        "permalink": "/pages/e7aa60/",
        "categories": [
          "中间件",
          "Netty"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/040.EventLoop%E5%92%8CEventLoopGroup.html",
      "relativePath": "04.中间件/10.Netty/040.EventLoop和EventLoopGroup.md",
      "key": "v-62f3fa3e",
      "path": "/pages/e7aa60/",
      "headers": [
        {
          "level": 2,
          "title": "EventLoop和EventLoopGroup",
          "slug": "eventloop和eventloopgroup",
          "normalizedTitle": "eventloop和eventloopgroup",
          "charIndex": 2
        }
      ],
      "headersStr": "EventLoop和EventLoopGroup",
      "content": "# EventLoop和EventLoopGroup\n\nEventLoop负责处理连接中的事件， 和EvenvLoop有关的几个概念是：Channel, EventLoopGroup。\n\n * 一个EventLoopGroup包含一个或多个EventLoop。\n * 一个EventLoop对应于一个线程，所有EventLoop处理的I/O事件都在这个线程中完成。\n * 一个Channel对应唯一个一个EventLoop。\n * 一个EventLoop可以对应多个Channel。\n\n对于基于Netty的网络服务，Client端启动需要一个EventLoopGroup， Server端启动需要两个EventLoopGroup, 因为Server端需要两种Channel, 一种是ServerChannel, 只有一个，负责接受连接，另一种是用于处理连接的一组Channel。\n\nEventLoop继承了concurrent包里的 ScheduledExecutorService，这使得它可以接受Callable或者Runnable并执行。EventLoop中的parent()方法返回包含这个EventLoop的EventLoopGroup",
      "normalizedContent": "# eventloop和eventloopgroup\n\neventloop负责处理连接中的事件， 和evenvloop有关的几个概念是：channel, eventloopgroup。\n\n * 一个eventloopgroup包含一个或多个eventloop。\n * 一个eventloop对应于一个线程，所有eventloop处理的i/o事件都在这个线程中完成。\n * 一个channel对应唯一个一个eventloop。\n * 一个eventloop可以对应多个channel。\n\n对于基于netty的网络服务，client端启动需要一个eventloopgroup， server端启动需要两个eventloopgroup, 因为server端需要两种channel, 一种是serverchannel, 只有一个，负责接受连接，另一种是用于处理连接的一组channel。\n\neventloop继承了concurrent包里的 scheduledexecutorservice，这使得它可以接受callable或者runnable并执行。eventloop中的parent()方法返回包含这个eventloop的eventloopgroup",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Java NIO了解吗？",
      "frontmatter": {
        "title": "Java NIO了解吗？",
        "date": "2022-05-21T23:39:27.000Z",
        "permalink": "/pages/bfdcc8/",
        "categories": [
          "中间件",
          "Netty"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/10.Netty/050.Java%20NIO%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F.html",
      "relativePath": "04.中间件/10.Netty/050.Java NIO了解吗？.md",
      "key": "v-6b32ada0",
      "path": "/pages/bfdcc8/",
      "headers": [
        {
          "level": 2,
          "title": "1.1 IO概念",
          "slug": "_1-1-io概念",
          "normalizedTitle": "1.1 io概念",
          "charIndex": 22
        },
        {
          "level": 3,
          "title": "1.1.1 Buffer Handler",
          "slug": "_1-1-1-buffer-handler",
          "normalizedTitle": "1.1.1 buffer handler",
          "charIndex": 35
        },
        {
          "level": 3,
          "title": "1.1.1 scatter/gather",
          "slug": "_1-1-1-scatter-gather",
          "normalizedTitle": "1.1.1 scatter/gather",
          "charIndex": 537
        },
        {
          "level": 3,
          "title": "1.1.2 虚拟内存",
          "slug": "_1-1-2-虚拟内存",
          "normalizedTitle": "1.1.2 虚拟内存",
          "charIndex": 1452
        },
        {
          "level": 3,
          "title": "1.1.3 内存页",
          "slug": "_1-1-3-内存页",
          "normalizedTitle": "1.1.3 内存页",
          "charIndex": 1664
        },
        {
          "level": 3,
          "title": "1.1.4 文件IO",
          "slug": "_1-1-4-文件io",
          "normalizedTitle": "1.1.4 文件io",
          "charIndex": 1791
        },
        {
          "level": 3,
          "title": "1.1.5 IO流",
          "slug": "_1-1-5-io流",
          "normalizedTitle": "1.1.5 io流",
          "charIndex": 1900
        },
        {
          "level": 2,
          "title": "2.1 Buffer Basic",
          "slug": "_2-1-buffer-basic",
          "normalizedTitle": "2.1 buffer basic",
          "charIndex": 2130
        },
        {
          "level": 3,
          "title": "2.1.1 Buffer的几个属性",
          "slug": "_2-1-1-buffer的几个属性",
          "normalizedTitle": "2.1.1 buffer的几个属性",
          "charIndex": 2151
        },
        {
          "level": 3,
          "title": "2.1.2 Buffer API",
          "slug": "_2-1-2-buffer-api",
          "normalizedTitle": "2.1.2 buffer api",
          "charIndex": 2215
        },
        {
          "level": 3,
          "title": "2.1.3 访问Buffer",
          "slug": "_2-1-3-访问buffer",
          "normalizedTitle": "2.1.3 访问buffer",
          "charIndex": 2740
        },
        {
          "level": 3,
          "title": "2.1.4 write",
          "slug": "_2-1-4-write",
          "normalizedTitle": "2.1.4 write",
          "charIndex": 3055
        },
        {
          "level": 3,
          "title": "2.1.5 Flipping",
          "slug": "_2-1-5-flipping",
          "normalizedTitle": "2.1.5 flipping",
          "charIndex": 3270
        },
        {
          "level": 3,
          "title": "2.1.6 Draining",
          "slug": "_2-1-6-draining",
          "normalizedTitle": "2.1.6 draining",
          "charIndex": 3522
        },
        {
          "level": 3,
          "title": "2.1.7 Compacting",
          "slug": "_2-1-7-compacting",
          "normalizedTitle": "2.1.7 compacting",
          "charIndex": 3872
        },
        {
          "level": 3,
          "title": "2.1.9 Mark",
          "slug": "_2-1-9-mark",
          "normalizedTitle": "2.1.9 mark",
          "charIndex": 3998
        },
        {
          "level": 3,
          "title": "2.1.9 Comparing",
          "slug": "_2-1-9-comparing",
          "normalizedTitle": "2.1.9 comparing",
          "charIndex": 4147
        },
        {
          "level": 3,
          "title": "2.2 创建Buffer",
          "slug": "_2-2-创建buffer",
          "normalizedTitle": "2.2 创建buffer",
          "charIndex": 4476
        },
        {
          "level": 2,
          "title": "2.3 Duplicating Buffers",
          "slug": "_2-3-duplicating-buffers",
          "normalizedTitle": "2.3 duplicating buffers",
          "charIndex": 5030
        },
        {
          "level": 2,
          "title": "2.4 Byte Buffers",
          "slug": "_2-4-byte-buffers",
          "normalizedTitle": "2.4 byte buffers",
          "charIndex": 5966
        },
        {
          "level": 3,
          "title": "2.4.1 Byte Ordering",
          "slug": "_2-4-1-byte-ordering",
          "normalizedTitle": "2.4.1 byte ordering",
          "charIndex": 5987
        },
        {
          "level": 3,
          "title": "2.4.2 Direct Buffers",
          "slug": "_2-4-2-direct-buffers",
          "normalizedTitle": "2.4.2 direct buffers",
          "charIndex": 6473
        },
        {
          "level": 3,
          "title": "2.4.3 View Buffers",
          "slug": "_2-4-3-view-buffers",
          "normalizedTitle": "2.4.3 view buffers",
          "charIndex": 6835
        },
        {
          "level": 3,
          "title": "2.4.4 Data Element Views",
          "slug": "_2-4-4-data-element-views",
          "normalizedTitle": "2.4.4 data element views",
          "charIndex": 7400
        },
        {
          "level": 2,
          "title": "3.1 basic",
          "slug": "_3-1-basic",
          "normalizedTitle": "3.1 basic",
          "charIndex": 7698
        },
        {
          "level": 3,
          "title": "3.1.1 Open channel",
          "slug": "_3-1-1-open-channel",
          "normalizedTitle": "3.1.1 open channel",
          "charIndex": 8270
        },
        {
          "level": 3,
          "title": "3.1.2 Using Channels",
          "slug": "_3-1-2-using-channels",
          "normalizedTitle": "3.1.2 using channels",
          "charIndex": 8725
        },
        {
          "level": 3,
          "title": "3.1.3 close Channels",
          "slug": "_3-1-3-close-channels",
          "normalizedTitle": "3.1.3 close channels",
          "charIndex": 9090
        },
        {
          "level": 2,
          "title": "3.2 Scatter/Gather",
          "slug": "_3-2-scatter-gather",
          "normalizedTitle": "3.2 scatter/gather",
          "charIndex": 9115
        },
        {
          "level": 2,
          "title": "3.3 File Channels",
          "slug": "_3-3-file-channels",
          "normalizedTitle": "3.3 file channels",
          "charIndex": 9200
        },
        {
          "level": 2,
          "title": "3.3.1 Accessing Files",
          "slug": "_3-3-1-accessing-files",
          "normalizedTitle": "3.3.1 accessing files",
          "charIndex": 9248
        },
        {
          "level": 3,
          "title": "3.3.2 File Locking",
          "slug": "_3-3-2-file-locking",
          "normalizedTitle": "3.3.2 file locking",
          "charIndex": 10039
        },
        {
          "level": 2,
          "title": "3.4 Memory-Mapped Files",
          "slug": "_3-4-memory-mapped-files",
          "normalizedTitle": "3.4 memory-mapped files",
          "charIndex": 10062
        },
        {
          "level": 2,
          "title": "3.5 Socket Channels",
          "slug": "_3-5-socket-channels",
          "normalizedTitle": "3.5 socket channels",
          "charIndex": 10090
        },
        {
          "level": 3,
          "title": "3.5.1 Nonblocking Mode",
          "slug": "_3-5-1-nonblocking-mode",
          "normalizedTitle": "3.5.1 nonblocking mode",
          "charIndex": 10562
        },
        {
          "level": 3,
          "title": "3.5.2 ServerSocketChannel",
          "slug": "_3-5-2-serversocketchannel",
          "normalizedTitle": "3.5.2 serversocketchannel",
          "charIndex": 11237
        },
        {
          "level": 3,
          "title": "3.5.4 DatagramChannel",
          "slug": "_3-5-4-datagramchannel",
          "normalizedTitle": "3.5.4 datagramchannel",
          "charIndex": 12348
        },
        {
          "level": 3,
          "title": "3.5.5 Pipes",
          "slug": "_3-5-5-pipes",
          "normalizedTitle": "3.5.5 pipes",
          "charIndex": 12444
        },
        {
          "level": 2,
          "title": "4.1 基础",
          "slug": "_4-1-基础",
          "normalizedTitle": "4.1 基础",
          "charIndex": 13917
        },
        {
          "level": 2,
          "title": "4.2 示例",
          "slug": "_4-2-示例",
          "normalizedTitle": "4.2 示例",
          "charIndex": 14101
        }
      ],
      "headersStr": "1.1 IO概念 1.1.1 Buffer Handler 1.1.1 scatter/gather 1.1.2 虚拟内存 1.1.3 内存页 1.1.4 文件IO 1.1.5 IO流 2.1 Buffer Basic 2.1.1 Buffer的几个属性 2.1.2 Buffer API 2.1.3 访问Buffer 2.1.4 write 2.1.5 Flipping 2.1.6 Draining 2.1.7 Compacting 2.1.9 Mark 2.1.9 Comparing 2.2 创建Buffer 2.3 Duplicating Buffers 2.4 Byte Buffers 2.4.1 Byte Ordering 2.4.2 Direct Buffers 2.4.3 View Buffers 2.4.4 Data Element Views 3.1 basic 3.1.1 Open channel 3.1.2 Using Channels 3.1.3 close Channels 3.2 Scatter/Gather 3.3 File Channels 3.3.1 Accessing Files 3.3.2 File Locking 3.4 Memory-Mapped Files 3.5 Socket Channels 3.5.1 Nonblocking Mode 3.5.2 ServerSocketChannel 3.5.4 DatagramChannel 3.5.5 Pipes 4.1 基础 4.2 示例",
      "content": "@TOC\n\n\n# 第一章 IO介绍\n\n\n# 1.1 IO概念\n\n\n# 1.1.1 Buffer Handler\n\n内存分为用户空间（User space），内核空间（Kernel space）。 用户空间的数据读写需要通过内存空间传递。 如下图所示，用户需要读数据，则向cpu发送一个读请求，cpu相应这个请求控制disk controller从disk读取数据到内核buffer，然后再把内核buffer的数据推送给用户空间的buffer。 为什么要区分用户空间和内核空间呢？ 每个进程有独立的内存空间好处在于多个进程的内存分配互不影响。如果多个进程共享一块内存，那么内存分配的时候就得排队。\n\n为什么用户空间不能直接从disk读数据呢？\n\n * 硬件控制器只能处理固定大小的数据，用户空间需要的可能是数据块大小异常或者不对齐的数据，内核空间起作到数拆分、重组的作用。\n * 硬件设备通常不允许直接操作虚拟内存，即用户空间\n\nDMA是什么？ DMA(Direct Memory Access,直接存储器访问)。 在DMA之前通过中断CPU来传输数据。CPU响应中断，控制总线传输数据。 DMA不需要CPU参与数据传输。DMA可以和CPU交互请求控制总线传输数据。\n\n\n# 1.1.1 scatter/gather\n\n分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。 聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。\n\n比如某个协议的消息固定消息头128字节，消息体1024字节，消息尾128字节。我们想要分别处理消息头，消息体，消息尾。 使用scatter示例代码:\n\nByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body   = ByteBuffer.allocate(1024);\nByteBuffer tail   = ByteBuffer.allocate(128);\n\nByteBuffer[] bufferArray = { header, body,tail };\nchannel.read(bufferArray);\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。 所以。\n\nscatter不适合处理动态消息，相反，gather适合处理动态消息。 buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。\n\n\n# 1.1.2 虚拟内存\n\n虚拟内存是指使用虚拟内存地址代替物理内存地址。\n\n * 会有多个虚拟内存指向同一个物理内存\n * 虚拟内存可能会大于物理内存 上面说disk controller不可以直接把数据读到用户空间。虚拟内存可以通过虚拟地址映射内核空间的方式做到这一点。 如下图，内核空间的buffer对用户空间也是可见的。这就是netty零拷贝的原理，这减少了buffer在用户空间和内核空间的拷贝，非常有意义。\n\n\n# 1.1.3 内存页\n\n操作系统将内存按固定字节分页。 内存读取的基本单位是页。\n\nMMU(Memory Management Unit):内存管理单元，保存虚拟内存和物理内存的映射关系，处在CPU和内存之间，起到将虚拟内存转换为物理内存的作用。\n\n\n# 1.1.4 文件IO\n\n文件系统：文件IO发生在文件系统。文件保存在磁盘，磁盘扇区类似内存分页的概念。内存文件读取通过文件系统间接操作磁盘文件。 文件零拷贝如下图。避免了文件系统内存页和用户内存页之间的拷贝。\n\n\n# 1.1.5 IO流\n\n上面说的IO都是面向块的IO。还有面向流的IO。 大多数操作系统支持将流置为非阻塞模式，额外设置一个进程用于检查流上是否有输入，因此流本身是不被阻塞的。 网络IO一般都是流IO。 多路复用：用一个进程管理多个非阻塞IO流的状态。\n\n\n# 第二章 Buffer\n\n标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。\n\n\n# 2.1 Buffer Basic\n\n\n# 2.1.1 Buffer的几个属性\n\n * capacity\n * limit\n * position\n * mark\n\n\n# 2.1.2 Buffer API\n\npackage java.nio;\npublic abstract class Buffer {\npublic final int capacity()\npublic final int position()\npublic final Buffer position (int newPosition) public final int limit()\n  }\npublic final Buffer limit (int newLimit)\npublic final Buffer mark()\npublic final Buffer reset()\npublic final Buffer clear()\npublic final Buffer flip()\npublic final Buffer rewind()\npublic final int remaining()\npublic final boolean hasRemaining()\npublic abstract boolean isReadOnly();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.1.3 访问Buffer\n\npublic abstract class ByteBuffer\n       extends Buffer implements Comparable\n {\n// This is a partial API listing\npublic abstract byte get();\npublic abstract byte get (int index);\npublic abstract ByteBuffer put (byte b);\npublic abstract ByteBuffer put (int index, byte b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.1.4 write\n\nFigure 2-2的buffer经过下面这个代码会变成Figure 2-3的样子：\n\nbuffer.put((byte)'H').put((byte)'e').put((byte)'l')\n.put((byte)'l').put( (byte)'o');\n\n\n1\n2\n\n\n也可以按绝对位置写入：\n\nbuffer.put(0, (byte)'M').put((byte)'w');\n\n\n1\n\n\n\n\n\n# 2.1.5 Flipping\n\n当我们想要写出buffer的内容时，我们需要用position和limit指针指向时机内容的起始位置。类似这样：\n\nbuffer.limit(buffer.position()).position(0);\n\n\n1\n\n\n这等同于buffer.flip(); 调用flip()后2-4会变成2-5 说白了，flip()改变position和limit两个指针。 rewind()只改变position指针，等同于：\n\nbuffer.position(0);\n\n\n1\n\n\n\n# 2.1.6 Draining\n\nhasRemaining()可以判断是否到达limit指针 下面是一个实现，将buffer内容读到一个数组中\n\nfor (int i = 0; buffer.hasRemaining(), i++) {\n       myByteArray [i] = buffer.get();\n}\n\n\n1\n2\n3\n\n\nremaining()会返回position到limit的数量。 将buffer内容读到一个数组中另一种实现方式：\n\nint count = buffer.remaining();\nfor (int i = 0; i < count, i++) {\n       myByteArray [i] = buffer.get();\n}\n\n\n1\n2\n3\n4\n\n\n\n# 2.1.7 Compacting\n\n当你drain一部分数据想要继续fill数据的时候，你需要把还未drain的数据整体前移。 buffer.compact()；可以完成这个工作。 调用buffer.compact()的效果就是2-6到2-7\n\n\n# 2.1.9 Mark\n\nmark()方法会用mark指针指向position的位置。\n\nbuffer.position(2).mark().position(4);\n\n\n1\n\n\nreset()方法会把position指针指向mark的位置。\n\nbuffer.reset();\n\n\n1\n\n\n\n\n\n# 2.1.9 Comparing\n\npublic abstract class ByteBuffer\n       extends Buffer implements Comparable\n  {\n  // This is a partial API listing\npublic boolean equals (Object ob)\npublic int compareTo (Object ob)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nequals()返回true需要满足三个条件：\n\n * Buffer包含相同类型的元素\n * 两个Buffer的remaining()返回值相同\n * remaining data的序列相同 下面是两个例子：\n\n\n# 2.2 创建Buffer\n\n创建新buffer的两种方式：allocation or wrapping\n\npublic abstract class CharBuffer\nextends Buffer implements CharSequence, Comparable\n{\n}\n// This is a partial API listing\npublic static CharBuffer allocate (int capacity)\npublic static CharBuffer wrap (char [] array)\npublic static CharBuffer wrap (char [] array, int offset, int length)\npublic final boolean hasArray()\npublic final char [] array()\npublic final int arrayOffset()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过allocation创建的buffer是分配一块固定大小的堆内存作为buffer存储空间。 wrapping创建的buffer是创建一个buffer对象指向一个array空间。\n\n\n# 2.3 Duplicating Buffers\n\npublic abstract class CharBuffer\nextends Buffer implements CharSequence, Comparable\n   {\n}\n// This is a partial API listing\npublic abstract CharBuffer duplicate();\npublic abstract CharBuffer asReadOnlyBuffer(); \npublic abstract CharBuffer slice();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nduplicate()创建一个新的buffer,和原buffer一样。 两个buffer共享数据元素 但是他们有独立的position, limit, and mark 一个buffer更改了数据元素对另一个buffer可见 只读、直接内存这两个属性也可以通过duplicate()继承 举个例子：\n\nCharBuffer buffer = CharBuffer.allocate (8); \nbuffer.position (3).limit (6).mark().position (5); \nCharBuffer dupeBuffer = buffer.duplicate(); buffer.clear();\n\n\n1\n2\n3\n\n\nasReadOnlyBuffer()和duplicate()功能类似，只是asReadOnlyBuffer()返回一个只读的视图。 slice() 返回一个新的buffer视图，不过 new_position = original_position new_capacity = original_limit - original_position 举个例子来看slice():\n\nCharBuffer buffer = CharBuffer.allocate (8); \nbuffer.position (3).limit (5);\nCharBuffer sliceBuffer = buffer.slice();\n\n\n1\n2\n3\n\n\n\n\n\n# 2.4 Byte Buffers\n\n\n# 2.4.1 Byte Ordering\n\n原始数据类型在内存中的存储方式是多个字节的连续序列。 举个例子一个32-bit int 值为 0x037FB4C7的内存存储序列可能为2-14也可能为2-15: 这就是所谓的大端设计和小端设计。 采用大端还是小端通常由硬件的设计者决定而不是小端的设计者。 IP协议定义的字节顺序是大端。所有使用IP协议的多字节数值必须在网络字节序和本地主机字节序做转换。\n\npackage java.nio;\npublic final class ByteOrder\n{\npublic static final ByteOrder BIG_ENDIAN public static final ByteOrder LITTLE_ENDIAN\npublic static ByteOrder nativeOrder()\npublic String toString()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n除了ByteBuffer之外，其他buffer的order()适中返回同一个值，ByteOrder.nativeOrder()。\n\n\n# 2.4.2 Direct Buffers\n\npublic abstract class ByteBuffer extends Buffer implements Comparable {\n// This is a partial API listing\npublic static ByteBuffer allocate (int capacity) ;\npublic static ByteBuffer allocateDirect (int capacity) ;\npublic abstract boolean isDirect();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nallocateDirect可以直接在堆外开辟一个buffer。 堆外buffer节省了用户空间和系统空间的buffer拷贝，提升效率。\n\n\n# 2.4.3 View Buffers\n\n收到数据的时候你可能要先看一下数据再决定做什么操作，这就需要用到ByteBuffer的视图API。\n\npublic abstract class ByteBuffer extends Buffer implements Comparable {\n// This is a partial API listing\npublic abstract CharBuffer asCharBuffer(); \npublic abstract ShortBuffer asShortBuffer(); \npublic abstract IntBuffer asIntBuffer();\n public abstract LongBuffer asLongBuffer();\n  public abstract FloatBuffer asFloatBuffer();\n   public abstract DoubleBuffer asDoubleBuffer();\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n视图在直接内存buffer上操作更高效。 当本地硬件的字节顺序和buffer中的字节顺序一致时，通过低级代码就可以操作buffer中的数据，而不需要经过字节码的编码解码。\n\n\n# 2.4.4 Data Element Views\n\n当getInt() 被调用时，那么从当前位置开始的4个字节将被打包成一个int返回。 int value = buffer.getInt();将返回buffer中的1-4位，具体返回的数据值与字节序有关系。 int value = buffer.order (ByteOrder.BIG_ENDIAN).getInt(); 返回0x3BC5315E。 int value = buffer.order (ByteOrder.LITTLE_ENDIAN).getInt(); 返回0x5E31C53B。\n\n\n# 第三章 Channels\n\n\n# 3.1 basic\n\n在NIO接口中我们需要使用Channel和Buffer进行IO操作，Channel模拟了流的概念，但是又有不同。数据总是从一个Channel读到一个buffer中，或者从一个buffer中写到channel中。 channel接口的主要实现类如下：\n\n * FileChannel\n * DatagramChannel\n * SocketChannel\n * ServerSocketChannel\n\nJavaNIO Channels和流有一些相似，但是又有些不同：\n\n你可以同时读和写Channels，流Stream只支持单向的读或写（InputStream/OutputStream）\n\n * Channels可以异步的读和写，流Stream是同步的\n * Channels总是读取到buffer或者从buffer中写入\n\n下面分别介绍一下Channel最重要的一些实现类：\n\n * FileChannel : 可以读写文件中的数据\n * DatagramChannel：可以通过UDP协议读写数据\n * SocketChannel：可以通过TCP协议读写数据\n * ServerSocketChannel：允许我们像一个web服务器那样监听TCP链接请求，为每一个链接请求创建一个SocketChannel\n\n\n# 3.1.1 Open channel\n\nFileChannel只能通过getChannel()得到。 SocketChannel有工厂方法可以得到。\n\nSocketChannel sc = SocketChannel.open();\nsc.connect (new InetSocketAddress (\"somehost\", someport));\n\nServerSocketChannel ssc = ServerSocketChannel.open(); ssc.socket().bind (new InetSocketAddress (somelocalport));\nDatagramChannel dc = DatagramChannel.open();\n\nRandomAccessFile raf = new RandomAccessFile (\"somefile\", \"r\"); FileChannel fc = raf.getChannel();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.1.2 Using Channels\n\npublic interface ReadableByteChannel extends Channel {\npublic int read (ByteBuffer dst) throws IOException;\n}\n\npublic interface WritableByteChannel extends Channel {\npublic int write (ByteBuffer src) throws IOException;\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nChannels 可以是单向或者双向的。 如果一个class实现了上面两个接口，就是双向的。 Channels可以在阻塞模式和非阻塞模式工作。 只有socket和pipes可以工作在非阻塞模式。\n\n\n# 3.1.3 close Channels\n\n\n# 3.2 Scatter/Gather\n\nScatter：将多个buffer按照顺序合成一个 Gather：将一个字符串按照顺序拆分成多个。逐个填满buffer。\n\n\n# 3.3 File Channels\n\nFile channels 只能以阻塞模式工作。\n\n\n# 3.3.1 Accessing Files\n\npublic abstract class FileChannel extends AbstractChannel \nimplements ByteChannel, GatheringByteChannel, ScatteringByteChannel{\n// This is a partial API listing\n//获取position位置\npublic abstract long position()\n//设置position\npublic abstract void position (long newPosition)\n//从position位置开始读\npublic abstract int read (ByteBuffer dst)\n//从position位置开始读\npublic abstract int read (ByteBuffer dst, long position)\n//从position位置开始写\n public abstract int write (ByteBuffer src)\n//从position位置开始写\npublic abstract int write (ByteBuffer src, long position)\npublic abstract long size()\n//截取文件保留size大小，并移动position到size的位置\npublic abstract void truncate (long size) \n//强制刷新缓存到磁盘文件\npublic abstract void force (boolean metaData)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.3.2 File Locking\n\n\n# 3.4 Memory-Mapped Files\n\n\n# 3.5 Socket Channels\n\nThe new socket channels can operate in nonblocking mode and are selectable. These two capabilities enable tremendous scalability and flexibility in large applications. ServerSocketChannel没有实现read和write接口，说明它不需要转发数据。它只负责家庭socket连接，创建SocketChannel。\n\na channel is a conduit to an I/O service and provides methods for interacting with that service\n\n每个socket channels都有一个socket与之对应，调用socket()可以获得。 但并不是所有的sockets都有channels。socket的getChannel()可能但会null;\n\n\n# 3.5.1 Nonblocking Mode\n\n调用configureBlocking (false);设置channel为非阻塞模式。 但是只有持有blockingLock() 返回的对象锁的线程才能修改阻塞模式。\n\nSocket socket = null;\nObject lockObj = serverChannel.blockingLock();\n// have a handle to the lock object, but haven't locked it yet\n// may block here until lock is acquired\nsynchronize (lockObj){\n// This thread now owns the lock; mode can't be changed boolean prevState = serverChannel.isBlocking();\nserverChannel.configureBlocking (false); socket = serverChannel.accept(); serverChannel.configureBlocking (prevState);\n}\n// lock is now released, mode is allowed to change\nif (socket != null) {\ndoSomethingWithTheSocket (socket);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.5.2 ServerSocketChannel\n\nThe ServerSocketChannel class is a channel-based socket listener. 它负责处理socket任务并添加channel。\n\npublic abstract class SocketChannel\n    extends AbstractSelectableChannel\n    implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel\n{\n//SocketChannel被创建但是并没有连接，open（）只是创建一个SocketChannel，还需要调用connect()连接到一个地址\npublic static SocketChannel open() throws IOException\n//创建并连接\npublic static SocketChannel open(SocketAddress remote) throws IOException\n//支持的操作（读、写、连接）\npublic final int validOps()\n、、\npublic abstract Socket socket();\n//是否连接到远程\npublic abstract boolean isConnected();\n//Connect（）方法是耗时的，因为需要数据包对话（TCP握手）。如果SocketChannel身上有并发、connect(),isConnectionPending返回true\npublic abstract boolean isConnectionPending();\n//建立连接\npublic abstract boolean connect(SocketAddress remote) throws IOException;\n//任何时候都可以安全的调用\npublic abstract boolean finishConnect() throws IOException;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nSocket channels是线程安全的。 Socket是面向流的而不是面向数据包的，它能保证到达的顺序是发送的顺序，不能保证维护分组。发送方发送20个字节，接收方read可能直接受到7个字节，其余字节在传输中。所以，多个线程共享一个socket的一端不是好的设计。\n\n\n# 3.5.4 DatagramChannel\n\nsocketchannel为面向连接的流协议（如tcp/ip） datagramchannel为面向无连接的数据包协议（如udp/ip）\n\n\n# 3.5.5 Pipes\n\nPipe用于同一个JVM内不同线程之间的数据交换问题 不同JVM之间的数据交换问题应该使用SocketChannel Pipe类创建了一对channel对象，它们提供了一种回送机制。 Pipe实现两个进程之间的单向数据连接。 Pipe有一个SinkChannel和一个SourceChannel 数据会从SourceChannel读取、被写到SinkChannel\n\npublic abstract class Pipe {\n    public static abstract class SourceChannel\n        extends AbstractSelectableChannel\n        implements ReadableByteChannel, ScatteringByteChannel\n    {\n        protected SourceChannel(SelectorProvider provider) {\n            super(provider);\n        }\n        public final int validOps() {\n            return SelectionKey.OP_READ;\n        }\n    }\n\n    public static abstract class SinkChannel\n        extends AbstractSelectableChannel\n        implements WritableByteChannel, GatheringByteChannel\n    {\n        protected SinkChannel(SelectorProvider provider) {\n            super(provider);\n        }\n        public final int validOps() {\n            return SelectionKey.OP_WRITE;\n        }\n\n    }\n    protected Pipe() { }\n    //从管道读取数据，要访问source通道\n    public abstract SourceChannel source();\n    //向管道写入数据，要访问Sink通道\n    public abstract SinkChannel sink();\n    //管道创建\n    public static Pipe open() throws IOException {\n        return SelectorProvider.provider().openPipe();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 第四章 Selectors\n\nSelector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接,仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。\n\n\n# 4.1 基础\n\n * Selector：一个selector可以注册多个channel，一个线程通过管理Selector实现管理多个channel。\n * SelectableChannel：提供channle selectability的通用方法。\n * SelectionKey：封装了channle和selector的注册关系，包含注册的感兴趣的事件。\n\n\n# 4.2 示例\n\n//创建Selector\nSelector selector = Selector.open();\nchannel.configureBlocking(false);\n//注册Selector\nSelectionKey key = channel.register(selector, SelectionKey.OP_READ);\nwhile(true) {\n//单线程阻塞检查Selector中就绪的事件\n  int readyChannels = selector.select();\n  if(readyChannels == 0) continue;\n  Set selectedKeys = selector.selectedKeys();\n  Iterator keyIterator = selectedKeys.iterator();\n  //循环处理就绪的事件\n  while(keyIterator.hasNext()) {\n    SelectionKey key = keyIterator.next();\n    if(key.isAcceptable()) {\n        // a connection was accepted by a ServerSocketChannel.\n    } else if (key.isConnectable()) {\n        // a connection was established with a remote server.\n    } else if (key.isReadable()) {\n        // a channel is ready for reading\n    } else if (key.isWritable()) {\n        // a channel is ready for writing\n    }\n    keyIterator.remove();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",
      "normalizedContent": "@toc\n\n\n# 第一章 io介绍\n\n\n# 1.1 io概念\n\n\n# 1.1.1 buffer handler\n\n内存分为用户空间（user space），内核空间（kernel space）。 用户空间的数据读写需要通过内存空间传递。 如下图所示，用户需要读数据，则向cpu发送一个读请求，cpu相应这个请求控制disk controller从disk读取数据到内核buffer，然后再把内核buffer的数据推送给用户空间的buffer。 为什么要区分用户空间和内核空间呢？ 每个进程有独立的内存空间好处在于多个进程的内存分配互不影响。如果多个进程共享一块内存，那么内存分配的时候就得排队。\n\n为什么用户空间不能直接从disk读数据呢？\n\n * 硬件控制器只能处理固定大小的数据，用户空间需要的可能是数据块大小异常或者不对齐的数据，内核空间起作到数拆分、重组的作用。\n * 硬件设备通常不允许直接操作虚拟内存，即用户空间\n\ndma是什么？ dma(direct memory access,直接存储器访问)。 在dma之前通过中断cpu来传输数据。cpu响应中断，控制总线传输数据。 dma不需要cpu参与数据传输。dma可以和cpu交互请求控制总线传输数据。\n\n\n# 1.1.1 scatter/gather\n\n分散（scatter）从channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，channel将从channel中读取的数据“分散（scatter）”到多个buffer中。 聚集（gather）写入channel是指在写操作时将多个buffer的数据写入同一个channel，因此，channel 将多个buffer中的数据“聚集（gather）”后发送到channel。\n\n比如某个协议的消息固定消息头128字节，消息体1024字节，消息尾128字节。我们想要分别处理消息头，消息体，消息尾。 使用scatter示例代码:\n\nbytebuffer header = bytebuffer.allocate(128);\nbytebuffer body   = bytebuffer.allocate(1024);\nbytebuffer tail   = bytebuffer.allocate(128);\n\nbytebuffer[] bufferarray = { header, body,tail };\nchannel.read(bufferarray);\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意buffer首先被插入到数组，然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。 所以。\n\nscatter不适合处理动态消息，相反，gather适合处理动态消息。 buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与scattering reads相反，gathering writes能较好的处理动态消息。\n\n\n# 1.1.2 虚拟内存\n\n虚拟内存是指使用虚拟内存地址代替物理内存地址。\n\n * 会有多个虚拟内存指向同一个物理内存\n * 虚拟内存可能会大于物理内存 上面说disk controller不可以直接把数据读到用户空间。虚拟内存可以通过虚拟地址映射内核空间的方式做到这一点。 如下图，内核空间的buffer对用户空间也是可见的。这就是netty零拷贝的原理，这减少了buffer在用户空间和内核空间的拷贝，非常有意义。\n\n\n# 1.1.3 内存页\n\n操作系统将内存按固定字节分页。 内存读取的基本单位是页。\n\nmmu(memory management unit):内存管理单元，保存虚拟内存和物理内存的映射关系，处在cpu和内存之间，起到将虚拟内存转换为物理内存的作用。\n\n\n# 1.1.4 文件io\n\n文件系统：文件io发生在文件系统。文件保存在磁盘，磁盘扇区类似内存分页的概念。内存文件读取通过文件系统间接操作磁盘文件。 文件零拷贝如下图。避免了文件系统内存页和用户内存页之间的拷贝。\n\n\n# 1.1.5 io流\n\n上面说的io都是面向块的io。还有面向流的io。 大多数操作系统支持将流置为非阻塞模式，额外设置一个进程用于检查流上是否有输入，因此流本身是不被阻塞的。 网络io一般都是流io。 多路复用：用一个进程管理多个非阻塞io流的状态。\n\n\n# 第二章 buffer\n\n标准的io基于字节流和字符流进行操作的，而nio是基于通道（channel）和缓冲区（buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。\n\n\n# 2.1 buffer basic\n\n\n# 2.1.1 buffer的几个属性\n\n * capacity\n * limit\n * position\n * mark\n\n\n# 2.1.2 buffer api\n\npackage java.nio;\npublic abstract class buffer {\npublic final int capacity()\npublic final int position()\npublic final buffer position (int newposition) public final int limit()\n  }\npublic final buffer limit (int newlimit)\npublic final buffer mark()\npublic final buffer reset()\npublic final buffer clear()\npublic final buffer flip()\npublic final buffer rewind()\npublic final int remaining()\npublic final boolean hasremaining()\npublic abstract boolean isreadonly();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.1.3 访问buffer\n\npublic abstract class bytebuffer\n       extends buffer implements comparable\n {\n// this is a partial api listing\npublic abstract byte get();\npublic abstract byte get (int index);\npublic abstract bytebuffer put (byte b);\npublic abstract bytebuffer put (int index, byte b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.1.4 write\n\nfigure 2-2的buffer经过下面这个代码会变成figure 2-3的样子：\n\nbuffer.put((byte)'h').put((byte)'e').put((byte)'l')\n.put((byte)'l').put( (byte)'o');\n\n\n1\n2\n\n\n也可以按绝对位置写入：\n\nbuffer.put(0, (byte)'m').put((byte)'w');\n\n\n1\n\n\n\n\n\n# 2.1.5 flipping\n\n当我们想要写出buffer的内容时，我们需要用position和limit指针指向时机内容的起始位置。类似这样：\n\nbuffer.limit(buffer.position()).position(0);\n\n\n1\n\n\n这等同于buffer.flip(); 调用flip()后2-4会变成2-5 说白了，flip()改变position和limit两个指针。 rewind()只改变position指针，等同于：\n\nbuffer.position(0);\n\n\n1\n\n\n\n# 2.1.6 draining\n\nhasremaining()可以判断是否到达limit指针 下面是一个实现，将buffer内容读到一个数组中\n\nfor (int i = 0; buffer.hasremaining(), i++) {\n       mybytearray [i] = buffer.get();\n}\n\n\n1\n2\n3\n\n\nremaining()会返回position到limit的数量。 将buffer内容读到一个数组中另一种实现方式：\n\nint count = buffer.remaining();\nfor (int i = 0; i < count, i++) {\n       mybytearray [i] = buffer.get();\n}\n\n\n1\n2\n3\n4\n\n\n\n# 2.1.7 compacting\n\n当你drain一部分数据想要继续fill数据的时候，你需要把还未drain的数据整体前移。 buffer.compact()；可以完成这个工作。 调用buffer.compact()的效果就是2-6到2-7\n\n\n# 2.1.9 mark\n\nmark()方法会用mark指针指向position的位置。\n\nbuffer.position(2).mark().position(4);\n\n\n1\n\n\nreset()方法会把position指针指向mark的位置。\n\nbuffer.reset();\n\n\n1\n\n\n\n\n\n# 2.1.9 comparing\n\npublic abstract class bytebuffer\n       extends buffer implements comparable\n  {\n  // this is a partial api listing\npublic boolean equals (object ob)\npublic int compareto (object ob)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nequals()返回true需要满足三个条件：\n\n * buffer包含相同类型的元素\n * 两个buffer的remaining()返回值相同\n * remaining data的序列相同 下面是两个例子：\n\n\n# 2.2 创建buffer\n\n创建新buffer的两种方式：allocation or wrapping\n\npublic abstract class charbuffer\nextends buffer implements charsequence, comparable\n{\n}\n// this is a partial api listing\npublic static charbuffer allocate (int capacity)\npublic static charbuffer wrap (char [] array)\npublic static charbuffer wrap (char [] array, int offset, int length)\npublic final boolean hasarray()\npublic final char [] array()\npublic final int arrayoffset()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过allocation创建的buffer是分配一块固定大小的堆内存作为buffer存储空间。 wrapping创建的buffer是创建一个buffer对象指向一个array空间。\n\n\n# 2.3 duplicating buffers\n\npublic abstract class charbuffer\nextends buffer implements charsequence, comparable\n   {\n}\n// this is a partial api listing\npublic abstract charbuffer duplicate();\npublic abstract charbuffer asreadonlybuffer(); \npublic abstract charbuffer slice();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nduplicate()创建一个新的buffer,和原buffer一样。 两个buffer共享数据元素 但是他们有独立的position, limit, and mark 一个buffer更改了数据元素对另一个buffer可见 只读、直接内存这两个属性也可以通过duplicate()继承 举个例子：\n\ncharbuffer buffer = charbuffer.allocate (8); \nbuffer.position (3).limit (6).mark().position (5); \ncharbuffer dupebuffer = buffer.duplicate(); buffer.clear();\n\n\n1\n2\n3\n\n\nasreadonlybuffer()和duplicate()功能类似，只是asreadonlybuffer()返回一个只读的视图。 slice() 返回一个新的buffer视图，不过 new_position = original_position new_capacity = original_limit - original_position 举个例子来看slice():\n\ncharbuffer buffer = charbuffer.allocate (8); \nbuffer.position (3).limit (5);\ncharbuffer slicebuffer = buffer.slice();\n\n\n1\n2\n3\n\n\n\n\n\n# 2.4 byte buffers\n\n\n# 2.4.1 byte ordering\n\n原始数据类型在内存中的存储方式是多个字节的连续序列。 举个例子一个32-bit int 值为 0x037fb4c7的内存存储序列可能为2-14也可能为2-15: 这就是所谓的大端设计和小端设计。 采用大端还是小端通常由硬件的设计者决定而不是小端的设计者。 ip协议定义的字节顺序是大端。所有使用ip协议的多字节数值必须在网络字节序和本地主机字节序做转换。\n\npackage java.nio;\npublic final class byteorder\n{\npublic static final byteorder big_endian public static final byteorder little_endian\npublic static byteorder nativeorder()\npublic string tostring()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n除了bytebuffer之外，其他buffer的order()适中返回同一个值，byteorder.nativeorder()。\n\n\n# 2.4.2 direct buffers\n\npublic abstract class bytebuffer extends buffer implements comparable {\n// this is a partial api listing\npublic static bytebuffer allocate (int capacity) ;\npublic static bytebuffer allocatedirect (int capacity) ;\npublic abstract boolean isdirect();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nallocatedirect可以直接在堆外开辟一个buffer。 堆外buffer节省了用户空间和系统空间的buffer拷贝，提升效率。\n\n\n# 2.4.3 view buffers\n\n收到数据的时候你可能要先看一下数据再决定做什么操作，这就需要用到bytebuffer的视图api。\n\npublic abstract class bytebuffer extends buffer implements comparable {\n// this is a partial api listing\npublic abstract charbuffer ascharbuffer(); \npublic abstract shortbuffer asshortbuffer(); \npublic abstract intbuffer asintbuffer();\n public abstract longbuffer aslongbuffer();\n  public abstract floatbuffer asfloatbuffer();\n   public abstract doublebuffer asdoublebuffer();\n   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n视图在直接内存buffer上操作更高效。 当本地硬件的字节顺序和buffer中的字节顺序一致时，通过低级代码就可以操作buffer中的数据，而不需要经过字节码的编码解码。\n\n\n# 2.4.4 data element views\n\n当getint() 被调用时，那么从当前位置开始的4个字节将被打包成一个int返回。 int value = buffer.getint();将返回buffer中的1-4位，具体返回的数据值与字节序有关系。 int value = buffer.order (byteorder.big_endian).getint(); 返回0x3bc5315e。 int value = buffer.order (byteorder.little_endian).getint(); 返回0x5e31c53b。\n\n\n# 第三章 channels\n\n\n# 3.1 basic\n\n在nio接口中我们需要使用channel和buffer进行io操作，channel模拟了流的概念，但是又有不同。数据总是从一个channel读到一个buffer中，或者从一个buffer中写到channel中。 channel接口的主要实现类如下：\n\n * filechannel\n * datagramchannel\n * socketchannel\n * serversocketchannel\n\njavanio channels和流有一些相似，但是又有些不同：\n\n你可以同时读和写channels，流stream只支持单向的读或写（inputstream/outputstream）\n\n * channels可以异步的读和写，流stream是同步的\n * channels总是读取到buffer或者从buffer中写入\n\n下面分别介绍一下channel最重要的一些实现类：\n\n * filechannel : 可以读写文件中的数据\n * datagramchannel：可以通过udp协议读写数据\n * socketchannel：可以通过tcp协议读写数据\n * serversocketchannel：允许我们像一个web服务器那样监听tcp链接请求，为每一个链接请求创建一个socketchannel\n\n\n# 3.1.1 open channel\n\nfilechannel只能通过getchannel()得到。 socketchannel有工厂方法可以得到。\n\nsocketchannel sc = socketchannel.open();\nsc.connect (new inetsocketaddress (\"somehost\", someport));\n\nserversocketchannel ssc = serversocketchannel.open(); ssc.socket().bind (new inetsocketaddress (somelocalport));\ndatagramchannel dc = datagramchannel.open();\n\nrandomaccessfile raf = new randomaccessfile (\"somefile\", \"r\"); filechannel fc = raf.getchannel();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.1.2 using channels\n\npublic interface readablebytechannel extends channel {\npublic int read (bytebuffer dst) throws ioexception;\n}\n\npublic interface writablebytechannel extends channel {\npublic int write (bytebuffer src) throws ioexception;\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nchannels 可以是单向或者双向的。 如果一个class实现了上面两个接口，就是双向的。 channels可以在阻塞模式和非阻塞模式工作。 只有socket和pipes可以工作在非阻塞模式。\n\n\n# 3.1.3 close channels\n\n\n# 3.2 scatter/gather\n\nscatter：将多个buffer按照顺序合成一个 gather：将一个字符串按照顺序拆分成多个。逐个填满buffer。\n\n\n# 3.3 file channels\n\nfile channels 只能以阻塞模式工作。\n\n\n# 3.3.1 accessing files\n\npublic abstract class filechannel extends abstractchannel \nimplements bytechannel, gatheringbytechannel, scatteringbytechannel{\n// this is a partial api listing\n//获取position位置\npublic abstract long position()\n//设置position\npublic abstract void position (long newposition)\n//从position位置开始读\npublic abstract int read (bytebuffer dst)\n//从position位置开始读\npublic abstract int read (bytebuffer dst, long position)\n//从position位置开始写\n public abstract int write (bytebuffer src)\n//从position位置开始写\npublic abstract int write (bytebuffer src, long position)\npublic abstract long size()\n//截取文件保留size大小，并移动position到size的位置\npublic abstract void truncate (long size) \n//强制刷新缓存到磁盘文件\npublic abstract void force (boolean metadata)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.3.2 file locking\n\n\n# 3.4 memory-mapped files\n\n\n# 3.5 socket channels\n\nthe new socket channels can operate in nonblocking mode and are selectable. these two capabilities enable tremendous scalability and flexibility in large applications. serversocketchannel没有实现read和write接口，说明它不需要转发数据。它只负责家庭socket连接，创建socketchannel。\n\na channel is a conduit to an i/o service and provides methods for interacting with that service\n\n每个socket channels都有一个socket与之对应，调用socket()可以获得。 但并不是所有的sockets都有channels。socket的getchannel()可能但会null;\n\n\n# 3.5.1 nonblocking mode\n\n调用configureblocking (false);设置channel为非阻塞模式。 但是只有持有blockinglock() 返回的对象锁的线程才能修改阻塞模式。\n\nsocket socket = null;\nobject lockobj = serverchannel.blockinglock();\n// have a handle to the lock object, but haven't locked it yet\n// may block here until lock is acquired\nsynchronize (lockobj){\n// this thread now owns the lock; mode can't be changed boolean prevstate = serverchannel.isblocking();\nserverchannel.configureblocking (false); socket = serverchannel.accept(); serverchannel.configureblocking (prevstate);\n}\n// lock is now released, mode is allowed to change\nif (socket != null) {\ndosomethingwiththesocket (socket);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.5.2 serversocketchannel\n\nthe serversocketchannel class is a channel-based socket listener. 它负责处理socket任务并添加channel。\n\npublic abstract class socketchannel\n    extends abstractselectablechannel\n    implements bytechannel, scatteringbytechannel, gatheringbytechannel, networkchannel\n{\n//socketchannel被创建但是并没有连接，open（）只是创建一个socketchannel，还需要调用connect()连接到一个地址\npublic static socketchannel open() throws ioexception\n//创建并连接\npublic static socketchannel open(socketaddress remote) throws ioexception\n//支持的操作（读、写、连接）\npublic final int validops()\n、、\npublic abstract socket socket();\n//是否连接到远程\npublic abstract boolean isconnected();\n//connect（）方法是耗时的，因为需要数据包对话（tcp握手）。如果socketchannel身上有并发、connect(),isconnectionpending返回true\npublic abstract boolean isconnectionpending();\n//建立连接\npublic abstract boolean connect(socketaddress remote) throws ioexception;\n//任何时候都可以安全的调用\npublic abstract boolean finishconnect() throws ioexception;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nsocket channels是线程安全的。 socket是面向流的而不是面向数据包的，它能保证到达的顺序是发送的顺序，不能保证维护分组。发送方发送20个字节，接收方read可能直接受到7个字节，其余字节在传输中。所以，多个线程共享一个socket的一端不是好的设计。\n\n\n# 3.5.4 datagramchannel\n\nsocketchannel为面向连接的流协议（如tcp/ip） datagramchannel为面向无连接的数据包协议（如udp/ip）\n\n\n# 3.5.5 pipes\n\npipe用于同一个jvm内不同线程之间的数据交换问题 不同jvm之间的数据交换问题应该使用socketchannel pipe类创建了一对channel对象，它们提供了一种回送机制。 pipe实现两个进程之间的单向数据连接。 pipe有一个sinkchannel和一个sourcechannel 数据会从sourcechannel读取、被写到sinkchannel\n\npublic abstract class pipe {\n    public static abstract class sourcechannel\n        extends abstractselectablechannel\n        implements readablebytechannel, scatteringbytechannel\n    {\n        protected sourcechannel(selectorprovider provider) {\n            super(provider);\n        }\n        public final int validops() {\n            return selectionkey.op_read;\n        }\n    }\n\n    public static abstract class sinkchannel\n        extends abstractselectablechannel\n        implements writablebytechannel, gatheringbytechannel\n    {\n        protected sinkchannel(selectorprovider provider) {\n            super(provider);\n        }\n        public final int validops() {\n            return selectionkey.op_write;\n        }\n\n    }\n    protected pipe() { }\n    //从管道读取数据，要访问source通道\n    public abstract sourcechannel source();\n    //向管道写入数据，要访问sink通道\n    public abstract sinkchannel sink();\n    //管道创建\n    public static pipe open() throws ioexception {\n        return selectorprovider.provider().openpipe();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 第四章 selectors\n\nselector（选择器）是java nio中能够检测一到多个nio通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接,仅用单个线程来处理多个channels的好处是，只需要更少的线程来处理通道。\n\n\n# 4.1 基础\n\n * selector：一个selector可以注册多个channel，一个线程通过管理selector实现管理多个channel。\n * selectablechannel：提供channle selectability的通用方法。\n * selectionkey：封装了channle和selector的注册关系，包含注册的感兴趣的事件。\n\n\n# 4.2 示例\n\n//创建selector\nselector selector = selector.open();\nchannel.configureblocking(false);\n//注册selector\nselectionkey key = channel.register(selector, selectionkey.op_read);\nwhile(true) {\n//单线程阻塞检查selector中就绪的事件\n  int readychannels = selector.select();\n  if(readychannels == 0) continue;\n  set selectedkeys = selector.selectedkeys();\n  iterator keyiterator = selectedkeys.iterator();\n  //循环处理就绪的事件\n  while(keyiterator.hasnext()) {\n    selectionkey key = keyiterator.next();\n    if(key.isacceptable()) {\n        // a connection was accepted by a serversocketchannel.\n    } else if (key.isconnectable()) {\n        // a connection was established with a remote server.\n    } else if (key.isreadable()) {\n        // a channel is ready for reading\n    } else if (key.iswritable()) {\n        // a channel is ready for writing\n    }\n    keyiterator.remove();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Spring",
      "frontmatter": {
        "title": "Spring",
        "date": "2022-03-11T00:57:23.000Z",
        "permalink": "/pages/434235/",
        "categories": [
          "中间件",
          "Spring"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/20.Spring/01.Spring.html",
      "relativePath": "04.中间件/20.Spring/01.Spring.md",
      "key": "v-3465d7fa",
      "path": "/pages/434235/",
      "headers": [
        {
          "level": 2,
          "title": "简述 Spring IOC",
          "slug": "简述-spring-ioc",
          "normalizedTitle": "简述 spring ioc",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "简述 Spring bean 的生命周期",
          "slug": "简述-spring-bean-的生命周期",
          "normalizedTitle": "简述 spring bean 的生命周期",
          "charIndex": 58
        },
        {
          "level": 2,
          "title": "简述 Spring AOP 的原理",
          "slug": "简述-spring-aop-的原理",
          "normalizedTitle": "简述 spring aop 的原理",
          "charIndex": 83
        },
        {
          "level": 2,
          "title": "如何解决 Spring 的循环依赖问题？",
          "slug": "如何解决-spring-的循环依赖问题",
          "normalizedTitle": "如何解决 spring 的循环依赖问题？",
          "charIndex": 105
        },
        {
          "level": 2,
          "title": "简述 Spring 注解的实现原理",
          "slug": "简述-spring-注解的实现原理",
          "normalizedTitle": "简述 spring 注解的实现原理",
          "charIndex": 130
        },
        {
          "level": 2,
          "title": "Spring MVC 的原理和流程",
          "slug": "spring-mvc-的原理和流程",
          "normalizedTitle": "spring mvc 的原理和流程",
          "charIndex": 152
        }
      ],
      "headersStr": "简述 Spring IOC 简述 Spring bean 的生命周期 简述 Spring AOP 的原理 如何解决 Spring 的循环依赖问题？ 简述 Spring 注解的实现原理 Spring MVC 的原理和流程",
      "content": "# 简述 Spring IOC\n\nhttps://javadoop.com/post/spring-ioc\n\n\n# 简述 Spring bean 的生命周期\n\n\n# 简述 Spring AOP 的原理\n\n\n# 如何解决 Spring 的循环依赖问题？\n\n\n# 简述 Spring 注解的实现原理\n\n\n# Spring MVC 的原理和流程",
      "normalizedContent": "# 简述 spring ioc\n\nhttps://javadoop.com/post/spring-ioc\n\n\n# 简述 spring bean 的生命周期\n\n\n# 简述 spring aop 的原理\n\n\n# 如何解决 spring 的循环依赖问题？\n\n\n# 简述 spring 注解的实现原理\n\n\n# spring mvc 的原理和流程",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Kafka",
      "frontmatter": {
        "title": "Kafka",
        "date": "2020-05-21T21:50:26.000Z",
        "permalink": "/pages/561f34/",
        "categories": [
          "中间件",
          "Kafka"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/001.Kafka%E5%8C%85%E5%90%AB%E9%82%A3%E5%87%A0%E9%83%A8%E5%88%86.html",
      "relativePath": "04.中间件/40.Kafka/001.Kafka包含那几部分.md",
      "key": "v-0df39df8",
      "path": "/pages/561f34/",
      "headersStr": null,
      "content": "# 主题和分区\n\nkafka通过主题对消息分类。 kafka通过分区实现数据冗余和伸缩性。 一个主题包含多个分区，所以在topic内消息可能是无需的，但是在单个partition内部是有序的。\n\n\n# 生产者和消费者\n\n生产者创建消息，发布到一个特定的主题上，消息会均衡在所有分区上。 消费者订阅一个或者多个主题，按照生产顺序消费消息。 偏移量是一种元数据，是一个不断递增的整数值，消费者通过偏移量来区分已经消费的消息。每个分区有唯一的偏移量，消费者把最后消费的消息的偏移量发送到broker或者zookeeper保存。 消费者群组多个消费者共同读取一个主题，有唯一的groupId,群组保证，每个分区只能被一个消费者使用。\n\n\n# broker和集群\n\nbroker是一个独立的kafka 服务器。负责接收生产者的消息，为消息设置偏移量，提交消息到磁盘保存。是集群的组成部分。 集群控制器是集群中的一个broker。负责分区分配和broker监控。 分区首领。一个分区会分配给多个broker，这种复制机制是为了提供消息冗余。在这多个broker中需要有一个分区首领，消费者只消费分区首领的消息，分区首领负责把消费的offset同步到冗余分区中。",
      "normalizedContent": "# 主题和分区\n\nkafka通过主题对消息分类。 kafka通过分区实现数据冗余和伸缩性。 一个主题包含多个分区，所以在topic内消息可能是无需的，但是在单个partition内部是有序的。\n\n\n# 生产者和消费者\n\n生产者创建消息，发布到一个特定的主题上，消息会均衡在所有分区上。 消费者订阅一个或者多个主题，按照生产顺序消费消息。 偏移量是一种元数据，是一个不断递增的整数值，消费者通过偏移量来区分已经消费的消息。每个分区有唯一的偏移量，消费者把最后消费的消息的偏移量发送到broker或者zookeeper保存。 消费者群组多个消费者共同读取一个主题，有唯一的groupid,群组保证，每个分区只能被一个消费者使用。\n\n\n# broker和集群\n\nbroker是一个独立的kafka 服务器。负责接收生产者的消息，为消息设置偏移量，提交消息到磁盘保存。是集群的组成部分。 集群控制器是集群中的一个broker。负责分区分配和broker监控。 分区首领。一个分区会分配给多个broker，这种复制机制是为了提供消息冗余。在这多个broker中需要有一个分区首领，消费者只消费分区首领的消息，分区首领负责把消费的offset同步到冗余分区中。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "生产者",
      "frontmatter": {
        "title": "生产者",
        "date": "2022-05-21T23:43:06.000Z",
        "permalink": "/pages/fe7ca2/",
        "categories": [
          "中间件",
          "Kafka"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/010.%E7%94%9F%E4%BA%A7%E8%80%85.html",
      "relativePath": "04.中间件/40.Kafka/010.生产者.md",
      "key": "v-7c0136cf",
      "path": "/pages/fe7ca2/",
      "headersStr": null,
      "content": "# 创建生产者\n\n创建生产者有三个属性是必选的 bootstrap.servers 指定broker集群的地址，格式为host:port key.serializer kafka broker希望收到消息的键和值都是字节数组，但是为了代码的可读性，允许producer把java对象发送给broker，但是需要指定一个实现了org.apache.kafka.common.serialization.Serializer接口的序列化器。 value.serializer 与key.serializer一样的道理。\n\n\t\tProperties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"172.16.1.1,172.16.1.2\");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringSerializer\");\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringSerializer\");\n        producer = new KafkaProducer<>(props);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 发送消息\n\n发送消息有三种方式：\n\n * 发送并忘记（fire-and-forget）\n * 同步发送\n * 异步发送\n\n发送并忘记 不关心消息是否到达\n\nProducerRecord<String, String> record = new ProducerRecord<>(topicName, key,value);\nproducer.send(record);\n\n\n1\n2\n\n\n同步发送\n\nProducerRecord<String, String> record = new ProducerRecord<>(topicName, key,value);\ntry{\n\tproducer.send(record).get();//producer.send(record)返回一个Future对象，调用get()阻塞等待返回结果\n} catch (Exception e){\n\te.printStackTrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nkafkaProducer会发送两类错误\n\n * 可重试的：比如连接错误、无主（no leader）错误\n * 不可重试的：比如消息太大 异步发送 异步发送的异常需要记录下拉，producer支持回调。\n\nProducerRecord<String, String> record = new ProducerRecord<>(topicNameTrade, key,value);\n            producer.send(record, new Callback() {\n                @Override\n                public void onCompletion(RecordMetadata metadata, Exception exception) {\n                    exception.printStackTrace();\n                }\n            });\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 生产者的配置\n\nacks 指定要多少个分区副本收到消息，生产者才认为消息写入是成功的。其值有0、1、all.\n\n * 0：不等待任何服务器的相应\n * 1： 只要集群的首领节点收到\n * all: 等待所有副本都收到\n\nbuffer.memory 设置生产者内存缓冲区大小。 程序发送消息的速度 > 发送到broker的速度会导致这个缓冲区空间不足。 空间不足时程序阻塞还是抛异常取决于配置max.block.ms compression.type 默认，消息是不会被压缩的。 producer向broker发送消息不是逐条发送的，是一批一批发送的。 发送批次有可选的压缩方式，有三种：\n\n * snappy\n * gzip\n * lz4\n\nretries 重试次数 默认重试之间会等待100ms retry.backoff.ms可设置这个等待时间 batch.size 有多个消息要发送到一个分区的时候，producer会把他们放到一个批次。 该配置指定是批次大小（字节）。 批次装满的时候会被发送出去，\n\n\n# 序列化器\n\n\n# 分区\n\nkafka消息的recode包含topic、key、value。 broker用key分配分区。key相同的一定会分配到同一个分区。 如果key为null,那么将使用默认分区，默认的分区器是使用Round Robin算法。 也可以实现partitioner实现自定义分区器。",
      "normalizedContent": "# 创建生产者\n\n创建生产者有三个属性是必选的 bootstrap.servers 指定broker集群的地址，格式为host:port key.serializer kafka broker希望收到消息的键和值都是字节数组，但是为了代码的可读性，允许producer把java对象发送给broker，但是需要指定一个实现了org.apache.kafka.common.serialization.serializer接口的序列化器。 value.serializer 与key.serializer一样的道理。\n\n\t\tproperties props = new properties();\n        props.put(producerconfig.bootstrap_servers_config, \"172.16.1.1,172.16.1.2\");\n        props.put(producerconfig.key_serializer_class_config, \"org.apache.kafka.common.serialization.stringserializer\");\n        props.put(producerconfig.value_serializer_class_config, \"org.apache.kafka.common.serialization.stringserializer\");\n        producer = new kafkaproducer<>(props);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 发送消息\n\n发送消息有三种方式：\n\n * 发送并忘记（fire-and-forget）\n * 同步发送\n * 异步发送\n\n发送并忘记 不关心消息是否到达\n\nproducerrecord<string, string> record = new producerrecord<>(topicname, key,value);\nproducer.send(record);\n\n\n1\n2\n\n\n同步发送\n\nproducerrecord<string, string> record = new producerrecord<>(topicname, key,value);\ntry{\n\tproducer.send(record).get();//producer.send(record)返回一个future对象，调用get()阻塞等待返回结果\n} catch (exception e){\n\te.printstacktrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nkafkaproducer会发送两类错误\n\n * 可重试的：比如连接错误、无主（no leader）错误\n * 不可重试的：比如消息太大 异步发送 异步发送的异常需要记录下拉，producer支持回调。\n\nproducerrecord<string, string> record = new producerrecord<>(topicnametrade, key,value);\n            producer.send(record, new callback() {\n                @override\n                public void oncompletion(recordmetadata metadata, exception exception) {\n                    exception.printstacktrace();\n                }\n            });\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 生产者的配置\n\nacks 指定要多少个分区副本收到消息，生产者才认为消息写入是成功的。其值有0、1、all.\n\n * 0：不等待任何服务器的相应\n * 1： 只要集群的首领节点收到\n * all: 等待所有副本都收到\n\nbuffer.memory 设置生产者内存缓冲区大小。 程序发送消息的速度 > 发送到broker的速度会导致这个缓冲区空间不足。 空间不足时程序阻塞还是抛异常取决于配置max.block.ms compression.type 默认，消息是不会被压缩的。 producer向broker发送消息不是逐条发送的，是一批一批发送的。 发送批次有可选的压缩方式，有三种：\n\n * snappy\n * gzip\n * lz4\n\nretries 重试次数 默认重试之间会等待100ms retry.backoff.ms可设置这个等待时间 batch.size 有多个消息要发送到一个分区的时候，producer会把他们放到一个批次。 该配置指定是批次大小（字节）。 批次装满的时候会被发送出去，\n\n\n# 序列化器\n\n\n# 分区\n\nkafka消息的recode包含topic、key、value。 broker用key分配分区。key相同的一定会分配到同一个分区。 如果key为null,那么将使用默认分区，默认的分区器是使用round robin算法。 也可以实现partitioner实现自定义分区器。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "消费者",
      "frontmatter": {
        "title": "消费者",
        "date": "2022-05-21T23:43:44.000Z",
        "permalink": "/pages/fed167/",
        "categories": [
          "中间件",
          "Kafka"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/020.%E6%B6%88%E8%B4%B9%E8%80%85.html",
      "relativePath": "04.中间件/40.Kafka/020.消费者.md",
      "key": "v-04af9e42",
      "path": "/pages/fed167/",
      "headers": [
        {
          "level": 2,
          "title": "几个概念",
          "slug": "几个概念",
          "normalizedTitle": "几个概念",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "配置项",
          "slug": "配置项",
          "normalizedTitle": "配置项",
          "charIndex": 1024
        }
      ],
      "headersStr": "几个概念 配置项",
      "content": "# 几个概念\n\n消费者组 多个消费实例共享一个GroupId,多个消费实例组织在一起协调消费订阅的主题和分区。 消费实例可以是一个进程也可以是一个线程 GroupId是一个字符串，唯一标识一个消费组 GroupId.consumerInstance:GroupId.partition = 1:N，也就是说同一个消费者实例和partition的对应关系是1：N offset 位移（offset）:consumer记录消费消息的位置 kafka的位移机制：\n\n * consumer实例保存自己的offset,通过checkPoint机制定期持久化\n * 新版本的kafka通过topic定期持久化到broker\n * 老版本的kafka是持久化到zk的，但是zk并不适合频繁的写\n\nrebalance 一个groupId内有多个consumer，其订阅topic有多个partition，那么那个消费者消费那个partition呢？rebalance就是做consumer和partition的匹配。\n\n什么时候rebalance\n\n * 组成员的变更（consumer的加入或者离开、崩溃）\n * 订阅的partition发生变更\n * 订阅的topic发生变更（按照正则方式订阅时是可能发生的）\n\n如何rebalance consumerClient有两种策略可选，通过partition.assignment.strategy配置；默认是Range策略\n\n * Range strategy：按照topic维度均分partition,问题是可能出现分配不均的问题\n * RoundRobin：所有partition均分，分配的更均匀\n\n谁来执行rebalance和consumer group管理 每个consumer group都会被分配一个coordinator用于组管理和位移管理。 当新版本consumer group的第一个consumer启动的时候，它会去和kafka server确定谁是它们组的coordinator，之后该group内的所有成员都会和该coordinator进行协调通信。\n\n谁是coordinator consumer group位移信息写入__consumers_offsets的分区为partition,该partition的leader所在的broker就是该组的coordinator。\n\n\n# 配置项\n\n\t//组唯一id\n\tpublic static final String GROUP_ID_CONFIG = \"group.id\";\n\n\n    //控制单次调用call()返回的记录数量\n    public static final String MAX_POLL_RECORDS_CONFIG = \"max.poll.records\";\n\n    /** 使用组管理的时候生效 如果consumer两次poll()调用时间超过这个阈值 组管理器会进行rebalance */\n    public static final String MAX_POLL_INTERVAL_MS_CONFIG = \"max.poll.interval.ms\";\n\n    /** consumer的心跳时间*/\n    public static final String SESSION_TIMEOUT_MS_CONFIG = \"session.timeout.ms\";\n    /**\n     * 自动提交offset 默认是true\n     * 可关闭，然后自己控制提交offset,通过auto.commit.interval.ms控制提交频次\n     */\n    public static final String ENABLE_AUTO_COMMIT_CONFIG = \"enable.auto.commit\";\n\n    /**\n     * 自动提交offset的频次\n     */\n    public static final String AUTO_COMMIT_INTERVAL_MS_CONFIG = \"auto.commit.interval.ms\";\n    /**\n     * 自定义分区策略的class全路径\n     */\n    public static final String PARTITION_ASSIGNMENT_STRATEGY_CONFIG = \"partition.assignment.strategy\";\n\n    /**\n     * 当offset不存在或者失效的情况下，指定消费策略\n     * 有两次消费策略earliest、latest\n     * 分别表示从最新的消息开始消费还是从最早的开始消费\n     */\n    public static final String AUTO_OFFSET_RESET_CONFIG = \"auto.offset.reset\";\n\n    /**\n     * 指定从broker获取的最小的数据量字节数\n     * 如果broker的数据量小于该配置那么会等一会再返回consumer\n     * 可降低broker和consumer之间的交互次数\n     */\n    public static final String FETCH_MIN_BYTES_CONFIG = \"fetch.min.bytes\";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",
      "normalizedContent": "# 几个概念\n\n消费者组 多个消费实例共享一个groupid,多个消费实例组织在一起协调消费订阅的主题和分区。 消费实例可以是一个进程也可以是一个线程 groupid是一个字符串，唯一标识一个消费组 groupid.consumerinstance:groupid.partition = 1:n，也就是说同一个消费者实例和partition的对应关系是1：n offset 位移（offset）:consumer记录消费消息的位置 kafka的位移机制：\n\n * consumer实例保存自己的offset,通过checkpoint机制定期持久化\n * 新版本的kafka通过topic定期持久化到broker\n * 老版本的kafka是持久化到zk的，但是zk并不适合频繁的写\n\nrebalance 一个groupid内有多个consumer，其订阅topic有多个partition，那么那个消费者消费那个partition呢？rebalance就是做consumer和partition的匹配。\n\n什么时候rebalance\n\n * 组成员的变更（consumer的加入或者离开、崩溃）\n * 订阅的partition发生变更\n * 订阅的topic发生变更（按照正则方式订阅时是可能发生的）\n\n如何rebalance consumerclient有两种策略可选，通过partition.assignment.strategy配置；默认是range策略\n\n * range strategy：按照topic维度均分partition,问题是可能出现分配不均的问题\n * roundrobin：所有partition均分，分配的更均匀\n\n谁来执行rebalance和consumer group管理 每个consumer group都会被分配一个coordinator用于组管理和位移管理。 当新版本consumer group的第一个consumer启动的时候，它会去和kafka server确定谁是它们组的coordinator，之后该group内的所有成员都会和该coordinator进行协调通信。\n\n谁是coordinator consumer group位移信息写入__consumers_offsets的分区为partition,该partition的leader所在的broker就是该组的coordinator。\n\n\n# 配置项\n\n\t//组唯一id\n\tpublic static final string group_id_config = \"group.id\";\n\n\n    //控制单次调用call()返回的记录数量\n    public static final string max_poll_records_config = \"max.poll.records\";\n\n    /** 使用组管理的时候生效 如果consumer两次poll()调用时间超过这个阈值 组管理器会进行rebalance */\n    public static final string max_poll_interval_ms_config = \"max.poll.interval.ms\";\n\n    /** consumer的心跳时间*/\n    public static final string session_timeout_ms_config = \"session.timeout.ms\";\n    /**\n     * 自动提交offset 默认是true\n     * 可关闭，然后自己控制提交offset,通过auto.commit.interval.ms控制提交频次\n     */\n    public static final string enable_auto_commit_config = \"enable.auto.commit\";\n\n    /**\n     * 自动提交offset的频次\n     */\n    public static final string auto_commit_interval_ms_config = \"auto.commit.interval.ms\";\n    /**\n     * 自定义分区策略的class全路径\n     */\n    public static final string partition_assignment_strategy_config = \"partition.assignment.strategy\";\n\n    /**\n     * 当offset不存在或者失效的情况下，指定消费策略\n     * 有两次消费策略earliest、latest\n     * 分别表示从最新的消息开始消费还是从最早的开始消费\n     */\n    public static final string auto_offset_reset_config = \"auto.offset.reset\";\n\n    /**\n     * 指定从broker获取的最小的数据量字节数\n     * 如果broker的数据量小于该配置那么会等一会再返回consumer\n     * 可降低broker和consumer之间的交互次数\n     */\n    public static final string fetch_min_bytes_config = \"fetch.min.bytes\";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Mybatis",
      "frontmatter": {
        "title": "Mybatis",
        "date": "2022-03-11T00:57:23.000Z",
        "permalink": "/pages/3793a5/",
        "categories": [
          "中间件",
          "Mybatis"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/30.Mybatis/01.Mybatis.html",
      "relativePath": "04.中间件/30.Mybatis/01.Mybatis.md",
      "key": "v-7cd0ca26",
      "path": "/pages/3793a5/",
      "headers": [
        {
          "level": 2,
          "title": "Mybatis缓存机制",
          "slug": "mybatis缓存机制",
          "normalizedTitle": "mybatis缓存机制",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "#{}和${}的区别",
          "slug": "和-的区别",
          "normalizedTitle": "#{}和${}的区别",
          "charIndex": 18
        },
        {
          "level": 2,
          "title": "mapper中传递多个参数",
          "slug": "mapper中传递多个参数",
          "normalizedTitle": "mapper中传递多个参数",
          "charIndex": 33
        },
        {
          "level": 2,
          "title": "Mybatis动态sql",
          "slug": "mybatis动态sql",
          "normalizedTitle": "mybatis动态sql",
          "charIndex": 51
        },
        {
          "level": 2,
          "title": "Mybatis的延迟加载",
          "slug": "mybatis的延迟加载",
          "normalizedTitle": "mybatis的延迟加载",
          "charIndex": 68
        }
      ],
      "headersStr": "Mybatis缓存机制 #{}和${}的区别 mapper中传递多个参数 Mybatis动态sql Mybatis的延迟加载",
      "content": "# Mybatis缓存机制\n\n\n# #{}和${}的区别\n\n\n# mapper中传递多个参数\n\n\n# Mybatis动态sql\n\n\n# Mybatis的延迟加载",
      "normalizedContent": "# mybatis缓存机制\n\n\n# #{}和${}的区别\n\n\n# mapper中传递多个参数\n\n\n# mybatis动态sql\n\n\n# mybatis的延迟加载",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "如何保证Kafka的可靠性",
      "frontmatter": {
        "title": "如何保证Kafka的可靠性",
        "date": "2022-05-21T23:47:03.000Z",
        "permalink": "/pages/76a94c/",
        "categories": [
          "中间件",
          "Kafka"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/040.%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Kafka%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7.html",
      "relativePath": "04.中间件/40.Kafka/040.如何保证Kafka的可靠性.md",
      "key": "v-684c4815",
      "path": "/pages/76a94c/",
      "headersStr": null,
      "content": "# 可靠性保证\n\nkafka在哪些方面做出保证呢？\n\n * 单生产者，kafka可以保证顺序消费\n * 只有当写入的消息被写入所有的副本时，才认为是“已提交”的\n * 只要有一个活跃的分区副本，那么，已提交的数据就不会丢失。\n * 消费者只能读取已经提交的消息\n\n如何保证topic元数据信息安全 replication.factor配置topic的复制系数\n\n所有的分区副本都没有正常同步，分区首领又挂掉了，如何做选举？ 方案有两个\n\n * 在未正常同步的副中选举一个作为首领，缺点是存在丢失数据的风险。\n * 等待旧的首领恢复。缺点是可用性低。\n\n配置unclean.leader.election.enable=true表示允许不同步的副本称为首领，这也将面临丢失消息的风险。\n\n\n# producer如何做可靠性保证\n\n如何保证可靠投递消息？\n\n 1. ack=all表示broker要等待所有分区副本同步完消息才返回给producer response，是最可靠的投递。\n 2. 设置重试次数，注意要做业务幂等。\n 3. 有些小时不可重试错误，比如消息太大、认证错误等。根据业务来特殊处理这类消息。\n\n\n# consumer如何做可靠性保证\n\nconsumer请求的offset在broker上不存在时怎么处理？ 配置auto.offset.reset指定了两种策略：\n\n * earliest:从分区的开始读取\n * latest：从分区的末尾读取",
      "normalizedContent": "# 可靠性保证\n\nkafka在哪些方面做出保证呢？\n\n * 单生产者，kafka可以保证顺序消费\n * 只有当写入的消息被写入所有的副本时，才认为是“已提交”的\n * 只要有一个活跃的分区副本，那么，已提交的数据就不会丢失。\n * 消费者只能读取已经提交的消息\n\n如何保证topic元数据信息安全 replication.factor配置topic的复制系数\n\n所有的分区副本都没有正常同步，分区首领又挂掉了，如何做选举？ 方案有两个\n\n * 在未正常同步的副中选举一个作为首领，缺点是存在丢失数据的风险。\n * 等待旧的首领恢复。缺点是可用性低。\n\n配置unclean.leader.election.enable=true表示允许不同步的副本称为首领，这也将面临丢失消息的风险。\n\n\n# producer如何做可靠性保证\n\n如何保证可靠投递消息？\n\n 1. ack=all表示broker要等待所有分区副本同步完消息才返回给producer response，是最可靠的投递。\n 2. 设置重试次数，注意要做业务幂等。\n 3. 有些小时不可重试错误，比如消息太大、认证错误等。根据业务来特殊处理这类消息。\n\n\n# consumer如何做可靠性保证\n\nconsumer请求的offset在broker上不存在时怎么处理？ 配置auto.offset.reset指定了两种策略：\n\n * earliest:从分区的开始读取\n * latest：从分区的末尾读取",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "集群下的Kafka要考虑哪些事情",
      "frontmatter": {
        "title": "集群下的Kafka要考虑哪些事情",
        "date": "2022-05-21T23:46:20.000Z",
        "permalink": "/pages/8d1d04/",
        "categories": [
          "中间件",
          "Kafka"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/40.Kafka/030.%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84Kafka%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85.html",
      "relativePath": "04.中间件/40.Kafka/030.集群下的Kafka要考虑哪些事情.md",
      "key": "v-0c440466",
      "path": "/pages/8d1d04/",
      "headersStr": null,
      "content": "# 集群成员关系\n\nKafka使用 Zookeeper来维护集群成员的信息. 每个broker都有唯一的标识符，可以配置指定，也可以自动生成。 在broker启动时，他通过创建临时节点把自己注册到zk。 broker订阅zk的/brokers/ids路径，当有broker加入或者退出集群时，这些组件可以获得通知。\n\n在关闭 broker时，它对应的节点也会消失，不过它的 ID会继续存在于其他数据结构中。例如，主题的副本列表(下面会介绍)里就可能包含这些ID。 在完全关闭一个 broker之 后，如果使用相同的 ID 启动另一个全新的 broker，它会立即加入集群，井拥有与旧 broker 相同的分区和主题。\n\n\n# 控制器\n\n控制器其实就是 一 个 broker，只不过它除了具有一般 broker 的功能之外，还负责分区 首领的选举。 哪个broker可以成为控制器？ 在集群启动时，所有broker都会尝试在zk创建节点/controller，但是只有一个broker可以创建成功，它就是控制器。 非控制器的broker节点会在控制器节点创建zk watch对象，用于接收这个节点的变更通知。 通过watch对象得知控制器节点消失，那么其他broker节点会进入下一轮的首领选举，选举成功会有一个新的递增的ID产生。 新broker加入集群会发生什么？ 控制器会检查新broker是否包含现有分区的副本，如果有，则通知其他broker，允许新的broker同步分区副本。 broker退出集群会发生什么？ 控制器监听到broker离开集群的消息，check哪些分区首领在该broker上。然后再其他broker上选举新的分区首领，并通知所有broker新的分区首领。\n\n\n# 复制\n\nkafka是一个分布式的、可分区的、可复制的提交日志服务。 复制什么？ 每个topic由对个partition、每个partition有多个副本，其中一个是首领副本，其他是跟随者副本。 该partition的生产者和消费者请求都会经过首领副本。 复制就发生在首领副本和跟随者副本之间。 当首领副本崩溃时，其中一个跟随者副本可以提升为首领副本。 当首领副本崩溃时，哪个跟随者副本可以提升为首领副本 不同步的跟随者是不能成为首领的 什么标准判断一个跟随者是不同步的？ 跟随者请求同步时总是按照offset递增的顺序请求同步的消息，而且总是在收到上一个请求的影响之后才会发出下一个请求。所以当首领收不到follower的请求最新的offset时或者一定时间内收不到follower的同步请求时，认为这个follower是不同步的。这个一定时间可以通过replica.lg.time.max.ms配置。 首选首领是可以优先称为下一届首领的。 首选首领是在创建分区时，为了在broker之间均衡首领选举的分区首领。\n\n\n# 处理请求\n\nbroker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求。 producer的生产请求和consumer的获取请求都必须发送给分区的首领副本。 那么客户端怎么知道谁是首领副本呢? 客户端使用了另一 种请求类型，也就是元数据请求。请求到元数据后缓存在本地。 通过配置matedata.max.age.ms设置定时刷新元数据。\n\n生产者请求 包含首领副本的 broker在收到生产请求时，会对请求做一些验证\n\n * 发送数据的用户是否有主题的写权限\n * 请求里的acks值是否是有效值（只允许0、1、all）\n * 如果acks=all，是否有足够的读本保证消息已经被安全写入？ 以上都做完给客户端相应。\n\n消费者请求 客户端可以指定broker最多从一个分区里返回多少数据，这是有必要的，因为broker返回大量的数据有可能撑爆客户端的buffer broke会check请求是否有效，比如请求的偏移量是否存在，如果存在，则用零拷贝的方式返回数据。 客户端也可以指定broker积攒一定的数据再返回，避免频繁的网络IO。 并不是首领副本上的消息都可以返回给客户端，只有被所有follower同步了的消息才可以返回给客户端。\n\n\n# 物理存储\n\nkafka的基本存储单元是分区。 log.dirs配置用于指定存储分区的目录。 如何做分区和broker之间的分配 加入要在6个broker的kafka集群上创建分区数为10复制系数为3的主题，那么这30个分区副本如何分配给6个broker? 做分区和broker之间的分配要遵循以下原则：\n\n * 在broker间平均的分布分区副本\n * 每个分区的副本尽可能的分布在不同的broker上\n * 如果制定了broker的机架信息，尽可能的把每个分区的副本分配到不同的机架上\n\n依照这个规则，分配方式可以如下：\n\n 1. 先均匀分配首领分区。随机选一个broker，轮训的方式给每个broker分配分区来确定首领分区的位置。\n 2. 再均匀分配分区副本。以首领分区为起点，了轮训分配分区副本。\n 3. 指定机架信息的时候，均匀分配分区的方式。假设 broker0、 broker1和 broker2放置在同一个机架上， broker3、 broker4 和 broker5分别放置在其他不同的机架上，那么在轮训分配的时候，我们不是按照从 0到 5的顺序来选择 broker，而 是按照 0, 3, 1, 4, 2, 5 的顺序来选择。\n\n如何做文件管理 因为在一个大文件中查找和删除是非常耗时的，所以我们把分区分成若干个片段。默认每个片段包含1G或者1周的数据。 当前正在写入数据的片段叫做活跃片段。活跃片段永远不会被删除。 broker会为分区的每个片段打开一个文件句柄，这会导致打开过多的文件句柄，所以操作系统必须根据实际情况做一些调优。 broker如何在一个分区的众多文件中定位指定的offset位置？ kakfa为每个分区文件建立索引，根据索引可以快速定位offset在文件中的位置。\n\n如果有必要，管理员可以删除索引，kafka会重新生成这些索引。",
      "normalizedContent": "# 集群成员关系\n\nkafka使用 zookeeper来维护集群成员的信息. 每个broker都有唯一的标识符，可以配置指定，也可以自动生成。 在broker启动时，他通过创建临时节点把自己注册到zk。 broker订阅zk的/brokers/ids路径，当有broker加入或者退出集群时，这些组件可以获得通知。\n\n在关闭 broker时，它对应的节点也会消失，不过它的 id会继续存在于其他数据结构中。例如，主题的副本列表(下面会介绍)里就可能包含这些id。 在完全关闭一个 broker之 后，如果使用相同的 id 启动另一个全新的 broker，它会立即加入集群，井拥有与旧 broker 相同的分区和主题。\n\n\n# 控制器\n\n控制器其实就是 一 个 broker，只不过它除了具有一般 broker 的功能之外，还负责分区 首领的选举。 哪个broker可以成为控制器？ 在集群启动时，所有broker都会尝试在zk创建节点/controller，但是只有一个broker可以创建成功，它就是控制器。 非控制器的broker节点会在控制器节点创建zk watch对象，用于接收这个节点的变更通知。 通过watch对象得知控制器节点消失，那么其他broker节点会进入下一轮的首领选举，选举成功会有一个新的递增的id产生。 新broker加入集群会发生什么？ 控制器会检查新broker是否包含现有分区的副本，如果有，则通知其他broker，允许新的broker同步分区副本。 broker退出集群会发生什么？ 控制器监听到broker离开集群的消息，check哪些分区首领在该broker上。然后再其他broker上选举新的分区首领，并通知所有broker新的分区首领。\n\n\n# 复制\n\nkafka是一个分布式的、可分区的、可复制的提交日志服务。 复制什么？ 每个topic由对个partition、每个partition有多个副本，其中一个是首领副本，其他是跟随者副本。 该partition的生产者和消费者请求都会经过首领副本。 复制就发生在首领副本和跟随者副本之间。 当首领副本崩溃时，其中一个跟随者副本可以提升为首领副本。 当首领副本崩溃时，哪个跟随者副本可以提升为首领副本 不同步的跟随者是不能成为首领的 什么标准判断一个跟随者是不同步的？ 跟随者请求同步时总是按照offset递增的顺序请求同步的消息，而且总是在收到上一个请求的影响之后才会发出下一个请求。所以当首领收不到follower的请求最新的offset时或者一定时间内收不到follower的同步请求时，认为这个follower是不同步的。这个一定时间可以通过replica.lg.time.max.ms配置。 首选首领是可以优先称为下一届首领的。 首选首领是在创建分区时，为了在broker之间均衡首领选举的分区首领。\n\n\n# 处理请求\n\nbroker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求。 producer的生产请求和consumer的获取请求都必须发送给分区的首领副本。 那么客户端怎么知道谁是首领副本呢? 客户端使用了另一 种请求类型，也就是元数据请求。请求到元数据后缓存在本地。 通过配置matedata.max.age.ms设置定时刷新元数据。\n\n生产者请求 包含首领副本的 broker在收到生产请求时，会对请求做一些验证\n\n * 发送数据的用户是否有主题的写权限\n * 请求里的acks值是否是有效值（只允许0、1、all）\n * 如果acks=all，是否有足够的读本保证消息已经被安全写入？ 以上都做完给客户端相应。\n\n消费者请求 客户端可以指定broker最多从一个分区里返回多少数据，这是有必要的，因为broker返回大量的数据有可能撑爆客户端的buffer broke会check请求是否有效，比如请求的偏移量是否存在，如果存在，则用零拷贝的方式返回数据。 客户端也可以指定broker积攒一定的数据再返回，避免频繁的网络io。 并不是首领副本上的消息都可以返回给客户端，只有被所有follower同步了的消息才可以返回给客户端。\n\n\n# 物理存储\n\nkafka的基本存储单元是分区。 log.dirs配置用于指定存储分区的目录。 如何做分区和broker之间的分配 加入要在6个broker的kafka集群上创建分区数为10复制系数为3的主题，那么这30个分区副本如何分配给6个broker? 做分区和broker之间的分配要遵循以下原则：\n\n * 在broker间平均的分布分区副本\n * 每个分区的副本尽可能的分布在不同的broker上\n * 如果制定了broker的机架信息，尽可能的把每个分区的副本分配到不同的机架上\n\n依照这个规则，分配方式可以如下：\n\n 1. 先均匀分配首领分区。随机选一个broker，轮训的方式给每个broker分配分区来确定首领分区的位置。\n 2. 再均匀分配分区副本。以首领分区为起点，了轮训分配分区副本。\n 3. 指定机架信息的时候，均匀分配分区的方式。假设 broker0、 broker1和 broker2放置在同一个机架上， broker3、 broker4 和 broker5分别放置在其他不同的机架上，那么在轮训分配的时候，我们不是按照从 0到 5的顺序来选择 broker，而 是按照 0, 3, 1, 4, 2, 5 的顺序来选择。\n\n如何做文件管理 因为在一个大文件中查找和删除是非常耗时的，所以我们把分区分成若干个片段。默认每个片段包含1g或者1周的数据。 当前正在写入数据的片段叫做活跃片段。活跃片段永远不会被删除。 broker会为分区的每个片段打开一个文件句柄，这会导致打开过多的文件句柄，所以操作系统必须根据实际情况做一些调优。 broker如何在一个分区的众多文件中定位指定的offset位置？ kakfa为每个分区文件建立索引，根据索引可以快速定位offset在文件中的位置。\n\n如果有必要，管理员可以删除索引，kafka会重新生成这些索引。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "Dubbo",
      "frontmatter": {
        "title": "Dubbo",
        "date": "2020-05-21T21:50:26.000Z",
        "permalink": "/pages/78517c/",
        "categories": [
          "中间件",
          "Dubbo"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/50.Dubbo/01.Dubbo.html",
      "relativePath": "04.中间件/50.Dubbo/01.Dubbo.md",
      "key": "v-03ae2029",
      "path": "/pages/78517c/",
      "headers": [
        {
          "level": 2,
          "title": "简述 Dubbo 服务调用过程",
          "slug": "简述-dubbo-服务调用过程",
          "normalizedTitle": "简述 dubbo 服务调用过程",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "简述 Dubbo 服务注册与发现的过程",
          "slug": "简述-dubbo-服务注册与发现的过程",
          "normalizedTitle": "简述 dubbo 服务注册与发现的过程",
          "charIndex": 22
        }
      ],
      "headersStr": "简述 Dubbo 服务调用过程 简述 Dubbo 服务注册与发现的过程",
      "content": "# 简述 Dubbo 服务调用过程\n\n\n# 简述 Dubbo 服务注册与发现的过程",
      "normalizedContent": "# 简述 dubbo 服务调用过程\n\n\n# 简述 dubbo 服务注册与发现的过程",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "系统设计",
      "frontmatter": {
        "title": "系统设计",
        "date": "2022-03-11T00:56:07.000Z",
        "permalink": "/pages/01b9b2/",
        "categories": [
          "系统设计"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/001.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html",
      "relativePath": "08.系统设计/001.系统设计.md",
      "key": "v-a9558ec0",
      "path": "/pages/01b9b2/",
      "headers": [
        {
          "level": 2,
          "title": "电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？",
          "slug": "电商系统中-如何实现秒杀功能-如何解决商品的超卖问题",
          "normalizedTitle": "电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "如何解决缓存与数据库不一致的问题？",
          "slug": "如何解决缓存与数据库不一致的问题",
          "normalizedTitle": "如何解决缓存与数据库不一致的问题？",
          "charIndex": 34
        },
        {
          "level": 2,
          "title": "简述中间件削峰和限流的使用场景",
          "slug": "简述中间件削峰和限流的使用场景",
          "normalizedTitle": "简述中间件削峰和限流的使用场景",
          "charIndex": 56
        },
        {
          "level": 2,
          "title": "项目上有什么技术难点？",
          "slug": "项目上有什么技术难点",
          "normalizedTitle": "项目上有什么技术难点？",
          "charIndex": 76
        },
        {
          "level": 2,
          "title": "简述 Zookeeper 基础原理以及使用场景",
          "slug": "简述-zookeeper-基础原理以及使用场景",
          "normalizedTitle": "简述 zookeeper 基础原理以及使用场景",
          "charIndex": 92
        },
        {
          "level": 2,
          "title": "如何实现百度搜索功能？",
          "slug": "如何实现百度搜索功能",
          "normalizedTitle": "如何实现百度搜索功能？",
          "charIndex": 120
        },
        {
          "level": 2,
          "title": "高并发情景下，核心线程池该如何设置参数？",
          "slug": "高并发情景下-核心线程池该如何设置参数",
          "normalizedTitle": "高并发情景下，核心线程池该如何设置参数？",
          "charIndex": 136
        },
        {
          "level": 2,
          "title": "设计一个阻塞队列",
          "slug": "设计一个阻塞队列",
          "normalizedTitle": "设计一个阻塞队列",
          "charIndex": 161
        },
        {
          "level": 2,
          "title": "容器化了解吗？它的基本原理是什么？",
          "slug": "容器化了解吗-它的基本原理是什么",
          "normalizedTitle": "容器化了解吗？它的基本原理是什么？",
          "charIndex": 174
        },
        {
          "level": 2,
          "title": "如何实现唯一的分布式 ID",
          "slug": "如何实现唯一的分布式-id",
          "normalizedTitle": "如何实现唯一的分布式 id",
          "charIndex": 196
        },
        {
          "level": 2,
          "title": "简述中间件削峰和限流的使用场景",
          "slug": "简述中间件削峰和限流的使用场景-2",
          "normalizedTitle": "简述中间件削峰和限流的使用场景",
          "charIndex": 56
        },
        {
          "level": 2,
          "title": "简述一致性哈希算法的实现方式及原理",
          "slug": "简述一致性哈希算法的实现方式及原理",
          "normalizedTitle": "简述一致性哈希算法的实现方式及原理",
          "charIndex": 234
        },
        {
          "level": 2,
          "title": "简述常见的负载均衡算法",
          "slug": "简述常见的负载均衡算法",
          "normalizedTitle": "简述常见的负载均衡算法",
          "charIndex": 256
        },
        {
          "level": 2,
          "title": "简述 MapReduce 的原理",
          "slug": "简述-mapreduce-的原理",
          "normalizedTitle": "简述 mapreduce 的原理",
          "charIndex": 272
        },
        {
          "level": 2,
          "title": "设计 Tiny URL 系统",
          "slug": "设计-tiny-url-系统",
          "normalizedTitle": "设计 tiny url 系统",
          "charIndex": 293
        },
        {
          "level": 2,
          "title": "如何设计一个无锁队列",
          "slug": "如何设计一个无锁队列",
          "normalizedTitle": "如何设计一个无锁队列",
          "charIndex": 312
        },
        {
          "level": 2,
          "title": "RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？",
          "slug": "restful-与-rpc-的区别是什么-restful-的优点在哪里",
          "normalizedTitle": "restful 与 rpc 的区别是什么？restful 的优点在哪里？",
          "charIndex": 327
        },
        {
          "level": 2,
          "title": "假如明天是活动高峰？QPS 预计会翻10倍，你要怎么做？",
          "slug": "假如明天是活动高峰-qps-预计会翻10倍-你要怎么做",
          "normalizedTitle": "假如明天是活动高峰？qps 预计会翻10倍，你要怎么做？",
          "charIndex": 368
        }
      ],
      "headersStr": "电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？ 如何解决缓存与数据库不一致的问题？ 简述中间件削峰和限流的使用场景 项目上有什么技术难点？ 简述 Zookeeper 基础原理以及使用场景 如何实现百度搜索功能？ 高并发情景下，核心线程池该如何设置参数？ 设计一个阻塞队列 容器化了解吗？它的基本原理是什么？ 如何实现唯一的分布式 ID 简述中间件削峰和限流的使用场景 简述一致性哈希算法的实现方式及原理 简述常见的负载均衡算法 简述 MapReduce 的原理 设计 Tiny URL 系统 如何设计一个无锁队列 RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？ 假如明天是活动高峰？QPS 预计会翻10倍，你要怎么做？",
      "content": "# 电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？\n\n\n# 如何解决缓存与数据库不一致的问题？\n\n\n# 简述中间件削峰和限流的使用场景\n\n\n# 项目上有什么技术难点？\n\n\n# 简述 Zookeeper 基础原理以及使用场景\n\n\n# 如何实现百度搜索功能？\n\n\n# 高并发情景下，核心线程池该如何设置参数？\n\n\n# 设计一个阻塞队列\n\n\n# 容器化了解吗？它的基本原理是什么？\n\n\n# 如何实现唯一的分布式 ID\n\n\n# 简述中间件削峰和限流的使用场景\n\n\n# 简述一致性哈希算法的实现方式及原理\n\n\n# 简述常见的负载均衡算法\n\n\n# 简述 MapReduce 的原理\n\n\n# 设计 Tiny URL 系统\n\n\n# 如何设计一个无锁队列\n\n\n# RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？\n\n\n# 假如明天是活动高峰？QPS 预计会翻10倍，你要怎么做？",
      "normalizedContent": "# 电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？\n\n\n# 如何解决缓存与数据库不一致的问题？\n\n\n# 简述中间件削峰和限流的使用场景\n\n\n# 项目上有什么技术难点？\n\n\n# 简述 zookeeper 基础原理以及使用场景\n\n\n# 如何实现百度搜索功能？\n\n\n# 高并发情景下，核心线程池该如何设置参数？\n\n\n# 设计一个阻塞队列\n\n\n# 容器化了解吗？它的基本原理是什么？\n\n\n# 如何实现唯一的分布式 id\n\n\n# 简述中间件削峰和限流的使用场景\n\n\n# 简述一致性哈希算法的实现方式及原理\n\n\n# 简述常见的负载均衡算法\n\n\n# 简述 mapreduce 的原理\n\n\n# 设计 tiny url 系统\n\n\n# 如何设计一个无锁队列\n\n\n# restful 与 rpc 的区别是什么？restful 的优点在哪里？\n\n\n# 假如明天是活动高峰？qps 预计会翻10倍，你要怎么做？",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "非技术问题",
      "frontmatter": {
        "title": "非技术问题",
        "date": "2022-03-27T13:53:27.000Z",
        "permalink": "/pages/5e507a/",
        "categories": [
          "非技术"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/10.%E9%9D%9E%E6%8A%80%E6%9C%AF/01.%E9%9D%9E%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98.html",
      "relativePath": "10.非技术/01.非技术问题.md",
      "key": "v-2a52a762",
      "path": "/pages/5e507a/",
      "headers": [
        {
          "level": 2,
          "title": "最有技术难度的项目是什么？遇到技术难点怎么解决？",
          "slug": "最有技术难度的项目是什么-遇到技术难点怎么解决",
          "normalizedTitle": "最有技术难度的项目是什么？遇到技术难点怎么解决？",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "为什么要离开现在的公司？",
          "slug": "为什么要离开现在的公司",
          "normalizedTitle": "为什么要离开现在的公司？",
          "charIndex": 31
        },
        {
          "level": 2,
          "title": "未来的职业规划是什么？",
          "slug": "未来的职业规划是什么",
          "normalizedTitle": "未来的职业规划是什么？",
          "charIndex": 48
        },
        {
          "level": 2,
          "title": "下一份工作希望学习到什么？",
          "slug": "下一份工作希望学习到什么",
          "normalizedTitle": "下一份工作希望学习到什么？",
          "charIndex": 64
        },
        {
          "level": 2,
          "title": "团队中对技术选型有冲突的话怎么解决？",
          "slug": "团队中对技术选型有冲突的话怎么解决",
          "normalizedTitle": "团队中对技术选型有冲突的话怎么解决？",
          "charIndex": 82
        },
        {
          "level": 2,
          "title": "你的性格和技能上有什么缺点",
          "slug": "你的性格和技能上有什么缺点",
          "normalizedTitle": "你的性格和技能上有什么缺点",
          "charIndex": 105
        },
        {
          "level": 2,
          "title": "简单描述一下自己是怎么样的人？",
          "slug": "简单描述一下自己是怎么样的人",
          "normalizedTitle": "简单描述一下自己是怎么样的人？",
          "charIndex": 123
        },
        {
          "level": 2,
          "title": "学习中遇到的最大的困难是什么？",
          "slug": "学习中遇到的最大的困难是什么",
          "normalizedTitle": "学习中遇到的最大的困难是什么？",
          "charIndex": 143
        },
        {
          "level": 2,
          "title": "最有成就感的项目是什么？",
          "slug": "最有成就感的项目是什么",
          "normalizedTitle": "最有成就感的项目是什么？",
          "charIndex": 163
        },
        {
          "level": 2,
          "title": "团队合作沟通中遇到过什么问题？",
          "slug": "团队合作沟通中遇到过什么问题",
          "normalizedTitle": "团队合作沟通中遇到过什么问题？",
          "charIndex": 180
        },
        {
          "level": 2,
          "title": "目前为止，坚持得最久一件事情是什么？",
          "slug": "目前为止-坚持得最久一件事情是什么",
          "normalizedTitle": "目前为止，坚持得最久一件事情是什么？",
          "charIndex": 200
        },
        {
          "level": 2,
          "title": "能接受多大强度的加班？",
          "slug": "能接受多大强度的加班",
          "normalizedTitle": "能接受多大强度的加班？",
          "charIndex": 223
        },
        {
          "level": 2,
          "title": "最近在看什么书吗，有没有接触过什么新技术？",
          "slug": "最近在看什么书吗-有没有接触过什么新技术",
          "normalizedTitle": "最近在看什么书吗，有没有接触过什么新技术？",
          "charIndex": 239
        }
      ],
      "headersStr": "最有技术难度的项目是什么？遇到技术难点怎么解决？ 为什么要离开现在的公司？ 未来的职业规划是什么？ 下一份工作希望学习到什么？ 团队中对技术选型有冲突的话怎么解决？ 你的性格和技能上有什么缺点 简单描述一下自己是怎么样的人？ 学习中遇到的最大的困难是什么？ 最有成就感的项目是什么？ 团队合作沟通中遇到过什么问题？ 目前为止，坚持得最久一件事情是什么？ 能接受多大强度的加班？ 最近在看什么书吗，有没有接触过什么新技术？",
      "content": "# 最有技术难度的项目是什么？遇到技术难点怎么解决？\n\n\n# 为什么要离开现在的公司？\n\n\n# 未来的职业规划是什么？\n\n\n# 下一份工作希望学习到什么？\n\n\n# 团队中对技术选型有冲突的话怎么解决？\n\n\n# 你的性格和技能上有什么缺点\n\n\n# 简单描述一下自己是怎么样的人？\n\n\n# 学习中遇到的最大的困难是什么？\n\n\n# 最有成就感的项目是什么？\n\n\n# 团队合作沟通中遇到过什么问题？\n\n\n# 目前为止，坚持得最久一件事情是什么？\n\n\n# 能接受多大强度的加班？\n\n\n# 最近在看什么书吗，有没有接触过什么新技术？",
      "normalizedContent": "# 最有技术难度的项目是什么？遇到技术难点怎么解决？\n\n\n# 为什么要离开现在的公司？\n\n\n# 未来的职业规划是什么？\n\n\n# 下一份工作希望学习到什么？\n\n\n# 团队中对技术选型有冲突的话怎么解决？\n\n\n# 你的性格和技能上有什么缺点\n\n\n# 简单描述一下自己是怎么样的人？\n\n\n# 学习中遇到的最大的困难是什么？\n\n\n# 最有成就感的项目是什么？\n\n\n# 团队合作沟通中遇到过什么问题？\n\n\n# 目前为止，坚持得最久一件事情是什么？\n\n\n# 能接受多大强度的加班？\n\n\n# 最近在看什么书吗，有没有接触过什么新技术？",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "什么是 CAP ？什么是最终一致性？什么是幂等操作？",
      "frontmatter": {
        "title": "什么是 CAP ？什么是最终一致性？什么是幂等操作？",
        "date": "2022-05-21T17:11:49.000Z",
        "permalink": "/pages/20c647/",
        "categories": [
          "系统设计"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/010.%E4%BB%80%E4%B9%88%E6%98%AF%20CAP%20%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%E6%93%8D%E4%BD%9C%EF%BC%9F.html",
      "relativePath": "08.系统设计/010.什么是 CAP ？什么是最终一致性？什么是幂等操作？.md",
      "key": "v-5675b06b",
      "path": "/pages/20c647/",
      "headers": [
        {
          "level": 3,
          "title": "CAP理论",
          "slug": "cap理论",
          "normalizedTitle": "cap理论",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "为什么这三者如此重要？",
          "slug": "为什么这三者如此重要",
          "normalizedTitle": "为什么这三者如此重要？",
          "charIndex": 261
        },
        {
          "level": 3,
          "title": "CAP权衡",
          "slug": "cap权衡",
          "normalizedTitle": "cap权衡",
          "charIndex": 577
        },
        {
          "level": 3,
          "title": "三种组合",
          "slug": "三种组合",
          "normalizedTitle": "三种组合",
          "charIndex": 784
        },
        {
          "level": 3,
          "title": "一致性的妥协——最终一致性和Base原则",
          "slug": "一致性的妥协-最终一致性和base原则",
          "normalizedTitle": "一致性的妥协——最终一致性和base原则",
          "charIndex": 1070
        },
        {
          "level": 3,
          "title": "幂等性",
          "slug": "幂等性",
          "normalizedTitle": "幂等性",
          "charIndex": 1420
        },
        {
          "level": 3,
          "title": "如何解决幂等性问题",
          "slug": "如何解决幂等性问题",
          "normalizedTitle": "如何解决幂等性问题",
          "charIndex": 1560
        }
      ],
      "headersStr": "CAP理论 为什么这三者如此重要？ CAP权衡 三种组合 一致性的妥协——最终一致性和Base原则 幂等性 如何解决幂等性问题",
      "content": "# CAP理论\n\nCAP的结论非常简单：在分布式系统里，有3个属性非常重要，但只能同时满足其中的2个。\n\nConsistency：all nodes在任何时刻看到的data都是一样的（或说client的read操作总是返回最新写入的那个value） Availability：系统时刻都允许操作，并且操作总会快速被Coordinator响应，最终client很快就得到返回的结果 Partition-tolerance：尽管网路有时候会因为故障导致被分隔开，但是系统依然在正常工作（或者说在满足前述的条件下工作）\n\n\n# 为什么这三者如此重要？\n\nFor Availability：\n\n经统计，对于Google、Amazon这样的数据公司，系统增加500ms的延迟就会损失公司20%的收益，所以必须快速且可靠地进行 Read/Write。\n\nFor Consistency：\n\n比如在银行系统，任何client都必须查看到最新的updated data item，不然就会给交易造成致命的影响。\n\nFor Partition-tolerance：\n\n因为Internet可能因为某些原因随时断开（Router故障、海地线缆断开、DNS故障）；即使在同一个data center里，故障都会随时随地地发生，比如 Rack switcher 宕机。\n\n\n# CAP权衡\n\n * 如今的云计算环境里，因为网络随时都会被隔离开来，这是无法避免的，P是必须满足的，那么CAP暗示一个system要在C和A中做出抉择。\n * A和C并不是一个硬币的两面,只能选择其中一个;A和C应该看成天平,系统可以选择向哪边倾斜,但另一边也应该一定程度的保留。\n * 对于A和C之间的选择,不应该粗粒度的整个系统级别进行选取,而应该针对系统中的不同子系统,针对性的采取不同的取舍策略。\n\n\n# 三种组合\n\n * CA: 保证可用性和一致性,放弃分区:除非不是分布式架构,或者应用在一个永不会通信故障的网络中(理想),只有个别场景符合,当前的互联网架构显然不符合使用\n * CP: 保证一致性和分区容忍性,放弃可用性:当节点间不可通信时,进行阻塞,直到通信恢复,期间无法再对外提供服务,用户体验不好,如A转账给B,只有A扣款成功并B收款成功,整个事务才算完成,显然耗费资源\n * AP: 保证可用性和分区容忍性,放弃强一致性(使用最终一致性):给出一个用户可以忍受的时间,时间内达成数据的最终一致性,比如跨行转账,并不是立刻到账,可能是明天,或者2小时内到账\n\n\n# 一致性的妥协——最终一致性和Base原则\n\n * BA(Basically Available)基本可用:系统在绝大部分时间应处于可用状态,允许出现故障损失部分可用性,但保证核心可用。\n * S(Soft State)软状态:数据状态不要求在任何时刻都保持一致,允许存在中间状态,而该状态不影响系统可用性。对于多副本的存储系统而言,就是允许副本之间的同步存在延时,并且在这个过程中系统依旧可以响应客户端请求。\n * E(Eventual Consistency)最终一致性:尽管软状态不要求分布式数据在任何时刻都保持一致,但经过一定时间后,这些数据最终能达到一致性状态。 BASE理论的核心思想是:把分布式系统的可用性放在首位,放弃CAP中对数据强一致性的追求,只要系统能保证数据最终一致。\n\n\n# 幂等性\n\n在微服务架构下,不同微服务间会有大量的基于http,rpc或者mq消息的网络通信,接口的重复调用以及消息的重复消费可能会经常发生。\n\n微服务架构应该具有幂等性,当接口被重复调用时,消息被重复消费时,对系统的产生的影响应该和接口被调用一次,消息被消费一次时一样。\n\n\n# 如何解决幂等性问题\n\n * 全局唯一ID。根据业务生成一个全局唯一ID,在调用接口时会传入该ID,接口提供方会从相应的存储系统比如Redis中去检索这个全局ID是否存在,如果存在则说明该操作已经执行过了,将拒绝本次服务请求;否则将相应该服务请求并将全局ID存入存储系统中,之后包含相同业务ID参数的请求将被拒绝。\n\n * 数据库表唯一键。这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中,一个订单只会支付一次,可以建立一张去重表,将订单ID作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中,这样当出现重复支付时,数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。\n\n * 多版本并发控制适合对更新请求作幂等性控制,比如要更新商品的名字,这是就可以在更新的接口中增加一个版本号来做幂等性控制",
      "normalizedContent": "# cap理论\n\ncap的结论非常简单：在分布式系统里，有3个属性非常重要，但只能同时满足其中的2个。\n\nconsistency：all nodes在任何时刻看到的data都是一样的（或说client的read操作总是返回最新写入的那个value） availability：系统时刻都允许操作，并且操作总会快速被coordinator响应，最终client很快就得到返回的结果 partition-tolerance：尽管网路有时候会因为故障导致被分隔开，但是系统依然在正常工作（或者说在满足前述的条件下工作）\n\n\n# 为什么这三者如此重要？\n\nfor availability：\n\n经统计，对于google、amazon这样的数据公司，系统增加500ms的延迟就会损失公司20%的收益，所以必须快速且可靠地进行 read/write。\n\nfor consistency：\n\n比如在银行系统，任何client都必须查看到最新的updated data item，不然就会给交易造成致命的影响。\n\nfor partition-tolerance：\n\n因为internet可能因为某些原因随时断开（router故障、海地线缆断开、dns故障）；即使在同一个data center里，故障都会随时随地地发生，比如 rack switcher 宕机。\n\n\n# cap权衡\n\n * 如今的云计算环境里，因为网络随时都会被隔离开来，这是无法避免的，p是必须满足的，那么cap暗示一个system要在c和a中做出抉择。\n * a和c并不是一个硬币的两面,只能选择其中一个;a和c应该看成天平,系统可以选择向哪边倾斜,但另一边也应该一定程度的保留。\n * 对于a和c之间的选择,不应该粗粒度的整个系统级别进行选取,而应该针对系统中的不同子系统,针对性的采取不同的取舍策略。\n\n\n# 三种组合\n\n * ca: 保证可用性和一致性,放弃分区:除非不是分布式架构,或者应用在一个永不会通信故障的网络中(理想),只有个别场景符合,当前的互联网架构显然不符合使用\n * cp: 保证一致性和分区容忍性,放弃可用性:当节点间不可通信时,进行阻塞,直到通信恢复,期间无法再对外提供服务,用户体验不好,如a转账给b,只有a扣款成功并b收款成功,整个事务才算完成,显然耗费资源\n * ap: 保证可用性和分区容忍性,放弃强一致性(使用最终一致性):给出一个用户可以忍受的时间,时间内达成数据的最终一致性,比如跨行转账,并不是立刻到账,可能是明天,或者2小时内到账\n\n\n# 一致性的妥协——最终一致性和base原则\n\n * ba(basically available)基本可用:系统在绝大部分时间应处于可用状态,允许出现故障损失部分可用性,但保证核心可用。\n * s(soft state)软状态:数据状态不要求在任何时刻都保持一致,允许存在中间状态,而该状态不影响系统可用性。对于多副本的存储系统而言,就是允许副本之间的同步存在延时,并且在这个过程中系统依旧可以响应客户端请求。\n * e(eventual consistency)最终一致性:尽管软状态不要求分布式数据在任何时刻都保持一致,但经过一定时间后,这些数据最终能达到一致性状态。 base理论的核心思想是:把分布式系统的可用性放在首位,放弃cap中对数据强一致性的追求,只要系统能保证数据最终一致。\n\n\n# 幂等性\n\n在微服务架构下,不同微服务间会有大量的基于http,rpc或者mq消息的网络通信,接口的重复调用以及消息的重复消费可能会经常发生。\n\n微服务架构应该具有幂等性,当接口被重复调用时,消息被重复消费时,对系统的产生的影响应该和接口被调用一次,消息被消费一次时一样。\n\n\n# 如何解决幂等性问题\n\n * 全局唯一id。根据业务生成一个全局唯一id,在调用接口时会传入该id,接口提供方会从相应的存储系统比如redis中去检索这个全局id是否存在,如果存在则说明该操作已经执行过了,将拒绝本次服务请求;否则将相应该服务请求并将全局id存入存储系统中,之后包含相同业务id参数的请求将被拒绝。\n\n * 数据库表唯一键。这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中,一个订单只会支付一次,可以建立一张去重表,将订单id作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中,这样当出现重复支付时,数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。\n\n * 多版本并发控制适合对更新请求作幂等性控制,比如要更新商品的名字,这是就可以在更新的接口中增加一个版本号来做幂等性控制",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "简述什么是两阶段提交？",
      "frontmatter": {
        "title": "简述什么是两阶段提交？",
        "date": "2022-05-21T17:12:23.000Z",
        "permalink": "/pages/4eae5b/",
        "categories": [
          "系统设计"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/08.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/020.%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%9F.html",
      "relativePath": "08.系统设计/020.简述什么是两阶段提交？.md",
      "key": "v-f88544f4",
      "path": "/pages/4eae5b/",
      "headersStr": null,
      "content": "TCC/Try Confirm Cancel模式TCC模式只有在所有的服务的第一阶段（try）都成功的时候才进行第二阶段确认（Confirm）操作，否则进行补偿(Cancel)操作，而在try阶段是不会进行真正的业务处理的。\n\n\nTCC模式TCC模式的具体流程为两个阶段：Try，业务服务完成所有的业务检查，预留必需的业务资源如果Try在所有服务中都成功，那么执行Confirm操作，Confirm操作不做任何的业务检查（因为try中已经做过），只是用Try阶段预留的业务资源进行业务处理；否则进行Cancel操作，Cancel操作释放Try阶段预留的业务资源。\n\n\n这么说可能比较模糊，下面我举一个具体的例子，小明在线从招商银行转账100元到广发银行。\n\n\n这个操作可看作两个服务，服务a从小明的招行账户转出100元，服务b从小明的广发银行帐户汇入100元。\n\n\n服务a（小明从招行转出100元）:try: update cmb_account set balance=balance-100, freeze=freeze+100 where\nacc_id=1 and balance>100;\n\nconfirm: update cmb_account set freeze=freeze-100 where acc_id=1;\n\ncancel: update cmb_account set balance=balance+100, freeze=freeze-100 where\nacc_id=1;\n\n\n服务b（小明往广发银行汇入100元）:try: update cgb_account set freeze=freeze+100 where acc_id=1;\n\nconfirm: update cgb_account set balance=balance+100, freeze=freeze-100 where acc_id=1;\n\ncancel: update cgb_account set freeze=freeze-100 where acc_id=1;\n\n\n具体说明：a的try阶段，服务做了两件事，1：业务检查，这里是检查小明的帐户里的钱是否多余100元；2:预留资源，将100元从余额中划入冻结资金。\na的confirm阶段，这里不再进行业务检查，因为try阶段已经做过了，同时由于转账已经成功，将冻结资金扣除。a的cancel阶段，释放预留资源，既100元冻结资金，并恢复到余额。\n\n\nb的try阶段进行，预留资源，将100元冻结。b的confirm阶段，使用try阶段预留的资源，将100元冻结资金划入余额。\nb的cancel阶段，释放try阶段的预留资源，将100元从冻结资金中减去。从上面的简单例子可以看出，TCC模式比纯业务补偿模式更加复杂，所以在实现上每个服务都需要实现Cofirm和Cancel两个接口。",
      "normalizedContent": "tcc/try confirm cancel模式tcc模式只有在所有的服务的第一阶段（try）都成功的时候才进行第二阶段确认（confirm）操作，否则进行补偿(cancel)操作，而在try阶段是不会进行真正的业务处理的。\n\n\ntcc模式tcc模式的具体流程为两个阶段：try，业务服务完成所有的业务检查，预留必需的业务资源如果try在所有服务中都成功，那么执行confirm操作，confirm操作不做任何的业务检查（因为try中已经做过），只是用try阶段预留的业务资源进行业务处理；否则进行cancel操作，cancel操作释放try阶段预留的业务资源。\n\n\n这么说可能比较模糊，下面我举一个具体的例子，小明在线从招商银行转账100元到广发银行。\n\n\n这个操作可看作两个服务，服务a从小明的招行账户转出100元，服务b从小明的广发银行帐户汇入100元。\n\n\n服务a（小明从招行转出100元）:try: update cmb_account set balance=balance-100, freeze=freeze+100 where\nacc_id=1 and balance>100;\n\nconfirm: update cmb_account set freeze=freeze-100 where acc_id=1;\n\ncancel: update cmb_account set balance=balance+100, freeze=freeze-100 where\nacc_id=1;\n\n\n服务b（小明往广发银行汇入100元）:try: update cgb_account set freeze=freeze+100 where acc_id=1;\n\nconfirm: update cgb_account set balance=balance+100, freeze=freeze-100 where acc_id=1;\n\ncancel: update cgb_account set freeze=freeze-100 where acc_id=1;\n\n\n具体说明：a的try阶段，服务做了两件事，1：业务检查，这里是检查小明的帐户里的钱是否多余100元；2:预留资源，将100元从余额中划入冻结资金。\na的confirm阶段，这里不再进行业务检查，因为try阶段已经做过了，同时由于转账已经成功，将冻结资金扣除。a的cancel阶段，释放预留资源，既100元冻结资金，并恢复到余额。\n\n\nb的try阶段进行，预留资源，将100元冻结。b的confirm阶段，使用try阶段预留的资源，将100元冻结资金划入余额。\nb的cancel阶段，释放try阶段的预留资源，将100元从冻结资金中减去。从上面的简单例子可以看出，tcc模式比纯业务补偿模式更加复杂，所以在实现上每个服务都需要实现cofirm和cancel两个接口。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/22, 00:01:01",
      "lastUpdatedTimestamp": 1653148861000
    },
    {
      "title": "关于",
      "frontmatter": {
        "title": "关于",
        "date": "2019-12-25T14:27:01.000Z",
        "permalink": "/about",
        "sidebar": false,
        "article": false
      },
      "regularPath": "/15.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",
      "relativePath": "15.关于/01.关于.md",
      "key": "v-918dfaf8",
      "path": "/about/",
      "headers": [
        {
          "level": 2,
          "title": "📚Blog",
          "slug": "📚blog",
          "normalizedTitle": "📚blog",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "⚡ 反馈与交流",
          "slug": "⚡-反馈与交流",
          "normalizedTitle": "⚡ 反馈与交流",
          "charIndex": 27
        },
        {
          "level": 2,
          "title": "🐼Me",
          "slug": "🐼me",
          "normalizedTitle": "🐼me",
          "charIndex": 156
        },
        {
          "level": 3,
          "title": "技能",
          "slug": "技能",
          "normalizedTitle": "技能",
          "charIndex": 177
        },
        {
          "level": 2,
          "title": "Java学习",
          "slug": "java学习",
          "normalizedTitle": "java学习",
          "charIndex": 14
        },
        {
          "level": 2,
          "title": "✉️ 联系",
          "slug": "联系",
          "normalizedTitle": "✉️ 联系",
          "charIndex": 345
        }
      ],
      "headersStr": "📚Blog ⚡ 反馈与交流 🐼Me 技能 Java学习 ✉️ 联系",
      "content": "# 📚Blog\n\n这是一个Java学习网站\n\n\n# ⚡ 反馈与交流\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n在使用过程中有任何问题和想法，你可以：\n\n * 给我提 Issue。\n\n你也可以在Issue查看别人提的问题和给出解决方案。\n\n * 戳JavaDriver社区\n\n更新日志\n\n\n# 🐼Me\n\n西二旗Java老司机\n\n\n# 技能\n\n * 熟悉 SpringBoot、Mybatis、Netty、Kafka 的拼写\n * 了解 Linux、windows、macOS 的开关机方式\n * 精通 Git 的 pull 和 push，并注册了 GitHub 帐号刷了一些 star\n\n\n# Java学习\n\n\n关注公众号，回复后端资源，即可获取学习资源一份。\n\n\n# ✉️ 联系\n\n * WeChat or QQ: {{ QQ }}\n * Email: 854818303@qq.com\n * GitHub: https://github.com/AdmireAn/JavaDriver",
      "normalizedContent": "# 📚blog\n\n这是一个java学习网站\n\n\n# ⚡ 反馈与交流\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n在使用过程中有任何问题和想法，你可以：\n\n * 给我提 issue。\n\n你也可以在issue查看别人提的问题和给出解决方案。\n\n * 戳javadriver社区\n\n更新日志\n\n\n# 🐼me\n\n西二旗java老司机\n\n\n# 技能\n\n * 熟悉 springboot、mybatis、netty、kafka 的拼写\n * 了解 linux、windows、macos 的开关机方式\n * 精通 git 的 pull 和 push，并注册了 github 帐号刷了一些 star\n\n\n# java学习\n\n\n关注公众号，回复后端资源，即可获取学习资源一份。\n\n\n# ✉️ 联系\n\n * wechat or qq: {{ qq }}\n * email: 854818303@qq.com\n * github: https://github.com/admirean/javadriver",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/20, 22:11:32",
      "lastUpdatedTimestamp": 1653055892000
    },
    {
      "title": "网站",
      "frontmatter": {
        "title": "网站",
        "permalink": "/pages/beb6c0bd8a66cea6",
        "date": "2020-04-19T11:33:04.000Z",
        "article": false
      },
      "regularPath": "/20.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",
      "relativePath": "20.收藏夹/01.网站.md",
      "key": "v-89a39f02",
      "path": "/pages/beb6c0bd8a66cea6/",
      "headers": [
        {
          "level": 2,
          "title": "推荐",
          "slug": "推荐",
          "normalizedTitle": "推荐",
          "charIndex": 12
        },
        {
          "level": 2,
          "title": "文档",
          "slug": "文档",
          "normalizedTitle": "文档",
          "charIndex": 167
        },
        {
          "level": 2,
          "title": "社区",
          "slug": "社区",
          "normalizedTitle": "社区",
          "charIndex": 375
        },
        {
          "level": 3,
          "title": "社区互动",
          "slug": "社区互动",
          "normalizedTitle": "社区互动",
          "charIndex": 596
        },
        {
          "level": 2,
          "title": "技巧",
          "slug": "技巧",
          "normalizedTitle": "技巧",
          "charIndex": 623
        },
        {
          "level": 2,
          "title": "博客",
          "slug": "博客",
          "normalizedTitle": "博客",
          "charIndex": 711
        },
        {
          "level": 2,
          "title": "电子书",
          "slug": "电子书",
          "normalizedTitle": "电子书",
          "charIndex": 775
        },
        {
          "level": 2,
          "title": "优秀文章",
          "slug": "优秀文章",
          "normalizedTitle": "优秀文章",
          "charIndex": 833
        },
        {
          "level": 2,
          "title": "视频",
          "slug": "视频",
          "normalizedTitle": "视频",
          "charIndex": 897
        },
        {
          "level": 2,
          "title": "Github",
          "slug": "github",
          "normalizedTitle": "github",
          "charIndex": 382
        },
        {
          "level": 2,
          "title": "评论系统",
          "slug": "评论系统",
          "normalizedTitle": "评论系统",
          "charIndex": 1148
        },
        {
          "level": 2,
          "title": "前端小工具",
          "slug": "前端小工具",
          "normalizedTitle": "前端小工具",
          "charIndex": 1197
        },
        {
          "level": 2,
          "title": "代码编辑",
          "slug": "代码编辑",
          "normalizedTitle": "代码编辑",
          "charIndex": 1269
        },
        {
          "level": 2,
          "title": "Emoji表情",
          "slug": "emoji表情",
          "normalizedTitle": "emoji表情",
          "charIndex": 1330
        },
        {
          "level": 2,
          "title": "图片工具",
          "slug": "图片工具",
          "normalizedTitle": "图片工具",
          "charIndex": 1493
        },
        {
          "level": 2,
          "title": "思维导图",
          "slug": "思维导图",
          "normalizedTitle": "思维导图",
          "charIndex": 1753
        },
        {
          "level": 2,
          "title": "CSS",
          "slug": "css",
          "normalizedTitle": "css",
          "charIndex": 875
        },
        {
          "level": 2,
          "title": "CDN加速",
          "slug": "cdn加速",
          "normalizedTitle": "cdn加速",
          "charIndex": 2090
        },
        {
          "level": 2,
          "title": "网站托管",
          "slug": "网站托管",
          "normalizedTitle": "网站托管",
          "charIndex": 2150
        },
        {
          "level": 2,
          "title": "正则",
          "slug": "正则",
          "normalizedTitle": "正则",
          "charIndex": 2180
        },
        {
          "level": 2,
          "title": "其他",
          "slug": "其他",
          "normalizedTitle": "其他",
          "charIndex": 2241
        },
        {
          "level": 2,
          "title": "设计",
          "slug": "设计",
          "normalizedTitle": "设计",
          "charIndex": 574
        },
        {
          "level": 2,
          "title": "图库",
          "slug": "图库",
          "normalizedTitle": "图库",
          "charIndex": 3342
        },
        {
          "level": 2,
          "title": "3D",
          "slug": "_3d",
          "normalizedTitle": "3d",
          "charIndex": 1967
        },
        {
          "level": 2,
          "title": "交互",
          "slug": "交互",
          "normalizedTitle": "交互",
          "charIndex": 2420
        },
        {
          "level": 2,
          "title": "有趣",
          "slug": "有趣",
          "normalizedTitle": "有趣",
          "charIndex": 139
        },
        {
          "level": 2,
          "title": "生成器",
          "slug": "生成器",
          "normalizedTitle": "生成器",
          "charIndex": 1839
        },
        {
          "level": 2,
          "title": "元宇宙",
          "slug": "元宇宙",
          "normalizedTitle": "元宇宙",
          "charIndex": 4444
        },
        {
          "level": 2,
          "title": "教程",
          "slug": "教程",
          "normalizedTitle": "教程",
          "charIndex": 251
        },
        {
          "level": 2,
          "title": "产品",
          "slug": "产品",
          "normalizedTitle": "产品",
          "charIndex": 3329
        },
        {
          "level": 2,
          "title": "实用",
          "slug": "实用",
          "normalizedTitle": "实用",
          "charIndex": 4688
        },
        {
          "level": 2,
          "title": "Talk",
          "slug": "talk",
          "normalizedTitle": "talk",
          "charIndex": 5061
        },
        {
          "level": 2,
          "title": "算法",
          "slug": "算法",
          "normalizedTitle": "算法",
          "charIndex": 2330
        },
        {
          "level": 2,
          "title": "nginx",
          "slug": "nginx",
          "normalizedTitle": "nginx",
          "charIndex": 5141
        },
        {
          "level": 2,
          "title": "生活",
          "slug": "生活",
          "normalizedTitle": "生活",
          "charIndex": 5169
        }
      ],
      "excerpt": "<h1 id=\"个人收藏夹\"><a class=\"header-anchor\" href=\"#个人收藏夹\">#</a> 个人收藏夹</h1>\n<h2 id=\"推荐\"><a class=\"header-anchor\" href=\"#推荐\">#</a> 推荐</h2>\n<ul>\n<li><a href=\"https://panjiachen.github.io/awesome-bookmarks/\" target=\"_blank\" rel=\"noopener noreferrer\">panjiachen<OutboundLink/></a> by 花裤衩</li>\n<li><a href=\"https://www.code-nav.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">编程导航<OutboundLink/></a> by 程序员鱼皮</li>\n<li><a href=\"https://r2coding.com/\" target=\"_blank\" rel=\"noopener noreferrer\">编程自学之路<OutboundLink/></a> by 程序羊</li>\n<li><a href=\"https://gitee.com/jishupang/web_atlas\" target=\"_blank\" rel=\"noopener noreferrer\">前端知识图谱+B站资源整合<OutboundLink/></a> by 技术胖</li>\n<li><a href=\"https://shengxinjing.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">大圣编程自学网<OutboundLink/></a> by 大圣</li>\n<li><a href=\"https://devtool.tech/\" target=\"_blank\" rel=\"noopener noreferrer\">开发者武器库<OutboundLink/></a></li>\n<li><a href=\"https://www.fly63.com/tool/home.html\" target=\"_blank\" rel=\"noopener noreferrer\">工具大全<OutboundLink/></a></li>\n</ul>\n<p align=\"center\">\n<img src=\"https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/qrcode.zdqv9mlfc0g.jpg\" width=\"200\">\n</p>\n<div class=\"center-container\"><p>关注公众号[有趣研究社]，回复<code>前端资源</code>，获取 <a href=\"https://github.com/xugaoyi/blog-gitalk-comment/wiki/Front-end-Study\" target=\"_blank\" rel=\"noopener noreferrer\">前端学习资料<OutboundLink/></a></p>\n</div>",
      "headersStr": "推荐 文档 社区 社区互动 技巧 博客 电子书 优秀文章 视频 Github 评论系统 前端小工具 代码编辑 Emoji表情 图片工具 思维导图 CSS CDN加速 网站托管 正则 其他 设计 图库 3D 交互 有趣 生成器 元宇宙 教程 产品 实用 Talk 算法 nginx 生活",
      "content": "# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+B站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ 促进软件开发及相关领域知识与创新的传播\n * V2EX 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * SoBooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用CSS开发技巧\n * 防御性CSS\n\n\n# 视频\n\n * bilibili B站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# Github\n\n * Repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 GitHub Discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> Windows系统下按Win + .\n> Mac系统下按Control + Command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# CSS\n\n * 各种CSS生成器和JS代码片段\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * beTheme\n * UI 中国\n * wallhaven 壁纸网站-\n\n\n# 3D\n\n * sketchfab 3D模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * Little Big Details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * Decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * Product Hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * Ventusky 风雨气温图",
      "normalizedContent": "# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+b站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq 促进软件开发及相关领域知识与创新的传播\n * v2ex 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * sobooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用css开发技巧\n * 防御性css\n\n\n# 视频\n\n * bilibili b站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# github\n\n * repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 github discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> windows系统下按win + .\n> mac系统下按control + command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# css\n\n * 各种css生成器和js代码片段\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n * wallhaven 壁纸网站-\n\n\n# 3d\n\n * sketchfab 3d模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * little big details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * product hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * ventusky 风雨气温图",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "常用的前端轮子",
      "frontmatter": {
        "title": "常用的前端轮子",
        "date": "2021-10-09T19:42:02.000Z",
        "permalink": "/pages/47cf96/",
        "article": false
      },
      "regularPath": "/20.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E5%B8%B8%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BD%AE%E5%AD%90.html",
      "relativePath": "20.收藏夹/02.常用的前端轮子.md",
      "key": "v-40502781",
      "path": "/pages/47cf96/",
      "headers": [
        {
          "level": 2,
          "title": "React UI 组件库",
          "slug": "react-ui-组件库",
          "normalizedTitle": "react ui 组件库",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "Vue UI组件库",
          "slug": "vue-ui组件库",
          "normalizedTitle": "vue ui组件库",
          "charIndex": 68
        },
        {
          "level": 2,
          "title": "常用效果组件",
          "slug": "常用效果组件",
          "normalizedTitle": "常用效果组件",
          "charIndex": 124
        },
        {
          "level": 2,
          "title": "工具类",
          "slug": "工具类",
          "normalizedTitle": "工具类",
          "charIndex": 201
        },
        {
          "level": 2,
          "title": "Vue工具类",
          "slug": "vue工具类",
          "normalizedTitle": "vue工具类",
          "charIndex": 331
        },
        {
          "level": 2,
          "title": "其他",
          "slug": "其他",
          "normalizedTitle": "其他",
          "charIndex": 469
        }
      ],
      "headersStr": "React UI 组件库 Vue UI组件库 常用效果组件 工具类 Vue工具类 其他",
      "content": "# React UI 组件库\n\n * Ant Design\n * React Bootstrap\n * MATERIAL-UI\n\n\n# Vue UI组件库\n\n * Element UI PC端\n * Vant 移动端\n * View UI\n\n\n# 常用效果组件\n\n * Animate.css 动画库\n * Swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生JS\n\n\n# 工具类\n\n * Lodash.js\n * Day.js 处理日期\n * Timeago.js 相对时间，如N小时前\n * Echarts 百度图表\n * Meditor.md 开源在线 Markdown 编辑器\n * validator.js 验证库\n\n\n# Vue工具类\n\n * vue-draggable 基于Sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * H5带笔锋手写签名，支持PC端和移动端",
      "normalizedContent": "# react ui 组件库\n\n * ant design\n * react bootstrap\n * material-ui\n\n\n# vue ui组件库\n\n * element ui pc端\n * vant 移动端\n * view ui\n\n\n# 常用效果组件\n\n * animate.css 动画库\n * swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生js\n\n\n# 工具类\n\n * lodash.js\n * day.js 处理日期\n * timeago.js 相对时间，如n小时前\n * echarts 百度图表\n * meditor.md 开源在线 markdown 编辑器\n * validator.js 验证库\n\n\n# vue工具类\n\n * vue-draggable 基于sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * h5带笔锋手写签名，支持pc端和移动端",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "你知道的越多，不知道的也就越多",
      "frontmatter": {
        "title": "你知道的越多，不知道的也就越多",
        "date": "2020-05-06T15:52:40.000Z",
        "permalink": "/pages/f2e63f",
        "sidebar": "auto",
        "categories": [
          "随笔"
        ],
        "tags": [
          "学习",
          "知识",
          "鸡汤"
        ],
        "author": {
          "name": "xugaoyi",
          "link": "https://github.com/xugaoyi"
        }
      },
      "regularPath": "/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",
      "relativePath": "_posts/随笔/你知道的越多，不知道的也就越多.md",
      "key": "v-2db11cb2",
      "path": "/pages/f2e63f/",
      "excerpt": "<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",
      "headersStr": null,
      "content": "不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",
      "normalizedContent": "不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "拥抱生活，拥抱快乐",
      "frontmatter": {
        "title": "拥抱生活，拥抱快乐",
        "date": "2020-06-26T20:40:38.000Z",
        "permalink": "/pages/cd8bde/",
        "sidebar": "auto",
        "categories": [
          "随笔"
        ],
        "tags": [
          "鸡汤"
        ],
        "author": {
          "name": "xugaoyi",
          "link": "https://github.com/xugaoyi"
        }
      },
      "regularPath": "/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",
      "relativePath": "_posts/随笔/拥抱生活，拥抱快乐.md",
      "key": "v-7d77d69c",
      "path": "/pages/cd8bde/",
      "excerpt": "<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",
      "headersStr": null,
      "content": "生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",
      "normalizedContent": "生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "我做了一个手写春联小网页，祝大家虎年暴富",
      "frontmatter": {
        "title": "我做了一个手写春联小网页，祝大家虎年暴富",
        "date": "2022-01-28T14:59:51.000Z",
        "permalink": "/pages/829589/",
        "titleTag": "原创",
        "sidebar": "auto",
        "categories": [
          "随笔"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/_posts/%E9%9A%8F%E7%AC%94/%E6%88%91%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E6%89%8B%E5%86%99%E6%98%A5%E8%81%94%E5%B0%8F%E7%BD%91%E9%A1%B5%EF%BC%8C%E7%A5%9D%E5%A4%A7%E5%AE%B6%E8%99%8E%E5%B9%B4%E6%9A%B4%E5%AF%8C.html",
      "relativePath": "_posts/随笔/我做了一个手写春联小网页，祝大家虎年暴富.md",
      "key": "v-a5c5f278",
      "path": "/pages/829589/",
      "headers": [
        {
          "level": 3,
          "title": "前言",
          "slug": "前言",
          "normalizedTitle": "前言",
          "charIndex": 33
        },
        {
          "level": 3,
          "title": "产品构思",
          "slug": "产品构思",
          "normalizedTitle": "产品构思",
          "charIndex": 195
        },
        {
          "level": 3,
          "title": "设计",
          "slug": "设计",
          "normalizedTitle": "设计",
          "charIndex": 478
        },
        {
          "level": 3,
          "title": "开发",
          "slug": "开发",
          "normalizedTitle": "开发",
          "charIndex": 487
        }
      ],
      "excerpt": "<p>手写春联：<a href=\"https://cl.xugaoyi.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://cl.xugaoyi.com/<OutboundLink/></a></p>\n<h3 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>虎年春节快到了，首先祝大家新年快乐，轻松暴富。\n最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么UI特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）</p>\n",
      "headersStr": "前言 产品构思 设计 开发",
      "content": "手写春联：https://cl.xugaoyi.com/\n\n\n# 前言\n\n虎年春节快到了，首先祝大家新年快乐，轻松暴富。 最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么UI特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）\n\n\n\n\n# 产品构思\n\n包含手写春节和生成春联两大功能：\n\n * 手写春联\n   \n   * 模拟用笔写字的字迹\n   * 选择画笔颜色\n   * 调整画笔大小\n   * 清空画布\n   * 撤回笔画\n   * 切换上、下联、横批、福字\n   * 随机切换对联提示\n   * 预览图片和下载\n   * 贴春联海报和下载\n\n * 生成模式\n   \n   * 选择画笔颜色\n   * 挑选生成的对联\n   * 输入对联\n   * 随机切换对联\n   * 贴春联海报和下载\n\n * 其他\n   \n   * 快速切换模式按钮\n   * 可控制的背景音乐\n   * 微信分享网页\n\n\n# 设计\n\n\n\n\n# 开发\n\n * 技术栈\n   * vite (打包&构建)\n   * vue3 (页面开发)\n   * vant（ui）\n   * sass (css)\n   * smooth-signature.js (带笔锋手写库)\n\n<template>\n  <div class=\"wrap\" :class=\"'mode-' + mode\" @touchstart=\"handleTouchstart\">\n    <!-- 切换模式按钮 -->\n    <div class=\"toggle-mode-btn\" @click=\"toggleMode\">\n      {{ mode === 1 ? '手写' : '生成' }}\n      <i class=\"iconfont icon-qiehuan\"></i>\n    </div>\n\n    <!-- 工具栏 -->\n    <div\n      class=\"actions\"\n      :style=\"{ borderTopRightRadius: colorListVisibility ? '0' : '5px' }\"\n    >\n      <!-- 手写模式显示 -->\n      <template v-if=\"mode === 1\">\n        <!-- 调色板 -->\n        <div class=\"palette btn-block\">\n          <div\n            class=\"cur-color\"\n            @click=\"togglePalette\"\n            :style=\"{ background: colorList[curColorIndex] }\"\n          ></div>\n          <ul class=\"colorList\" v-show=\"colorListVisibility\">\n            <li\n              v-for=\"(item, index) in colorList\"\n              :key=\"item\"\n              :style=\"{ background: item }\"\n              @click=\"selectColor(index)\"\n            ></li>\n          </ul>\n        </div>\n\n        <!-- 滑块 -->\n        <div class=\"slider-box btn-block\">\n          <van-slider\n            v-model=\"progress\"\n            vertical\n            @change=\"changeProgress\"\n            bar-height=\"28\"\n            active-color=\"transparent\"\n            :min=\"50\"\n            :max=\"150\"\n          >\n            <template #button>\n              <div class=\"custom-button\"></div>\n            </template>\n          </van-slider>\n        </div>\n\n        <!-- 清空 -->\n        <div class=\"btn\" @click=\"handleClear\">\n          <i class=\"iconfont icon-lajitong\"></i>\n        </div>\n\n        <!-- 撤销 -->\n        <div class=\"btn\" @click=\"handleUndo\">\n          <i class=\"iconfont icon-fanhui\"></i>\n        </div>\n\n        <div class=\"line\"></div>\n\n        <!-- 切换画布的按钮 -->\n        <div\n          class=\"btn\"\n          :class=\"{ 'cur-active': curCanvasIndex === index }\"\n          v-for=\"(item, index) in canvasList\"\n          :key=\"item.name\"\n          @click=\"changeCanvas(index)\"\n        >\n          {{ item.name }}\n        </div>\n\n        <div class=\"line\"></div>\n\n        <div class=\"btn prominent\" @click=\"handlePreview\">预览</div>\n        <div class=\"btn prominent\" @click=\"openPosters\">贴联</div>\n      </template>\n\n      <!-- 生成模式显示 -->\n      <template v-else>\n        <!-- 选颜色 -->\n        <div\n          class=\"color-list-quick\"\n          :class=\"{ active: curColorIndex === index }\"\n          v-for=\"(item, index) in colorList\"\n          :key=\"item\"\n          :style=\"{ background: item }\"\n          @click=\"selectColor(index)\"\n        ></div>\n        <div class=\"line\"></div>\n        <div class=\"btn\" @click=\"showPickBox = true\">挑选</div>\n        <div class=\"btn\" @click=\"showInputBox = true\">输入</div>\n\n        <!-- 挑选对联弹窗 -->\n        <van-action-sheet v-model:show=\"showPickBox\" title=\"请挑选对联\">\n          <ul class=\"duilian-list\">\n            <li\n              v-for=\"(item, index) in duilianList\"\n              :key=\"index\"\n              @click=\"handlePickDuilian(item)\"\n            >\n              <span>{{ item.shang }}</span\n              >， <span>{{ item.xia }}</span\n              >。\n              <span>{{ item.heng }}</span>\n            </li>\n          </ul>\n        </van-action-sheet>\n\n        <!-- 输入对联弹窗 -->\n        <van-action-sheet v-model:show=\"showInputBox\" title=\"请输入对联\">\n          <van-form @submit=\"handleSubmitInput\">\n            <van-cell-group inset>\n              <van-field\n                v-model=\"shanglian\"\n                name=\"shang\"\n                label=\"上联\"\n                placeholder=\"上联\"\n                :rules=\"[\n                  {\n                    required: true,\n                    message: '请输入7位汉字上联',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]\"\n                clearable\n              />\n              <van-field\n                v-model=\"xialian\"\n                name=\"xia\"\n                label=\"下联\"\n                placeholder=\"下联\"\n                :rules=\"[\n                  {\n                    required: true,\n                    message: '请输入7位汉字下联',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]\"\n                clearable\n              />\n              <van-field\n                v-model=\"hengpi\"\n                name=\"heng\"\n                label=\"横批\"\n                placeholder=\"横批\"\n                :rules=\"[\n                  {\n                    required: true,\n                    message: '请输入4位汉字横批',\n                    pattern: /^[\\u4e00-\\u9fa5]{4}$/\n                  }\n                ]\"\n                clearable\n              />\n            </van-cell-group>\n            <div style=\"margin: 16px\">\n              <van-button\n                round\n                block\n                type=\"primary\"\n                native-type=\"submit\"\n                color=\"linear-gradient(to right, #ff6034, #c33825)\"\n              >\n                完成\n              </van-button>\n            </div>\n          </van-form>\n        </van-action-sheet>\n      </template>\n    </div>\n\n    <!-- 模式1-春联画布 -->\n    <div\n      v-show=\"mode === 1\"\n      v-for=\"(item, index) in canvasList\"\n      :key=\"item.name\"\n    >\n      <canvas\n        class=\"canvas\"\n        :class=\"item.className\"\n        v-show=\"curCanvasIndex === index\"\n        :style=\"{\n          marginTop:\n            item.height < clientHeight\n              ? `${(clientHeight - item.height) / 2}px`\n              : 0,\n          marginLeft:\n            item.width < clientWidth ? `${(clientWidth - item.width) / 2}px` : 0\n        }\"\n      />\n    </div>\n\n    <!-- 模式2-春联画布 -->\n    <div v-show=\"mode === 2\" class=\"canvas-mode-2\">\n      <div class=\"row\">\n        <canvas id=\"canvas-top\" :width=\"200 * scale\" :height=\"60 * scale\" />\n      </div>\n      <div class=\"row\">\n        <canvas id=\"canvas-left\" :width=\"60 * scale\" :height=\"364 * scale\" />\n        <canvas id=\"canvas-right\" :width=\"60 * scale\" :height=\"364 * scale\" />\n      </div>\n    </div>\n\n    <!-- 贴春联按钮 -->\n    <Button class=\"btn-posters\" @click=\"openPosters\" />\n\n    <!-- footer-当前对联提示 -->\n    <footer v-if=\"duilian.shang\">\n      <div class=\"refresh-btn\" @click=\"handleRefresh(true)\">\n        <i class=\"iconfont icon-shuaxin\" :class=\"{ rotate: isRotate }\"></i>\n      </div>\n      <dl class=\"duilian\">\n        <dt>对联</dt>\n        <dd>\n          <div>{{ duilian.shang }}</div>\n          <div>{{ duilian.xia }}</div>\n        </dd>\n      </dl>\n      <dl>\n        <dt>横批</dt>\n        <dd>{{ duilian.heng }}</dd>\n      </dl>\n    </footer>\n\n    <!-- 分享按钮 -->\n    <div class=\"share-btn\" v-if=\"isShowShareBtn\" @click=\"isShowShareTip = true\">\n      <i class=\"iconfont icon-fenxiang\"></i>\n    </div>\n    <!-- 微信分享提示语 -->\n    <div\n      class=\"share-tip\"\n      v-if=\"isShowShareTip\"\n      @click=\"isShowShareTip = false\"\n    >\n      点击右上角把这个工具分享给朋友\n      <div class=\"hand\">👆</div>\n    </div>\n\n    <!-- 保存tip -->\n    <p v-if=\"isShowTip\" class=\"download-tip\">*长按图片保存或转发</p>\n\n    <!-- 版权 -->\n    <div class=\"copyright\">公众号「有趣研究社」 ©版权所有</div>\n\n    <!-- 载入图片元素，用于快速贴图使用, 注意设置crossorigin=\"anonymous\"解决跨域 -->\n    <div v-if=\"isReadImages\">\n      <img\n        crossorigin=\"anonymous\"\n        v-for=\"(item, index) in bgList\"\n        :src=\"item\"\n        :key=\"item\"\n        class=\"hide-img\"\n        :id=\"`bg-img-` + index\"\n      />\n      <img\n        crossorigin=\"anonymous\"\n        class=\"hide-img\"\n        id=\"qrcode\"\n        src=\"https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/img/qrcode.zul0pldsuao.png\"\n      />\n    </div>\n\n    <!-- 背景音乐 -->\n    <audio\n      src=\"https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/cjxq.mp3\"\n      id=\"bgm\"\n      ref=\"bgm\"\n      loop\n    />\n    <div\n      class=\"play-btn\"\n      :class=\"{ paused: !isPlay }\"\n      ref=\"playBtn\"\n      @click=\"handlePlay\"\n    >\n      <i class=\"iconfont icon-yinle\"></i>\n    </div>\n  </div>\n\n  <div class=\"body-bg-img\"></div>\n</template>\n\n<script>\nimport { ImagePreview, Notify } from 'vant'\nimport { isWX, isMobile } from '@/utils'\nimport Button from '@/components/Button.vue'\nimport dl from '@/assets/img/yh/dl.jpeg'\nimport hp from '@/assets/img/yh/hp.jpeg'\nimport fz from '@/assets/img/yh/fz.png'\n\n// 对联数据\nimport duilianList from '@/mock/duilian'\n\nconst PROPORTION = 0.37 // 图片缩小比例\nconst INSTANTIATE_NAME = 'signature' // 实例名称\nconst MIN_WIDTH = 3 // 画笔最小宽\nconst MAX_WIDTH = 12 // 画笔最大宽\n\n// 海报背景图大小\nconst BG_WIDTH = 750\nconst BG_HEIGHT = 1448\n\n// 贴图定位和大小\nconst POSITION = [\n  { left: 57, top: 510, width: 90, height: 546 }, // 上联\n  { left: 600, top: 510, width: 90, height: 546 }, // 下联\n  { left: 225, top: 345, width: 300, height: 90 }, // 横幅\n  { left: 460, top: 450, width: 130, height: 130 }, // 福字\n]\n\nexport default {\n  name: \"Home\",\n  components: {\n    Button\n  },\n  data() {\n    return {\n      duilianList,\n      mode: Number(localStorage.getItem('mode')) || 1, // 1 手写，2 生成\n      curCanvasIndex: 0, // 显示哪个画布\n      progress: 100, // 画笔大小的刻度\n      clientWidth: document.documentElement.clientWidth,\n      clientHeight: document.documentElement.clientHeight,\n      canvasList: [\n        {\n          name: '上联',\n          className: 'canvas-a',\n          bgImage: dl,\n          width: 600 * PROPORTION,\n          height: 3640 * PROPORTION,\n        },\n        {\n          name: '下联',\n          className: 'canvas-b',\n          bgImage: dl,\n          width: 600 * PROPORTION,\n          height: 3640 * PROPORTION,\n        },\n        {\n          name: '横批',\n          className: 'canvas-c',\n          bgImage: hp,\n          width: 2000 * PROPORTION,\n          height: 600 * PROPORTION,\n        },\n        {\n          name: '福字',\n          className: 'canvas-d',\n          bgImage: fz,\n          width: 366,\n          height: 366,\n        }\n      ],\n      colorList: ['#000000', '#ffd800', '#e8bd48', '#ddc08c',],\n      curColorIndex: 0,\n      colorListVisibility: false, // 画布颜色选择列表可见性\n      isShowTip: false, // 是否显示底部提示语\n      duilian: {}, // 当前对联文本对象\n      isRotate: false, // 刷新icon旋转\n      bgList: [\n        'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/1.4j8qpdnq80i0.jpeg',\n        'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/4.4460an8ag5o0.jpeg',\n        'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/5.3axtl4xpvy00.jpeg',\n        'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/6.2lnbphdqjaq0.jpeg',\n      ],\n      isReadImages: false, // 延迟加载图片用\n      isShowShareBtn: false, // 是否显示分享按钮\n      isShowShareTip: false, // 是否显示分享提示语\n      isPlay: false, // 是否在播放\n\n      // 模式2\n      canvasTop: null, // 横批\n      canvasLeft: null, // 上联\n      canvasRight: null, // 下联\n      imgObj1: null, // 横批图片对象\n      imgObj2: null, // 上下联图片对象\n      scale: Math.max(window.devicePixelRatio || 1, 2), // 用于增加画布清晰度\n      showPickBox: false, // 挑选对联的弹框\n      showInputBox: false, // 输入对联的弹框\n      shanglian: '', // 输入的上联\n      xialian: '', // 输入的下联\n      hengpi: '', // 输入的横批\n    };\n  },\n  computed: {\n    // 模式1-当前画布实例\n    curCanvasInstantiate() {\n      return this[INSTANTIATE_NAME + this.curCanvasIndex]\n    }\n  },\n  created() {\n    // 微信浏览器显示分享按钮\n    this.isShowShareBtn = isWX()\n  },\n  mounted() {\n    if (!isMobile()) {\n      Notify({ type: 'warning', message: '请用移动端打开获得最佳体验', duration: 6000, });\n    }\n\n    this.initMode1();\n\n    // 初始化对联提示\n    this.handleRefresh();\n\n    this.initMode2();\n\n    // 按钮添加激活时发光效果class\n    const btnEl = document.querySelectorAll('.btn,.btn-block');\n    btnEl.forEach((item) => {\n      item.addEventListener('touchstart', () => {\n        item.classList.add('btn-active')\n      })\n      item.addEventListener('touchend', () => {\n        setTimeout(() => {\n          item.classList.remove('btn-active')\n        }, 100)\n      })\n    })\n\n    // 延迟加载贴图背景\n    setTimeout(() => {\n      this.isReadImages = true\n    }, 1000)\n  },\n\n  watch: {\n    // 切换画笔颜色\n    curColorIndex() {\n      this.curCanvasInstantiate.color = this.colorList[this.curColorIndex]\n      if (this.mode === 2) {\n        this.refreshDuilian()\n      }\n    },\n    // 切换画布时应用当前画笔颜色和大小\n    curCanvasIndex() {\n      this.curCanvasInstantiate.color = this.colorList[this.curColorIndex]\n      this.handleChangeSize()\n      window.scrollTo(0, 0)\n    }\n  },\n\n  methods: {\n    initMode1() {\n      const { colorList, curColorIndex } = this\n      this.canvasList.forEach((item, index) => {\n        const options = {\n          width: item.width,\n          height: item.height,\n          minWidth: MIN_WIDTH, // 画笔最小宽度(px)\n          maxWidth: MAX_WIDTH, // 画笔最大宽度\n          minSpeed: 1.8, // 画笔达到最小宽度所需最小速度(px/ms)，取值范围1.0-10.0\n          color: colorList[curColorIndex],\n          // 新增的配置\n          bgImage: item.bgImage,\n        };\n\n        this[INSTANTIATE_NAME + index] = new SmoothSignature(document.querySelector('.' + item.className), options);\n      })\n    },\n\n    initMode2() {\n      this.canvasTop = document.getElementById('canvas-top').getContext('2d')\n      this.canvasLeft = document.getElementById('canvas-left').getContext('2d')\n      this.canvasRight = document.getElementById('canvas-right').getContext('2d')\n\n      // 设字体样式\n      const font = \"36px xs, cursive\"\n      this.canvasTop.font = font\n      this.canvasLeft.font = font\n      this.canvasRight.font = font\n\n      // 增强清晰度\n      const { scale } = this\n      this.canvasTop.scale(scale, scale);\n      this.canvasLeft.scale(scale, scale);\n      this.canvasRight.scale(scale, scale);\n\n      // 设背景图\n      this.imgObj1 = new Image()\n      this.imgObj2 = new Image()\n      this.imgObj1.src = hp\n      this.imgObj2.src = dl\n      this.imgObj1.onload = () => {\n        // 贴背景\n        this.canvasTop.drawImage(this.imgObj1, 0, 0, 200, 60)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handleTopFillText()\n        });\n      }\n      this.imgObj2.onload = () => {\n        // 贴背景\n        this.canvasLeft.drawImage(this.imgObj2, 0, 0, 60, 364)\n        this.canvasRight.drawImage(this.imgObj2, 0, 0, 60, 364)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handleLRFillText(this.canvasLeft, this.duilian.shang)\n          this.handleLRFillText(this.canvasRight, this.duilian.xia)\n        });\n      }\n    },\n\n    // 模式2-刷新对联\n    refreshDuilian() {\n      this.canvasTop.drawImage(this.imgObj1, 0, 0, 200, 60)\n      this.canvasLeft.drawImage(this.imgObj2, 0, 0, 60, 364)\n      this.canvasRight.drawImage(this.imgObj2, 0, 0, 60, 364)\n      this.handleTopFillText()\n      this.handleLRFillText(this.canvasLeft, this.duilian.shang)\n      this.handleLRFillText(this.canvasRight, this.duilian.xia)\n    },\n\n    // 模式2-贴横批\n    handleTopFillText() {\n      // 贴文本\n      this.canvasTop.fillStyle = this.colorList[this.curColorIndex]\n      if (this.duilian.heng) {\n        this.duilian.heng.split('').forEach((item, index) => {\n          const left = 42 * (index + 1) - 22\n          this.canvasTop.fillText(item, left, 40)\n        })\n      }\n    },\n\n    // 模式2-贴上下联\n    handleLRFillText(ctx, text) {\n      ctx.fillStyle = this.colorList[this.curColorIndex]\n      if (text) {\n        text.split('').forEach((item, index) => {\n          const top = 50 * (index + 1) - 8\n          ctx.fillText(item, 13, top)\n        })\n      }\n    },\n\n    // 切换模式\n    toggleMode() {\n      if (this.mode === 1) {\n        this.mode = 2\n        this.refreshDuilian()\n      } else {\n        this.mode = 1\n      }\n      localStorage.setItem('mode', this.mode);\n    },\n\n    // 打开调色板\n    togglePalette() {\n      this.colorListVisibility = !this.colorListVisibility\n    },\n\n    // 关闭调色板\n    handleTouchstart(e) {\n      // 不是点击选择颜色时\n      if (e.path[1]?.classList?.value !== 'colorList' && e.target.classList?.value !== 'cur-color') {\n        this.colorListVisibility = false\n      }\n    },\n\n    // 选择颜色\n    selectColor(index) {\n      this.curColorIndex = index\n      this.colorListVisibility = false\n    },\n\n    // 切换画布\n    changeCanvas(index) {\n      this.curCanvasIndex = index\n    },\n\n    // 清空画布\n    handleClear() {\n      this.curCanvasInstantiate.clear();\n    },\n\n    // 撤销笔画\n    handleUndo() {\n      this.curCanvasInstantiate.undo();\n    },\n\n    // 预览\n    handlePreview() {\n      this.showTopTip();\n      this.isShowTip = true\n      const _this = this\n      ImagePreview({\n        images: this.getImageList(),\n        closeable: true,\n        startPosition: this.curCanvasIndex,\n        onClose() {\n          _this.isShowTip = false\n        },\n      });\n    },\n\n    // 打开海报预览\n    openPosters() {\n      // 创建画布\n      const canvas = document.createElement('canvas');\n      canvas.width = BG_WIDTH\n      canvas.height = BG_HEIGHT\n      const ctx = canvas.getContext('2d');\n      const resultImageList = [];\n\n      // 是否隐藏福字\n      const isHideFu = this[INSTANTIATE_NAME + 3].isEmpty()\n      this.bgList.forEach((item, index) => {\n        // 贴背景图\n        ctx.drawImage(document.getElementById('bg-img-' + index), 0, 0, BG_WIDTH, BG_HEIGHT)\n\n        // 贴对联\n        if (this.mode === 1) {\n          this.canvasList.forEach((item, index) => {\n            if (index === 3 && isHideFu) return;\n            const dlCanvas = document.querySelector('.' + item.className)\n            const { left, top, width, height } = POSITION[index]\n            ctx.drawImage(dlCanvas, left, top, width, height)\n          })\n        } else {\n          ['canvas-left', 'canvas-right', 'canvas-top'].forEach((item, index) => {\n            const dlCanvas = document.getElementById(item)\n            const { left, top, width, height } = POSITION[index]\n            ctx.drawImage(dlCanvas, left, top, width, height)\n          })\n        }\n\n        // 贴二维码\n        ctx.drawImage(document.getElementById(\"qrcode\"), 40, 1280, 580, 136)\n\n        // 贴文本\n        ctx.font = \"18px sans-serif\"\n        ctx.fillStyle = \"#666666\"\n        ctx.fillText('©公众号「有趣研究社」', 550, 1420)\n\n        // 导出图片\n        resultImageList.push(canvas.toDataURL('image/jpeg', 0.8))\n      })\n\n      // 打开图片预览\n      this.isShowTip = true\n      const _this = this\n      ImagePreview({\n        images: resultImageList,\n        closeable: true,\n        onClose() {\n          _this.isShowTip = false\n        },\n      });\n      this.showTopTip();\n    },\n\n    // 弹出顶部提示语\n    showTopTip() {\n      if (!sessionStorage.getItem('showTip')) {\n        sessionStorage.setItem('showTip', 'true');\n        Notify({\n          message: '长按图片可保存到本地',\n          color: '#c33825',\n          background: '#eed3ae',\n        });\n      }\n    },\n\n    // 获取对联图片列表\n    getImageList(type = 'image/png') {\n      const imageList = []\n      this.canvasList.forEach((item, index) => {\n        if (index === 3) {\n          // `福`字必须是png格式\n          type = 'image/png'\n        }\n        imageList.push(this[INSTANTIATE_NAME + index].toDataURL(type, 0.8))\n      })\n      return imageList\n    },\n\n    // 进度改变时\n    changeProgress(progress) {\n      this.progress = progress\n      this.handleChangeSize()\n    },\n\n    // 调整画笔大小\n    handleChangeSize() {\n      const { progress } = this\n      this.curCanvasInstantiate.minWidth = MIN_WIDTH * progress / 100\n      this.curCanvasInstantiate.maxWidth = MAX_WIDTH * progress / 100\n    },\n\n    // 刷新对联\n    handleRefresh(rotate) {\n      this.duilian = duilianList[Math.floor(Math.random() * duilianList.length)]\n\n      if (rotate) {\n        if (this.mode === 2) {\n          this.refreshDuilian()\n        }\n        // 使icon旋转\n        this.isRotate = true\n        setTimeout(() => {\n          this.isRotate = false\n        }, 300)\n      }\n    },\n\n    // 播放背景音乐\n    handlePlay() {\n      const { bgm } = this.$refs\n      if (bgm.paused) {\n        bgm.play()\n        this.isPlay = true\n      } else {\n        bgm.pause()\n        this.isPlay = false\n      }\n    },\n\n    // 完成输入对联\n    handleSubmitInput(values) {\n      this.duilian = values\n      this.showInputBox = false\n      this.refreshDuilian()\n    },\n\n    // 完成挑选对联\n    handlePickDuilian(item) {\n      this.duilian = item\n      this.showPickBox = false\n      this.refreshDuilian()\n    }\n  },\n};\n</script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n\n\n更多有趣的小网页欢迎关注公众号有趣研究社:\n\n> 手写春联\n> FC在线模拟器\n> 爱国头像生成器\n> 到账语音生成器",
      "normalizedContent": "手写春联：https://cl.xugaoyi.com/\n\n\n# 前言\n\n虎年春节快到了，首先祝大家新年快乐，轻松暴富。 最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么ui特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）\n\n\n\n\n# 产品构思\n\n包含手写春节和生成春联两大功能：\n\n * 手写春联\n   \n   * 模拟用笔写字的字迹\n   * 选择画笔颜色\n   * 调整画笔大小\n   * 清空画布\n   * 撤回笔画\n   * 切换上、下联、横批、福字\n   * 随机切换对联提示\n   * 预览图片和下载\n   * 贴春联海报和下载\n\n * 生成模式\n   \n   * 选择画笔颜色\n   * 挑选生成的对联\n   * 输入对联\n   * 随机切换对联\n   * 贴春联海报和下载\n\n * 其他\n   \n   * 快速切换模式按钮\n   * 可控制的背景音乐\n   * 微信分享网页\n\n\n# 设计\n\n\n\n\n# 开发\n\n * 技术栈\n   * vite (打包&构建)\n   * vue3 (页面开发)\n   * vant（ui）\n   * sass (css)\n   * smooth-signature.js (带笔锋手写库)\n\n<template>\n  <div class=\"wrap\" :class=\"'mode-' + mode\" @touchstart=\"handletouchstart\">\n    <!-- 切换模式按钮 -->\n    <div class=\"toggle-mode-btn\" @click=\"togglemode\">\n      {{ mode === 1 ? '手写' : '生成' }}\n      <i class=\"iconfont icon-qiehuan\"></i>\n    </div>\n\n    <!-- 工具栏 -->\n    <div\n      class=\"actions\"\n      :style=\"{ bordertoprightradius: colorlistvisibility ? '0' : '5px' }\"\n    >\n      <!-- 手写模式显示 -->\n      <template v-if=\"mode === 1\">\n        <!-- 调色板 -->\n        <div class=\"palette btn-block\">\n          <div\n            class=\"cur-color\"\n            @click=\"togglepalette\"\n            :style=\"{ background: colorlist[curcolorindex] }\"\n          ></div>\n          <ul class=\"colorlist\" v-show=\"colorlistvisibility\">\n            <li\n              v-for=\"(item, index) in colorlist\"\n              :key=\"item\"\n              :style=\"{ background: item }\"\n              @click=\"selectcolor(index)\"\n            ></li>\n          </ul>\n        </div>\n\n        <!-- 滑块 -->\n        <div class=\"slider-box btn-block\">\n          <van-slider\n            v-model=\"progress\"\n            vertical\n            @change=\"changeprogress\"\n            bar-height=\"28\"\n            active-color=\"transparent\"\n            :min=\"50\"\n            :max=\"150\"\n          >\n            <template #button>\n              <div class=\"custom-button\"></div>\n            </template>\n          </van-slider>\n        </div>\n\n        <!-- 清空 -->\n        <div class=\"btn\" @click=\"handleclear\">\n          <i class=\"iconfont icon-lajitong\"></i>\n        </div>\n\n        <!-- 撤销 -->\n        <div class=\"btn\" @click=\"handleundo\">\n          <i class=\"iconfont icon-fanhui\"></i>\n        </div>\n\n        <div class=\"line\"></div>\n\n        <!-- 切换画布的按钮 -->\n        <div\n          class=\"btn\"\n          :class=\"{ 'cur-active': curcanvasindex === index }\"\n          v-for=\"(item, index) in canvaslist\"\n          :key=\"item.name\"\n          @click=\"changecanvas(index)\"\n        >\n          {{ item.name }}\n        </div>\n\n        <div class=\"line\"></div>\n\n        <div class=\"btn prominent\" @click=\"handlepreview\">预览</div>\n        <div class=\"btn prominent\" @click=\"openposters\">贴联</div>\n      </template>\n\n      <!-- 生成模式显示 -->\n      <template v-else>\n        <!-- 选颜色 -->\n        <div\n          class=\"color-list-quick\"\n          :class=\"{ active: curcolorindex === index }\"\n          v-for=\"(item, index) in colorlist\"\n          :key=\"item\"\n          :style=\"{ background: item }\"\n          @click=\"selectcolor(index)\"\n        ></div>\n        <div class=\"line\"></div>\n        <div class=\"btn\" @click=\"showpickbox = true\">挑选</div>\n        <div class=\"btn\" @click=\"showinputbox = true\">输入</div>\n\n        <!-- 挑选对联弹窗 -->\n        <van-action-sheet v-model:show=\"showpickbox\" title=\"请挑选对联\">\n          <ul class=\"duilian-list\">\n            <li\n              v-for=\"(item, index) in duilianlist\"\n              :key=\"index\"\n              @click=\"handlepickduilian(item)\"\n            >\n              <span>{{ item.shang }}</span\n              >， <span>{{ item.xia }}</span\n              >。\n              <span>{{ item.heng }}</span>\n            </li>\n          </ul>\n        </van-action-sheet>\n\n        <!-- 输入对联弹窗 -->\n        <van-action-sheet v-model:show=\"showinputbox\" title=\"请输入对联\">\n          <van-form @submit=\"handlesubmitinput\">\n            <van-cell-group inset>\n              <van-field\n                v-model=\"shanglian\"\n                name=\"shang\"\n                label=\"上联\"\n                placeholder=\"上联\"\n                :rules=\"[\n                  {\n                    required: true,\n                    message: '请输入7位汉字上联',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]\"\n                clearable\n              />\n              <van-field\n                v-model=\"xialian\"\n                name=\"xia\"\n                label=\"下联\"\n                placeholder=\"下联\"\n                :rules=\"[\n                  {\n                    required: true,\n                    message: '请输入7位汉字下联',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]\"\n                clearable\n              />\n              <van-field\n                v-model=\"hengpi\"\n                name=\"heng\"\n                label=\"横批\"\n                placeholder=\"横批\"\n                :rules=\"[\n                  {\n                    required: true,\n                    message: '请输入4位汉字横批',\n                    pattern: /^[\\u4e00-\\u9fa5]{4}$/\n                  }\n                ]\"\n                clearable\n              />\n            </van-cell-group>\n            <div style=\"margin: 16px\">\n              <van-button\n                round\n                block\n                type=\"primary\"\n                native-type=\"submit\"\n                color=\"linear-gradient(to right, #ff6034, #c33825)\"\n              >\n                完成\n              </van-button>\n            </div>\n          </van-form>\n        </van-action-sheet>\n      </template>\n    </div>\n\n    <!-- 模式1-春联画布 -->\n    <div\n      v-show=\"mode === 1\"\n      v-for=\"(item, index) in canvaslist\"\n      :key=\"item.name\"\n    >\n      <canvas\n        class=\"canvas\"\n        :class=\"item.classname\"\n        v-show=\"curcanvasindex === index\"\n        :style=\"{\n          margintop:\n            item.height < clientheight\n              ? `${(clientheight - item.height) / 2}px`\n              : 0,\n          marginleft:\n            item.width < clientwidth ? `${(clientwidth - item.width) / 2}px` : 0\n        }\"\n      />\n    </div>\n\n    <!-- 模式2-春联画布 -->\n    <div v-show=\"mode === 2\" class=\"canvas-mode-2\">\n      <div class=\"row\">\n        <canvas id=\"canvas-top\" :width=\"200 * scale\" :height=\"60 * scale\" />\n      </div>\n      <div class=\"row\">\n        <canvas id=\"canvas-left\" :width=\"60 * scale\" :height=\"364 * scale\" />\n        <canvas id=\"canvas-right\" :width=\"60 * scale\" :height=\"364 * scale\" />\n      </div>\n    </div>\n\n    <!-- 贴春联按钮 -->\n    <button class=\"btn-posters\" @click=\"openposters\" />\n\n    <!-- footer-当前对联提示 -->\n    <footer v-if=\"duilian.shang\">\n      <div class=\"refresh-btn\" @click=\"handlerefresh(true)\">\n        <i class=\"iconfont icon-shuaxin\" :class=\"{ rotate: isrotate }\"></i>\n      </div>\n      <dl class=\"duilian\">\n        <dt>对联</dt>\n        <dd>\n          <div>{{ duilian.shang }}</div>\n          <div>{{ duilian.xia }}</div>\n        </dd>\n      </dl>\n      <dl>\n        <dt>横批</dt>\n        <dd>{{ duilian.heng }}</dd>\n      </dl>\n    </footer>\n\n    <!-- 分享按钮 -->\n    <div class=\"share-btn\" v-if=\"isshowsharebtn\" @click=\"isshowsharetip = true\">\n      <i class=\"iconfont icon-fenxiang\"></i>\n    </div>\n    <!-- 微信分享提示语 -->\n    <div\n      class=\"share-tip\"\n      v-if=\"isshowsharetip\"\n      @click=\"isshowsharetip = false\"\n    >\n      点击右上角把这个工具分享给朋友\n      <div class=\"hand\">👆</div>\n    </div>\n\n    <!-- 保存tip -->\n    <p v-if=\"isshowtip\" class=\"download-tip\">*长按图片保存或转发</p>\n\n    <!-- 版权 -->\n    <div class=\"copyright\">公众号「有趣研究社」 ©版权所有</div>\n\n    <!-- 载入图片元素，用于快速贴图使用, 注意设置crossorigin=\"anonymous\"解决跨域 -->\n    <div v-if=\"isreadimages\">\n      <img\n        crossorigin=\"anonymous\"\n        v-for=\"(item, index) in bglist\"\n        :src=\"item\"\n        :key=\"item\"\n        class=\"hide-img\"\n        :id=\"`bg-img-` + index\"\n      />\n      <img\n        crossorigin=\"anonymous\"\n        class=\"hide-img\"\n        id=\"qrcode\"\n        src=\"https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/img/qrcode.zul0pldsuao.png\"\n      />\n    </div>\n\n    <!-- 背景音乐 -->\n    <audio\n      src=\"https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/cjxq.mp3\"\n      id=\"bgm\"\n      ref=\"bgm\"\n      loop\n    />\n    <div\n      class=\"play-btn\"\n      :class=\"{ paused: !isplay }\"\n      ref=\"playbtn\"\n      @click=\"handleplay\"\n    >\n      <i class=\"iconfont icon-yinle\"></i>\n    </div>\n  </div>\n\n  <div class=\"body-bg-img\"></div>\n</template>\n\n<script>\nimport { imagepreview, notify } from 'vant'\nimport { iswx, ismobile } from '@/utils'\nimport button from '@/components/button.vue'\nimport dl from '@/assets/img/yh/dl.jpeg'\nimport hp from '@/assets/img/yh/hp.jpeg'\nimport fz from '@/assets/img/yh/fz.png'\n\n// 对联数据\nimport duilianlist from '@/mock/duilian'\n\nconst proportion = 0.37 // 图片缩小比例\nconst instantiate_name = 'signature' // 实例名称\nconst min_width = 3 // 画笔最小宽\nconst max_width = 12 // 画笔最大宽\n\n// 海报背景图大小\nconst bg_width = 750\nconst bg_height = 1448\n\n// 贴图定位和大小\nconst position = [\n  { left: 57, top: 510, width: 90, height: 546 }, // 上联\n  { left: 600, top: 510, width: 90, height: 546 }, // 下联\n  { left: 225, top: 345, width: 300, height: 90 }, // 横幅\n  { left: 460, top: 450, width: 130, height: 130 }, // 福字\n]\n\nexport default {\n  name: \"home\",\n  components: {\n    button\n  },\n  data() {\n    return {\n      duilianlist,\n      mode: number(localstorage.getitem('mode')) || 1, // 1 手写，2 生成\n      curcanvasindex: 0, // 显示哪个画布\n      progress: 100, // 画笔大小的刻度\n      clientwidth: document.documentelement.clientwidth,\n      clientheight: document.documentelement.clientheight,\n      canvaslist: [\n        {\n          name: '上联',\n          classname: 'canvas-a',\n          bgimage: dl,\n          width: 600 * proportion,\n          height: 3640 * proportion,\n        },\n        {\n          name: '下联',\n          classname: 'canvas-b',\n          bgimage: dl,\n          width: 600 * proportion,\n          height: 3640 * proportion,\n        },\n        {\n          name: '横批',\n          classname: 'canvas-c',\n          bgimage: hp,\n          width: 2000 * proportion,\n          height: 600 * proportion,\n        },\n        {\n          name: '福字',\n          classname: 'canvas-d',\n          bgimage: fz,\n          width: 366,\n          height: 366,\n        }\n      ],\n      colorlist: ['#000000', '#ffd800', '#e8bd48', '#ddc08c',],\n      curcolorindex: 0,\n      colorlistvisibility: false, // 画布颜色选择列表可见性\n      isshowtip: false, // 是否显示底部提示语\n      duilian: {}, // 当前对联文本对象\n      isrotate: false, // 刷新icon旋转\n      bglist: [\n        'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/1.4j8qpdnq80i0.jpeg',\n        'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/4.4460an8ag5o0.jpeg',\n        'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/5.3axtl4xpvy00.jpeg',\n        'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/6.2lnbphdqjaq0.jpeg',\n      ],\n      isreadimages: false, // 延迟加载图片用\n      isshowsharebtn: false, // 是否显示分享按钮\n      isshowsharetip: false, // 是否显示分享提示语\n      isplay: false, // 是否在播放\n\n      // 模式2\n      canvastop: null, // 横批\n      canvasleft: null, // 上联\n      canvasright: null, // 下联\n      imgobj1: null, // 横批图片对象\n      imgobj2: null, // 上下联图片对象\n      scale: math.max(window.devicepixelratio || 1, 2), // 用于增加画布清晰度\n      showpickbox: false, // 挑选对联的弹框\n      showinputbox: false, // 输入对联的弹框\n      shanglian: '', // 输入的上联\n      xialian: '', // 输入的下联\n      hengpi: '', // 输入的横批\n    };\n  },\n  computed: {\n    // 模式1-当前画布实例\n    curcanvasinstantiate() {\n      return this[instantiate_name + this.curcanvasindex]\n    }\n  },\n  created() {\n    // 微信浏览器显示分享按钮\n    this.isshowsharebtn = iswx()\n  },\n  mounted() {\n    if (!ismobile()) {\n      notify({ type: 'warning', message: '请用移动端打开获得最佳体验', duration: 6000, });\n    }\n\n    this.initmode1();\n\n    // 初始化对联提示\n    this.handlerefresh();\n\n    this.initmode2();\n\n    // 按钮添加激活时发光效果class\n    const btnel = document.queryselectorall('.btn,.btn-block');\n    btnel.foreach((item) => {\n      item.addeventlistener('touchstart', () => {\n        item.classlist.add('btn-active')\n      })\n      item.addeventlistener('touchend', () => {\n        settimeout(() => {\n          item.classlist.remove('btn-active')\n        }, 100)\n      })\n    })\n\n    // 延迟加载贴图背景\n    settimeout(() => {\n      this.isreadimages = true\n    }, 1000)\n  },\n\n  watch: {\n    // 切换画笔颜色\n    curcolorindex() {\n      this.curcanvasinstantiate.color = this.colorlist[this.curcolorindex]\n      if (this.mode === 2) {\n        this.refreshduilian()\n      }\n    },\n    // 切换画布时应用当前画笔颜色和大小\n    curcanvasindex() {\n      this.curcanvasinstantiate.color = this.colorlist[this.curcolorindex]\n      this.handlechangesize()\n      window.scrollto(0, 0)\n    }\n  },\n\n  methods: {\n    initmode1() {\n      const { colorlist, curcolorindex } = this\n      this.canvaslist.foreach((item, index) => {\n        const options = {\n          width: item.width,\n          height: item.height,\n          minwidth: min_width, // 画笔最小宽度(px)\n          maxwidth: max_width, // 画笔最大宽度\n          minspeed: 1.8, // 画笔达到最小宽度所需最小速度(px/ms)，取值范围1.0-10.0\n          color: colorlist[curcolorindex],\n          // 新增的配置\n          bgimage: item.bgimage,\n        };\n\n        this[instantiate_name + index] = new smoothsignature(document.queryselector('.' + item.classname), options);\n      })\n    },\n\n    initmode2() {\n      this.canvastop = document.getelementbyid('canvas-top').getcontext('2d')\n      this.canvasleft = document.getelementbyid('canvas-left').getcontext('2d')\n      this.canvasright = document.getelementbyid('canvas-right').getcontext('2d')\n\n      // 设字体样式\n      const font = \"36px xs, cursive\"\n      this.canvastop.font = font\n      this.canvasleft.font = font\n      this.canvasright.font = font\n\n      // 增强清晰度\n      const { scale } = this\n      this.canvastop.scale(scale, scale);\n      this.canvasleft.scale(scale, scale);\n      this.canvasright.scale(scale, scale);\n\n      // 设背景图\n      this.imgobj1 = new image()\n      this.imgobj2 = new image()\n      this.imgobj1.src = hp\n      this.imgobj2.src = dl\n      this.imgobj1.onload = () => {\n        // 贴背景\n        this.canvastop.drawimage(this.imgobj1, 0, 0, 200, 60)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handletopfilltext()\n        });\n      }\n      this.imgobj2.onload = () => {\n        // 贴背景\n        this.canvasleft.drawimage(this.imgobj2, 0, 0, 60, 364)\n        this.canvasright.drawimage(this.imgobj2, 0, 0, 60, 364)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handlelrfilltext(this.canvasleft, this.duilian.shang)\n          this.handlelrfilltext(this.canvasright, this.duilian.xia)\n        });\n      }\n    },\n\n    // 模式2-刷新对联\n    refreshduilian() {\n      this.canvastop.drawimage(this.imgobj1, 0, 0, 200, 60)\n      this.canvasleft.drawimage(this.imgobj2, 0, 0, 60, 364)\n      this.canvasright.drawimage(this.imgobj2, 0, 0, 60, 364)\n      this.handletopfilltext()\n      this.handlelrfilltext(this.canvasleft, this.duilian.shang)\n      this.handlelrfilltext(this.canvasright, this.duilian.xia)\n    },\n\n    // 模式2-贴横批\n    handletopfilltext() {\n      // 贴文本\n      this.canvastop.fillstyle = this.colorlist[this.curcolorindex]\n      if (this.duilian.heng) {\n        this.duilian.heng.split('').foreach((item, index) => {\n          const left = 42 * (index + 1) - 22\n          this.canvastop.filltext(item, left, 40)\n        })\n      }\n    },\n\n    // 模式2-贴上下联\n    handlelrfilltext(ctx, text) {\n      ctx.fillstyle = this.colorlist[this.curcolorindex]\n      if (text) {\n        text.split('').foreach((item, index) => {\n          const top = 50 * (index + 1) - 8\n          ctx.filltext(item, 13, top)\n        })\n      }\n    },\n\n    // 切换模式\n    togglemode() {\n      if (this.mode === 1) {\n        this.mode = 2\n        this.refreshduilian()\n      } else {\n        this.mode = 1\n      }\n      localstorage.setitem('mode', this.mode);\n    },\n\n    // 打开调色板\n    togglepalette() {\n      this.colorlistvisibility = !this.colorlistvisibility\n    },\n\n    // 关闭调色板\n    handletouchstart(e) {\n      // 不是点击选择颜色时\n      if (e.path[1]?.classlist?.value !== 'colorlist' && e.target.classlist?.value !== 'cur-color') {\n        this.colorlistvisibility = false\n      }\n    },\n\n    // 选择颜色\n    selectcolor(index) {\n      this.curcolorindex = index\n      this.colorlistvisibility = false\n    },\n\n    // 切换画布\n    changecanvas(index) {\n      this.curcanvasindex = index\n    },\n\n    // 清空画布\n    handleclear() {\n      this.curcanvasinstantiate.clear();\n    },\n\n    // 撤销笔画\n    handleundo() {\n      this.curcanvasinstantiate.undo();\n    },\n\n    // 预览\n    handlepreview() {\n      this.showtoptip();\n      this.isshowtip = true\n      const _this = this\n      imagepreview({\n        images: this.getimagelist(),\n        closeable: true,\n        startposition: this.curcanvasindex,\n        onclose() {\n          _this.isshowtip = false\n        },\n      });\n    },\n\n    // 打开海报预览\n    openposters() {\n      // 创建画布\n      const canvas = document.createelement('canvas');\n      canvas.width = bg_width\n      canvas.height = bg_height\n      const ctx = canvas.getcontext('2d');\n      const resultimagelist = [];\n\n      // 是否隐藏福字\n      const ishidefu = this[instantiate_name + 3].isempty()\n      this.bglist.foreach((item, index) => {\n        // 贴背景图\n        ctx.drawimage(document.getelementbyid('bg-img-' + index), 0, 0, bg_width, bg_height)\n\n        // 贴对联\n        if (this.mode === 1) {\n          this.canvaslist.foreach((item, index) => {\n            if (index === 3 && ishidefu) return;\n            const dlcanvas = document.queryselector('.' + item.classname)\n            const { left, top, width, height } = position[index]\n            ctx.drawimage(dlcanvas, left, top, width, height)\n          })\n        } else {\n          ['canvas-left', 'canvas-right', 'canvas-top'].foreach((item, index) => {\n            const dlcanvas = document.getelementbyid(item)\n            const { left, top, width, height } = position[index]\n            ctx.drawimage(dlcanvas, left, top, width, height)\n          })\n        }\n\n        // 贴二维码\n        ctx.drawimage(document.getelementbyid(\"qrcode\"), 40, 1280, 580, 136)\n\n        // 贴文本\n        ctx.font = \"18px sans-serif\"\n        ctx.fillstyle = \"#666666\"\n        ctx.filltext('©公众号「有趣研究社」', 550, 1420)\n\n        // 导出图片\n        resultimagelist.push(canvas.todataurl('image/jpeg', 0.8))\n      })\n\n      // 打开图片预览\n      this.isshowtip = true\n      const _this = this\n      imagepreview({\n        images: resultimagelist,\n        closeable: true,\n        onclose() {\n          _this.isshowtip = false\n        },\n      });\n      this.showtoptip();\n    },\n\n    // 弹出顶部提示语\n    showtoptip() {\n      if (!sessionstorage.getitem('showtip')) {\n        sessionstorage.setitem('showtip', 'true');\n        notify({\n          message: '长按图片可保存到本地',\n          color: '#c33825',\n          background: '#eed3ae',\n        });\n      }\n    },\n\n    // 获取对联图片列表\n    getimagelist(type = 'image/png') {\n      const imagelist = []\n      this.canvaslist.foreach((item, index) => {\n        if (index === 3) {\n          // `福`字必须是png格式\n          type = 'image/png'\n        }\n        imagelist.push(this[instantiate_name + index].todataurl(type, 0.8))\n      })\n      return imagelist\n    },\n\n    // 进度改变时\n    changeprogress(progress) {\n      this.progress = progress\n      this.handlechangesize()\n    },\n\n    // 调整画笔大小\n    handlechangesize() {\n      const { progress } = this\n      this.curcanvasinstantiate.minwidth = min_width * progress / 100\n      this.curcanvasinstantiate.maxwidth = max_width * progress / 100\n    },\n\n    // 刷新对联\n    handlerefresh(rotate) {\n      this.duilian = duilianlist[math.floor(math.random() * duilianlist.length)]\n\n      if (rotate) {\n        if (this.mode === 2) {\n          this.refreshduilian()\n        }\n        // 使icon旋转\n        this.isrotate = true\n        settimeout(() => {\n          this.isrotate = false\n        }, 300)\n      }\n    },\n\n    // 播放背景音乐\n    handleplay() {\n      const { bgm } = this.$refs\n      if (bgm.paused) {\n        bgm.play()\n        this.isplay = true\n      } else {\n        bgm.pause()\n        this.isplay = false\n      }\n    },\n\n    // 完成输入对联\n    handlesubmitinput(values) {\n      this.duilian = values\n      this.showinputbox = false\n      this.refreshduilian()\n    },\n\n    // 完成挑选对联\n    handlepickduilian(item) {\n      this.duilian = item\n      this.showpickbox = false\n      this.refreshduilian()\n    }\n  },\n};\n</script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n\n\n更多有趣的小网页欢迎关注公众号有趣研究社:\n\n> 手写春联\n> fc在线模拟器\n> 爱国头像生成器\n> 到账语音生成器",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "分类",
      "frontmatter": {
        "categoriesPage": true,
        "title": "分类",
        "permalink": "/categories/",
        "article": false
      },
      "regularPath": "/@pages/categoriesPage.html",
      "relativePath": "@pages/categoriesPage.md",
      "key": "v-5f8dfe80",
      "path": "/categories/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "归档",
      "frontmatter": {
        "archivesPage": true,
        "title": "归档",
        "permalink": "/archives/",
        "article": false
      },
      "regularPath": "/@pages/archivesPage.html",
      "relativePath": "@pages/archivesPage.md",
      "key": "v-48f7eec0",
      "path": "/archives/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "标签",
      "frontmatter": {
        "tagsPage": true,
        "title": "标签",
        "permalink": "/tags/",
        "article": false
      },
      "regularPath": "/@pages/tagsPage.html",
      "relativePath": "@pages/tagsPage.md",
      "key": "v-64f9b920",
      "path": "/tags/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2022/05/19, 21:26:01",
      "lastUpdatedTimestamp": 1652966761000
    },
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroImage": "/img/JAVADRIVER.png",
        "heroText": "JavaDriver",
        "tagline": "🚀精选大厂Java面试题",
        "actionText": "开始使用 →",
        "actionLink": "/pages/a030ff/",
        "bannerBg": "none",
        "features": [
          {
            "title": "联系源码",
            "details": "围绕源码讲解面试题，知其然知所以然，做到真正明白一道题，不惧面试官从任何角度发起提问。"
          },
          {
            "title": "生动直观",
            "details": "图、文、表格、动画帮助你更好的理解。"
          },
          {
            "title": "题目来源",
            "details": "题目来源国内大中厂面试者的反馈，包括但不限于阿里巴巴、腾讯、美团、字节跳动、快手、京东、拼多多、小红书、滴滴。"
          }
        ],
        "postList": "none"
      },
      "regularPath": "/",
      "relativePath": "index.md",
      "key": "v-2cf94a0e",
      "path": "/",
      "headers": [
        {
          "level": 2,
          "title": "🎖友情链接",
          "slug": "🎖友情链接",
          "normalizedTitle": "🎖友情链接",
          "charIndex": 11
        },
        {
          "level": 2,
          "title": "🎉上新推荐",
          "slug": "🎉上新推荐",
          "normalizedTitle": "🎉上新推荐",
          "charIndex": 696
        },
        {
          "level": 2,
          "title": "⚡️未来...",
          "slug": "⚡️未来",
          "normalizedTitle": "⚡️未来...",
          "charIndex": 748
        },
        {
          "level": 2,
          "title": "⚡ 反馈与交流",
          "slug": "⚡-反馈与交流",
          "normalizedTitle": "⚡ 反馈与交流",
          "charIndex": 812
        }
      ],
      "headersStr": "🎖友情链接 🎉上新推荐 ⚡️未来... ⚡ 反馈与交流",
      "content": "支持这个项目\n\n\n# 🎖友情链接\n\nOpenHarmony\n\n开放原子开源基金会\n\nMyBatis-Plus官网\n\n🚀为简化开发而生\n\nDeepin 社区\n\nDeepin 应用开发技术分享、DTK开发经验等\n\nVForm官网\n\n低代码表单优选方案，拖拽式设计，一键生成源码\n\n- name: OpenHarmony\n  desc: 开放原子开源基金会\n  link: https://docs.openharmony.cn/pages/000000/\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: MyBatis-Plus官网\n  desc: 🚀为简化开发而生\n  link: https://baomidou.com/\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: Deepin 社区\n  desc: Deepin 应用开发技术分享、DTK开发经验等\n  link: https://docs.deepin.org\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: VForm官网\n  desc: 低代码表单优选方案，拖拽式设计，一键生成源码\n  link: http://www.vform666.com\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n# 🎉上新推荐\n\n * v1.1.x：第一个版本，快去 看看 吧~\n\n更多上新请查阅：更新日志\n\n\n\n# ⚡️未来...\n\n提示\n\n期待 更多Java领域的面试题正式发布...\n\n还希望大家多多 💖支持 哟，持续关注吧~\n\n\n\n# ⚡ 反馈与交流\n\n在使用过程中有任何问题和想法，你可以：\n\n * 给我提 Issue。\n\n你也可以在Issue查看别人提的问题和给出解决方案。\n\n * 戳JavaDriver社区\n\n",
      "normalizedContent": "支持这个项目\n\n\n# 🎖友情链接\n\nopenharmony\n\n开放原子开源基金会\n\nmybatis-plus官网\n\n🚀为简化开发而生\n\ndeepin 社区\n\ndeepin 应用开发技术分享、dtk开发经验等\n\nvform官网\n\n低代码表单优选方案，拖拽式设计，一键生成源码\n\n- name: openharmony\n  desc: 开放原子开源基金会\n  link: https://docs.openharmony.cn/pages/000000/\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: mybatis-plus官网\n  desc: 🚀为简化开发而生\n  link: https://baomidou.com/\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: deepin 社区\n  desc: deepin 应用开发技术分享、dtk开发经验等\n  link: https://docs.deepin.org\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: vform官网\n  desc: 低代码表单优选方案，拖拽式设计，一键生成源码\n  link: http://www.vform666.com\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n# 🎉上新推荐\n\n * v1.1.x：第一个版本，快去 看看 吧~\n\n更多上新请查阅：更新日志\n\n\n\n# ⚡️未来...\n\n提示\n\n期待 更多java领域的面试题正式发布...\n\n还希望大家多多 💖支持 哟，持续关注吧~\n\n\n\n# ⚡ 反馈与交流\n\n在使用过程中有任何问题和想法，你可以：\n\n * 给我提 issue。\n\n你也可以在issue查看别人提的问题和给出解决方案。\n\n * 戳javadriver社区\n\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2022/05/20, 20:19:56",
      "lastUpdatedTimestamp": 1653049196000
    }
  ],
  "themeConfig": {
    "nav": [
      {
        "text": "首页",
        "link": "/"
      },
      {
        "text": "Java相关",
        "link": "/java/",
        "items": [
          {
            "text": "基础",
            "link": "/pages/a030ff/"
          },
          {
            "text": "并发",
            "link": "/pages/0da4b0/"
          },
          {
            "text": "JVM",
            "link": "/pages/948850/"
          },
          {
            "text": "设计模式",
            "link": "/pages/b37ad7/"
          }
        ]
      },
      {
        "text": "计算机基础",
        "link": "/basic/",
        "items": [
          {
            "text": "计算机网络",
            "link": "/pages/e00207/"
          },
          {
            "text": "操作系统",
            "link": "/pages/e5f2d7/"
          },
          {
            "text": "数据结构",
            "link": "/pages/a25c3a/"
          },
          {
            "text": "算法",
            "link": "/pages/92288a/"
          }
        ]
      },
      {
        "text": "数据库",
        "link": "/database/",
        "items": [
          {
            "text": "MYSQL",
            "link": "/pages/3a8659/"
          },
          {
            "text": "REDIS",
            "link": "/pages/d70c1f/"
          }
        ]
      },
      {
        "text": "中间件",
        "link": "/middleware/",
        "items": [
          {
            "text": "Netty",
            "link": "/pages/40f3c9/"
          },
          {
            "text": "Spring",
            "link": "/pages/434235/"
          },
          {
            "text": "Mybatis",
            "link": "/pages/3793a5/"
          },
          {
            "text": "Kafka",
            "link": "/pages/561f34/"
          },
          {
            "text": "Dubbo",
            "link": "/pages/78517c/"
          }
        ]
      },
      {
        "text": "系统设计",
        "link": "/pages/01b9b2/"
      },
      {
        "text": "非技术",
        "link": "/pages/5e507a/"
      },
      {
        "text": "关于",
        "link": "/about/"
      },
      {
        "text": "收藏",
        "link": "/pages/beb6c0bd8a66cea6/"
      },
      {
        "text": "索引",
        "link": "/archives/",
        "items": [
          {
            "text": "分类",
            "link": "/categories/"
          },
          {
            "text": "标签",
            "link": "/tags/"
          },
          {
            "text": "归档",
            "link": "/archives/"
          }
        ]
      }
    ],
    "sidebarDepth": 2,
    "logo": "/img/JAVADRIVER.png",
    "repo": "https://github.com/AdmireAn/JavaDriver",
    "searchMaxSuggestions": 10,
    "lastUpdated": "上次更新",
    "docsDir": "docs",
    "editLinks": true,
    "editLinkText": "编辑",
    "sidebar": {
      "/00.目录页/": [
        [
          "01.Java相关.md",
          "Java相关",
          "/java"
        ],
        [
          "02.计算机基础.md",
          "计算机基础",
          "/basic"
        ],
        [
          "03.数据库.md",
          "数据库",
          "/database"
        ],
        [
          "04.中间件.md",
          "中间件",
          "/middleware"
        ]
      ],
      "catalogue": {
        "Java相关": "/java",
        "计算机基础": "/basic",
        "数据库": "/database",
        "中间件": "/middleware"
      },
      "/01.Java相关/": [
        {
          "title": "基础",
          "collapsable": true,
          "children": [
            [
              "10.基础/001.Java 异常有哪些类型？.md",
              "Java 异常有哪些类型？",
              "/pages/a030ff/"
            ],
            [
              "10.基础/010.HashMap 与 ConcurrentHashMap 的实现原理是怎样的？.md",
              "HashMap 与 ConcurrentHashMap 的实现原理是怎样的？",
              "/pages/d1c564/"
            ],
            [
              "10.基础/020.Java 中接口和抽象类的区别.md",
              "Java 中接口和抽象类的区别",
              "/pages/826c8b/"
            ],
            [
              "10.基础/030.为什么重写 equals 必须重写 hashcode ？.md",
              "为什么重写 equals 必须重写 hashcode ？",
              "/pages/0d22ad/"
            ],
            [
              "10.基础/040.== 和 equals() 的区别？.md",
              "== 和 equals() 的区别？",
              "/pages/06b28a/"
            ],
            [
              "10.基础/050.String，StringBuffer，StringBuilder 之间有什么区别？.md",
              "String，StringBuffer，StringBuilder 之间有什么区别？",
              "/pages/211d8c/"
            ],
            [
              "10.基础/060.简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度.md",
              "简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度",
              "/pages/305919/"
            ],
            [
              "10.基础/070.简述 BIO, NIO, AIO 的区别.md",
              "简述 BIO, NIO, AIO 的区别",
              "/pages/276740/"
            ],
            [
              "10.基础/080.在一个静态方法内调用一个非静态成员为什么是非法的？.md",
              "在一个静态方法内调用一个非静态成员为什么是非法的？",
              "/pages/56314c/"
            ],
            [
              "10.基础/090.简述 Java 的反射机制及其应用场景.md",
              "简述 Java 的反射机制及其应用场景",
              "/pages/fae5d5/"
            ],
            [
              "10.基础/100.Java 类的加载流程是怎样的？.md",
              "Java 类的加载流程是怎样的？",
              "/pages/33c5d6/"
            ],
            [
              "10.基础/110.什么是双亲委派机制？.md",
              "什么是双亲委派机制？",
              "/pages/38bcaf/"
            ],
            [
              "10.基础/120.Java 中 sleep() 与 wait() 的区别 .md",
              "Java 中 sleep() 与 wait() 的区别",
              "/pages/d69890/"
            ],
            [
              "10.基础/130.简述 Java 中 final 关键字的作用.md",
              "简述 Java 中 final 关键字的作用",
              "/pages/2b00a3/"
            ],
            [
              "10.基础/140.String 类能不能被继承？为什么？.md",
              "String 类能不能被继承？为什么？",
              "/pages/73113f/"
            ],
            [
              "10.基础/150.Java 缓冲流 buffer 的用途和原理是什么？.md",
              "Java 缓冲流 buffer 的用途和原理是什么？",
              "/pages/115772/"
            ],
            [
              "10.基础/160.简述动态代理与静态代理 .md",
              "简述动态代理与静态代理",
              "/pages/37dba4/"
            ],
            [
              "10.基础/170.阻塞队列都有哪几种，有什么区别？.md",
              "阻塞队列都有哪几种，有什么区别？",
              "/pages/e9ce4e/"
            ],
            [
              "10.基础/180.简述 HashSet 实现原理.md",
              "简述 HashSet 实现原理",
              "/pages/75552c/"
            ]
          ]
        },
        {
          "title": "并发",
          "collapsable": true,
          "children": [
            [
              "20.并发/001.线程池是如何实现的？.md",
              "线程池是如何实现的？",
              "/pages/0da4b0/"
            ],
            [
              "20.并发/020.简述 CAS 原理，什么是 ABA 问题，怎么解决？.md",
              "简述 CAS 原理，什么是 ABA 问题，怎么解决？",
              "/pages/3356c6/"
            ],
            [
              "20.并发/030.简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点.md",
              "简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点",
              "/pages/97245f/"
            ],
            [
              "20.并发/040.Synchronized 关键字底层是如何实现的？.md",
              "Synchronized 与 Lock 相比优缺点分别是什么？",
              "/pages/d5d161/"
            ],
            [
              "20.并发/050.重入锁是如何实现的？.md",
              "重入锁是如何实现的？",
              "/pages/9b59d1/"
            ],
            [
              "20.并发/060.volatile 关键字解决了什么问题，它的实现原理是什么？.md",
              "volatile 关键字解决了什么问题，它的实现原理是什么？",
              "/pages/383264/"
            ],
            [
              "20.并发/070.简述 Java 锁升级的机制.md",
              "简述 Java 锁升级的机制",
              "/pages/ff0616/"
            ],
            [
              "20.并发/080.简述 Java AQS 的原理以及使用场景.md",
              "简述 Java AQS 的原理以及使用场景",
              "/pages/52a687/"
            ],
            [
              "20.并发/090.什么是公平锁？什么是非公平锁？.md",
              "什么是公平锁？什么是非公平锁？",
              "/pages/fd6a59/"
            ],
            [
              "20.并发/100.Java 的线程有哪些状态，转换关系是怎么样的？.md",
              "Java 的线程有哪些状态，转换关系是怎么样的？",
              "/pages/52483b/"
            ],
            [
              "20.并发/110.Java 是如何实现线程安全的，哪些数据结构是线程安全的？.md",
              "Java 是如何实现线程安全的，哪些数据结构是线程安全的？",
              "/pages/c1f760/"
            ],
            [
              "20.并发/115.手写死锁.md",
              "手写死锁",
              "/pages/ce292c/"
            ],
            [
              "20.并发/120.为什么我们不能直接调用 run() 方法？.md",
              "为什么我们不能直接调用 run() 方法？",
              "/pages/13856f/"
            ],
            [
              "20.并发/130.Java 线程有哪些常用方法？.md",
              "Java 线程有哪些常用方法？",
              "/pages/a6c84e/"
            ],
            [
              "20.并发/140.手写生产者消费者模型.md",
              "手写生产者消费者模型",
              "/pages/2b8c6e/"
            ],
            [
              "20.并发/150.ThreadLocal 实现原理是什么？为什么要使用弱引用？.md",
              "ThreadLocal 实现原理是什么？为什么要使用弱引用？",
              "/pages/b3e720/"
            ]
          ]
        },
        {
          "title": "JVM",
          "collapsable": true,
          "children": [
            [
              "30.JVM/001.Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？.md",
              "Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？",
              "/pages/948850/"
            ],
            [
              "30.JVM/020.Java 中如何进行 GC 调优？.md",
              "Java 中如何进行 GC 调优？",
              "/pages/07a030/"
            ],
            [
              "30.JVM/030.JMM 中内存模型是怎样的？什么是指令序列重排序？.md",
              "JMM 中内存模型是怎样的？什么是指令序列重排序？",
              "/pages/c8e6cb/"
            ],
            [
              "30.JVM/040.JVM 内存是如何对应到操作系统内存的？.md",
              "JVM 内存是如何对应到操作系统内存的？",
              "/pages/da65e7/"
            ],
            [
              "30.JVM/050.JVM 是怎么去调优的？了解哪些参数和指令？.md",
              "JVM 是怎么去调优的？了解哪些参数和指令？",
              "/pages/d730dd/"
            ],
            [
              "30.JVM/060.什么是内存泄漏，怎么确定内存泄漏？.md",
              "什么是内存泄漏，怎么确定内存泄漏？",
              "/pages/3ab5f5/"
            ],
            [
              "30.JVM/070.简述 CMS 与 G1 机制的区别.md",
              "简述 CMS 与 G1 机制的区别",
              "/pages/be69af/"
            ]
          ]
        },
        {
          "title": "设计模式",
          "collapsable": true,
          "children": [
            [
              "40.设计模式/002.实现单例设计模式（懒汉，饿汉）.md",
              "实现单例设计模式（懒汉，饿汉）",
              "/pages/b37ad7/"
            ],
            [
              "40.设计模式/003.什么是设计模式，描述几个常用的设计模式 .md",
              "什么是设计模式，描述几个常用的设计模式",
              "/pages/3d768c/"
            ],
            [
              "40.设计模式/004.工厂模式使用场景 能举个例子吗.md",
              "工厂模式使用场景 能举个例子吗",
              "/pages/f15489/"
            ],
            [
              "40.设计模式/005.装饰者模式.md",
              "简述装饰者模式以及适配器模式",
              "/pages/47a4e3/"
            ],
            [
              "40.设计模式/010.适配器模式.md",
              "适配器模式",
              "/pages/827fc4/"
            ],
            [
              "40.设计模式/020.代理模式.md",
              "代理模式",
              "/pages/dd3a6f/"
            ],
            [
              "40.设计模式/030.责任链模式.md",
              "责任链模式",
              "/pages/d3ff35/"
            ],
            [
              "40.设计模式/040.模板方法模式.md",
              "模板方法模式",
              "/pages/43b656/"
            ],
            [
              "40.设计模式/050.策略模式.md",
              "策略模式",
              "/pages/78c7aa/"
            ],
            [
              "40.设计模式/060.观察模式.md",
              "观察模式",
              "/pages/cbff3c/"
            ],
            [
              "40.设计模式/070.代理模式.md",
              "代理模式",
              "/pages/a3c735/"
            ],
            [
              "40.设计模式/080.建造者模式.md",
              "建造者模式",
              "/pages/c332ae/"
            ]
          ]
        }
      ],
      "/02.计算机基础/": [
        {
          "title": "计算机网络.HTML",
          "collapsable": true,
          "children": [
            [
              "10.计算机网络.HTML/01.计算机网络.md",
              "计算机网络",
              "/pages/e00207/"
            ]
          ]
        },
        {
          "title": "操作系统.CSS",
          "collapsable": true,
          "children": [
            [
              "20.操作系统.CSS/01.操作系统.md",
              "操作系统",
              "/pages/e5f2d7/"
            ]
          ]
        },
        {
          "title": "数据结构.CSS",
          "collapsable": true,
          "children": [
            [
              "30.数据结构.CSS/01.数据结构.md",
              "数据结构",
              "/pages/a25c3a/"
            ]
          ]
        },
        {
          "title": "算法.CSS",
          "collapsable": true,
          "children": [
            [
              "40.算法.CSS/01.算法.md",
              "算法",
              "/pages/92288a/"
            ]
          ]
        }
      ],
      "/03.数据库/": [
        {
          "title": "MYSQL相关",
          "collapsable": true,
          "children": [
            [
              "01.MYSQL相关/001.MySQL中 InnoDB 和 MylSAM 的区别是什么？.md",
              "MySQL中 InnoDB 和 MylSAM 的区别是什么？",
              "/pages/3a8659/"
            ],
            [
              "01.MYSQL相关/006.聚簇索引和非聚簇索引有什么区别？.md",
              "聚簇索引和非聚簇索引有什么区别？",
              "/pages/a5adb0/"
            ],
            [
              "01.MYSQL相关/007.简述 MySQL 常见索引类型，介绍一下覆盖索引.md",
              "简述 MySQL 常见索引类型，介绍一下覆盖索引",
              "/pages/17b014/"
            ],
            [
              "01.MYSQL相关/010.简述Mysql的事务隔离级别.md",
              "简述Mysql的事务隔离级别",
              "/pages/9f2936/"
            ],
            [
              "01.MYSQL相关/015.说一下Mysql锁.md",
              "说一下Mysql锁",
              "/pages/b17e88/"
            ],
            [
              "01.MYSQL相关/020.MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么.md",
              "MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么",
              "/pages/bc5538/"
            ],
            [
              "01.MYSQL相关/030.简述乐观锁以及悲观锁的区别以及使用场景.md",
              "简述乐观锁以及悲观锁的区别以及使用场景",
              "/pages/57561d/"
            ],
            [
              "01.MYSQL相关/040.简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？.md",
              "简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？",
              "/pages/36672c/"
            ],
            [
              "01.MYSQL相关/050.简述什么是最左匹配原则.md",
              "简述什么是最左匹配原则",
              "/pages/7a1f1e/"
            ],
            [
              "01.MYSQL相关/060.MySQL 联合索引底层原理是什么？.md",
              "MySQL 联合索引底层原理是什么？",
              "/pages/52773a/"
            ],
            [
              "01.MYSQL相关/070.产生死锁的必要条件有哪些？如何解决死锁？.md",
              "产生死锁的必要条件有哪些？如何解决死锁？",
              "/pages/f4cf50/"
            ],
            [
              "01.MYSQL相关/080.简述常见的负载均衡算法.md",
              "简述常见的负载均衡算法",
              "/pages/f2dbbe/"
            ],
            [
              "01.MYSQL相关/090.简述 MySQL 的主从同步机制，如果同步失败会怎么样？.md",
              "简述 MySQL 的主从同步机制，如果同步失败会怎么样？",
              "/pages/1ac30e/"
            ],
            [
              "01.MYSQL相关/100.如何设计数据库压测方案？.md",
              "如何设计数据库压测方案？",
              "/pages/a8eb47/"
            ],
            [
              "01.MYSQL相关/110.简述数据库中什么情况下进行分库，什么情况下进行分表？.md",
              "简述数据库中什么情况下进行分库，什么情况下进行分表？",
              "/pages/ac0bb8/"
            ],
            [
              "01.MYSQL相关/120.数据库的读写分离的作用是什么？如何实现？.md",
              "数据库的读写分离的作用是什么？如何实现？",
              "/pages/f62359/"
            ],
            [
              "01.MYSQL相关/130.简述 undo log 和 redo log 的作用.md",
              "简述 undo log 和 redo log 的作用",
              "/pages/7bbbf6/"
            ],
            [
              "01.MYSQL相关/140.什么是 SQL 注入攻击？如何防止这类攻击？.md",
              "什么是 SQL 注入攻击？如何防止这类攻击？",
              "/pages/b4338e/"
            ],
            [
              "01.MYSQL相关/150.MySQL 中 join 与 left join 的区别是什么？.md",
              "MySQL 中 join 与 left join 的区别是什么？",
              "/pages/429100/"
            ],
            [
              "01.MYSQL相关/160.简述 MySQL MVCC 的实现原理 .md",
              "简述 MySQL MVCC 的实现原理",
              "/pages/1656d8/"
            ],
            [
              "01.MYSQL相关/170.MySQL 中 varchar 和 char 的区别是什么？.md",
              "MySQL 中 varchar 和 char 的区别是什么？",
              "/pages/d97948/"
            ],
            [
              "01.MYSQL相关/180.模糊查询是如何实现的？.md",
              "模糊查询是如何实现的？",
              "/pages/32696d/"
            ]
          ]
        },
        {
          "title": "REDIS相关",
          "collapsable": true,
          "children": [
            [
              "02.REDIS相关/001.Redis 有几种数据结构？Zset 是如何实现的？.md",
              "Redis 有几种数据结构？Zset 是如何实现的？",
              "/pages/d70c1f/"
            ],
            [
              "02.REDIS相关/002.为什么 Redis 在单线程下能如此快？.md",
              "为什么 Redis 在单线程下能如此快？",
              "/pages/d66211/"
            ],
            [
              "02.REDIS相关/005.简述 Redis 字符串的底层结构.md",
              "简述 Redis 字符串的底层结构",
              "/pages/34aec2/"
            ],
            [
              "02.REDIS相关/010.Redis的缓存淘汰策略有哪些？.md",
              "Redis的缓存淘汰策略有哪些？",
              "/pages/9326cc/"
            ],
            [
              "02.REDIS相关/020.简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点.md",
              "简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点",
              "/pages/7e708d/"
            ],
            [
              "02.REDIS相关/030.Redis 如何实现分布式锁？.md",
              "Redis 如何实现分布式锁？",
              "/pages/656f46/"
            ],
            [
              "02.REDIS相关/040.简述 Redis 集群配置以及基础原理.md",
              "简述 Redis 集群配置以及基础原理",
              "/pages/338e30/"
            ],
            [
              "02.REDIS相关/050.简述 Redis 中跳表的应用以及优缺点.md",
              "简述 Redis 中跳表的应用以及优缺点",
              "/pages/a42826/"
            ],
            [
              "02.REDIS相关/060.Redis 中，sentinel 和 cluster 的区别和适用场景是什么？.md",
              "Redis 中，sentinel 和 cluster 的区别和适用场景是什么？",
              "/pages/e2e910/"
            ],
            [
              "02.REDIS相关/070.简述 Redis 中如何防止缓存雪崩和缓存击穿.md",
              "简述 Redis 中如何防止缓存雪崩和缓存击穿",
              "/pages/03cd25/"
            ],
            [
              "02.REDIS相关/080.简述 Redis 的线程模型以及底层架构设计.md",
              "简述 Redis 的线程模型以及底层架构设计",
              "/pages/9c28c9/"
            ],
            [
              "02.REDIS相关/100.简述 Redis 的哨兵机制.md",
              "简述 Redis 的哨兵机制",
              "/pages/cc8507/"
            ],
            [
              "02.REDIS相关/110.简述 Redis 如何处理热点 key 访问.md",
              "简述 Redis 如何处理热点 key 访问",
              "/pages/795c09/"
            ],
            [
              "02.REDIS相关/120.Redis 序列化有哪些方式？.md",
              "Redis 序列化有哪些方式？",
              "/pages/0d3c6b/"
            ]
          ]
        }
      ],
      "/04.中间件/": [
        {
          "title": "Netty",
          "collapsable": true,
          "children": [
            [
              "10.Netty/001.你熟悉哪些IO模型？.md",
              "Netty",
              "/pages/40f3c9/"
            ],
            [
              "10.Netty/010.TCP粘包拆包问题的解决之道.md",
              "TCP粘包拆包问题的解决之道",
              "/pages/3db019/"
            ],
            [
              "10.Netty/015.Netty中有哪些解码器？.md",
              "Netty中有哪些解码器？",
              "/pages/59089d/"
            ],
            [
              "10.Netty/020.为什么Netty要自己写一个ByteBuf.md",
              "为什么Netty要自己写一个ByteBuf",
              "/pages/ef17ee/"
            ],
            [
              "10.Netty/030.ChannelPipeline和ChannelHandler.md",
              "ChannelPipeline和ChannelHandler",
              "/pages/f851b6/"
            ],
            [
              "10.Netty/040.EventLoop和EventLoopGroup.md",
              "EventLoop和EventLoopGroup",
              "/pages/e7aa60/"
            ],
            [
              "10.Netty/050.Java NIO了解吗？.md",
              "Java NIO了解吗？",
              "/pages/bfdcc8/"
            ]
          ]
        },
        {
          "title": "Spring",
          "collapsable": true,
          "children": [
            [
              "20.Spring/01.Spring.md",
              "Spring",
              "/pages/434235/"
            ]
          ]
        },
        {
          "title": "Mybatis",
          "collapsable": true,
          "children": [
            [
              "30.Mybatis/01.Mybatis.md",
              "Mybatis",
              "/pages/3793a5/"
            ]
          ]
        },
        {
          "title": "Kafka",
          "collapsable": true,
          "children": [
            [
              "40.Kafka/001.Kafka包含那几部分.md",
              "Kafka",
              "/pages/561f34/"
            ],
            [
              "40.Kafka/010.生产者.md",
              "生产者",
              "/pages/fe7ca2/"
            ],
            [
              "40.Kafka/020.消费者.md",
              "消费者",
              "/pages/fed167/"
            ],
            [
              "40.Kafka/030.集群下的Kafka要考虑哪些事情.md",
              "集群下的Kafka要考虑哪些事情",
              "/pages/8d1d04/"
            ],
            [
              "40.Kafka/040.如何保证Kafka的可靠性.md",
              "如何保证Kafka的可靠性",
              "/pages/76a94c/"
            ]
          ]
        },
        {
          "title": "Dubbo",
          "collapsable": true,
          "children": [
            [
              "50.Dubbo/01.Dubbo.md",
              "Dubbo",
              "/pages/78517c/"
            ]
          ]
        }
      ],
      "/08.系统设计/": [
        [
          "001.系统设计.md",
          "系统设计",
          "/pages/01b9b2/"
        ],
        [
          "010.什么是 CAP ？什么是最终一致性？什么是幂等操作？.md",
          "什么是 CAP ？什么是最终一致性？什么是幂等操作？",
          "/pages/20c647/"
        ],
        [
          "020.简述什么是两阶段提交？.md",
          "简述什么是两阶段提交？",
          "/pages/4eae5b/"
        ]
      ],
      "/10.非技术/": [
        [
          "01.非技术问题.md",
          "非技术问题",
          "/pages/5e507a/"
        ]
      ],
      "/15.关于/": [
        [
          "01.关于.md",
          "关于",
          "/about"
        ]
      ],
      "/20.收藏夹/": [
        [
          "01.网站.md",
          "网站",
          "/pages/beb6c0bd8a66cea6"
        ],
        [
          "02.常用的前端轮子.md",
          "常用的前端轮子",
          "/pages/47cf96/"
        ]
      ]
    },
    "author": {
      "name": "YoungAnn",
      "link": "https://github.com/AdmireAn/JavaDriver"
    },
    "blogger": {
      "avatar": "https://tva1.sinaimg.cn/large/e6c9d24egy1h2f580pnmdj213w0u0422.jpg",
      "name": "YoungAnn",
      "slogan": "西二旗Java老司机一枚 致力于社会主义添砖Java"
    },
    "social": {
      "icons": [
        {
          "iconClass": "icon-youjian",
          "title": "发邮件",
          "link": "mailto:854818303@qq.com"
        },
        {
          "iconClass": "icon-github",
          "title": "GitHub",
          "link": "https://github.com/AdmireAn"
        },
        {
          "iconClass": "icon-erji",
          "title": "听音乐",
          "link": "https://music.163.com/#/playlist?id=755597173"
        }
      ]
    },
    "footer": {
      "createYear": 2022,
      "copyrightInfo": "YoungAnnn | <a href=\"https://github.com/AdmireAn/JavaDriver\" target=\"_blank\">MIT License</a>"
    },
    "htmlModules": {
      "homeSidebarB": "<div style=\"padding: 0.95rem\">\n    <p style=\"\n      color: var(--textColor);\n      opacity: 0.9;\n      font-size: 20px;\n      font-weight: bold;\n      margin: 0 0 8px 0;\n    \">问题反馈</p>\n    <img src=\"https://tva1.sinaimg.cn/large/e6c9d24egy1h2h0q9m8wzj20b40b4myw.jpg\"  style=\"width:100%;\" />\n    [<b>扫码反馈</b>]<span><svg xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\" focusable=\"false\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\" width=\"15\" height=\"15\" class=\"icon outbound\"><path fill=\"currentColor\" d=\"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z\"></path> <polygon fill=\"currentColor\" points=\"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9\"></polygon></svg> <span class=\"sr-only\">(opens new window)</span></span></a>\n    </p>\n    </div>"
    }
  },
  "locales": {
    "/": {
      "lang": "zh-CN",
      "title": "JavaDriver",
      "description": "Java学习与总结",
      "path": "/"
    }
  }
}